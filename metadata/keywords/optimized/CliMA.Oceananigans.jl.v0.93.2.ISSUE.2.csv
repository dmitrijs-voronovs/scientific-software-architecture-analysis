quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,2,['Adapt'],['Adapt']
Modifiability,"Opening this request as per the Slack conversation. Sometimes file sizes become very big (and thus are not easy to transfer, etc.), and so quite often it would probably be good to split data files according to time intervals. So something with API like; ```; split_file = Filesize(10Mb). split_file = TimeInterval(10days); ```. Is there any specific things that should be noted if we are to extend the `start_next_file()` functionality to NetCDF as well instead of just JLD2? Like any flags or things that I should note.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967:391,extend,extend,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967,1,['extend'],['extend']
Modifiability,"Overlapping MPI communication and computation in the HydrostaticFreeSurfaceModel and the NonhydrostaticModel. In particular, this PR introduces two keyword arguments for the `fill_halo_regions!` function, active **only** in case of distributed halo passing boundary conditions:; - the`async::Bool` keyword argument that allows launching MPI operations without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/ke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:848,variab,variables,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,2,['variab'],['variables']
Modifiability,"Overlapping MPI communication and computation in the `HydrostaticFreeSurfaceModel`. In particular, this PR introduces the `async` keyword argument to `fill_halo_regions!` that allows launching MPI operations without waiting for the communication to complete. ; This allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an _interior_ kernel that calculates tendencies between `H` and `N-H`, and a _boundary_ kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. This PR is contingent on #2924 . Closes #615; Closes #1882",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953:316,variab,variables,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953,2,['variab'],['variables']
Modifiability,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137:340,refactor,refactoring,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137,1,['refactor'],['refactoring']
Modifiability,Parameterized abstractions that work on CPU and GPU architectures.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147:0,Parameteriz,Parameterized,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147,1,['Parameteriz'],['Parameterized']
Modifiability,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746:992,config,configuration,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746,2,['config'],['configuration']
Modifiability,Poisson solver that allows for variable vertical grid spacing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/46:31,variab,variable,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/46,1,['variab'],['variable']
Modifiability,Portable random number generator for testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:0,Portab,Portable,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['Portab'],['Portable']
Modifiability,PreconditionedConjugateGradientSolver and ImplicitFreeSurface refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:62,refactor,refactor,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,1,['refactor'],['refactor']
Modifiability,Prescribed variable diffusivities and viscosities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/781:11,variab,variable,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/781,1,['variab'],['variable']
Modifiability,Preserve locations when adapting Field to GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:24,adapt,adapting,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Modifiability,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1649:96,extend,extends,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649,2,"['adapt', 'extend']","['adapting', 'extends']"
Modifiability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:595,parameteriz,parameterization,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['parameteriz'],['parameterization']
Modifiability,Proposed enhancements/changes in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2448:9,enhance,enhancements,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2448,1,['enhance'],['enhancements']
Modifiability,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294:129,config,configuring,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294,1,['config'],['configuring']
Modifiability,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153:104,refactor,refactor,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153,1,['refactor'],['refactor']
Modifiability,Refactor SavedFields struct into a FieldWriter and FieldMemoryWriter.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/29:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/29,1,['Refactor'],['Refactor']
Modifiability,Refactor `Fields.interpolate` to make sense for `Nothing` locations and `Flat` directions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3368:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3368,1,['Refactor'],['Refactor']
Modifiability,Refactor `Fields.interpolate` to make sense for `Nothing` locations and `Flat` directions - take 2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3395:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395,1,['Refactor'],['Refactor']
Modifiability,Refactor `Simulations` + simulations infrastructure to be loaded first,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,1,['Refactor'],['Refactor']
Modifiability,Refactor `SplitExplicitFreeSurface`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894,1,['Refactor'],['Refactor']
Modifiability,Refactor `regrid!` so that it works with non-flat `x` and `y` dimensions?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2067:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067,1,['Refactor'],['Refactor']
Modifiability,Refactor boundary conditions container,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['Refactor'],['Refactor']
Modifiability,Refactor diagnostics framework?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/43:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/43,1,['Refactor'],['Refactor']
Modifiability,Refactor examples to use FieldTimeSeries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1871:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1871,1,['Refactor'],['Refactor']
Modifiability,Refactor exported names,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,1,['Refactor'],['Refactor']
Modifiability,Refactor interpolate to work for `Nothing` locations and to make sense for `Flat` topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3358:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3358,1,['Refactor'],['Refactor']
Modifiability,Refactor of some stretched rectilinear grid tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2917:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917,1,['Refactor'],['Refactor']
Modifiability,Refactor vector invariant advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2820:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2820,1,['Refactor'],['Refactor']
Modifiability,Refactor vertical vorticity to return operation rather than Field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3340:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3340,1,['Refactor'],['Refactor']
Modifiability,Refactoring Coriolis implementation and semantics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1904:0,Refactor,Refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1904,1,['Refactor'],['Refactoring']
Modifiability,Refactoring for `ImmersedBoundaries` to take precedence over `Solvers`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3847:0,Refactor,Refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3847,1,['Refactor'],['Refactoring']
Modifiability,Refactors Poisson solver interfaces and new implicit free surface solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:0,Refactor,Refactors,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['Refactor'],['Refactors']
Modifiability,Regriding enhancements,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1991:10,enhance,enhancements,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1991,1,['enhance'],['enhancements']
Modifiability,Remove Immersed map from `Adapt`ing the `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:26,Adapt,Adapt,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['Adapt'],['Adapt']
Modifiability,"Remove `GKSwstype: ""100""` from buildkite environment variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3604:53,variab,variables,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3604,1,['variab'],['variables']
Modifiability,"Reopening a PR based on #261 and #263 which I reverted as it broke some of the examples we usually run, e.g. free convection. Before merging we should probably either refactor the examples to use the new boundary conditions API or come up with this `BoundaryConditionsWizard` that does everything for us.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282:167,refactor,refactor,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282,1,['refactor'],['refactor']
Modifiability,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799:100,variab,variable,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799,1,['variab'],['variable']
Modifiability,"Revert ""Cut down the examples. Moved stuff into a sandbox.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/231:50,sandbox,sandbox,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/231,1,['sandbox'],['sandbox']
Modifiability,"Revert ""Revert ""Cut down the examples. Moved stuff into a sandbox.""""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/232:58,sandbox,sandbox,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/232,1,['sandbox'],['sandbox']
Modifiability,Rework CI to use buildkite plugin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042:27,plugin,plugin,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042,1,['plugin'],['plugin']
Modifiability,Rewrite regression tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:0,Rewrite,Rewrite,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,1,['Rewrite'],['Rewrite']
Modifiability,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719:782,sandbox,sandbox,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719,3,['sandbox'],['sandbox']
Modifiability,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1313:143,extend,extended,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313,2,['extend'],['extended']
Modifiability,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115:124,variab,variable,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115,2,['variab'],['variable']
Modifiability,"Right now we have monstrosities like (this one is a bit extreme); ```julia; Nx, Ny, Nz = model.grid.Nx, model.grid.Ny, model.grid.Nz; Lx, Ly, Lz = model.grid.Lx, model.grid.Ly, model.grid.Lz; Δx, Δy, Δz = model.grid.Δx, model.grid.Δy, model.grid.Δz. grid = model.grid; cfg = model.configuration; bcs = model.boundary_conditions; clock = model.clock. G = model.G; Gp = model.Gp; constants = model.constants; eos = model.eos; U = model.velocities; tr = model.tracers; pr = model.pressures; forcing = model.forcing; poisson_solver = model.poisson_solver. δρ = model.stepper_tmp.fC1; RHS = model.stepper_tmp.fCC1; ϕ = model.stepper_tmp.fCC2. gΔz = model.constants.g * model.grid.Δz; fCor = model.constants.f. uvw = U.u.data, U.v.data, U.w.data; TS = tr.T.data, tr.S.data; Guvw = G.Gu.data, G.Gv.data, G.Gw.data. # Source terms at current (Gⁿ) and previous (G⁻) time steps.; Gⁿ = G.Gu.data, G.Gv.data, G.Gw.data, G.GT.data, G.GS.data; G⁻ = Gp.Gu.data, Gp.Gv.data, Gp.Gw.data, Gp.GT.data, Gp.GS.data; ```. Would be nice to prettify or abstract away this unpacking. @charleskawczynski I noticed you used some @unpack macros in the code you showed on Monday, is it up on GitHub by any chance?. I think [Parameters.jl](https://github.com/mauro3/Parameters.jl) implements an @unpack macro, might be good to look at.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155:281,config,configuration,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155,1,['config'],['configuration']
Modifiability,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:521,variab,variable,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,3,['variab'],['variable']
Modifiability,Sandbox scripts for Large eddy simulation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:0,Sandbox,Sandbox,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['Sandbox'],['Sandbox']
Modifiability,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:98,adapt,adapt,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['adapt'],['adapt']
Modifiability,"SingleColumn enhancements and ""ensemble of columns"" abstraction",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,1,['enhance'],['enhancements']
Modifiability,So here a local variable `area` is defined but `area` could be `Δx`. This is confusing... right?. https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/Operators/products_between_fields_and_grid_metrics.jl#L8. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2285:16,variab,variable,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285,1,['variab'],['variable']
Modifiability,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:91,adapt,adaptive,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['adapt'],['adaptive']
Modifiability,"So, I've been running some simulations with a bunch of diagnostics, which make the simulation slower. I think some of the diagnostics that I'm calculating are already being calculated by Oceananigans (like derivatives). If I understand correctly, in each of those cases Oceananigans calculates that variable once to get the tendencies and then does the same calculation again when for my diagnostics, which seems wasteful. Is it possible (or desirable) to create a way for the code not to do the calculation twice if the user wants that diagnostic specifically? Maybe pass options when creating the model like:. ```julia; model = IncompressibleModel(grid, computed_fields=(:dudz, :dvdz,)); ```; so that those fields get stored just like the velocity and the tracers do?. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483:299,variab,variable,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483,1,['variab'],['variable']
Modifiability,Some docstring fixes/enhancements + Code cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2872:21,enhance,enhancements,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2872,2,['enhance'],['enhancements']
Modifiability,Some further enhancements for the KH example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1144:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1144,1,['enhance'],['enhancements']
Modifiability,Some phrasal enhancements in the docs/physics section. The page `physics/boundary_conditions.md` wasn't included in the `make.jl`? Is this markdown file deprecated and we should delete it altogether?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2599:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2599,1,['enhance'],['enhancements']
Modifiability,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:1657,config,configuration,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['config'],['configuration']
Modifiability,Some refactoring of `time_step!` to unify `HydrostaticFreeSurfaceModel` and `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:5,refactor,refactoring,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,1,['refactor'],['refactoring']
Modifiability,"Some time ago @sandreza and @xiaozhour suggested it would be useful to add the GM-Redi parameterization to Oceananigans.jl since we may want to train mesoscale eddy parameterizations. I'm opening this issue to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is impo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:87,parameteriz,parameterization,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,2,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,Sorry meant to delete the sandbox before merging PR #1348.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395:26,sandbox,sandbox,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395,1,['sandbox'],['sandbox']
Modifiability,Stop adapting `OffsetArray` in Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:5,adapt,adapting,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapting']
Modifiability,Store model metadata as parameterized types in the Model struct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/133:24,parameteriz,parameterized,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/133,1,['parameteriz'],['parameterized']
Modifiability,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283:52,refactor,refactors,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283,1,['refactor'],['refactors']
Modifiability,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11614,adapt,adapt,11614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['adapt'],['adapt']
Modifiability,"Supercedes #3090, introducing a more comprehensive refactoring of the CATKE formulation. Closes https://github.com/CliMA/Oceananigans.jl/issues/3064; Closes https://github.com/CliMA/Oceananigans.jl/issues/3047",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122:51,refactor,refactoring,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122,1,['refactor'],['refactoring']
Modifiability,"SurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1666,adapt,adapt,1666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Modifiability,"Thanks to @vchuravy's work, a two-year old PR was finally merged! https://github.com/JuliaArrays/OffsetArrays.jl/pull/57. So OffsetArrays v1.4.0 now adapts OffsetArrays. This means we can should rid of this file: https://github.com/CliMA/Oceananigans.jl/blob/a48f284ca7341193254ddb3fc44daa9f5e9f318d/src/Utils/adapt_structure.jl. because right now we get a method redefinition warning:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition adapt_structure(Any, OffsetArrays.OffsetArray{T, N, AA} where AA<:AbstractArray{T, N} where N where T) in module OffsetArrays at /home/alir/.julia/packages/OffsetArrays/ExQCD/src/OffsetArrays.jl:486 overwritten in module Utils at /home/alir/Oceananigans.jl/src/Utils/adapt_structure.jl:5.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:149,adapt,adapts,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapts']
Modifiability,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:531,variab,variable,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['variab'],['variable']
Modifiability,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/804:36,variab,variable,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804,2,['variab'],['variable']
Modifiability,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:316,portab,portable,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['portab'],['portable']
Modifiability,"The docs include a ""Model setup"" section which includes references and info about `Simulation`. I think we should have a separate section on `Simulation`, which includes an explanation of diagnostics, output writers, adaptive timestepping, and `run!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/946:217,adapt,adaptive,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/946,1,['adapt'],['adaptive']
Modifiability,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:664,adapt,adaptive,664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Modifiability,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1046:279,config,configuration,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046,1,['config'],['configuration']
Modifiability,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:31,extend,extend,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['extend'],['extend']
Modifiability,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:48,refactor,refactor,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,2,['refactor'],"['refactor', 'refactored']"
Modifiability,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388:128,variab,variable,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388,1,['variab'],['variable']
Modifiability,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308:121,config,configuration,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308,4,"['config', 'refactor']","['configuration', 'refactoring']"
Modifiability,"The recent diffusivity refactor #2247 changed `ExplicitTimeDiscretization` -> `Explicit`. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L8-L27. We are importing these in http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl and it seems a bit vague to import. ```Julia; using Oceananigans.TurbulenceClosures: Explicit; ```. Should we go back to bit more verbose names?. cc: @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2264:23,refactor,refactor,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2264,1,['refactor'],['refactor']
Modifiability,"The signature used to extend `FFTImplicitFreeSurfaceSolver` was not used by `build_implicit_free_surface_solver`; thus, slice ensemble models had incorrect free surface solvers. This PR fixes it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2220:22,extend,extend,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2220,1,['extend'],['extend']
Modifiability,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478:243,variab,variables,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478,1,['variab'],['variables']
Modifiability,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3252:811,variab,variably-spaced,811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252,2,['variab'],"['variably', 'variably-spaced']"
Modifiability,"There's a number of changes we should make to `TKEBasedVerticalDiffusivity` that might make parameter estimation easier:. * Pull out a single “bulk” scaling parameter from the diffusivity scalings rather than using two independent scales for Ri -> -infty and Ri -> + infty; * Identify one diffusivity as “primary” (eg tracer diffusivities), and formulate the other diffusivities in terms of the ratio between the primary diffusivity (eg, using Prandtl numbers rather than raw diffusivities); * Parameterize the diffusivity scaling functions in terms of a “-” and “delta” rather than “-” and “+” value. Eventually we want to embed a convective adjustment ""submodel"" in `TKEBasedVerticalDiffusivity`; in this we want to write the convective adjustment diffusivity as a “correction” to the ""primary"" diffusivity. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1695:494,Parameteriz,Parameterize,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1695,1,['Parameteriz'],['Parameterize']
Modifiability,"These are just functions which retrieve `Ax`, `Ay`, `Az` and `V` on the location of interest. On the other hand, they conflict with the same variables exported from `AbstractOperations`. I think they should be exported only by the latter because as `AbstractOperations` they have a unique functionality whereas from `Operators` they are just a renaming of `Axᵃᵃᵃ`, `Ayᵃᵃᵃ`, `Azᵃᵃᵃ`and `Vᵃᵃᵃ`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2158:141,variab,variables,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2158,1,['variab'],['variables']
Modifiability,"These kernels:. https://github.com/CliMA/Oceananigans.jl/blob/1dbe86c49e1d4e013c5ea595f837b4c226b1561e/src/BoundaryConditions/fill_halo_regions.jl#L51-L66. use broadcasting and are thus executed on the default CUDA stream. We should rewrite these kernels using the `KernelAbstractions.jl` kernel language so that we can control when they are executed. In particular, kernel filling for periodic directions must be filled after non-periodic directions to ensure that corner points are set properly. We can potentially solve this problem by asking *only* the west, east halo-filling routines to fill corner points. This ensures the corner points will be filled if _at least_ one direction is periodic. In the case that no directions are periodic, the corner points do not need to be filled.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/811:233,rewrite,rewrite,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811,1,['rewrite'],['rewrite']
Modifiability,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/238:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238,2,"['adapt', 'variab']","['adapts', 'variable']"
Modifiability,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2537:9,enhance,enhances,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537,1,['enhance'],['enhances']
Modifiability,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794:227,plugin,plugin,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794,4,"['evolve', 'plugin']","['evolve', 'plugin']"
Modifiability,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:710,Adapt,Adapt,710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['Adapt'],['Adapt']
Modifiability,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,2,"['adapt', 'config']","['adapts', 'configurations']"
Modifiability,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328,1,['adapt'],['adapts']
Modifiability,"This PR adds Lagrangian particle tracking for incompressible models. You construct `LagrangianParticles` by passing in a bunch of x, y, z coordinates as 1D arrays (`xs`, `ys`, `zs`) when constructing an incompressible model:. ```julia; model = IncompressibleModel(grid = grid, ..., particles = LagrangianParticles(x=xs, y=ys, z=zs)); ```. then the particles are advected with the flow at every time step (i.e. online particle advection). If arrays are used for `x`, `y`, `z` then I think you should be able to add/remove/birth/kill/breed/split/combine/beach/teleport/etc. particles at any time since arrays are mutable and the type signature of the `LagrangianParticles` won't change. In a futue PR we might want to add `LagrangianParticles` parameters, forcing functions (?), and callafters so that particle properties can be tracked, evolved, and interacted with tracers to model biogeochemistry (https://github.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091:836,evolve,evolved,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091,1,['evolve'],['evolved']
Modifiability,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:709,variab,variables,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,2,['variab'],['variables']
Modifiability,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:375,extend,extend,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,3,"['config', 'extend']","['configuration', 'extend']"
Modifiability,"This PR adds a new example called ""Microbial rock paper scissors"" in which an idealized diurnal cycle is simulated with an agent-based model of marine microbes as Lagrangian particles playing rock paper scissors. This example is loosely based off of https://github.com/ali-ramadhan/lagrangian-microbes and can be extended to to study competition between marine microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244:313,extend,extended,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244,1,['extend'],['extended']
Modifiability,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:244,adapt,adaptive,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,4,"['adapt', 'extend']","['adaptive', 'extend']"
Modifiability,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522:203,flexible,flexible,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522,2,"['flexible', 'refactor']","['flexible', 'refactoring']"
Modifiability,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014:818,extend,extend,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014,1,['extend'],['extend']
Modifiability,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:209,evolve,evolve,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['evolve'],['evolve']
Modifiability,"This PR adds an `IsopycnalSkewSymmetricDiffusivity` turbulence closure. This is otherwise knows as Gent-McWilliams parametrization but here we chose the more descriptive name. Also plans include to possibly extend this closure for turbulent viscosity. joint work with @glwagner . Resolves #1492, resolves #1972. This PR further enhances `FieldTimeSeries` to allow building `FieldTimeSeries` for data without halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994:207,extend,extend,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994,2,"['enhance', 'extend']","['enhances', 'extend']"
Modifiability,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1998:1082,refactor,refactor,1082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998,1,['refactor'],['refactor']
Modifiability,This PR adds an example that computes the linear instability of a vertically shear mean flow profile U(z) accompanied with a sheared buoyancy profile B(z) and then evolves the unstable eigenmode to its nonlinear equilibration. [preview of the docs](https://clima.github.io/OceananigansDocumentation/previews/PR1125/generated/kelvin_helmholtz_instability/),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125:164,evolve,evolves,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125,1,['evolve'],['evolves']
Modifiability,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:644,adapt,adapt,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,1,['adapt'],['adapt']
Modifiability,"This PR adds experimental support for rotating/tilting the gravity vector. I'm not even sure if it works properly but I'm opening a draft PR as it might be ready to be experimented with? I don't think we can have a non-zero gravity component along a periodic direction as the fluid just free falls along that dimension and the model blows up. But here's a thermal bubble rising with gravity tilted at 45 degrees. ![tilted_gravity_plume](https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif). This is an experimental feature since it needs more rigorous testing and because full support for tilted gravity may require more work, e.g.; 1. Should AMD use `z_dot_g_b` now?; 2. Should `∂x_b` return a vector or should it be split up into `x_dot_∂x_b`, etc.? The Leith closure uses `∂x_b`.; 3. We may want to clean up and refactor the implementation, taking some suggestions from #1151. cc @tomchor . Resolves #1151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242:865,refactor,refactor,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242,1,['refactor'],['refactor']
Modifiability,"This PR adds grid topologies: `Periodic`, `Bounded`, and `Singleton`. We should finalize our choice of named before merging. As `topology` is now a required kwarg of all grid constructors tons of refactoring was needed. It also does a bit of cleanup: `AbstractGrid` is now defined in the Grids submodule, and grids no longer have the `Tx, Ty, Tz` property (total number of grid points). Documentation should be updated before this PR is merged. Resolves #446 ; Resolves #459; Resolves #489",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614:196,refactor,refactoring,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614,1,['refactor'],['refactoring']
Modifiability,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/534:308,flexible,flexible,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534,1,['flexible'],['flexible']
Modifiability,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/783:170,flexible,flexible,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783,1,['flexible'],['flexible']
Modifiability,"This PR adds regridding in x (and there was previously untested regridding in y). Regridding is only supported for tracer fields (though it's not a huge amount of work to extend the schemes for any field). I believe the regridding is conservative for `RectilinearGrid`, and also conservative for `LatitudeLongitudeGrid` when the grids are aligned (ie when all grid lines of the coarser of the two grids is shared with the finer grid). In the case of partial overlaps on curvilinear grids, the volumes of the overlaps are approximated and thus the regridding is not perfectly conservative. It could make sense to emit a warning in this case. In principle, this should allow regridding in 3D by forming intermediate regridding in x, y, and z. We leave multi-dimensional regridding to the user for now. This PR also adds a `minimum_turbulent_kinetic_energy` and `negative_turbulent_kinetic_energy_damping_timescale` to `CATKEVerticalDiffusivity`, either of which can help stabilize 2D or 3D simulations with CATKE (where due to advection TKE may go negative).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881:171,extend,extend,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881,1,['extend'],['extend']
Modifiability,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370:25,variab,variable,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370,2,"['refactor', 'variab']","['refactors', 'variable']"
Modifiability,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1415:482,refactor,refactored,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415,1,['refactor'],['refactored']
Modifiability,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/887:836,extend,extend,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887,1,['extend'],['extend']
Modifiability,"This PR aims to create a single `FieldBoundaryConditions` function to replace `HorizontallyPeriodicBCs` and `ChannelBCs`. This paves the way for boundary conditions to become a `Field` property (#606). It's a pretty big breaking change so would be good to agree on the design and API before refactoring. Side note: Ideally we would set `default_bc(::Flat) = nothing` but until we elide operations and halo filling along `Flat` dimensions, I think we should use `default_bc(::Flat) = PeriodicBC()`. @glwagner Let me know if this looks like what we discussed. If so, I'll go ahead and change all the tests and examples to use it instead of `HorizontallyPeriodicBCs` and `ChannelBCs`. Reminder to self: Documentation, especially model setup, will have to be revised as part of this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/620:291,refactor,refactoring,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620,1,['refactor'],['refactoring']
Modifiability,"This PR aims to incorporate trained neural networks that represent the entrainment process due to turbulent convection in the upper ocean into Oceananigans.jl. This parameterization is designed to work using the TEOS-10 nonlinear equation of state, hence it works only in typical oceanographic conditions on Earth.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3819:165,parameteriz,parameterization,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3819,1,['parameteriz'],['parameterization']
Modifiability,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:28,rewrite,rewrites,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,2,"['refactor', 'rewrite']","['refactoring', 'rewrites']"
Modifiability,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1940:99,variab,variable,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940,1,['variab'],['variable']
Modifiability,"This PR changes `NonhydrostaticModel` to use a single pressure variable. Prior to this PR, pressure is decomposed into a ""hydrostatic anomaly"" and a ""non-hydrostatic"" component. The vertical momentum equation in `NonhydrostaticModel` is. $$ \partial_t w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:63,variab,variable,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['variab'],['variable']
Modifiability,"This PR changes ~two things~ about the BBL example:. - The variable `κ` was used for both the von Karman constant and for the eddy diffusivity. Now it's just used for the von Karman constant; - ~When calling `NonhydrostaticModel` we were using ordered arguments, which could make a new user interpret that they should know the order of the arguments when calling `NonhydrostaticModel`. Now this call is made in a more usual way with keyword arguments, where the order doesn't matter.~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2934:59,variab,variable,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2934,1,['variab'],['variable']
Modifiability,"This PR checks whether two grids are only different in the vertical dimension using runtime information, rather then relying on both fields being `SingleColumnGrid`. It also extends `total_length` for directions that are `Flat`, but have non-zero grid points (for simulations representing ensembles of simulations). Closes #2067",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2174:174,extend,extends,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2174,1,['extend'],['extends']
Modifiability,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1807:468,extend,extends,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807,1,['extend'],['extends']
Modifiability,"This PR defines and exports ""WENO"" `VectorInvariant`, which is a convenience constructor for `VectorInvariant` wherein the vorticity, divergence, and vertical schemes are all WENO. It also defines the proper type alias and refactors the code to make it slightly more readable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3341:223,refactor,refactors,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341,1,['refactor'],['refactors']
Modifiability,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325:24,refactor,refactoring,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325,1,['refactor'],['refactoring']
Modifiability,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295:170,parameteriz,parameterizations,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295,1,['parameteriz'],['parameterizations']
Modifiability,This PR enhances the `ShallowWaterModel` to allow for multiple fluid layers. The equations are summarized in [this overleaf doc](https://www.overleaf.com/read/mtyjxnnrjpqv). Closes #2507.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600:8,enhance,enhances,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600,2,"['enhance', 'layers']","['enhances', 'layers']"
Modifiability,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128:8,enhance,enhances,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128,1,['enhance'],['enhances']
Modifiability,"This PR extends `BatchedTridiagonalSolver` to also work when the tridiagonal direction is `x` and `y`, in addition to `z`. This is one necessary step to getting the `NonhydrostaticModel` to work with grids that are irregularly-spacing in the `x` and `y` directions. Related to https://github.com/CliMA/Oceananigans.jl/issues/3116",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117,1,['extend'],['extends']
Modifiability,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350,1,['extend'],['extends']
Modifiability,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['extend'],['extends']
Modifiability,"This PR extends the capability of the ""implicit diffusion solver"" to handle an ""additional linear term"". This feature is then used to treat the TKE dissipation term semi-implicitly in attempt to alleviate CATKE's time-step restrictions. I use quotes because it's not exactly a ""diffusion solver"" anymore. So a little name shuffling might be in order if this turns out to work well. Thanks to @yairchn for help in formulating this potential solution for CATKE's inclination toward instability.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426,1,['extend'],['extends']
Modifiability,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999,1,['extend'],['extends']
Modifiability,"This PR felt so good!. The internal code base had to be massively refactored thus the size of this PR but I think it's taking the code base in the right direction with submodules for everything, and will make implementing big new features (like vertically stretched grid and MPI) much easier and cleaner. There were a few breaking changes, e.g. `Face` and `Cell` moving to `Oceananigans.Fields`. In particular, Oceananigans does not export `day`, `minute`, `second`, and `hour` anymore as they conflict with the `Dates` module used by the logger. And it might also confuse users as to why Oceananigans is exporting these common names. They are now exported by `Oceananigans.Utils`. But otherwise, the impact to user scripts is pretty minimal (the examples barely changed). This should be merged as the next PR ASAP as merging anything else in will probably create some form of merge conflict hell. Resolves #456; Resolves #495; Resolves #497; Resolves #563",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591:66,refactor,refactored,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591,1,['refactor'],['refactored']
Modifiability,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/538:122,refactor,refactor,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538,1,['refactor'],['refactor']
Modifiability,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:323,refactor,refactoring,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['refactor'],['refactoring']
Modifiability,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413:187,adapt,adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413,1,['adapt'],['adapt']
Modifiability,"This PR generalizes file splitting for `JLD2OutputWriter`, replacing `max_filesize` with a `file_splitting` keyword argument. To implement a maximum filesize we use. ```julia; JLD2OutputWriter(model, outputs; file_splitting=FileSizeLimit(max_filesize), ...); ```. This feature should also be extended to `NetCDFOutputWriter` in this PR -- hopefully @josuemtzmo can help!. This PR will enable `TimeInterval` (or any other schedule --- `IterationInterval`, `WallTimeInterval`) to be used for splitting output files. Closes #2967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515:292,extend,extended,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515,1,['extend'],['extended']
Modifiability,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794:80,extend,extended,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794,1,['extend'],['extended']
Modifiability,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:27,refactor,refactor,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,2,['refactor'],['refactor']
Modifiability,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972:858,refactor,refactors,858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972,1,['refactor'],['refactors']
Modifiability,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:636,extend,extends,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,2,['extend'],['extends']
Modifiability,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3509:59,evolve,evolve,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509,3,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,"This PR implements an FFT-based preconditioner for `PCGImplicitFreeSurfaceSolver` on immersed boundary `RectilinearGrid`. Note that we have a direct FFT solver for _non-immersed_ `RectilinearGrid`. # Premise. The premise of the FFT-based preconditioner is to use the non-immersed FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:436,variab,variable,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['variab'],['variable']
Modifiability,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:40,parameteriz,parameterization,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,3,"['parameteriz', 'variab']","['parameterization', 'variable']"
Modifiability,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:405,evolve,evolve,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['evolve'],['evolve']
Modifiability,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:204,refactor,refactoring,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"This PR improves the `HorizontalAverage` utility to allow users to specify a return type, and refactors the code a bit to dispatch on the length of `fields`. This will be useful in the future when more sophisticated functions for computing horizontal averages (which, for example, interpolate fields to a common location) are implemented. It also refactors the time to write function and eliminates some boilerplate.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/386:94,refactor,refactors,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386,2,['refactor'],['refactors']
Modifiability,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:154,variab,variables,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,3,"['enhance', 'variab']","['enhances', 'variables']"
Modifiability,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:345,refactor,refactor,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:81,config,configurations,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['config'],['configurations']
Modifiability,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1614:161,config,configurations,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614,2,"['config', 'extend']","['configurations', 'extend']"
Modifiability,"This PR introduces a ZStar, free surface following vertical coordinate. . the vertical coordinate evolves in time and is implemented following the recipe in ; [Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models ](https://www.sciencedirect.com/science/article/abs/pii/S1463500303000544) that allows the implementation of a general vertical coordinate where the only specification needed is the vertical derivative of the vertical coordinate. Closes https://github.com/CliMA/Oceananigans.jl/issues/1679",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411:98,evolve,evolves,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411,1,['evolve'],['evolves']
Modifiability,"This PR introduces a `Simulation` type that manages time stepping with a high level interface. I think `diagnostics` and `output_writers` will have to become keyword arguments to `time_step!`. It will be a pretty big breaking change once we move `diagnostics` and `output_writers` outside of `Model` so would be good to agree on the design and API before refactoring. @glwagner Let me know what you think, we can iterate on the design in this PR. Resolves #432 ; Resolves #447",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621:355,refactor,refactoring,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621,1,['refactor'],['refactoring']
Modifiability,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:27,refactor,refactor,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['refactor'],['refactor']
Modifiability,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:831,sandbox,sandbox,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['sandbox'],['sandbox']
Modifiability,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2852:211,refactor,refactors,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852,2,"['config', 'refactor']","['configuration', 'refactors']"
Modifiability,"This PR introduces the `NormalFlow` boundary condition, and renames `BoundaryCondition(NoPenetration, nothing)` to `BoundaryCondition(NormalFlow, 0)`. There is an alias `ImpenetrableBoundaryCondition() = BoundaryCondition(NormalFlow, 0)`, though this probably won't be touched by users. This PR also extends boundary conditions to the `x`-direction, and reversed an incorrect assumption that `Value` and `Gradient` boundary conditions should be applied at all halo points. In reality, extra boundary conditions are required for the case that halo regions are larger than 1. Developing an abstraction for higher-order boundary conditions is straightforward, but is not a priority. The implementation of `NormalFlow` boundary conditions is likely incorrect for general stretched grids. We don't have a test for this, however. I think we should wait until we have full stretched grid implementation to fix this; it should not be hard. It requires correctly satisfying the continuity equations in halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710:300,extend,extends,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710,1,['extend'],['extends']
Modifiability,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589:267,refactor,refactors,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589,1,['refactor'],['refactors']
Modifiability,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250:313,refactor,refactoring,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627:74,refactor,refactoring,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627,1,['refactor'],['refactoring']
Modifiability,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253:263,rewrite,rewrite,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253,1,['rewrite'],['rewrite']
Modifiability,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/411:836,extend,extends,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411,2,['extend'],"['extending', 'extends']"
Modifiability,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:550,parameteriz,parameterization,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,3,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"This PR makes the separation computation of the hydrostatic pressure anomaly an optional feature of `NonhydrostaticModel`. It's also off by default, which hopefully means that triply periodic simulations should work by default (@johnryantaylor a while ago you wanted to do a triply periodic simulation, hopefully this PR makes that possible). @tomchor ready to review, let me know what you think about the design. This PR supercedes #3080, where there is an extended description of this change plus a discussion about its pros and cons. Closes #3364 (I think...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574:458,extend,extended,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574,1,['extend'],['extended']
Modifiability,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/677:654,refactor,refactoring,654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677,1,['refactor'],['refactoring']
Modifiability,"This PR moves the time stepping functionality into a module and refactors and orthogonalizes the time-stepping algorithm to make it easier to implement new time steppers. . It also introduces a macro `@loop_xyz` that copy-pastes code to specify a 3D loop, reducing a lot of boiler plate. There is also a new function `compute_w_from_continuity!(model)` that a user might employ to ensure their initial velocity field is non-divergent. . Resolves #485 ; Resolves #461 ; Probably resolves #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/505:64,refactor,refactors,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505,1,['refactor'],['refactors']
Modifiability,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:861,config,configuration,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['config'],['configuration']
Modifiability,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:476,refactor,refactors,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,3,"['Adapt', 'adapt', 'refactor']","['Adaptive', 'adaptive', 'refactors']"
Modifiability,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:757,Parameteriz,ParameterizedForcing,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:31,rewrite,rewrite,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['rewrite'],['rewrite']
Modifiability,"This PR readies `PartialCellBottom` for prime time. Mostly we reorganize code; the substantial changes are:. * Use `Field{Center, Center, Nothing}` for bottom_height. This is convenient mostly for `show` / `summary` but may also prove helpful for users.; * Extend implicit vertical diffusion functionality for partial cells. I'm not sure we did this right... Closes #3064",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3060:257,Extend,Extend,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3060,1,['Extend'],['Extend']
Modifiability,This PR refactors `diagnostics.jl` and `output_writers.jl` into their own submodules. We might want to discuss #497 as we refactor things into submodules as it increases the number of cross-module import statements. Helps with #456 and #495,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/498:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/498,2,['refactor'],"['refactor', 'refactors']"
Modifiability,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['refactor'],['refactors']
Modifiability,"This PR refactors each of `grids.jl`, `poisson_solvers.jl`, `diagnostics.jl` and `output_writers.jl` into their own submodules. Moving stuff into modules is a pretty disruptive change that introduces tough merge conflicts into other PRs so I also created a Grids and a Solvers submodule in preparation for the vertically stretched grid as I didn't want to include them with vertically stretched PRs that could sit open for days. The whole code still feels a bit messy to me but I think working on #497 will help a lot. Helps with #456 and #495",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512,1,['refactor'],['refactors']
Modifiability,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147,1,['refactor'],['refactors']
Modifiability,"This PR refactors the FieldBoundaryConditions constructor to allow a consistent user API for specifying field locations. Field locations are specified with _uninstantiated_ types: in other words, a location is . ```julia; (Face, Cell, Cell); ```. rather than. ```julia; (Face(), Cell(), Cell()); ```. The latter form was deemed too much `()`. This is open to debate of course. I am slightly worried the former form is non-Julian. But it seems fairly unequivocal that it's easier to read. I also took the opportunity to clean up field constructors a bit. We now have the concept of _default_ boundary conditions; mostly, this is useful when a user wants to build a field that will never call `fill_halo_regions` and therefore its boundary conditions are irrelevant. I changed the `two_dimensionsional_turbulence.jl` example to use this default. The constructor shenanigans aren't perfect, and there is still a constructor that actually does accept instantiated locations (despite that we officially discourage it, and instantiated field locations are not supported for boundary conditions or abstract operations). It seems the checkpointer needs this special constructor. Resolves #659 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698,1,['refactor'],['refactors']
Modifiability,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1040:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,1,['refactor'],['refactors']
Modifiability,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['refactor'],['refactors']
Modifiability,"This PR refactors the calculation of `isopycnal_rotation_components` to _actually_ use the ""Cox stencil"" described by [Griffies et al 1998](https://journals.ametsoc.org/view/journals/phoc/28/5/1520-0485_1998_028_0805_idiazc_2.0.co_2.xml). ~~It looks to me like MITgcm uses this so-called anti-Cox stencil.~~ It looks like MITgcm uses the Cox stencil. For example, when calculating the ""Gradient of Sigma at rVel points"" --- which appears in `isopycnal_rotation_tensor_xz_ccf` --- MITgcm uses. https://github.com/MITgcm/MITgcm/blob/9bcb4977016b9cc234328aa357b105d227417e43/pkg/gmredi/gmredi_calc_tensor.F#L712. which reconstructs the x-component of the density gradient by _averaging the gradient_ (with a four point average). On the other hand, we use. https://github.com/CliMA/Oceananigans.jl/blob/001ec56debf0447103d9b75c81de4036a8d6a94a/src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl#L68. which instead computes the _gradient of the average_ (first by averaging with 4 points, then calculating the gradient of that). ~~But Griffies 1998 describers the Cox87 discretization as~~ EDIT: we were confused by Griffies' notation. NOW, this PR changes all the buoyancy gradient calculations so they are similar to MITgcm (average of the gradient) --- the ""actually-Cox stencil"". We'll see what that does.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481,1,['refactor'],['refactors']
Modifiability,"This PR refactors the grid implementation so that the coordinate arrays `xC`, `yC`, `zC`, `xF`, `yF`, and `zF` have nodal points within the halo regions of fields and are reshape to match their respective dimension. In other words, we now have `size(c, 2) == length(yC)` and `size(u, 1) == length(xF)`, for example, and `xC * yC * zC` produces an object of `size(c)`. There are three new methods `xnodes(loc, grid::AbstractGrid)`, `ynodes(loc, grid::AbstractGrid)`, `znodes(loc, grid::AbstractGrid)`. For example, `xnodes(Cell, grid)` extracts a view over the interior nodes `grid.xC`, while `xnodes(Face, grid) extracts a view over the physical points of `grid.xF`, which include both boundaries for `Bounded` directions. In addition, the `RegularCartesianGrid` keyword `length` is changed to `extent`, and the `VerticallyStretchedCartesianGrid` no longer accepts a keyword `length`, or a keyword `z`.; Note that the `VerticallyStretchedCartesianGrid` implementation is incomplete and untested. This PR should enable saving the halos of fields in NetCDF data if desired, which is needed for reconstructing field gradients and interpolating fields in post-processing. ~~However, it seems the output writer is currently broken and tests are failing. Thus this PR is WIP.~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/715:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/715,1,['refactor'],['refactors']
Modifiability,"This PR refactors the implementation of the Field abstraction. There is now only one type of `Field`, with the type signature . ```julia; Field{Lx, Ly, Lz, A, G}; ```. where `Lx, Ly, Lz` denote the 'locations' of the field within a cell. For example, a `CellField` is now defined via. ```julia; const CellField = Field{Cell, Cell, Cell}; ```. Let's consider this PR carefully and ensure that it makes sense. Resolves #298.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409,1,['refactor'],['refactors']
Modifiability,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['refactor'],['refactors']
Modifiability,"This PR refactors the names we export publically. I think that many names have been added that are poorly motivated --- for example, MultiRegionGrid and cubed sphere grid are _very_ experimental yet still exported. This PR mostly removes exports. Most of the removals are motivated by one of two reasons: (i) the feature is experimental or (ii) the feature is not commonly used. For (i) we would like to avoid export because as an experimental feature we would like to fix bugs or change the API without incurring an ""officially breaking change"". For (ii), the purpose is merely to avoid over-polluting the namespace. For example, `XPartition` for `MultiRegionGrid` is very easily confused with `Partition` for `DistributedComputations` (the API here should probably be reconsidered, cc @simone-silvestri). More than once I have lost cluster time because I confused `YPartition(N)` with `Partition(y=N)`. But `YPartition` isn't really useful so there's little benefit to exporting this. Of course these changes are up for debate so I welcome comments. More detail:. * Remove `OceananigansLogger`: rarely used; * Add `PartialCellBottom`: we are using it in an example, indicating that it is ready for use (not necessarily completely bug-free but we would like to bring it into regular / default use now); * Remove `WENOThirdOrder`, `WENOFifthOrder`: the syntax `WENO(order=5)` is preferred (same for `Centered` and `UpwindBiased`); * Remove `location`: this is a low-level function that does not need to be part of the API; * Add `CATKEVerticalDiffusivity`: this is ready for use, a publication is imminent.; * Remove `StateChecker`: not used as far as I know.; * Remove multi-region and cubed sphere functionality: these are experimental.; * Remove `apply_regionally!, construct_regionally, @apply_regionally, MultiRegionObject`: experimental.; * Remove `Time`: too low-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,1,['refactor'],['refactors']
Modifiability,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['refactor'],['refactors']
Modifiability,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:726,refactor,refactoring,726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,1,['refactor'],['refactoring']
Modifiability,"This PR removes . * `src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl`; * `src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl`. from the source. It also does a bit of refactoring, since types like `AbstractSmagorinsky` are no longer needed to organize the Smagorinsky implementations. RIP `AbstractSmagorinsky`. PS @ali-ramadhan you might have some opinions about how I should provide citations in the source code / docstrings, which I am happy to oblige on this PR. Plus any other misc. cleanup. This PR makes progress towards #1381, and. Resolves #1002 (since the other concerns raised in #1002 can be addressed when resolving #1381).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1428:248,refactor,refactoring,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1428,1,['refactor'],['refactoring']
Modifiability,"This PR removes a bunch of scalar operations introduced by #3575 on the GPU and instead performs operations on CPU and converts to CuArrays afterwards. There are two issues that don't allow us to create the grid natively on the GPU but rather force us to create the grid on CPU and then convert it. 1. The metrics for the `OrthogonalSphericalShellGrid` use scalar operations; see the functions that are called at https://github.com/CliMA/Oceananigans.jl/blob/4c853b94e6c99949134981153250a4e2391bb0f1/src/Grids/orthogonal_spherical_shell_grid.jl#L780-L782. 2. When we create the `ConformalCubedSphreGrid`, to fill the metric and coordinate horizontal halos properly we use the same functionality that we use to fill halos for prognostic variables. To do that, we create Fields with the coordinate and metric values, call `fill_halo_regions!` on these fields, and then copy back the data from the Fields to the metrics. Copying the data from the metrics to the fields and vice-versa requires scalar operations, e.g., see ; https://github.com/CliMA/Oceananigans.jl/blob/7f12be3d82486b8be2923d8675d2e59c84efd722/src/MultiRegion/cubed_sphere_grid.jl#L280-L292. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3579:736,variab,variables,736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3579,1,['variab'],['variables']
Modifiability,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279:404,config,configuration,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279,2,['config'],['configuration']
Modifiability,"This PR removes the adapting of the immersed map from the immersed boundary grid by shuffling some definitions around and making sure that the active cells map is always passed as an argument instead of being embedded in the grid. This can possibly help with parameter space issues in complex kernels (see [ClimaOcean, Issue#116](https://github.com/CliMA/ClimaOcean.jl/issues/116#issuecomment-2273878888)). . This PR is still a draft because I would like to take the opportunity to add some docstring for the immersed map",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:20,adapt,adapting,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['adapt'],['adapting']
Modifiability,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:474,variab,variable,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,2,"['Adapt', 'variab']","['Adapt', 'variable']"
Modifiability,"This PR renames `TKEBasedVerticalDiffusivity` as `CATKEVerticalDiffusivity`, and implements the _triple max_ CATKE formulation that involves a ""convective mixing length"", in addition to the grid-proportional mixing length, and stably stratified mixing length. This formulation is described here (missing some context):. ![image](https://user-images.githubusercontent.com/15271942/128558326-5ee9e1dd-9f0e-4c98-91ee-694b4e9d72c4.png). This requires some minor modifications to the `HydrostaticFreeSurfaceModel` time-stepping algorithm and also refactoring of the `calculate_diffusivities!` interface. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1926:542,refactor,refactoring,542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1926,1,['refactor'],['refactoring']
Modifiability,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:1697,extend,extend,1697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,1,['extend'],['extend']
Modifiability,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488,1,['rewrite'],['rewrites']
Modifiability,This PR rewrites the top-level `export` statement for `Oceananigans.jl`. Mainly it omits many names from the `export` statement that we do not intend to be part of the user API. Resolves #364.; Resolves #313.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/399:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/399,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412,1,['rewrite'],['rewrites']
Modifiability,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:438,extend,extend,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['extend'],['extend']
Modifiability,This PR sets out to refactor advection along the lines proposed in #2454; A final form for the new advection scheme is still to be decided though,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2642:20,refactor,refactor,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2642,1,['refactor'],['refactor']
Modifiability,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:1181,Parameteriz,ParameterizedDiscreteBoundaryFunction,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"This PR simplifies the Docs/Appandix/Library and also adds missing modules in it. . Furthermore, it enhances formatting in several docstrings and converts some examples to doctests. Closes #2080. For example, regarding 2 vs 4 spaces in markdown formatting,. **before this PR**. <img width=""994"" alt=""Screen Shot 2021-11-25 at 4 03 01 pm"" src=""https://user-images.githubusercontent.com/7112768/143382619-b30f8312-fd64-4240-a59a-d8b3d6e50484.png"">. while **after this PR**. <img width=""861"" alt=""Screen Shot 2021-11-25 at 4 02 41 pm"" src=""https://user-images.githubusercontent.com/7112768/143382640-469f9d58-07cc-4a42-97f4-1c6c4bdeb43b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2082:100,enhance,enhances,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082,1,['enhance'],['enhances']
Modifiability,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697:205,Parameteriz,ParameterizedForcing,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697,3,"['Parameteriz', 'extend']","['ParameterizedBoundaryCondition', 'ParameterizedForcing', 'extend']"
Modifiability,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:93,variab,variable,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,1,['variab'],['variable']
Modifiability,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339:125,extend,extends,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339,1,['extend'],['extends']
Modifiability,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273:291,flexible,flexible,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273,1,['flexible'],['flexible']
Modifiability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:740,flexible,flexible,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['flexible'],['flexible']
Modifiability,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417:198,flexible,flexible,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417,2,"['flexible', 'sandbox']","['flexible', 'sandbox']"
Modifiability,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752:25,variab,variables,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752,1,['variab'],['variables']
Modifiability,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:20,Adapt,Adapt,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,3,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Modifiability,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664:223,variab,variable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664,2,"['parameteriz', 'variab']","['parameterization', 'variable']"
Modifiability,"This draft PR introduces a few enhancements to `RiBasedVerticalDiffusivity`. `RiBasedVerticalDiffusivity` imposes viscosities and diffusivities of the form. ```; ν₀ * tapering(Ri, Ri_c, Ri_d); ```. where `Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:31,enhance,enhancements,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,1,['enhance'],['enhancements']
Modifiability,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:376,variab,variable,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,2,['variab'],['variable']
Modifiability,This is a wilderness of the code with not many tests. This is part of ongoing work to build infrastructure for calibrating mesoscale parameterizations in conjunction with `OceanTurbulenceParameterEstimation.jl`. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2215:133,parameteriz,parameterizations,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2215,1,['parameteriz'],['parameterizations']
Modifiability,"This is probably fine as I don't think the MITgcm uses adaptive time stepping and for what we do I doubt we'll be changing Δt halfway through a simulation, but as it stands if Δt changes it will break some code, `read_output(...)` methods in particular.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37:55,adapt,adaptive,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37,1,['adapt'],['adaptive']
Modifiability,"This is related to the discussion in https://github.com/CliMA/Oceananigans.jl/pull/2262. Instead of defining structs specifically to symbolize directions (`Vertical`, `ThreeDimensional`, `Horizontal`) to use with `ScalarDiffusivity`, is it possible/worth it to use arrays, similar to what `Average()` does?. In this way, instead of specifying a `ConstantDiffusivity` as . ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=Horizontal()); ```. a user would write. ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=(1,2)); ```. Seems to me like this would be more general and it would also decrease the amount of code used, but I'm not very familiar with that part of the code (especially since the recent refactor) so can't be sure. I thought it was worth posting about this though. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2265:751,refactor,refactor,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265,1,['refactor'],['refactor']
Modifiability,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:742,refactor,refactors,742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,1,['refactor'],['refactors']
Modifiability,This is the latest attempt to preserve locations when adapting `Field` to the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:54,adapt,adapting,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Modifiability,"This issue describes an overhaul / refactoring of the ""Model setup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://gi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672,1,['refactor'],['refactoring']
Modifiability,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:1294,Refactor,Refactor,1294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,1,['Refactor'],['Refactor']
Modifiability,"This may require extending `heatmap!` directly, probably using the utilities developed for Imaginocean. Another possibility is to generate heatmaps in ""array coordinates"" rather than making heatmaps in geographic coordinates. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3811:17,extend,extending,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3811,1,['extend'],['extending']
Modifiability,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,1,['Adapt'],['Adapt']
Modifiability,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,1,['Adapt'],['Adapt']
Modifiability,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/891:174,variab,variable,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891,1,['variab'],['variable']
Modifiability,Time_step refactor and new Model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:10,refactor,refactor,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,1,['refactor'],['refactor']
Modifiability,"To do:. - [ ] Add docs for `UpwindBiased` reconstruction; - [ ] Refactor `UpwindBiased` to get rid of ""coeffs"" for stretched grids; - [ ] Fix up docs for `WENO`; - [ ] Clean up constructors for advection schemes; - [ ] Throw errors in advection scheme constructors if the grid halo is too small. Resolves #2717",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2972:64,Refactor,Refactor,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2972,1,['Refactor'],['Refactor']
Modifiability,"To reduce the number of operations, the number of memory allocations, and register pressure in GPU kernels, we might want to try refactoring upwind schemes to convert this pattern. ```julia; @inline upwind_biased_product(ũ, ψᴸ, ψᴿ) = ((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2. @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v). ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); uᴸ = _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); uᴿ = _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u). return Ayᵃᵃᶠ(i, j, k, grid) * upwind_biased_product(ṽ, uᴸ, uᴿ); end; ```. to something like. ```julia; @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v); ; ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); u = ṽ > 0 ? _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u) :; _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); ; return Ayᵃᵃᶠ(i, j, k, grid) * ṽ * u; end; ```. Could save a lot of operations and register pressure for higher-order schemes. I actually don't see why `((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2` is used instead of if-statements. Maybe @christophernhill or @jm-c know?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987:129,refactor,refactoring,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987,1,['refactor'],['refactoring']
Modifiability,True portable RNG for deep convection golden master test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/219:5,portab,portable,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/219,1,['portab'],['portable']
Modifiability,Turbulence closure kernel refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:26,refactor,refactor,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['refactor'],['refactor']
Modifiability,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:13402,config,configure,13402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['config'],['configure']
Modifiability,Update packages and one less adapt,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1142:29,adapt,adapt,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1142,1,['adapt'],['adapt']
Modifiability,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296:168,Adapt,Adapt,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296,1,['Adapt'],['Adapt']
Modifiability,Use a dynamic launch config for more kernels,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/271:21,config,config,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/271,1,['config'],['config']
Modifiability,Use adaptive timestep in two-dimensional turbulence example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3540:4,adapt,adaptive,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3540,1,['adapt'],['adaptive']
Modifiability,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191:8,variab,variable,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191,2,['variab'],['variable']
Modifiability,Variable grid spacing in horizontal dimension (x or y) causes `NonhydrostaticModel` instantiation to fail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191:0,Variab,Variable,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191,1,['Variab'],['Variable']
Modifiability,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3307:1742,variab,variably,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307,1,['variab'],['variably']
Modifiability,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682:653,variab,variables,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682,1,['variab'],['variables']
Modifiability,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490:109,variab,variable,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490,3,"['extend', 'variab']","['extends', 'variable', 'variables']"
Modifiability,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769:215,parameteriz,parameterized,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769,2,['parameteriz'],['parameterized']
Modifiability,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186:38,variab,variables,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186,2,"['extend', 'variab']","['extended', 'variables']"
Modifiability,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/428:348,layers,layers,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428,1,['layers'],['layers']
Modifiability,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896:637,Parameteriz,ParameterizedForcing,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"We need to extend our verification tests for the AMD closure to compare results for all turbulence closures we have implemented. As of now, the only turbulence closure implemented is `SmagorinskyLilly`. When #440 is resolved we can compare to the Vreman closure as well. This applies to . * Stratified Couette flow verification; * free convection verification; * Kato-Phillips verification. ref #81 and #381 . cc @tapios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/441:11,extend,extend,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441,1,['extend'],['extend']
Modifiability,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:429,config,configured,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,2,['config'],"['configured', 'configuring']"
Modifiability,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:658,variab,variably,658,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,2,['variab'],['variably']
Modifiability,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381:1115,variab,variable,1115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381,1,['variab'],['variable']
Modifiability,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163,3,['adapt'],['adapt']
Modifiability,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86:776,refactor,refactoring,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86,1,['refactor'],['refactoring']
Modifiability,"Would be nice to specify a list of e.g. 32 parameters and just spin off 32 models running in different configurations, maybe on Google Cloud. I think this is something Chris might have already figured out:; * https://github.com/christophernhill/oceananiganshacks; * https://github.com/ali-ramadhan/gcloudhacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/144:103,config,configurations,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/144,1,['config'],['configurations']
Modifiability,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:569,plugin,plugin,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"[This `if`-statement](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L140) is not necessary, because the architecture can be known from the array types of the `CellField`s. Specifically, [this line](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/spectral_solvers.jl#L389) can be changed to. ```; function solve_poisson_3d_ppn_planned!(ssp::SpectralSolverParameters, g::RegularCartesianGrid, f::CellField{T}, ϕ::CellField{T}) where T<:CuArray. ... end; ```. I think it would actually be preferable to dispatch on the type of the arrays in `RegularCartesianGrid`. However, it does not appear that the arrays representing the coordinates of the grid are parameterized in [the definition of `RegularCartesianGrid`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/grids.jl#L12). Why is that? . If the array type of the problem is part of `RegularCartesianGrid`, then dispatch can be used in place of `if`-statements all over the code, especially in `fields.jl`. Finally, the term 'spectral solvers' is misleading here. The solver does not have spectral accuracy; it simply uses the FFT, which *happens* to be used to solve different problems that have a 'spectral' character.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45:770,parameteriz,parameterized,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45,1,['parameteriz'],['parameterized']
Modifiability,[WIP] Adapt Field to run on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:6,Adapt,Adapt,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,1,['Adapt'],['Adapt']
Modifiability,[WIP] Enhance `ShallowWater` model to allow for multiple fluid layers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600:6,Enhance,Enhance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600,2,"['Enhance', 'layers']","['Enhance', 'layers']"
Modifiability,[WIP] Extend MultiRegion to NonhydrostaticModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:6,Extend,Extend,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,1,['Extend'],['Extend']
Modifiability,"[WIP] Implement ""MEKE"" parameterization with prognostic mesoscale eddy kinetic energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:23,parameteriz,parameterization,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['parameteriz'],['parameterization']
Modifiability,[WIP] Work on AMD gpu portability,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540:22,portab,portability,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540,1,['portab'],['portability']
Modifiability,"\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:1200,variab,variable,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,2,['variab'],['variable']
Modifiability,`Adapt`ing all fields of the `OrthogonalSphericalShellGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619:1,Adapt,Adapt,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619,1,['Adapt'],['Adapt']
Modifiability,`FieldTimeSeries` does not adapt correctly on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,1,['adapt'],['adapt']
Modifiability,`Field` major refactor: one `Field` to rule them all,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:14,refactor,refactor,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,1,['refactor'],['refactor']
Modifiability,`MultiRegion` adaptation of the `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795:14,adapt,adaptation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795,1,['adapt'],['adaptation']
Modifiability,"`Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware M",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2732,variab,variable,2732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['variab'],['variable']
Modifiability,`Oceananigans.short_show` should really extend `Base.summary`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1986:40,extend,extend,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986,1,['extend'],['extend']
Modifiability,`PartialCellBottom` needs to be adapted correctly for the GPU when using a `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:32,adapt,adapted,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapted']
Modifiability,"`parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3557,Parameteriz,Parameterized,3557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['Parameterized']
Modifiability,`time_step!` function for adaptive time stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431:26,adapt,adaptive,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431,1,['adapt'],['adaptive']
Modifiability,"a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1004,Variab,Variable,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Variab'],['Variable']
Modifiability,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11570,Adapt,Adapt,11570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Modifiability,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:982,config,configurations,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,2,['config'],"['configuration', 'configurations']"
Modifiability,"ary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:1218,config,configurations,1218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,1,['config'],['configurations']
Modifiability,"at the moment, the default time stepping function is designed with the non-hydrostatic model in mind, so the logical steps of a time step (or substep for RK3) are. ```julia; step_variables!(...); calculate_pressure_correction!(...) ; pressure_correct_velocities!(...); compute_new_tendencies!(...); ```; In the hydrostatic model, we are extending the `step_variables!` function to include a `step_free_surface!` function that calculates `η` and we set ; ```julia; calculate_pressure_correction!(::HydrostaticFreeSurfaceModel, ...) = nothing; ```; I would like to calculate the free surface in the `calculate_pressure_correction!` function to unify conceptually the `NonhydrostaticModel` and the `HydrostaticFreeSurfaceModel`, minimize the amount of code, and reduce the necessity for extending the time-stepping function.; This will make it easier to implement new time-stepping schemes that work for both the models",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:337,extend,extending,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,2,['extend'],['extending']
Modifiability,"ay has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstracti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1827,Adapt,Adapt,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Modifiability,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11641,Adapt,Adapt,11641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Modifiability,"daryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δλ, Δϕ, Δz, λᶠᵃᵃ, λᶜᵃᵃ, ϕᵃᶠᵃ, ϕᵃᶜᵃ, zᵃᵃᶠ, zᵃᵃᶜ, radius); Grids/regular_latitude_longitude_grid.jl: ""grid spacing (Δλ, Δϕ, Δz): "", (g.Δλ, g.Δϕ, g.Δz)); Grids/regu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16597,sandbox,sandbox,16597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Modifiability,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/generic_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:63192,Parameteriz,ParameterizedForcing,63192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"e)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = GPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:4269,adapt,adaptive,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['adapt'],['adaptive']
Modifiability,"eBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}},NamedTuple{(:b,),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:16377,Parameteriz,ParameterizedDiscreteBoundaryFunction,16377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"ec u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clums",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4054,extend,extend,4054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['extend'],['extend']
Modifiability,"eling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:995,refactor,refactoring,995,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,2,"['refactor', 'variab']","['refactoring', 'variables']"
Modifiability,"ence and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = 0.0; bᵢ(x, y, z) = 0e-6*rand(). model = NonhydrostaticModel(; grid,; background_fields = (u=U, b=B),; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:1523,Evolve,Evolve,1523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['Evolve'],['Evolve']
Modifiability,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:1500,variab,variables,1500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,1,['variab'],['variables']
Modifiability,"erent advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:1178,extend,extending,1178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['extend'],['extending']
Modifiability,"eriodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,BuoyancyTracer,FPlane{Float64},Nothing,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:15541,Parameteriz,ParameterizedDiscreteBoundaryFunction,15541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:1981,evolve,evolved,1981,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['evolve'],['evolved']
Modifiability,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:2279,variab,variable,2279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,2,['variab'],['variable']
Modifiability,fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2033,Adapt,Adapt,2033,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Adapt'],['Adapt']
Modifiability,"fsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51286,sandbox,sandbox,51286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Modifiability,"g, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, LX::Center, LY::Center, LZ::Nothing, grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, x::Float64, y::Float64, z::Int64); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:187; [5] top-level scope; @ REPL[19]:1; ```. It doesn't really make sense to have to pass a `z` location into `interpolate`. I think we should refactor this function to read something like. ```julia; interpolate(to_node, from_field, from_location, from_grid); ```. Then `to_node` can be a tuple of appropriate length for the `from_location` and `from_grid` topology.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356:2908,refactor,refactor,2908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356,1,['refactor'],['refactor']
Modifiability,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1708,extend,extend,1708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['extend'],['extend']
Modifiability,"he context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:2450,parameteriz,parameterizations,2450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['parameteriz'],['parameterizations']
Modifiability,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:3027,variab,variables,3027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,3,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"hm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1419,extend,extend,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['extend'],['extend']
Modifiability,https://github.com/ali-ramadhan/Oceananigans.jl/blob/a41c604e9360ba79ce11efe6d4d6370bf79a3cc6/src/model.jl#L1. It would make model construction much more flexible. Would this hinder performance?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/42:154,flexible,flexible,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42,1,['flexible'],['flexible']
Modifiability,"https://painterqubits.github.io/Unitful.jl/stable/. The obvious use case would be to replace the units (e.g. `minutes` and `years`) in `Oceananigans.Utils` with ""proper units"" from Unitful.jl. Not sure if we want to use it absolutely everywhere. Would be cool and there should be no performance hit, but might take quite a bit of refactoring. Could also be useful for defining constants in examples and scripts? Might be cool to play around with it a bit. Apparently @alanedelman is gonna be making fun of us for not using it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1116:330,refactor,refactoring,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116,1,['refactor'],['refactoring']
Modifiability,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1556,Adapt,Adapt,1556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Modifiability,"ical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1023,config,configured,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['config'],['configured']
Modifiability,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594:1804,adapt,adapt,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594,2,"['adapt', 'flexible']","['adapt', 'flexible']"
Modifiability,"is PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2705,variab,variables,2705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['variab'],['variables']
Modifiability,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:2151,extend,extend,2151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,4,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"l and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only wo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:1375,variab,variable,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['variab'],['variable']
Modifiability,"left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition, for example, the user might write (to specify the boundary condition as a function). ```julia; model = Model(...). const constant_flux = # something; surface_temperature_flux(args...) = constant_flux; flux_bc = BoundaryCondition{Flux}(surface_temperature_flux); model.boundary_conditions.T.z.right = flux_bc; ```. to specify the boundary condition as a constant, . ```julia; model = Model(...). flux_bc = BoundaryCondition(Flux, constant_flux); model.boundary_conditions.T.z.right = flux_bc; ```. There are probably some sugary things that we can implement to smooth this specification. ### Caveats. * We support only flux boundary conditions at top and bottom at the moment; * We can only handle fluxes in terms of the constant vertical viscosities and diffusivities; * If the viscosities and diffusivities are allowed to vary in the vertical at some point in the future, we will have to re-configure the implementation; * We cannot intercept the specification of a flux if we have, for example, a parameterization like KPP that takes care of the surface fluxes with a closure (rather than as a boundary condition). ### A side note. I think that, at some point, it would be preferable to move the implementation of boundary conditions and equations to a new file / module so that new physics can be easily implemented my modifying that module / file.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118:2894,config,configure,2894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118,2,"['config', 'parameteriz']","['configure', 'parameterization']"
Modifiability,"lenceClosures.HyperbolicTangentRiDependentTapering}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:b,), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:\u03bb, :initial_buoyancy), Tuple{Float64, typeof(WenoNeverworld.initial_buoyancy_parabola)}}, typeof(WenoNeverworld.buoyancy_top_relaxation)}}}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to xnode); Stacktrace:; [1] node; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/grid_utils.jl:230; [2] buoyancy_top_relaxation; @ /nobackup1c/users/ssilvest/WenoNeverworld.jl/src/weno_neverworld.jl:47; [3] getbc; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BoundaryConditions/discrete_boundary_function.jl:41; [4] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy_tracer.jl:18; [5] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy.jl:76; [6] macro expansion; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl:190; [7] gpu_compute_ri_based_diffusivities!; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_compute_ri_based_diffusivities!; ```. Instances of `xnode` (and I would have to guess also `ynode` and `znode`) are not adapted to fit the new syntax",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:6944,adapt,adapted,6944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['adapt'],['adapted']
Modifiability,"me = "" * string(prettytime(times[$n])); fig[1, 1:5] = Label(fig, title, fontsize=24, tellwidth=false);. resize_to_layout!(fig); @info ""Animating...""; record(fig, filename * "".mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```. This simulation runs for 10 minutes and then plots this (on a 32x32 grid):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/e4fc9a13-f14f-4c6d-bda6-0d4aae79ac4c. So basically there's a discontinuity in the vertical direction's pressure, which causes an artificial vertical pressure gradient, causing a spurious flow at the top and bottom, even those aren't supposed to be boundaries since the grid is periodic in `z`.; It seems like this comes from the fact that the hydrostatic pressure isn't periodic (since it always comes from a vertical b integral I think), but the nonhydrostatic pressure *is* periodic. This in turn leads the total pressure to have a discontinuity. In fact if we run the exact same configuration but make both the gravitational direction and the periodic direction the `x` direction (code [here](https://pastebin.com/skAB1Bt4)) we have a plume looks and behaves as expected and has no discontinuities:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/97ab7df9-4b64-4f65-9433-4eb9a5e7fe22. I'm not sure if this is something that needs fixing or if it's just a consequence of the hydrostatic decomposition, which always assumes gravity is in the `NegativeZDirection()` and that `z` is `Bounded`. Hence I'm not sure this is better left as an issue or a discussion, so please lmk if I should move this to a discussion. Also, if I run the example above (where gravity is in the `z` direction) using https://github.com/CliMA/Oceananigans.jl/pull/3080, which gets rid of the hydrostatic pressure separation, then I get what I believe to be the correct behavior (all pressures in the animation below are actually total pressure):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/60ef470d-22d7-429a-9029-adb7db5687ba. Whic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290:4019,config,configuration,4019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290,1,['config'],['configuration']
Modifiability,"n_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields be? Should they really only appear in the advective terms, or should they also be diffused? And what should the boundary conditions on perturbations be when there are background fields?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:1961,config,configuration,1961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,1,['config'],['configuration']
Modifiability,"ncies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:2071,Adapt,Adapt,2071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['Adapt'],['Adapt']
Modifiability,"ng packages. An alternative would be to use the much more mature [netcdf4-python](http://unidata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; > ; > _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/31#issuecomment-468288154_. Some more comments:; * Right now NetCDF output is much slower than expected. We have asynchronous output writing #137 but spending 2-3 minutes to write out the fields of a 256³ grid is ridiculous.; * Compression doesn't seem to work in NetCDF.jl: See https://github.com/JuliaGeo/NetCDF.jl/issues/87; * We might want to share this output writing feature with CliMA.jl. See https://github.com/climate-machine/CLIMA/issues/114; * @simonbyrne and @charleskawczynski suggested looking at [HDF5.jl](https://github.com/JuliaIO/HDF5.jl). As NetCDF4 is built on HDF5, we should be able to generate valid NetCDF files with it.; * Whatever we end up doing, @christophernhill makes a good point that we should produce portable NetCDF files as this is what all our potential users would expect and want.; * Thinking more long-term @lcw says that IO performance is a hard problem and thinks we are going to want something that plays well on clusters (e.g., something MPI IO based). Some extra features we might want in the short-term:; - [ ] Option to only write out a specific subset of the model state, e.g. surface velocities only, or a vertical temperature slice. This would really speed up IO if you don't need full 3D fields.; - [ ] Select which fields to write out to NetCDF.; - [ ] Include diagnostics in NetCDF output. I believe this will be possible if we resolve the item above as output writing occurs right after diagnostics are run, so diagnostic fields can just be included as one of the fields to write out.; - [ ] Option to create one NetCDF file for each iteration, or to combine all output into one NeCDF file. I think the main point of this issue is that we should decide how to output NetCDF. Pac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145:1496,portab,portable,1496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145,1,['portab'],['portable']
Modifiability,"nge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubusercontent.com/13205162/100126723-2e4dea00-2e33-11eb-8a80-f97c525c6e91.png). Am I missing something here?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203:1901,variab,variables,1901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203,1,['variab'],['variables']
Modifiability,"nicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kernel). ~Requires https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 # On hold at the moment~; Closes #615; Closes #1882; Closes #3067; Closes #3068 ; Supersedes #2953",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:4263,parameteriz,parameterization,4263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['parameteriz'],['parameterization']
Modifiability,"ntext of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:1020,evolve,evolve,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['evolve'],['evolve']
Modifiability,"odel = HydrostaticFreeSurfaceModel(; closure=ivd_closure, model_kwargs...); explicit_model = HydrostaticFreeSurfaceModel(; closure=evd_closure, model_kwargs...); models = (implicit_model, explicit_model); ; initial_temperature(x, y, z) = exp(-z^2 / 0.02). [set!(model, c=initial_temperature) for model in models]. z = znodes(implicit_model.tracers.c). c_implicit = view(interior(implicit_model.tracers.c), 1, 1, :); c_explicit = view(interior(explicit_model.tracers.c), 1, 1, :). c_plot = plot(c_implicit, z, linewidth = 2, label = ""t = 0"", xlabel = ""Tracer concentration"", ylabel = ""z""); ; diffusion_time_scale = implicit_model.grid.Δz^2 / implicit_model.closure.κz.c; stop_time = 100diffusion_time_scale. simulations = [Simulation(explicit_model, Δt = 1e-1 * diffusion_time_scale, stop_time = stop_time),; Simulation(implicit_model, Δt = 1e0 * diffusion_time_scale, stop_time = stop_time)]. [run!(simulation) for simulation in simulations]. plot!(c_plot, c_implicit, z, linewidth = 3, alpha = 0.6, label = @sprintf(""implicit model, t = %.3e"", model.clock.time)); plot!(c_plot, c_explicit, z, linewidth = 2, linestyle = :dash, label = @sprintf(""explicit model, t = %.3e"", model.clock.time)). display(c_plot); ```. produces. <img width=""1392"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117589924-a6f2eb00-b0e1-11eb-87a2-fb51a4eacc85.png"">. Note that with implicit treatment of the diffusion term we can use a time step comparable to the diffusion time-scale. The same time-step with explicit time discretization leads to model blow up. ~~Future~~ This PR ~~will hopefully~~ extends functionality to other closures and also to `IncompressibleModel` and the RK3 time-stepper. In the process of cleaning up TurbulenceClosures I am also resolving a few other issues, such as an incorrect formulation of viscous fluxes for `IsotropicDiffusivity` and the semi-random default viscosity and thermal diffusivities that we've been using. Resolves #1278; Resolves #1643 ; Resolves #1644",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:3643,extend,extends,3643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,1,['extend'],['extends']
Modifiability,"odes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=6hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_pert_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_pert_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```. Method 2: evolve total field. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:3456,evolve,evolve,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['evolve'],['evolve']
Modifiability,"ognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1452,variab,variable,1452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['variab'],['variable']
Modifiability,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:7183,variab,variables,7183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['variab'],['variables']
Modifiability,"on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:1032,Extend,Extend,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['Extend'],['Extend']
Modifiability,"on`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:5788,extend,extend,5788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['extend'],['extend']
Modifiability,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3615,adapt,adapt,3615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['adapt'],['adapt']
Modifiability,"or example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common and useful development paradigm). What do others think about this? @iuryt @johnryantaylor @rafferrari @simone-silvestri @christophernhill @jm-c @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:2685,layers,layers,2685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['layers'],['layers']
Modifiability,"ostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1141,adapt,adapt,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Modifiability,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2090,refactor,refactored,2090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['refactor'],['refactored']
Modifiability,"othing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:2492,refactor,refactor,2492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['refactor'],['refactor']
Modifiability,"plemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:1702,variab,variables,1702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,1,['variab'],['variables']
Modifiability,"ple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:4446,layers,layers,4446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['layers'],['layers']
Modifiability,proabably because of previous refactoring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3827:30,refactor,refactoring,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3827,1,['refactor'],['refactoring']
Modifiability,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:4652,adapt,adaptive,4652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Modifiability,"rdinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2724,evolve,evolve,2724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['evolve'],['evolve']
Modifiability,refactoring of the `SplitExplicitFreeSurface` to comply with issue #3873,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894:0,refactor,refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894,1,['refactor'],['refactoring']
Modifiability,revamp of lagrangian particles to make sure that they work on a `LatitudeLongitudeGrid` and on an `ImmersedBoundaryGrid` (and adaptation to all the new changes to Oceananigans). closes #2397 ; closes #2395,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2658:126,adapt,adaptation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2658,1,['adapt'],['adaptation']
Modifiability,"rid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1230,Variab,Variable,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Variab'],['Variable']
Modifiability,"s of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:1824,Extend,Extend,1824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['Extend'],['Extend']
Modifiability,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1748,refactor,refactor,1748,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['refactor'],['refactor']
Modifiability,"s without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:1304,variab,variables,1304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['variab'],['variables']
Modifiability,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1829,adapt,adapt,1829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['adapt'],['adapt']
Modifiability,"se information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:1486,variab,variables,1486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['variab'],['variables']
Modifiability,"t I'm opening it to make the future design of the pressure solver module more transparent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1021,refactor,refactors,1021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['refactor'],['refactors']
Modifiability,"tead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:1902,refactor,refactoring,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['refactor'],['refactoring']
Modifiability,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7321,adapt,adapts,7321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,2,['adapt'],"['adapting', 'adapts']"
Modifiability,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:2799,variab,variable,2799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['variab'],['variable']
Modifiability,"tical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2856,variab,variables,2856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,3,['variab'],['variables']
Modifiability,"time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions and forcing functions. Previously, discrete-form boundary condition functions and forcing functions contained an object called `state`: `state.velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3873,Parameteriz,Parameterized,3873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['Parameterized']
Modifiability,"tions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,; Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:75138,Parameteriz,ParameterizedForcing,75138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is important:. From https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; ![image](https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:1561,parameteriz,parameterization,1561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,1,['parameteriz'],['parameterization']
Modifiability,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253:223,Adapt,Adapt,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253,1,['Adapt'],['Adapt']
Modifiability,"tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta t^n}{\Delta t^{n - 1}} \right) G^n - \frac{\Delta t^n}{\Delta t^{n - 1}} G^{n-1} \right); ```; However, also in this form, successive tendencies do not cancel out.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:2119,variab,variable,2119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,2,['variab'],"['variable', 'variablestep']"
Modifiability,"ttps://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:1112,parameteriz,parameterization,1112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['parameteriz'],['parameterization']
Modifiability,"unctions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1278,Adapt,Adapt,1278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Modifiability,"ure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoustic time stepper (nothing, fully explicit for regular grids, vertically implicit for stretched grids); 4. Setting fields and initial conditions is more complicated because the density needs to be adjusted when setting the potential temperature. Also because the prognostic variables are ρ, ρu, ρv, ρw, ρθ, etc.; 5. Other atmospheric things like cloud microphysics and radiation but for this there are packages that can be relied on, e.g. [RRTMGP.jl](https://github.com/climate-machine/RRTMGP.jl) and [Cloudy.jl](https://github.com/climate-machine/Cloudy.jl). It would be ideal if we have a single `Model` type and just change the equation between the `CompressibleModel` and `IncompressibleModel` but the numerical methods and abstractions employed are sufficiently different that I think it makes sense to have two separate model types. It might even make sense to keep a separate package for this `CompressibleModel` but I think for now it's better if we keep it all inside the Oceananigans.jl repository (see https://github.com/climate-machine/Oceananigans.jl/issues/284 for some previous discussion) until the code is more stable and also for extra visibility while the package is young. References:; Bannon (1995): https://doi.org/10.1175/1520-0469(1995)052%3C1743:HALP%3E",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605:2273,variab,variables,2273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605,1,['variab'],['variables']
Modifiability,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:2072,extend,extend,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['extend'],['extend']
Modifiability,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:4461,config,configuration,4461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['config'],['configuration']
Modifiability,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:2866,variab,variable,2866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,1,['variab'],['variable']
Modifiability,"using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1151,variab,variable,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['variab'],['variable']
Modifiability,"y `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusiv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1430,inherit,inherit,1430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['inherit'],['inherit']
Modifiability,"y conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:1335,flexible,flexible,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['flexible'],['flexible']
Modifiability,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:2785,refactor,refactoring,2785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['refactor'],['refactoring']
Modifiability,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['adapt'],['adapts']
Performance, /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 26236174 (Pool: 26209699; Big: ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5338,cache,cache,5338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance," 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceanan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:28328,load,loadsave,28328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['load'],['loadsave']
Performance," GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid);",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1372,optimiz,optimizing,1372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['optimiz'],['optimizing']
Performance," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2003,optimiz,optimize,2003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['optimiz'],['optimize']
Performance," MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.jul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4599,load,loading,4599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance," StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:80311,load,loadsave,80311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['load'],['loadsave']
Performance," `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, length=50); ; Tlims ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:5662,load,load,5662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['load'],['load']
Performance," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7289,perform,performance,7289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['perform'],['performance']
Performance," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:1082,Load,LoadError,1082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['Load'],['LoadError']
Performance, advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2501,cache,cache,2501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4554,optimiz,optimize,4554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['optimiz'],['optimize']
Performance," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314:1043,Load,LoadError,1043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314,2,"['Load', 'load']","['LoadError', 'loading']"
Performance," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:3066,perform,performance,3066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,4,['perform'],['performance']
Performance, v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [7da242da] Enzyme v0.11.19; ⌅ [f151be2c] EnzymeCore v0.6.5; [460bff9d] ExceptionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2585,Concurren,ConcurrentUtilities,2585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Concurren'],['ConcurrentUtilities']
Performance,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1351,Load,LoadError,1351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['Load'],['LoadError']
Performance,"# Introduction. This PR introduces `AbstractOperation`s for constructing 3D expressions with a friendly syntax (eg, not writing kernels), which can then be evaluated online during a simulation for diagnostics / output purposes. This PR introduces four kinds of `AbstractOperation`s:. 1. `Derivative` (things like `∂x`, `∂y`); 2. `BinaryOperation` (things like `a-b`, `a^b`); 3. `UnaryOperation` (things like `sqrt`, `sin`, `cos`); 4. `PolynaryOperation` (things like `a + b + c + d` or `a * b * c * d`). All of these act on combinations of `Field`, `Function`, and `Number`. `. `AbstractOperation`s arise from what appears to be ordinary arithmetic and calculus performed on `Field`s. Consider this example:. ```julia; julia> using Oceananigans; using Oceananigans: Face, Cell; using Oceananigans.AbstractOperations. grid = RegularCartesianGrid((16, 16, 16), (16, 16, 16));; a = Field(Cell, Cell, Cell, CPU(), grid);; b = Field(Cell, Cell, Cell, CPU(), grid);; a_times_b = a * b;. julia> typeof(a_times_b).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation; ```. Here, the object `a_times_b` is of the type `BinaryOperation`. `a_times_b` can be indexed into like an array or field, however:. ```julia; julia> a_times_b[8, 8, 8]; 0.0. set!(a, rand(size(grid)...)); set!(b, rand(size(grid)...)). julia> a_times_b[8, 8, 8]; 0.5342645056606357; ```. # Staggered grids, interpolation, and operation ""location"". Operations can also be defined between fields at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_en",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:662,perform,performed,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performed']
Performance,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:261,Load,LoadError,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['Load'],['LoadError']
Performance,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:429,perform,performance,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['perform'],['performance']
Performance,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:3215,load,loading,3215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['load'],['loading']
Performance,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:82,perform,performing,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['perform'],['performing']
Performance,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:709,Load,LoadError,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['Load'],['LoadError']
Performance,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1657,Load,LoadError,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['Load'],['LoadError']
Performance,"* ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2075,cache,cache,2075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8765,cache,cache,8765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,", 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:308; [8] #87 at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:6998,cache,cache,6998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['cache'],['cache']
Performance,", like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1713,Load,LoadError,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['Load', 'load']","['LoadError', 'load']"
Performance,", no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and mer",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:2248,Perform,Performance,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['Perform'],['Performance']
Performance,", v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:4758,perform,performed,4758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performed']
Performance,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1868,perform,performance,1868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['perform'],['performance']
Performance,-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8054,cache,cache,8054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5839,cache,cache,5839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:6091,load,loading,6091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,5,['load'],['loading']
Performance,".OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:288; [9] cufunction; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:282 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:102 [inlined]; [11] #launch_heuri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:3556,cache,cache,3556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['cache'],['cache']
Performance,".c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8566,cache,cache,8566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3081,cache,cache,3081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6816,cache,cache,6816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iterati",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8675,cache,cache,8675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17..",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8971,cache,cache,8971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5765,cache,cached,5765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['cache'],"['cached', 'caches']"
Performance,00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdc,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5947,cache,cache,5947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,01/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4585,cache,cache,4585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:4940,load,loading,4940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,5,['load'],['loading']
Performance,0a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4996,cache,cache,4996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1268,Load,LoadError,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['Load'],['LoadError']
Performance,10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4026,cache,cache,4026,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1812,Load,LoadError,1812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['Load'],['LoadError']
Performance,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1491,Load,LoadError,1491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['Load'],['LoadError']
Performance,4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5167,load,loading,5167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['load'],['loading']
Performance,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3973,perform,performance,3973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['perform'],['performance']
Performance,"520 ms │ 20.519 ms │ 5.56 MiB │ 17974 │ 10 │; │ GPU │ (2, 5) │ 15.824 ms │ 21.211 ms │ 21.064 ms │ 24.897 ms │ 7.86 MiB │ 23938 │ 10 │; │ GPU │ (2, 10) │ 22.085 ms │ 27.236 ms │ 28.231 ms │ 38.295 ms │ 15.02 MiB │ 31086 │ 10 │; └───────────────┴─────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘. Arbitrary tracers CPU to GPU speedup; ┌─────────┬─────────┬─────────┬─────────┐; │ tracers │ speedup │ memory │ allocs │; ├─────────┼─────────┼─────────┼─────────┤; │ (0, 0) │ 112.881 │ 1.78792 │ 7.44022 │; │ (0, 1) │ 112.761 │ 1.77743 │ 7.36045 │; │ (0, 2) │ 109.618 │ 1.6627 │ 6.96945 │; │ (1, 0) │ 110.717 │ 1.77723 │ 7.35221 │; │ (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │; │ (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │; │ (2, 5) │ 133.803 │ 1.5155 │ 4.87734 │; │ (2, 10) │ 137.615 │ 1.44535 │ 4.0466 │; └─────────┴─────────┴─────────┴─────────┘. Arbitrary tracers relative performance (CPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ CPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ (0, 1) │ 1.09293 │ 1.39873 │ 1.17271 │; │ CPU │ (0, 2) │ 1.15948 │ 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:10237,perform,performance,10237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['perform'],['performance']
Performance,"64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:4300,cache,cache,4300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"7-10x performance difference between 2D models in ""xy"" versus ""xz""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,1,['perform'],['performance']
Performance,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:13219,Load,LoadError,13219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Load'],['LoadError']
Performance,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1159,Load,LoadError,1159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['Load'],['LoadError']
Performance,": `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:3996,perform,performed,3996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['perform'],['performed']
Performance,":String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1506,load,loading,1506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['load'],['loading']
Performance,; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /h,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2778,cache,cache,2778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"= (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:2165,cache,cache,2165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['cache'],['cache']
Performance,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:2170,perform,performance,2170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,1,['perform'],['performance']
Performance,> @ali-ramadhan why not broadcast over CuArrays? Is there a Performance hit?; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/104#issuecomment-469749450_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108:60,Perform,Performance,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108,1,['Perform'],['Performance']
Performance,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/611:29,perform,performed,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611,1,['perform'],['performed']
Performance,> The performance plots on the README.md file show that the single precision speed up for CPUs is below 1. This is surprising and should be commented on.; >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/607:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/607,1,['perform'],['performance']
Performance,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:2298,Load,LoadError,2298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,4,"['Load', 'load']","['LoadError', 'loading']"
Performance,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:186,Load,LoadError,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['Load'],['LoadError']
Performance,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:1077,perform,performance,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,1,['perform'],['performance']
Performance,@sandreza and Adeline have a script that explodes into NaNs almost immediately at 128³ but takes many thousands of iterations to produce a NaN at 32³. Reverting to Oceananigans v0.27.0 the script runs fine. @sandreza suggested that it might be a race condition between kernels since KernelAbstractions.jl allows for multiple streams. Race conditions get much more (exponentially?) frequent as the number of threads increase I guess. I'm trying to reproduce this issue with a minimal working example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/816:246,race condition,race condition,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816,2,"['Race condition', 'race condition']","['Race conditions', 'race condition']"
Performance,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2418:429,optimiz,optimized,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418,1,['optimiz'],['optimized']
Performance,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:192,perform,performance-benchmarks,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['perform'],['performance-benchmarks']
Performance,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:35,scalab,scalable,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,2,"['perform', 'scalab']","['performance', 'scalable']"
Performance,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2012:213,perform,performed,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012,1,['perform'],['performed']
Performance,A potential race condition fix [WIP],MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:12,race condition,race condition,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['race condition'],['race condition']
Performance,"A preliminary implementation of (constant) smagorinsky.; - temporary arrays to be revisited; - need to improve the way to disable it (without loss of performance); - no attempt to try it on GPU. ; Tested with deep_convection example, running nicely with smag_coeff=3.3e-2 and Prandtl_num=1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218:150,perform,performance,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218,1,['perform'],['performance']
Performance,"Abstraction for ""equation"" for performance, code clarity, memory footprint reduction, and powerful user interface",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:31,perform,performance,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['perform'],['performance']
Performance,Adds test for race condition in `compute!(::AveragedField)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1805:14,race condition,race condition,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1805,1,['race condition'],['race condition']
Performance,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:969,Load,LoadError,969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,1,['Load'],['LoadError']
Performance,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:731,Load,LoadError,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,1,['Load'],['LoadError']
Performance,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:330,Load,LoadError,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Load'],['LoadError']
Performance,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/254:389,Load,LoadError,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254,1,['Load'],['LoadError']
Performance,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:28,load,loaded,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,4,['load'],"['loaded', 'loading']"
Performance,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365:379,perform,performance,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365,1,['perform'],['performance']
Performance,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:212,load,loaded,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,2,['load'],['loaded']
Performance,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442:105,bottleneck,bottleneck,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201:370,perform,performance,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201,1,['perform'],['performance']
Performance,"At the moment, the pressure solve is performed on one GPU/CPU, but this PR builds the infrastructure to allow multi-process global solves",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795:37,perform,performed,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795,1,['perform'],['performed']
Performance,Avoid data dep race condition in CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:15,race condition,race condition,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['race condition'],['race condition']
Performance,"Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4791,load,loading,4791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4731,load,loading,4731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,Benchmarking fully loaded simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089:19,load,loaded,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089,1,['load'],['loaded']
Performance,CPU performance regression: tons of allocations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/675:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675,1,['perform'],['performance']
Performance,Catching common performance / type inference issues with user functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:16,perform,performance,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['perform'],['performance']
Performance,"Coded some difference and averaging operators using the `@views` macro. Just a proof of concept right now as the model goes run on a GPU when creating a `Problem` with `arch=:gpu`, but because the kernels are very small (and there are many of them) it's very slow. At least we have something that runs, now we can worry about how to optimize for performance. Some hacks were used to get this to work but the operators and time stepping is completely shared. The only bit that is different is the quasi-spectral solver as cuFFT does not perform R2R or DCT transforms (`FFTW.REDFT01` and `FFTW.REDFT10`) in particular. A GPU-compatible DCT/IDCT transform was coded that calculates the DCT/IDCT in terms of `fft!` and `ifft!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/15:333,optimiz,optimize,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/15,3,"['optimiz', 'perform']","['optimize', 'perform', 'performance']"
Performance,"Compiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:289; [14] cufunction; @ ~/.julia/packages/CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:1676,cache,cache,1676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['cache'],['cache']
Performance,"Convection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal_convection.jl` example documentation](https://clima.github.io/OceananigansDocumentation/v0.84.1/generated/horizontal_convection/#Load-saved-output,-process,-visualize) and verified locally. <img width=""519"" alt=""Screenshot 2023-08-22 at 1 13 30 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/c61b002c-5fd5-453d-8809-623e577e54f3"">. I am referring to this as a bug because it is contrary to the expected behavior of halos containing the necessary information for satisfying boundary conditions, as discussed in the horizontal convection documentation example:; https://github.com/CliMA/Oceananigans.jl/blob/a226b3efa7db7426ccee03884d610035314955e4/examples/horizontal_convection.jl#L143-L147",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:2220,Load,Load-saved-output,2220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['Load'],['Load-saved-output']
Performance,"Current operators assume constant Δz which allow the model to use faster operators and use a tiny bit less space, so they'd have to be rewritten a tiny bit to account for a variable Δz when that gets implemented. We can either write new operators that get dispatched on `HorizontallyRegularCartesianGrid` structs (already possible), or maybe the performance gain is so tiny that we just make `RegularCartesianGrid` a subset of `HorizontallyRegularCartesianGrid` and only have one set of operators. `HorizontallyRegularCartesianGrid` might be a descriptive but pretty bad struct name.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/47:346,perform,performance,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47,1,['perform'],['performance']
Performance,"Currently `BatchedTridiagonalSolver` supports `Callable` tridiagonal coefficients via. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Solvers/batched_tridiagonal_solver.jl#L58-L59. However, as noted on #3030 this can produce a catastrophic loss of performance. Therefore, this support should be discontinued. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3047:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3047,1,['perform'],['performance']
Performance,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063:45,perform,performing,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063,2,['perform'],['performing']
Performance,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:390,Load,LoadError,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,1,['Load'],['LoadError']
Performance,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:884,optimiz,optimization,884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,2,['optimiz'],['optimization']
Performance,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:343,Load,LoadError,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,1,['Load'],['LoadError']
Performance,Do not install/load CUDA packages if no GPU is detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:15,load,load,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['load'],['load']
Performance,ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:7,Load,LoadError,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,1,['Load'],['LoadError']
Performance,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89:483,cache,cache,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89,1,['cache'],['cache']
Performance,Enzyme (performance) mark some functions as non-differentiable,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799:8,perform,performance,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799,1,['perform'],['performance']
Performance,Fix bug loading `netcdf`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2847:8,load,loading,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2847,1,['load'],['loading']
Performance,Fix performance benchmarks dead link in README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/822:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/822,1,['perform'],['performance']
Performance,Fix race condition affecting `HydrostaticFreeSurfaceModel` with `isnothing(free_surface)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2821:4,race condition,race condition,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2821,1,['race condition'],['race condition']
Performance,Fixes GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:17,load,loading,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['load'],['loading']
Performance,Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:30,load,loading,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['load'],['loading']
Performance,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['perform'],['performance']
Performance,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1045:477,load,loaded,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045,7,['load'],"['load', 'loaded']"
Performance,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622:651,Load,LoadError,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622,2,"['Load', 'optimiz']","['LoadError', 'optimization']"
Performance,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415:957,Load,LoadError,957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415,1,['Load'],['LoadError']
Performance,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:81,perform,performs,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,1,['perform'],['performs']
Performance,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:300,Load,LoadError,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,2,['Load'],['LoadError']
Performance,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:394,Load,LoadError,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['Load'],['LoadError']
Performance,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588:215,perform,performing,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588,1,['perform'],['performing']
Performance,Fusing kernels for calculating diagnostics to improve performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483:54,perform,performance,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483,1,['perform'],['performance']
Performance,Glw/performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2033:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2033,1,['perform'],['performance']
Performance,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:206,load,loaded,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,3,"['load', 'perform']","['loaded', 'perform', 'performance']"
Performance,"Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Ad",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:7642,cache,cache,7642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['cache'],['cache']
Performance,Halo optimization and solving the race condition on corner nodes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:5,optimiz,optimization,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,2,"['optimiz', 'race condition']","['optimization', 'race condition']"
Performance,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:1037,load,load,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,1,['load'],['load']
Performance,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:598,load,load,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['Load', 'load']","['LoadError', 'load']"
Performance,"Here's an example:. ```julia; using Oceananigans; using MPI; using JLD2. arch = Distributed(); @show arch. x = y = z = (0, 1); global_size = (8, 2, 2); grid = RectilinearGrid(arch, size=global_size; x, y, z); @show size(grid). rank = arch.local_rank; if rank === 0; bathymetry = 0.1 * rand(global_size...); @save ""bathymetry.jld2"" bathymetry; end. MPI.Barrier(arch.communicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, fal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3816:381,load,load,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816,1,['load'],['load']
Performance,"Hi all!. With the help of Ali and a colleague at my school, I can now run Oceananigans using a GPU on my school's HPC. I am now at a step that is totally unfamiliar to me, coding for a GPU. . Based on what I have read from the Oceananigans documentation, I think the only trouble I will have is creating my forcing functions and my initial conditions. Currently, I read in data from csv's, perform a 1D spline interpolation, and then assign the interpolated function (which is 1D) to a 3D field function. . My understanding is that the way arrays are treated is quite different when working with GPUs and I honestly don't even know where to begin. Below is an excerpt of my run script that shows the initial and boundary condition creation with a CPU architecture. If anyone can share resources on how to code this for a GPU or just explain it if it is easy, I would greatly appreciate the help!. ```; ρₒ = 1025; ############## Boundary conditions ###################; ## Pulling the boundary conditions from the data csv; df = CSV.read(""data_inputs/kma_buoy_fluxes_soulik.csv"", DataFrame);. seconds = df.time[:]*86400; # convert to seconds; secs = [tnow - seconds[1] for tnow in seconds]; # set first time stamp to 0; secs = [s - 518400 for s in secs]; # Move 0 time stamp to later in the time series. ## make the splines; spl_taux = Spline1D(secs, df.taux/(ρₒ), k=1);; spl_tauy = Spline1D(secs, df.tauy/(ρₒ), k=1);; spl_latHF = Spline1D(secs, df.lat_hf/(ρₒ * cᴾ), k=1);; spl_senHF = Spline1D(secs, df.sens_hf/(ρₒ * cᴾ), k=1);. ## turn the splines into functional arguments; @inline Fxn_taux(x,y,t) = spl_taux(t);; @inline Fxn_tauy(x,y,t) = spl_tauy(t);; @inline Fxn_HFlx(x,y,t) = spl_latHF(t) + spl_senHF(t); # K m⁻¹ s⁻¹, surface _temperature_ flux. ############# Initial conditions #############; ## Initial surface stress condition; Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz); # noise. ## Veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509:390,perform,perform,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509,1,['perform'],['perform']
Performance,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:718,Load,LoadError,718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['Load'],['LoadError']
Performance,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:163,load,loads,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['load'],['loads']
Performance,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:955,Load,LoadError,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['Load'],['LoadError']
Performance,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:222,Load,LoadError,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,1,['Load'],['LoadError']
Performance,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:211,Load,LoadError,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,1,['Load'],['LoadError']
Performance,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2760:140,optimiz,optimization,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:938,Load,LoadError,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,1,['Load'],['LoadError']
Performance,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:74,Load,Load,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,3,"['Load', 'load']","['Load', 'loaded']"
Performance,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:592,Load,LoadError,592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,1,['Load'],['LoadError']
Performance,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:413,Load,LoadError,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,1,['Load'],['LoadError']
Performance,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:66,load,load,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,1,['load'],['load']
Performance,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:862,Load,LoadError,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['Load'],['LoadError']
Performance,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56:131,perform,perform,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56,1,['perform'],['perform']
Performance,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1072:368,Load,LoadError,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072,1,['Load'],['LoadError']
Performance,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195:112,load,load,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195,1,['load'],['load']
Performance,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:371,Load,LoadError,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['Load'],['LoadError']
Performance,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:357,Load,LoadError,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,1,['Load'],['LoadError']
Performance,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:525,optimiz,optimizer,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,4,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188:1417,Load,LoadError,1417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188,1,['Load'],['LoadError']
Performance,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554:638,Load,LoadError,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554,1,['Load'],['LoadError']
Performance,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742:83,Load,LoadError,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742,1,['Load'],['LoadError']
Performance,"I just noticed that the Nusselt number calculation result in the horizontal convection example changed between v0.71.6 and v0.72.4. It almost doubled from around 10 at. https://clima.github.io/OceananigansDocumentation/v0.71.6/generated/horizontal_convection/#Load-saved-output,-process,-visualize. to around 20 in . https://clima.github.io/OceananigansDocumentation/v0.72.4/generated/horizontal_convection/#Load-saved-output,-process,-visualize. The calculation is done via. ```Julia; χ_diff = κ * b★^2 * π * tanh(2π * H / Lx). for i = 1:length(t); b = b_timeseries[i]; sum!(∫ⱽ_mod²_∇b, (∂x(b)^2 + ∂z(b)^2) * volume); Nu[i] = (κ * ∫ⱽ_mod²_∇b[1, 1, 1]) / χ_diff; end; ```. Did anything changed between these two version in the way `sum!` or `volume` works?. Here's the diff between v0.71.6 and v0.72.4: https://github.com/CliMA/Oceananigans.jl/compare/v0.71.6...v0.72.4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2735:260,Load,Load-saved-output,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735,2,['Load'],['Load-saved-output']
Performance,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:357,Load,LoadError,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,1,['Load'],['LoadError']
Performance,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:289,load,loading,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['load'],['loading']
Performance,"I looked through the package and it seems like things are already in CuArrays then. https://github.com/climate-machine/Oceananigans.jl/blob/master/src/time_steppers.jl#L42-L78. this should quite readily port over to using DifferentialEquations.jl. It looks like you're using an IMEXEuler scheme? I think there would be some pretty good performance gains, and it would be interesting to start being able to use this entire package as a benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391:336,perform,performance,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391,1,['perform'],['performance']
Performance,"I noticed that some issues with buildkite have to do with needing to re-resolve the Manifest, so this is yet another attempt to fix the race condition in our CI...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783:136,race condition,race condition,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783,1,['race condition'],['race condition']
Performance,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2840:678,load,loading,678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840,7,['load'],['loading']
Performance,"I opened a wiki for Oceananigans:. https://github.com/CliMA/Oceananigans.jl/wiki. I think we should use the wiki to host practical information and tips for using Oceananigans on various hardware (laptops, CPUs, GPUs), clusters / high-performance computing system (HPCs), and more. Using the wiki this way will allow us to focus the docs on code and numerics, and alleviate the need to submit PRs to update details about using clusters. We need to provide an introduction to Oceananigans ""knowledge base"" (where to find useful information in the documentation, wiki, Github Discussions, and Github Issues) in the README, the docs, and the wiki.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2470:234,perform,performance,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470,1,['perform'],['performance']
Performance,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3761:237,Load,LoadError,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761,1,['Load'],['LoadError']
Performance,"I recently ran the weak scaling shallow water model benchmark with the MultiGPU architecture on Satori, thanks to @christophernhill.; Here are the results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.765 ms | 2.786 ms | 2.849 ms | 3.374 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 6.932 ms | 7.081 ms | 8.037 ms | 26.174 ms | 2.03 MiB | 5859 | 20; (4096, 1024) | (1, 4) | 12.592 ms | 14.603 ms | 16.417 ms | 31.468 ms | 2.03 MiB | 5859 | 40. <!--EndFragment-->; </body>; </html>. <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 2.54127 | 0.393505 | 1.00271 | 1.05854; (4096, 1024) | (1, 4) | 5.24053 | 0.19082 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>. The results are not good but at least we can benchmark multi-GPU performance now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882:1018,perform,performance,1018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882,1,['perform'],['performance']
Performance,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:43,Load,LoadError,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,1,['Load'],['LoadError']
Performance,"I report here some issues connected to updating to Oceananigans 0.80.0 . ```; ERROR: LoadError: MethodError: no method matching min_Δx(::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:85,Load,LoadError,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['Load'],['LoadError']
Performance,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:776,optimiz,optimizations,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['optimiz'],['optimizations']
Performance,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455:544,Load,LoadError,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455,1,['Load'],['LoadError']
Performance,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179:118,load,loaded,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179,2,['load'],"['load', 'loaded']"
Performance,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477:614,Load,LoadError,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477,1,['Load'],['LoadError']
Performance,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/142:258,Load,LoadError,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142,1,['Load'],['LoadError']
Performance,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:420,Load,LoadError,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,1,['Load'],['LoadError']
Performance,I was doing some profiling on a model with no open boundaries and discovered that this function was causing a big slow down. I guess this is because the compiler isn't managing to work out its just a load of nothing operations but this change appears to make it completely go away.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792:200,load,load,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792,1,['load'],['load']
Performance,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990:799,perform,performance,799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990,1,['perform'],['performance']
Performance,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:223,Load,LoadError,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,2,['Load'],['LoadError']
Performance,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178:121,load,loading-of-code-in-packages,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178,3,['load'],"['load', 'loading-of-code-in-packages', 'loads']"
Performance,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453:802,perform,perform,802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453,1,['perform'],['perform']
Performance,"I was trying to add some Lagrangian particles to a 2D simulation I was running but Lagrangian particle advection currently assumes that the grid is bounded or periodic in all dimensions. An MWE (on Julia 1.10.1+0.x64.w64.mingw32 and Oceananigans version 0.90.12) that reproduces the issue is:. ```; using Oceananigans; NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```. with output. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (115.810 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching unsafe_trunc(::Type{Int64}, ::Nothing). Closest candidates are:; unsafe_trunc(::Type{Int64}, ::Union{Float16, Float32, Float64}); @ Base float.jl:336; unsafe_trunc(::Type{<:Integer}, ::BFloat16s.BFloat16); @ BFloat16s C:\Users\hildi\.julia\packages\BFloat16s\u3WQc\src\bfloat16.jl:288; unsafe_trunc(::Type{T}, ::BigFloat) where T<:Integer; @ Base mpfr.jl:358; ... Stacktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3545:943,Load,LoadError,943,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545,1,['Load'],['LoadError']
Performance,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:719,Load,LoadError,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,1,['Load'],['LoadError']
Performance,"I'd like to compute a `Field` (ideally in order to write it to a NetCDF file) but only at every `N` grid points. Something like the following example, which tries to compute `u` at every 2 grid points in the vertical direction:. ```julia; using Oceananigans; grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid,); u_slices = Field(model.velocities.u, indices=(:, :, 1:2:grid.Nz)); ```. However, the above code fails since `Field` currently doesn't accept `StepRange`s as `indices`, just (I think) `UnitRange`s and `Int`s:. ```; ERROR: LoadError: MethodError: no method matching isinteger(::StepRange{Int64, Int64}). Closest candidates are:; isinteger(::Integer); @ Base number.jl:20; isinteger(::Complex); @ Base complex.jl:148; isinteger(::Rational); @ Base rational.jl:281; ... Stacktrace:; [1] validate_index(idx::StepRange{Int64, Int64}, loc::Center, topo::Bounded, N::Int64, H::Int64); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:196; [2] map (repeats 3 times); @ ./tuple.jl:318 [inlined]; [3] validate_indices(indices::Tuple{Colon, Colon, StepRange{Int64, Int64}}, loc::Tuple{DataType, DataType, DataType}, topo::Tuple{DataType, DataType, DataType}, sz::Tuple{Int64, Int64, Int64}, halo_sz::Tuple{Int64, Int64, Int64}); ```. Is there a workaround?. CC @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460:579,Load,LoadError,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460,1,['Load'],['LoadError']
Performance,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:831,Load,LoadError,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,1,['Load'],['LoadError']
Performance,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:766,Load,LoadError,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['Load'],['LoadError']
Performance,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:686,Load,LoadError,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,1,['Load'],['LoadError']
Performance,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248:84,Load,LoadError,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248,1,['Load'],['LoadError']
Performance,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794:1615,optimiz,optimized,1615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794,1,['optimiz'],['optimized']
Performance,"I'm not sure why this was added, so we will see if something breaks. But through usage I've realized that its inconvenient (and unexpected) that the length of `FieldTimeSeries` depends on the backend. My intuition is that the length stays the same regardless of _where_ the data is (in memory, or on disk, or a combination of the two). It's also helpful that behavior is the same between backends, which makes switching backends for performance reasons painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3825:433,perform,performance,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3825,1,['perform'],['performance']
Performance,"I'm thinking about the future and hoping to start a discussion about the future of our equation abstraction system. ## The problem. We need an abstraction for the concept of an equation, so that we can make the model as performant and lightweight as possible for a given use case. For example, I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the bes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:220,perform,performant,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,2,['perform'],"['perform', 'performant']"
Performance,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:448,load,load,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,3,['load'],['load']
Performance,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:719,Load,LoadError,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['Load'],['LoadError']
Performance,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:405,Load,LoadError,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,1,['Load'],['LoadError']
Performance,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:327,Load,LoadError,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['Load'],['LoadError']
Performance,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:494,Load,LoadError,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,2,['Load'],['LoadError']
Performance,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144:1411,perform,performance,1411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144,1,['perform'],['performance']
Performance,"If you search for `grep -r ""\^2"" *` from Oceananigans' root dir, for example, you get many places where we exponentiate with an Int64. Per the discussion in https://github.com/CliMA/Oceananigans.jl/pull/1770 it seems that this causes a pretty big performance drawback in Julia 1.6 on GPUs. What should be our approach here? Do we wait for this to be resolved upstream or do we change all exponentiation in critical places to use `Int32`?. CC: @maleadt @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832:247,perform,performance,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832,1,['perform'],['performance']
Performance,Improve immersed boundary performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817:26,perform,performance,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817,1,['perform'],['performance']
Performance,Improve the performance of the HydrostaticFreeSurfaceModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2874:12,perform,performance,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2874,1,['perform'],['performance']
Performance,In #3151 it was discovered that the shallow water example in the docs needs ~25 min to run while all other examples need from ~1min (2D) or up to ~7min (Baroclinic instability). Was this always the case? Did something happen to impede the performance of the SWE model?. #3168 is relevant; it does not resolve the issue but nevertheless minimizes the toll that this issue has on the overall building time for the docs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3169:239,perform,performance,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169,1,['perform'],['performance']
Performance,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1451:225,perform,performance,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451,2,"['bottleneck', 'perform']","['bottlenecks', 'performance']"
Performance,"In PR #590 [WIP] I've prototyped how I've thought about adding support for distributed parallelism by adding a non-invasive `Distributed` MPI layer on top of Oceananigans to keep the core code MPI-free. At last week's CliMA software meeting @lcw and @jkozdon have pointed out a potential limitation of this approach: when running on many nodes and communication starts to eat up a lot of compute time it becomes beneficial to overlap computation and communication. Abstractions such as `CLIMA.MPIStateArray` help a lot with this but require MPI to be ""baked in"". Obviously this issue won't be tackled for a while until we have a working distributed model and need more performance, so I'm just documenting the issue here for future discussion. I think we can achieve this by splitting a kernel like `calculate_interior_source_terms!` into two kernels, one that computes source terms ""near"" the boundary (1-2? grid points from any boundary as needed), then halo communication can happen while a second more compute-intensive kernel computes the source terms in the rest of the interior. But that only helps with one particular instance of halo communication. There will be other halo communications needed that may be impossible to overlap with compute-intensive kernels. Pursuing overlapping in this manner to the extreme and applying it to as many kernels as possible may be detrimental to code clarity. Once we want more distributed performance we should go through the algorithm and minimize the number of halo communications (i.e. calls to `fill_halo_regions!`). cc @leios @jm-c; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/615:669,perform,performance,669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615,2,['perform'],['performance']
Performance,In [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) a simple method for generalizing WENO stencils for stretched grids is described. This scheme is easy to implement and limits to what we already have implemented in the case of a regular grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704:38,perform,performance,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704,1,['perform'],['performance']
Performance,"In large computations, advection tendency and implicit free surface are the bottleneck. This can be improved (probably) with an improved `SplitExplicitFreeSurface` that scales better at high resolutions and by introducing shared memory for the calculation of advection. (Another way to improve advection performance is to split the kernels based on the distance to a solid boundary such that we do not have to perform the calculations of all orders starting from 1, but it is probably a slightly more complex solution). This is an explorative PR to try to address both problems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2874:76,bottleneck,bottleneck,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2874,3,"['bottleneck', 'perform']","['bottleneck', 'perform', 'performance']"
Performance,Incorporate performance benchmarks into tests and CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/684:12,perform,performance,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684,1,['perform'],['performance']
Performance,"Increasingly we have the need to offset kernel indices; ie to perform computations over ""windows"" for incomplete `Field` `indices`:. https://github.com/CliMA/Oceananigans.jl/blob/be00e364f9dcd712b3d0c3d48e32b94b181a02fc/src/AbstractOperations/computed_field.jl#L84-L92. or for @simone-silvestri's work to overlap communication and computation, eg #3067. Possibly, such a feature can be supported by `KernelAbstractions` eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/384 which would simplify our code a lot (since we won't have to pass the offsets into the kernel explicitly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3068:62,perform,perform,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3068,1,['perform'],['perform']
Performance,Initializing environment on Buildkite can be a testing bottleneck,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:55,bottleneck,bottleneck,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,1,['bottleneck'],['bottleneck']
Performance,"It looks like KernelAbstractions.jl has added experimental support for AMD: https://github.com/JuliaGPU/KernelAbstractions.jl/releases/tag/v0.6.0. Should we try to make the code more GPU-architecture-agnostic based on that? From what I've heard, end-user level AMD GPUs are generally cheaper than Nvidia ones for similar performance. So running Oceananigans on AMD could potentially make it significantly easier for people to run simulations on their personal computer instead of a cluster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546:321,perform,performance,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546,1,['perform'],['performance']
Performance,"It seems that with Julia 1.6 and recent versions of CUDA.jl, the output of averaged fields is wrong. By inspection it seems that the output is being written to disk prematurely somehow as some grid points contain the sum instead of the mean. @xkykai and I have tried to reproduce in CUDA.jl but with no luck so far. I've tried adding a `CUDA.@sync blocking=true` to https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767:654,race condition,race condition,654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767,1,['race condition'],['race condition']
Performance,It'd be nice if we move CUDA functionality into an extension so it's only loaded for CUDA-enabled devices. @vchuravy made a first attempt to do that at https://github.com/CliMA/Oceananigans.jl/pull/3066. similar effort but for AMDGPU is at https://github.com/CliMA/Oceananigans.jl/pull/3475,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3481:74,load,loaded,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3481,1,['load'],['loaded']
Performance,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3298:224,perform,performed,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298,1,['perform'],['performed']
Performance,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44:295,perform,performance,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44,1,['perform'],['performance']
Performance,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234:811,optimiz,optimized,811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234,1,['optimiz'],['optimized']
Performance,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:59,perform,performance,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,5,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:11,perform,performance,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,4,"['latency', 'perform']","['latency', 'performance', 'performant']"
Performance,"MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; x = (-5, 5),; y = (-5, 5),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). island(x, y) = (x^2 + y^2) < 1; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(island)). Δx = xspacings(grid, Center(), Center(), Center()); ```. produces. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{…}, ::Center; with_halos::Bool). Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; xspacings(::LatitudeLongitudeGrid{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Number, <:Number}, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:674; xspacings(::LatitudeLongitudeGrid, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:658; ... Stacktrace:; [1] xspacings(grid::ImmersedBoundaryGrid{…}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; ```. This is probably also a problem for `yspacings` and `zspacings`, but I'm not sure. For `GridFittedBottom`, the spacings should just return spacings for the underlying grid (right now only `PartialCellBottom` immersed boundaries have different metrics than the underlying grid).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3701:387,Load,LoadError,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3701,1,['Load'],['LoadError']
Performance,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2283,optimiz,optimize,2283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['optimiz'],['optimize']
Performance,"Main motivation here is to make it possible to move CUDA with Julia 1.9 to a optional dependency,; making loading faster for non GPU workloads as well as making it easier for other GPU backends to be added. Package extensions is a backwards compatible 1.9 feature, in 1.8 and prior we still have to load CUDA.jl by default; but on 1.9 this is no longer required.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3066:106,load,loading,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3066,2,['load'],"['load', 'loading']"
Performance,Major performance regression,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/726:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/726,1,['perform'],['performance']
Performance,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/162:344,optimiz,optimize,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162,3,"['Optimiz', 'optimiz', 'perform']","['Optimizing-', 'optimize', 'performance']"
Performance,Might not end up being merged but testing if using shared memory for the `calculate_interior_source_terms` kernel via GPUifyLoop's `@stencil` abstraction improves performance for register-heavy kernels. We can use #289 to benchmark. Reliant on https://github.com/vchuravy/GPUifyLoops.jl/issues/85.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/293:163,perform,performance,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/293,1,['perform'],['performance']
Performance,Minor optimization: use `convert` rather than constructor to convert array type before output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:6,optimiz,optimization,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,1,['optimiz'],['optimization']
Performance,Minor performance regression (more memory allocations),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/397:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/397,1,['perform'],['performance']
Performance,More doc built optimizations -- run computationally expensive examples first,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151:15,optimiz,optimizations,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151,1,['optimiz'],['optimizations']
Performance,More docs built optimization,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3168:16,optimiz,optimization,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3168,1,['optimiz'],['optimization']
Performance,More performant mod1 functions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57:5,perform,performant,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57,1,['perform'],['performant']
Performance,Move distributed buildkite CI to the `new-central` queue,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3489:51,queue,queue,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3489,1,['queue'],['queue']
Performance,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207:694,perform,performance,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:781,perform,perform,781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,3,['perform'],['perform']
Performance,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534:526,load,loaded,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534,2,['load'],['loaded']
Performance,Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Mo,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2669,cache,cache,2669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2222:63,load,loading,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"On Julia 1.10 users are met with an ~~avalanche~~ tsunami of warnings. ```; warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; ```. For example we try. https://github.com/CliMA/Oceananigans.jl/blob/7291ada057afc9cfcefb2b6e9351cff8782d9217/src/Solvers/batched_tridiagonal_solver.jl#L133-L148. but this loop probably can't be unrolled because `Nx` is a runtime value, not a compile time constant. I don't know if we ever `@unroll` properly... Seems like the easiest thing is just to stop pretending that we `@unroll`. @jlk9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374:199,optimiz,optimizer,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,Only perform operations as needed depending on model dimension.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/35:5,perform,perform,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/35,1,['perform'],['perform']
Performance,Optimizes fill_halo_regions_open.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792:0,Optimiz,Optimizes,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792,1,['Optimiz'],['Optimizes']
Performance,"Our `Field` type may benefit from subtyping one of the many array types with named/dimensional axes out there in the julia ecosystem. This will permit some desirable behaviors for the manipulation, loading, output, and plotting of fields and slices of fields, and perhaps will also enable some nice behavior for online diagnostics. A good option could be `AbstractDimensionalArray` defined by. https://github.com/rafaqz/DimensionalData.jl. We'll have to figure out what functions and such we'd have to define to complete such an implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/457:198,load,loading,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457,1,['load'],['loading']
Performance,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269:499,Load,LoadError,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269,1,['Load'],['LoadError']
Performance,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137:918,queue,queued,918,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137,2,['queue'],['queued']
Performance,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1118:302,Load,LoadError,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118,1,['Load'],['LoadError']
Performance,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873:1663,perform,performs,1663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873,1,['perform'],['performs']
Performance,Perform some of the grid tests on GPU as well,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054:0,Perform,Perform,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054,1,['Perform'],['Perform']
Performance,Performance benchmarks section of the README is super out of date,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:0,Perform,Performance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['Perform'],['Performance']
Performance,Performance benchmarks section of the README wrongly says we don't support `Distributed`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758:0,Perform,Performance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758,1,['Perform'],['Performance']
Performance,Performance of Preconditioned Conjugate Gradient solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728:0,Perform,Performance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728,1,['Perform'],['Performance']
Performance,Performance testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:0,Perform,Performance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,1,['Perform'],['Performance']
Performance,Performant elementwise CPU/GPU kernels,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/54:0,Perform,Performant,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54,1,['Perform'],['Performant']
Performance,Potential performance improvement for upwind schemes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987:10,perform,performance,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987,1,['perform'],['performance']
Performance,Potentially a race condition?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:14,race condition,race condition,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['race condition'],['race condition']
Performance,Prevents race condition from multiple builds attempting to use/delete the same julia install,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662:9,race condition,race condition,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662,1,['race condition'],['race condition']
Performance,Prior of these PR constants (like Earth's radius) were multiply defined. Now all constants are gathered in a module loaded just after units. Closes #2981,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045:116,load,loaded,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045,1,['load'],['loaded']
Performance,"Probably as a result of PR #3847, on the `main` branch precompiation fails due to some method overwriting. This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping preco",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851:330,perform,performance,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851,1,['perform'],['performance']
Performance,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294:227,perform,performant,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294,2,"['optimiz', 'perform']","['optimize', 'performant']"
Performance,Race condition leading to NaNs with KernelAbstractions.jl on v0.31.0?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/816:0,Race condition,Race condition,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816,1,['Race condition'],['Race condition']
Performance,"RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}}); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:74; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:324; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\cache.jl:90; [11] cufunction(f::typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:10033,cache,cache,10033,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['cache'],['cache']
Performance,Refactor `Simulations` + simulations infrastructure to be loaded first,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:58,load,loaded,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,1,['load'],['loaded']
Performance,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031:328,load,load,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031,1,['load'],['load']
Performance,Related to #2179. If we don't then we can't load on CPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2240:44,load,load,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2240,1,['load'],['load']
Performance,"Related to https://github.com/CliMA/Oceananigans.jl/issues/1465. When fixing the MWE I gave in https://github.com/CliMA/Oceananigans.jl/issues/1465 but outputting things with a NetCDFWriter I also get an error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:38; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coordi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:229,Load,LoadError,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['Load'],['LoadError']
Performance,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/821:188,race condition,race condition,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821,1,['race condition'],['race condition']
Performance,Remove performance-/precompilation-time harmful `@eval`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3556:7,perform,performance,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556,1,['perform'],['performance']
Performance,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120:27,multi-thread,multi-threading,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120,1,['multi-thread'],['multi-threading']
Performance,Reusing the fill_halo optimization done in glw/performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2033:22,optimiz,optimization,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2033,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"Revert ""Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807:38,load,loading,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807,1,['load'],['loading']
Performance,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/54:39,perform,perform,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54,3,"['optimiz', 'perform']","['optimizing', 'perform', 'performance']"
Performance,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/64:429,perform,performance,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64,1,['perform'],['performance']
Performance,"Right now only 1 benchmark job is run to check for performance regression, which is important seeing as sometimes we introduce rogue bugs that kill performance. cc @simonbyrne will this work with the Slurm CI/CliMA bot framework you've set up? Will be awesome to start using it. No MPI stuff yet but will probably add some soon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280:51,perform,performance,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280,2,['perform'],['performance']
Performance,Right now we are wasting memory and time computing free surface tendencies when `free_surface isa ImplicitFreeSurface` with `HydrostaticFreeSurfaceModel`. A minor optimization would neither allocate memory for the free surface tendencies or calculate them in this case.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1941:163,optimiz,optimization,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1941,1,['optimiz'],['optimization']
Performance,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1586:13,load,load,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586,2,['load'],['load']
Performance,Running the example from #2389 it returned this error; `ERROR: LoadError: UndefVarError: div_Uc not defined`. Hope this suggestion makes sense.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390:63,Load,LoadError,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390,1,['Load'],['LoadError']
Performance,"S23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:103; [8] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/execution.jl:318 [inlined]; [9] macro expansion; @ ./lock.jl:223 [inlined]; [10] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:5085,cache,cache,5085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['cache'],['cache']
Performance,See: https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/376:82,load,loading,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/376,1,['load'],['loading']
Performance,"Seems like the Distributed Poisson solver would work only when `grid.Nx == grid.Ny` and `ranks[1] == 1`. Should we maybe implement a transpose to allow different grid sizes in Nx and Ny and 2D parallelization in case of vertically stretched domains?. On the other hand, this might hinder the performance quite a bit...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2074:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2074,1,['perform'],['performance']
Performance,Set up Slurm pipeline for performance regression testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280:26,perform,performance,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280,1,['perform'],['performance']
Performance,"Should examples be written so that the ""part 2"" (load output and plot/process) is independent of ""part 1"" (setup and run)?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850:49,load,load,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850,1,['load'],['load']
Performance,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1604:283,perform,performs,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604,2,['perform'],"['performance', 'performs']"
Performance,Some CATKE performance optimizations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3453:11,perform,performance,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3453,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:1574,load,loaded,1574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['load'],['loaded']
Performance,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:223,race condition,race conditions,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['race condition'],['race conditions']
Performance,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855:369,load,loaded,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855,1,['load'],['loaded']
Performance,"Somewhere between this commit ; https://buildkite.com/clima/oceananigans-distributed/builds/3113#01917ace-fe81-401d-ba21-467037e6aead; and main, we switched from using `libmpitrampoline.so` in the distributed tests to `libmpi.so` downloaded from the artifacts. . Previously, the mpi trampoline was loading a CUDA-aware implementation of Open MPI, while the libmpi.so we use now is a ; MPICH implementation non CUDA-aware:; https://buildkite.com/clima/oceananigans-distributed/builds/4227#0192f70a-b947-4d38-bd1c-c2497a964de9. This makes our GPU distributed tests fail. ; I am wondering where this switch happened because I couldn't trace any changes to the code. @Sbozzolo, do you know if something changed in the `LocalPreferences.toml` in the Caltech cluster?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897:298,load,loading,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897,1,['load'],['loading']
Performance,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:9814,cache,cache,9814,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:7848,cache,cache,7848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,Takes **longer than 6 hrs** atm... yikes!; https://buildkite.com/clima/oceananigans/builds/9087#01845448-a0ae-4e67-89df-6a4ec2ba9c9e. I believe the bottleneck is due to the nested `for`-loops in. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Solvers/sparse_approximate_inverse.jl#L61-L86,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2813:148,bottleneck,bottleneck,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2813,1,['bottleneck'],['bottleneck']
Performance,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:86,race condition,race condition,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['race condition'],['race condition']
Performance,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/169:1316,perform,performant,1316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169,1,['perform'],['performant']
Performance,The default is not a concrete type which may cause performance issues when `FieldTimeSeries` is used as boundary condition or forcing in a kernel:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/OutputReaders/field_time_series.jl#L373. I suggest `nothing` as the default. Users can still change it if they want. We could also use a `NamedTuple` instead of `Dict`. @ali-ramadhan I think you maybe were not thinking that we use `FieldTimeSeries` in kernels and models now (not just for reading output),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3898:51,perform,performance,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3898,1,['perform'],['performance']
Performance,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1046:384,queue,queue,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046,1,['queue'],['queue']
Performance,"The grids define their own `R_Earth`.; https://github.com/CliMA/Oceananigans.jl/blob/e881faee3de5f17cb382cd61e2b43c2069cadde7/src/Grids/latitude_longitude_grid.jl#L3. The `Coriolis` module defines another one... Perhaps we should have a module `Constants`, add everything in there and load it first? This potentially would come handy when we try to couple?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2981:285,load,load,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2981,1,['load'],['load']
Performance,The results over at https://github.com/glwagner/multithreaded-stencils suggest that we could be leaving as much as 2x on the table for CPU performance by choosing a non-optimal group size for multithreading. This PR changes the group size on the CPU. @hennyg888 could be good to runs some benchmarks to see if this improves our CPU / multithreading situation!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902:139,perform,performance,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902,1,['perform'],['performance']
Performance,"The tests in `test_cubed_spheres.jl` were not used (the file was not included). Therefore, the tests on vector rotation were not performed. This PR includes these tests in a new file on a coarse cubed sphere grid. ; @navidcy and @siddharthabishnu are there any tests in `test_cubed_spheres.jl` we want to salvage?. Another problem is the inclusion of `OrthogonalSphericalShellGrids` in the tests. This has caused a bit of problems because of circular dependency. . The inclusion of `OrthogonalSphericalShellGrids` in the tests is to have a non-trivial `OrthogonalSphericalShellGrid` in the tests. For the moment, however, it is used only in the vector rotation test (which was not performed anyways), which is covered by using a conformal cubed sphere. . For this reason thought to remove this dependency here since at the moment does not add anything, and I will open an issue to discuss which non-trivial OrthogonalSphericalShellGrid we want to build to test the OrthogonalSphericalShellGrid capabilities.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3881:129,perform,performed,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3881,2,['perform'],['performed']
Performance,"The way examples are written now is that there is the there is a **part 1** that sets up and runs a simulation and saves output. Then, **part 2** loads the `.jld2`/`.nc` file and plots an animations or what not. However, the way part 2 is currently coded up in most examples *it requires that part 1 is run** as it references on things like `grid` or `fields` constructed by part 1. E.g., ; https://github.com/CliMA/Oceananigans.jl/blob/3c930b00f0ccfdcc20556a9b6ac888b63aeb58d2/examples/eady_turbulence.jl#L317-L324. Ideally, one would like to be able to run the ""load `.jld2` file and animate"" independently. That's the whole idea, right? At the moment the way I do it is that I have to run part 1 until **just before** the `run!(simulation)`, make sure I overwrite the `.jld2` placeholder file that is created with the one that has been populated by some other run previously, and then move on with loading output and animating. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850:146,load,loads,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850,3,['load'],"['load', 'loading', 'loads']"
Performance,"There appears to be the possibility of a write/write race condition at the corners in this case. Discovered with @sandreza. No bug has yet been detected, however.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1938:53,race condition,race condition,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938,1,['race condition'],['race condition']
Performance,"There seems to be some performance regression as we now perform tons of little memory allocations somewhere. Model still time steps as fast as it should so we probably haven't noticed it as we run large model sizes where this allocations are kind of hidden. Seems like mainly a CPU issue. CPU: ; ```; julia> using Oceananigans. julia> model = Model(N=(128, 128, 128), L=(1, 1, 1));. julia> @time time_step!(model, 1, 1); 16.614982 seconds (34.03 M allocations: 1.775 GiB, 6.86% gc time). julia> @time time_step!(model, 1, 1); 0.738576 seconds (1.31 M allocations: 264.089 MiB, 3.97% gc time); ```. GPU:; ```; julia> using Oceananigans. julia> model = Model(N=(256, 256, 256), L=(1, 1, 1), arch=GPU());. julia> @time time_step!(model, 1, 1);; 28.425740 seconds (71.04 M allocations: 3.383 GiB, 10.72% gc time). julia> @time time_step!(model, 1, 1);; 0.025893 seconds (8.90 k allocations: 978.531 KiB); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/397:23,perform,performance,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/397,2,['perform'],"['perform', 'performance']"
Performance,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3402:280,perform,performance,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402,1,['perform'],['performance']
Performance,"There's a bug in `adapt_advection_order` (or the constructor for `HydrostaticFreeSurfaceModel`, since this code:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); tracer_advection = (b=nothing, c=WENO()); model = HydrostaticFreeSurfaceModel(; grid, tracer_advection); ```. fails with. ```; ERROR: LoadError: MethodError: no method matching adapt_advection_order(::@NamedTuple{…}, ::Int64, ::RectilinearGrid{…}). Closest candidates are:; adapt_advection_order(::Nothing, ::Int64, ::Oceananigans.Grids.AbstractGrid); @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:60; adapt_advection_order(::UpwindBiased{B}, ::Int64, ::Oceananigans.Grids.AbstractGrid) where B; @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:74; adapt_advection_order(::WENO{B, FT, XT, YT, ZT}, ::Int64, ::Oceananigans.Grids.AbstractGrid) where {B, FT, XT, YT, ZT}; @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:92; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3863:353,Load,LoadError,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3863,1,['Load'],['LoadError']
Performance,"This PR ""unrestricts"" (removes type annotations) from second and fourth derivative operators. These annotations are unnecessary, since the second and fourth derivative operators call first-derivative operators that perform appropriate dispatch. Also, the second vertical derivative operators are general (within the scope of current Oceananigans code) and should not be restricted. @jm-c does this fix your problem?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1936:215,perform,perform,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1936,1,['perform'],['perform']
Performance,This PR (will) implement(s) pre-computed nonlinear turbulent diffusivities for large eddy simulation. It also performs some minor clean-up for the model constructor to prevent boiler plate proliferation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312:110,perform,performs,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312,1,['perform'],['performs']
Performance,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198:163,perform,performance,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198,1,['perform'],['performance']
Performance,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:152,load,loaded,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['load'],['loaded']
Performance,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:1003,perform,performance,1003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['perform'],['performance']
Performance,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463:1218,load,loaded,1218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463,1,['load'],['loaded']
Performance,"This PR adds grid spacings to NetCDF out, which is a step closer to solving https://github.com/CliMA/Oceananigans.jl/issues/1334. EDIT:. The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652:536,optimiz,optimize,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652,2,['optimiz'],['optimize']
Performance,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2538:464,optimiz,optimization,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,This PR contains some improvements that allow better scaling on multiple devices. . In particular:; - Splitting the interior active cell map into `west` `east` `north` `south` and `interior` to allow for overlapping communication and computations with _active_ cells.; - Advancements for the `SplitExplicitFreeSurface` to reduce kernel launch latency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3404:343,latency,latency,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3404,1,['latency'],['latency']
Performance,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048:1005,perform,perform,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048,1,['perform'],['perform']
Performance,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541:135,concurren,concurrent,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541,1,['concurren'],['concurrent']
Performance,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931:871,optimiz,optimization,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931,1,['optimiz'],['optimization']
Performance,"This PR implements a minor performance optimization that changes the 'default' boundary condition type to `BoundaryCondition{Flux, Nothing}`. Using this type elides the adding of 0's in the case of zero flux boundary conditions. The functionality for eliding computation in this case was already implemented; however it was not used by default. . This may address #397, but @ali-ramadhan we need to benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/402:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:385,optimiz,optimization,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,1,['optimiz'],['optimization']
Performance,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2023:1520,perform,performance,1520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:22,optimiz,optimization,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"This PR implements two advancements for CATKE. First is a reformulation of the shear production term. Previously this was computed using the velocity field at time-step `n` in the TKE tendency, like all other terms in the velocity and tracer explicit tendencies. However, [Burchard (2002)](https://www.sciencedirect.com/science/article/pii/S1463500302000094?casa_token=3cKiqlICvN8AAAAA:Hg3iGP-1q_UYh2We7maQRb9z9F5blbp8lHiH61T_Gep7y0DG8VYVRWwGvzvCDlbD2iANNHbLp4g) argue that the shear production term should be formulated to _exactly_ conserve total kinetic energy, which means that it's form actually depends on the time-stepping scheme being used. In our case, temporally-discrete shear production requires using the velocity field at time step `n` and `n+1`. To implement this scheme we have to add some features to the time stepping routine. In particular we have to allow closures to tell `HydrostaticFreeSurfaceModel` not to step forward certain tracers. Next, we step forward the TKE within `compute_diffusivities!`. Second, this PR also implements split-explicit substepping for CATKE's TKE. It seems that this is required because even though the new shear production discretization dramatically stabilizes CATKE (allowing long time-steps stably), it does not render CATKE's solutions completely insensitive to the time-step. So, for _accuracy_ (and performance) purposes, we are motivated to also add the capability to advance the TKE on a short time-step while the velocities and tracers advance on a slower time-step. This only matters for high vertical resolutions and very strong forcing. But when you do global simulations, there is strong forcing somewhere on the Earth, and we probably want to represented it accurately... More documentation to come.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3585:1357,perform,performance,1357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3585,1,['perform'],['performance']
Performance,"This PR increases our support for `Flat` dimensions of `RegularCartesianGrid`. When topology in a direction is `Flat`, the halo size is set to 0, the grid size to 1, and halo filling, interpolation, and differences are all elided. Two new examples in the docstring for `RegularCartesianGrid` illustrate it's use:. * A two-dimenisional, horizontally-periodic grid:. ```julia; julia> using Oceananigans. julia> grid = RegularCartesianGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat)); RegularCartesianGrid{Float64, Periodic, Periodic, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 12.566370614359172], z ∈ [0.0, 0.0]; topology: (Periodic, Periodic, Flat); resolution (Nx, Ny, Nz): (32, 32, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.19634954084936207, 0.39269908169872414, 0.0); ```. * A one-dimensional ""column"" grid:. ```julia; julia> using Oceananigans. julia> grid = RegularCartesianGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded)); RegularCartesianGrid{Float64, Flat, Flat, Bounded}; domain: x ∈ [0.0, 0.0], y ∈ [0.0, 0.0], z ∈ [-128.0, 0.0]; topology: (Flat, Flat, Bounded); resolution (Nx, Ny, Nz): (1, 1, 256); halo size (Hx, Hy, Hz): (0, 0, 1); grid spacing (Δx, Δy, Δz): (0.0, 0.0, 0.5); ```. In principle we can also eliminate the pressure solver for column models. I'll leave this optimization for a future PR. Resolves #902 ; Resolves #940 ; Resolves #1001; Resolves #35",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1003:1361,optimiz,optimization,1361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1003,1,['optimiz'],['optimization']
Performance,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:297,bottleneck,bottleneck,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['bottleneck'],['bottleneck']
Performance,"This PR introduces a new ""Matrix based"" implicit solver `Oceananigans/Solvers/matrix_iterative_solver` that uses the package IterativeSolvers.jl to solve a linear system of equation based on a sparse matrix formulation. This has a couple of advantages in terms of performance; - there is no need to `fill_halo_regions!` on the residuals while iterating; - it is possible to implement efficient preconditioning techniques. the `MatrixIterativeSolver` accepts a tuple of coefficients `Ax, Ay, Az, C, D` as inputs and creates the associated matrix to solve the following ; <img src=""https://render.githubusercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an exa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:264,perform,performance,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['perform'],['performance']
Performance,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:353,load,loading,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,3,['load'],"['loading', 'loads']"
Performance,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641:324,load,loaded,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641,3,['load'],"['loaded', 'loading', 'loads']"
Performance,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:30,perform,performance,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,3,"['perform', 'tune']","['performance', 'tune']"
Performance,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:51,race condition,race condition,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,2,"['perform', 'race condition']","['performance', 'race condition']"
Performance,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2040:110,perform,perform,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040,1,['perform'],['perform']
Performance,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2597:551,perform,performant,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597,2,['perform'],"['performance', 'performant']"
Performance,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:42,perform,performance,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,3,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2320:460,optimiz,optimizations,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320,1,['optimiz'],['optimizations']
Performance,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:567,perform,performance,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['perform'],['performance']
Performance,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:533,optimiz,optimization,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['optimiz'],['optimization']
Performance,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:154,perform,performs,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['perform'],['performs']
Performance,"This PR removes a bunch of scalar operations introduced by #3575 on the GPU and instead performs operations on CPU and converts to CuArrays afterwards. There are two issues that don't allow us to create the grid natively on the GPU but rather force us to create the grid on CPU and then convert it. 1. The metrics for the `OrthogonalSphericalShellGrid` use scalar operations; see the functions that are called at https://github.com/CliMA/Oceananigans.jl/blob/4c853b94e6c99949134981153250a4e2391bb0f1/src/Grids/orthogonal_spherical_shell_grid.jl#L780-L782. 2. When we create the `ConformalCubedSphreGrid`, to fill the metric and coordinate horizontal halos properly we use the same functionality that we use to fill halos for prognostic variables. To do that, we create Fields with the coordinate and metric values, call `fill_halo_regions!` on these fields, and then copy back the data from the Fields to the metrics. Copying the data from the metrics to the fields and vice-versa requires scalar operations, e.g., see ; https://github.com/CliMA/Oceananigans.jl/blob/7f12be3d82486b8be2923d8675d2e59c84efd722/src/MultiRegion/cubed_sphere_grid.jl#L280-L292. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3579:88,perform,performs,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3579,1,['perform'],['performs']
Performance,"This PR removes argument splatting in intermediate functions that are called to compute the hydrostatic free surface tendencies. Argument splatting was removed in a prior PR (that'd be great if someone can remember), but was reinstated in #3360. This PR re-removes splatting. It yields a 2x performance gain for a column model:. # `main`. ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.398369 seconds (727.30 k allocations: 706.103 MiB, 30.55% gc time); ```. # This PR; ```julia; julia> include(""test_single_column_model.jl""); ┌ Info: Running a simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); │ ├── grid: 1×1×64 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; │ ├── timestepper: QuasiAdamsBashforth2TimeStepper; │ ├── tracers: (b, e); │ ├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}; │ ├── buoyancy: BuoyancyTracer with ĝ = NegativeZDirection(); └ └── coriolis: FPlane{Float64}...; 0.214935 seconds (258.50 k allocations: 195.374 MiB, 10.57% gc time); ```. It also reduces memory allocation. . Note that the nonhydrostatic model was not changed (it does not splat).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477:291,perform,performance,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477,1,['perform'],['performance']
Performance,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867:1678,perform,performance,1678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867,1,['perform'],['performance']
Performance,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279:296,perform,performed,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279,1,['perform'],['performed']
Performance,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:1014,perform,performance,1014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['perform'],['performance']
Performance,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805:312,Perform,Performance,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:485,perform,performance,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,3,['perform'],['performance']
Performance,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:530,perform,performance,530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['perform'],['performance']
Performance,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:340,perform,perform,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['perform'],['perform']
Performance,"This PR updates `FieldTimeSeries` to be slightly ""backward compatible"" and capable of loading data from Oceananigans versions that did not have `Field.indices`, or which serialized stretched GPU grids with `CuArray`s. We might have to constantly maintain this... but hopefully eventually structures will be more stable, and eventually we can just delete the stuff added here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2419:86,load,loading,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2419,1,['load'],['loading']
Performance,"This PR would add a [""Strange splitting""](http://hplgit.github.io/fdm-book/doc/pub/book/sphinx/._book018.html) time stepper where the biogeochemical components of the tendencies are computed more frequently than the transport since biogeochemistry can often be much stiffer and so it is relatively common practice to step the bgc at different frequencies to the physics (e.g. NEMO-PISCES allows multiple euler substeps to be taken between each physics step). Strange splitting assumes the tendency can be written as a stiff and non-stiff part:; $\frac{\partial C}{\partial t} = \mathcal{A} + \mathcal{B}$,; where $\mathcal{A}$ is the advection (less stiff) and $\mathcal{B}$ is the BGC (more stiff) components.; And we basically take half a step with just the stiff component, then a full step with just the non-stiff component, and finally another step with the stiff component.; i.e. we have $C^n$ then:; $C^{n+1/2} = C^n + \int_{t_n}^{t_n+\Delta t/2}\mathcal{B}\left(C^n\right)dt,$; $C^* = C^{n+1/2} + \int_{t_n}^{t_n+\Delta t}\mathcal{A}\left(C^{n+1/2}, \vec{u^n}\right) dt, $; $C^{n+1} = C^* + \int_{t_n +\Delta t / 2}^{t_n+\Delta t}\mathcal{B}\left(C^*\right)dt.$. This is supposedly $\mathcal{O}(\Delta t ^2)$ from the splitting, so you can take the substeps with $\mathcal{O}(\Delta t ^2)$ schemes. To do this I had to implement quite a few changes so that you can optionally turn off bgc transitions in the normal tendency calculation, and then add some new functions to the time steppers to allow them to just compute the tendencies for, and step the bgc. This currently does not work, but I ran out of time to debug it. If there is interest in using this I would be happy to have another look at it. Another thought I had was that we could allow the biogeochemical sub-stepping to be performed by e.g. DifferentialEquations.jl timesteppers, but then I realised it wouldn't be that straight forward to make a wrapper for them to work in oceananigans so decided to leave it for another time.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888:1917,perform,performed,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888,1,['perform'],['performed']
Performance,"This changes the threading structure in a kernel launch to only launch over the i,j indices to avoid race conditions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1944:101,race condition,race conditions,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1944,1,['race condition'],['race conditions']
Performance,"This code:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; halo = (4, 4, 1),; x = (0, 2π),; y = (0, 2π),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). momentum_advection = VectorInvariant(vorticity_scheme = WENO(order=5),; vertical_scheme = Centered(),; divergence_scheme = WENO(order=5)); buoyancy = nothing; tracers = nothing; free_surface = ExplicitFreeSurface(gravitational_acceleration=10); model_args = (; momentum_advection, buoyancy, tracers, free_surface). model = HydrostaticFreeSurfaceModel(; grid, model_args...); ```. throws an error:. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: ArgumentError: The grid halo (4, 4, 1) must be at least equal to (4, 4, 4).; Note that an ImmersedBoundaryGrid requires an extra halo point in all; non-flat directions compared to a non-immersed boundary grid.; Stacktrace:; [1] validate_model_halo; @ ~/.julia/packages/Oceananigans/OMBY0/src/Models/Models.jl:55 [inlined]; ```. This seems like a bug to me, because a `Centered()` scheme in the vertical should only require one halo point.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3699:651,Load,LoadError,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3699,1,['Load'],['LoadError']
Performance,"This code:. ```julia; using Oceananigans; using Oceananigans.Grids: with_halo. underlying_grid = RectilinearGrid(size=(3, 3, 3), x=(0, 2), y=(0, 1), z=(0, 1)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> x)). with_halo((4, 4, 4), grid); ```. produces. ```; ERROR: LoadError: ArgumentError: The dimensions of the immersed boundary (9, 9) do not match the grid size (11, 11); Stacktrace:; [1] validate_ib_size; @ ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92 [inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2988:292,Load,LoadError,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988,1,['Load'],['LoadError']
Performance,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1328:264,Perform,Performing,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328,1,['Perform'],['Performing']
Performance,This fixes a bug in `MultiRegion` for which `copyto!` is by default asynchronous. This is not a problem until very large meshes (which unfortunately is what we want with multi GPU) ; I still have to test performance... and maybe we also want another solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2547:204,perform,performance,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2547,1,['perform'],['performance']
Performance,"This fixes a bug in which halo regions were not filled for subgrid-scale LES diffusivities. . To do this robustly for various diffusivity structures with different nesting hierarchies, a recursive halo region filling functionality is implemented that dispatches on `bcs::NamedTuple{(:x, :y:, :z)}`, corresponding to a `FieldBoundaryCondition`. Thus, when `fill_halo_regions!(fields, bcs, grid)` is called with matching tuples for *both* `fields` and `bcs`, a simultaneous loop is done over the members of the two tuples. However, when `fill_halo_regions!(fields, bcs, grid)` is called and `bcs` is a `FieldBoundaryCondition`, a loop is performed over the members of `fields` *only*, and `bcs` is reused for every member of `fields`. Thus halo regions for fields embedded in nested structures (like diffusivities in `AnisotropicMinimumDissipation`) are all filled with a single call to `fill_halo_regions!`. For now, the code uses temperature boundary conditions to determine the diffusivity boundary conditions. This will work until we implement the changes proposed in #371.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/385:636,perform,performed,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385,1,['perform'],['performed']
Performance,"This is a (somewhat minor) convenience for parameter studies, because it means that if `u` was constructed with. ```julia; u_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(1.0)); ```. we can later write things like. ```julia; u.boundary_conditions.top = FluxBoundaryCondition(2.0); ```. to change the value of the boundary condition. Note that the _type_ of the boundary condition can't change. . Just opening this PR to see if tests pass with this change. If so it seem positive to me (I don't think `FieldBoundaryConditions` needs to be immutable for performance reasons, but please speak up if anyone thinks/knows otherwise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063:580,perform,performance,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063,1,['perform'],['performance']
Performance,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606:983,Load,LoadError,983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606,1,['Load'],['LoadError']
Performance,"This is a rather minimal example that tries to use `PrescribedVelocityFields` in the `ImmersedBoundaryMethod`,. ```; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(16, 8),; y=(-1, 1), z=(-1, 0), ; topology=(Flat, Periodic, Bounded)). seamount(x, y, z) = z < - 1 + 0.1*exp(-y^2/0.25^2) . grid_with_seamount = ImmersedBoundaryGrid(grid, GridFittedBoundary(seamount)). U(x, y, z) = 0.; V(x, y, z) = 0.; W(x, y, z) = 0. velocities = PrescribedVelocityFields(u=U, v=V, w=W). model = HydrostaticFreeSurfaceModel(architecture = CPU(), ; grid = grid_with_seamount,; momentum_advection = CenteredSecondOrder(), ; free_surface = ImplicitFreeSurface(),; closure = nothing, ; tracers = :b,; velocities = velocities,; buoyancy = BuoyancyTracer()); ```. Unfortunately, it fails with the following error,. ```; ERROR: LoadError: MethodError: no method matching device(::Nothing); Closest candidates are:; device(::Oceananigans.Architectures.AbstractCPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:50; device(::Oceananigans.Architectures.AbstractGPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:51; Stacktrace:; [1] device_event(arch::Nothing); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:75; [2] mask_immersed_field!(field::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:893,Load,LoadError,893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,1,['Load'],['LoadError']
Performance,"This is related to [this PR](https://github.com/CliMA/Oceananigans.jl/pull/2029). To summarize:. - I have a production-ready research code (that's far too complicated to post here) that does sines/cosines calculations for a background field; - If these sine/consine calculations are performed inside the background field function the code is about 100x slowed than if I perform these calculations outside the function, and just pass the pre-calculated sine and cosine; - I tried making a MWE to reproduce this behavior but failed, which indicates that it's not _just_ the trig functions that are causing the slowdown. It's the trig functions plus something else (I have no idea what). So that's the state of things. I'll try to start from my code and cut down on things one by one to try and post a small MWE whenever I have time. CC: @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2034:283,perform,performed,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034,2,['perform'],"['perform', 'performed']"
Performance,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1216,Load,LoadError,1216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['Load'],['LoadError']
Performance,This is the first step towards #2012. The goal is to test the method with a flat-bottom and compare performance / stability with respect to the other free-surface implementations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2013:100,perform,performance,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013,1,['perform'],['performance']
Performance,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:840,perform,performance,840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,2,['perform'],['performance']
Performance,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:402,Load,LoadError,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,1,['Load'],['LoadError']
Performance,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1076:154,perform,performance,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076,1,['perform'],['performance']
Performance,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1273:154,Load,LoadError,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273,1,['Load'],['LoadError']
Performance,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073:52,load,loaded,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073,1,['load'],['loaded']
Performance,Tries to catch the race condition that produces #1767 .,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1784:19,race condition,race condition,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784,1,['race condition'],['race condition']
Performance,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:158,Load,LoadError,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['Load'],['LoadError']
Performance,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:874,Load,LoadError,874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['Load'],['LoadError']
Performance,Unfortunately the previews clog up the [OceananigansDocumentation](https://github.com/CliMA/OceananigansDocumentation) repository and we need to perform manual cleanup often... I suggest we drop the doc previews for the moment. We could build the docs manually _or_ temporarily enable them for a particular PR that includes Doc changes and then disable them again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2870:145,perform,perform,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2870,1,['perform'],['perform']
Performance,Update Performance Benchmarks in Docs and README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1676:7,Perform,Performance,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676,1,['Perform'],['Performance']
Performance,Update performance benchmarks plot and discuss results,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/607:7,perform,performance,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/607,1,['perform'],['performance']
Performance,"Using Julia 1.7.3 and Oceananigans 0.77.1, this code:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(1, 1, 2), extent=(1, 1, 1)); buoyancy_bottom_bc = GradientBoundaryCondition(1e-5); buoyancy_bcs = FieldBoundaryConditions(bottom=buoyancy_bottom_bc); model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=BuoyancyTracer(),; boundary_conditions=(; b=buoyancy_bcs)); simulation = Simulation(model; Δt=1, stop_iteration=2); run!(simulation); ```. produces:. ```julia; julia> include(""simple_model.jl""); ERROR: LoadError: InvalidIRError: compiling kernel #gpu__fill_bottom_and_top_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, In",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2709:530,Load,LoadError,530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709,1,['Load'],['LoadError']
Performance,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1088:171,perform,perform,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088,3,"['multi-thread', 'perform']","['multi-threading', 'perform', 'performance']"
Performance,"Using `Cthulhu` by running the commands. ```julia; using Oceananigans, Cthulhu. model = Model(N=(32, 32, 32), L=(1, 1, 1)) . @descend time_step!(model, 1, 1); ```. and descending into the call to `store_previous_source_terms!` (I did this using the optimize flag and scrolling to invocation `%206`, then using the warn_type flag), reveals (I think) that for some reason julia cannot infer the types of arguments into any of the kernels. For example, the `Cthulhu` output from that exercise yields. ```; @ /Users/gregorywagner/Projects/Oceananigans.jl/src/time_steppers.jl:122 within `store_previous_source_terms!'; 15 ┄ %74 = (GPUifyLoops.isdevice)()::Core.Compiler.Const(false, false); │ %75 = !%74::Core.Compiler.Const(true, true); │ %75; │ %77 = (Base.getproperty)(grid, :Nx)::Any; ```. The type of `grid` is not inferred, and neither is the type of `grid.Nx`. None of the types of the arguments are inferred. I can fix this problem by explicitly typing all of the arguments except for the floating point type. However, I cannot fix the problem even if I specify that most of the arguments are `AbstractArray`. Is this causing performance problems? Is this the source of memory allocation during time-stepping?. @vchuravy @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/251:249,optimiz,optimize,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/251,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,Validation and performance benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:15,perform,performance,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['perform'],['performance']
Performance,Verification tests comparing performance of different LES closures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/441:29,perform,performance,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441,1,['perform'],['performance']
Performance,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:1007,perform,performing,1007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,1,['perform'],['performing']
Performance,"We currently calculate the barotropic mode inside the AB2 step:. https://github.com/CliMA/Oceananigans.jl/blob/e27988039e65e9244a84d241b70c2dcdeac93309/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L18-L22. I'm wondering if it makes more sense to calculate this inside `update_state!`. Our algorithm calculates `update_state!` at the _end_ of a time-step, which means that after calling `time_step!(model)` the model auxiliary and prognostic state are all concurrent, which is useful for output. cc @sandreza @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2244:487,concurren,concurrent,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2244,1,['concurren'],['concurrent']
Performance,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/502:811,perform,performant,811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502,1,['perform'],['performant']
Performance,"We may able to provide an interface for specifying background tracer distributions and velocity fields (which perform advection only?) using `FunctionField`s and the existing advection operators. I think we would want this functionality to assume that the _linear_ balances between background terms are somehow separately satisfied. With that assumption we can include just the two nonlinear terms associated with 1) advection of the resolved field by the background field and 2) advection of the background field by the resolved fields. For this to be easily implemented we need to change the function signature of the advection operators for momentum from. ```julia; div_ũu(i, j, k, grid, advection, U); ```. to . ```julia; div_ũu(i, j, k, grid, advection, U, u); ```. which then enables us to include background terms via. ```julia; div_ũu(i, j, k, grid, advection, U_background, u) + div_ũu(i, j, k, grid, advection, U, u_background); ```. for example. Tracers are fine, since the current function is. ```julia; div_uc(i, j, k, grid, advection, U, c); ```. which will become. ```julia; div_uc(i, j, k, grid, advection, U_background, c) + div_uc(i, j, k, grid, advection, U, c_background); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/960:110,perform,perform,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960,1,['perform'],['perform']
Performance,"We might need to implement the K-Profile boundary layer turbulence closure so that we can use it to compare the CATKE performance. . Ideally, we'd like to calibrate the K-Profile parametrisation using [OceanTurbulenceParameterEstimation.jl](http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl) alongside with CATKE closure and then compare how the two perform under various scenarios. @glwagner, would it be easy to implement KPP, similarly as done in [OceanTurb.jl](https://github.com/glwagner/OceanTurb.jl)?. cc @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2149:118,perform,performance,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149,2,['perform'],"['perform', 'performance']"
Performance,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/525:662,perform,performed,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525,2,['perform'],"['performed', 'performs']"
Performance,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089:38,load,loaded,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089,2,['load'],['loaded']
Performance,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:125,perform,performance,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,1,['perform'],['performance']
Performance,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:79,perform,performance,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['perform'],['performance']
Performance,We should run the [Performance Benchmarks](https://clima.github.io/OceananigansDocumentation/stable/benchmarks/) with the latest Oceananigans.jl version and on Julia v1.6.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1676:19,Perform,Performance,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676,1,['Perform'],['Performance']
Performance,We've experienced a major performance regression. For v0.27.0:. ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/726:26,perform,performance,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/726,1,['perform'],['performance']
Performance,"When I run the following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:838,Load,LoadError,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,1,['Load'],['LoadError']
Performance,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:648,Load,LoadError,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Load'],['LoadError']
Performance,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:587,Load,LoadError,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,1,['Load'],['LoadError']
Performance,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:114,perform,performant,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,2,['perform'],"['performance', 'performant']"
Performance,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308:878,Load,LoadError,878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308,1,['Load'],['LoadError']
Performance,"While `Array{Float32}` is neat because user output is smaller, it's a bad default because it often leads to confusing results, like the fact that outputing `Field(Integral(c))` is different (possibly by `eps(Float32)`) than computing `Integral(c_output)` in post processing when `Field(Integral(c))` is close to 0. Thus @xkykai and I propose to make the default `Array{Float64}`. We could regard outputting with `Array{Float32}` as an ""optimization"" which is premature as a default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2890:436,optimiz,optimization,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890,1,['optimiz'],['optimization']
Performance,"With @amontoison. We'd like to implement a Poisson solver that uses [`Krylov`](https://github.com/JuliaSmoothOptimizers/Krylov.jl) under the hood instead of our custom (preconditioned) conjugate gradient solver. This will open the door to [more solvers (that may be more appropriate for our pressure Poisson equation than conjugate gradient)](https://arxiv.org/abs/2310.01757) like conjugate residual, etc. To make this work we need to overload some of Krylov's operators for Oceananigans `Field`:. * [`kaxpby!(n, s, x, dx, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kaxpby!(n, s, x, dx, t, y, dy)`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L326C1-L326C8) which performs `y = t * y + s * x` where `n` is the total length (eg `Nx * Ny * Nz`), `s` is the output, `dx` and `dy` are strides (irrelevant for us); * [`kdot`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L310C1-L310C5); * [`knrm2`](https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/200a9cd01c3bba906b82eaa87103aa2881983e5f/src/krylov_utils.jl#L316C1-L316C6); * Either `kcopy!` or `copyto!`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803:671,perform,performs,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803,2,['perform'],['performs']
Performance,"With the code being (slightly) optimized, we probably need a way to track performance across PRs and make sure we don't lose performance due to reasons we do not have much control over (for example changes in dependencies). Over at [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/issues/464) they are thinking to do the same and the package [PkgBenchmark.jl](https://github.com/JuliaCI/PkgBenchmark.jl) was suggested as a way to simplify this implementation. The question here is what would be the suitable candidate for a performance test, we could start with ; - a non-hydrostatic simulation (no immersed boundaries); - a hydrostatic simulation on rectilinear; - same on latitude-longitude and on immersed boundary; - a near-global ocean at a quarter of a degree ; - a near-global ocean at a quarter of a degree on 4 GPUs. The tests do not have to be enforced but can run nightly (or once per week) on the main branch, with the possibility of performing the tests before merging sensitive PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492:31,optimiz,optimized,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492,5,"['optimiz', 'perform']","['optimized', 'performance', 'performing']"
Performance,With this PR we can now apply boundary conditions on `x` and `y`. I still need to add tests and benchmark performance (nothing should change). One discussion point: Should we even add support for `x` boundary conditions seeing as we only support `Periodic` boundary conditions in the `x` direction?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475:106,perform,performance,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475,1,['perform'],['performance']
Performance,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728:998,perform,perform,998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728,2,['perform'],['perform']
Performance,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380:80,perform,performance,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380,1,['perform'],['performance']
Performance,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:587,load,load,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['load'],['load']
Performance,"Yet another optimization for upwind stencil computations.; The pattern in Oceananigans to perform upwind reconstruction is roughly:; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ``` . This means that we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:12,optimiz,optimization,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,3,"['optimiz', 'perform']","['optimization', 'perform', 'performing']"
Performance,Zero-ed initial guess to preconditioner for CG solver improves performance compared to using previous `z`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2655:63,perform,performance,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655,1,['perform'],['performance']
Performance,"[inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:409; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inline::Bool, maxthreads::Int64}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:375; [15] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:112 [inlined]; [16] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:2456,cache,cache,2456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['cache'],['cache']
Performance,"[inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inline::Bool, maxthreads::Int64}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:375; [15] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:112 [inlined]; [16] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:2183,cache,cache,2183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['cache'],['cache']
Performance,[inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5611,cache,cache,5611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── tracers: (); ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1.0e-5); ├── buoyancy: Nothing; └── coriolis: Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:3027,optimiz,optimizer,3027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,6,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.j,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2392,cache,cache,2392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialan,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6163,cache,cache,6163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:1543,Load,LoadError,1543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['Load'],['LoadError']
Performance,"_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:1932,load,loads,1932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['load'],['loads']
Performance,`Callable` tridiagonal coefficients produces catastrophic loss of performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3047:66,perform,performance,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3047,1,['perform'],['performance']
Performance,"`HydrostaticFreeSurfaceModel` has two options for `free_surface`: `ExplicitFreeSurface` and `ImplicitFreeSurface`. Unfortunately, `ImplicitFreeSurface` using a `PreconditionedConjugateGradientSolver` incurs a significant cost (even relative to the cost of a _three-dimensional_ direct non hydrostatic pressure solve!), while `ExplicitFreeSurface` severely limits time-step with realistic `gravitational_acceleration` and velocity scales. For grids that are regular and rectilinear in the horizontal, there is a cure: we can implement a direct solve using the FFT based pressure solver either of the 2D barotropic poisson pressure equation, or for the 2D implicit free surface step. It will be interesting to compare the total cost of the barotropic integral + 2D solve, which requires integrals to extra the barotropic transport, with the 3D solve used by `IncompressibleModel`. The vertical FFT is _asymptotically_ more costly than the couple vertical integrals required for a barotropic pressure solve; but on the other hand the FFTs are highly optimized.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1727:1047,optimiz,optimized,1047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1727,1,['optimiz'],['optimized']
Performance,"```Julia; [ Info: Running the simulation...; ERROR: LoadError: KeyError: key ""timestepper/Gⁿ/w"" not found; Stacktrace:; [1] pathize(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String, create::Bool); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:70; [2] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:95; [3] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/JLD2.jl:379; [4] set_time_stepper_tendencies!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:52,Load,LoadError,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['Load'],['LoadError']
Performance,```julia; CuArrays.allowscalar(false); ```; to disable slow fallback methods for CuArrays so we don't accidentally perform some slow operation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/82:115,perform,perform,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/82,1,['perform'],['perform']
Performance,```julia; ERROR: LoadError: cannot write a pointer to JLD file; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420:17,Load,LoadError,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420,1,['Load'],['LoadError']
Performance,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=128, z=(-128, 0), topology=(Flat, Flat, Bounded)). closure = (VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), κ=1e-4),; CATKEVerticalDiffusivity()). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = (:b, :e),; buoyancy = BuoyancyTracer()). bᵢ(z) = 1e-5 * z; set!(model, b = bᵢ); simulation = Simulation(model, Δt=1minute, stop_iteration=10). run!(simulation); ```. generates the error. ```julia; julia> include(""tupled_vertical_diffusion.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.367 seconds); [ Info: Executing initial time step...; ERROR: LoadError: type Tuple has no field κe; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] time_step_catke_equation!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl:25; [3] compute_diffusivities!(diffusivities::@NamedTuple{…}, closure::CATKEVerticalDiffusivity{…}, model::HydrostaticFreeSurfaceModel{…}; parameters::Symbol); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:197; [4] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:181 [inlined]; [5] #compute_diffusivities!#24; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:79 [inlined]; [6] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:76 [inlined]; [7] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:772,Load,LoadError,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,1,['Load'],['LoadError']
Performance,`outputinfo(filename)` for inspecting output without loading data,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3859:53,load,loading,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3859,1,['load'],['loading']
Performance,"a/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3428,load,loading,3428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,aac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cac,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4693,cache,cache,4693,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,agrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-relea,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4530,cache,cache,4530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,alang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6405,cache,cache,6405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"alculation that reproduces the issue:. ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; extent = (1, 1, 1),; halo=(4, 4, 4)). bathymetry(x, y) = 1; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(; grid). @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = ∂x(u) + 1e-7; dudz_tilt = ∂z(u). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz); ```. This gives me:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_70 --output-file /glade/scratch/tomasc/jl_6zqZEpG5Yv.cubin /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; ptxas /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S7_11OffsetArrayIS7_Li1E12StepRangeLenIS7_14TwicePrecisionIS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvE16GridFittedBottomIS22_IS7_Li2ES9_IS7_Li2ELi1EEE23CenterImmerse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:1140,Load,LoadError,1140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['Load'],['LoadError']
Performance,"all to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5419,optimiz,optimize,5419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['optimiz'],['optimize']
Performance,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:2203,Optimiz,Optimize,2203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['Optimiz'],['Optimize']
Performance,amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cac,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6944,cache,cache,6944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,an_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-re,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4423,cache,cache,4423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:3252,scalab,scalability,3252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,2,['scalab'],"['scalability', 'scalable']"
Performance,"ang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:9059,cache,cache,9059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; > ; > _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/31#issuecomment-468288154_. Some more comments:; * Right now NetCDF output is much slower than expected. We have asynchronous output writing #137 but spending 2-3 minutes to write out the fields of a 256³ grid is ridiculous.; * Compression doesn't seem to work in NetCDF.jl: See https://github.com/JuliaGeo/NetCDF.jl/issues/87; * We might want to share this output writing feature with CliMA.jl. See https://github.com/climate-machine/CLIMA/issues/114; * @simonbyrne and @charleskawczynski suggested looking at [HDF5.jl](https://github.com/JuliaIO/HDF5.jl). As NetCDF4 is built on HDF5, we should be able to generate valid NetCDF files with it.; * Whatever we end up doing, @christophernhill makes a good point that we should produce portable NetCDF files as this is what all our potential users would expect and want.; * Thinking more long-term @lcw says that IO performance is a hard problem and thinks we are going to want something that plays well on clusters (e.g., something MPI IO based). Some extra features we might want in the short-term:; - [ ] Option to only write out a specific subset of the model state, e.g. surface velocities only, or a vertical temperature slice. This would really speed up IO if you don't need full 3D fields.; - [ ] Select which fields to write out to NetCDF.; - [ ] Include diagnostics in NetCDF output. I believe this will be possible if we resolve the item above as output writing occurs right after diagnostics are run, so diagnostic fields can just be included as one of the fields to write out.; - [ ] Option to create one NetCDF file for each iteration, or to combine all output into one NeCDF file. I think the main point of this issue is that we should decide how to output NetCDF. Packages we could choose from are NCDatasets.jl and HDF5.jl. Or we could go with something else.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145:1626,perform,performance,1626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145,1,['perform'],['performance']
Performance,"atch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:103; [8] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/execution.jl:318 [inlined]; [9] macro expansion; @ ./lock.jl:223 [inlined]; [10] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeIn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:5410,cache,cache,5410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['cache'],['cache']
Performance,atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4897,load,loading,4897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['load'],['loading']
Performance,ations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/juli,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4357,cache,cache,4357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3302,load,loading,3302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"be good to suppress them somehow. This package might help: https://github.com/JuliaIO/Suppressor.jl. What I see on a CPU:; ```; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537.; ERROR: LoadError: Could not find CUDA driver library; Stacktrace:; [1] top-level scope at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:33; [2] top-level scope at none:2; in expression starting at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:27; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366:1518,Load,LoadError,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366,1,['Load'],['LoadError']
Performance,"bstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothing, Tuple{ScalarBiharmonicDiffusivity{Oceananigans.TurbulenceCl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2591:1150,Load,LoadError,1150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591,1,['Load'],['LoadError']
Performance,build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-releas,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5297,cache,cache,5297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/bu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7053,cache,cache,7053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"bulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7559,optimiz,optimizing,7559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['optimiz'],['optimizing']
Performance,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:1215,Load,LoadError,1215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,2,['Load'],['LoadError']
Performance,c/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3851,cache,cache,3851,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,c/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:28,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7624,cache,cache,7624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 26236174 (Pool: 26209699; Big: 26475); GC: 35; ```. I'll test CPU then try to see if this situation is tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5447,cache,cache,5447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,6,['cache'],['cache']
Performance,cation.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Softwa,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4248,cache,cache,4248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"ceananigans/s0kF6/src/models.jl:186; [21] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:float_type, :grid, :closure, :architecture),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},ConstantIsotropicDiffusivity{Float64},GPU}}, ::Type{Model}) at ./none:0; [22] #BasicModel#23(::Tuple{Int64,Int64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Float64, ::Float64, ::Type, ::Base.Iterators.Pairs{Symbol,GPU,Tuple{Symbol},NamedTuple{(:architecture,),Tuple{GPU}}}, ::typeof(BasicModel)) at /home/tomaschor/.julia/packages/Oceananigans/s0kF6/src/models.jl:125; [23] (::getfield(Oceananigans, Symbol(""#kw##BasicModel"")))(::NamedTuple{(:N, :L, :architecture, :ν, :κ),Tuple{Tuple{Int64,Int64,Int64},Tuple{Int64,Int64,Int64},GPU,Float64,Float64}}, ::typeof(BasicModel)) at ./none:0; [24] top-level scope at /home/tomaschor/oceantest/test1.jl:5; [25] include at ./boot.jl:328 [inlined]; [26] include_relative(::Module, ::String) at ./loading.jl:1094; [27] include(::Module, ::String) at ./Base.jl:31; [28] include(::String) at ./client.jl:431; [29] top-level scope at REPL[1]:1; in expression starting at /home/tomaschor/oceantest/test1.jl:5; ```. Here's the output of `nvidia-smi`:; ```; +-----------------------------------------------------------------------------+; | NVIDIA-SMI 390.129 Driver Version: 390.129 |; |-------------------------------+----------------------+----------------------+; | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |; | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |; |===============================+======================+======================|; | 0 NVS 310 Off | 00000000:03:00.0 N/A | N/A |; | 30% 40C P8 N/A / N/A | 634MiB / 962MiB | N/A Default |; +-------------------------------+----------------------+----------------------+; ; +-----------------------------------------------------------------------------+; | Processes: GPU Memory |; | GPU PID Type Process nam",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:4405,load,loading,4405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,1,['load'],['loading']
Performance,"cf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl#L92-L96) should return also the barotropic velocities when using a split-explicit free surface. ***(3)***. I would like to flatten out the design of the `SplitExplicitFreeSurface` by; - removing the [`SplitExplicitState`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L136-L161), and have the barotropic velocities and the mean fields part of the main `free_surface` type and all the remaining fields required for specific timesteppers in the [`timestepper`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L259-L260) which at the moment is very simple but can be redesigned to contain all time-stepping specific information; - removing [`SplitExplicitSettings`](https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L253-L256) (I don't know why there is a `settings_kwargs` there but it looks odd and it's probably a sign that this type is not well designed). This leads to a `SplitExplicitFreeSurface` which will look like; ```julia; struct SplitExplicitFreeSurface{H, U, M, FT, K , S, T} <: AbstractFreeSurface{H, FT}; η :: H; barotropic_velocities :: U # A namedtuple with U, V ; filtered_state :: M # A namedtuple with η, U, V averaged throughout the substepping; gravitational_acceleration :: FT; kernel_parameters :: K; substepping :: S # Either `FixedSubstepNumber` or `FixedTimeStepSize`; timestepper :: T # redesigned to contain all auxiliary field and settings necessary to the particular timestepping; end; ```; These changes will not affect the performance nor the functioning of the algorithm, and (if there are none required) should not even affect the user interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873:3428,perform,performance,3428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873,1,['perform'],['performance']
Performance,che/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5397,cache,cache,5397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:2163,load,loading,2163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,8,['load'],['loading']
Performance,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:2070,Load,LoadError,2070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['Load'],['LoadError']
Performance,"com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0"">https://github.com/julia-actions/setup-julia/compare/v1.9.6...v2.0.0</a></p>; <h2>v1.9.6: Fix Apple Silicon installation</h2>; <h2>What's Changed</h2>; <ul>; <li>Fix the Apple Silicon (macOS <code>aarch64</code> / <code>arm64</code>) URLs for Julia nightly by <a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; <li>put quotes on readme version examples by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/203"">julia-actions/setup-julia#203</a></li>; </ul>; <h3>Deps &amp; CI</h3>; <ul>; <li>Bump actions/cache from 3 to 4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/215"">julia-actions/setup-julia#215</a></li>; <li>Bump <code>@​types/node</code> from 20.10.6 to 20.11.16 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/213"">julia-actions/setup-julia#213</a></li>; <li>Bump ts-jest from 29.1.1 to 29.1.2 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/212"">julia-actions/setup-julia#212</a></li>; <li>Bump nock from 13.4.0 to 13.5.1 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/211"">julia-actions/setup-julia#211</a></li>; <li>Bump semver from 7.5.4 to 7.6.0 by <a href=",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:2921,cache,cache,2921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['cache'],['cache']
Performance,"cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:409; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:2135,cache,cache,2135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['cache'],['cache']
Performance,"cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:262; [11] cached_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [12] macro expansion; @ ~/.julia/packages/CUDA/z3j2H/src/compiler/execution.jl:380 [inlined]; [13] macro expansion; @ ./lock.jl:267 [inlined]; [14] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu__update_hydrostatic_pressure!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, LatitudeLongitudeGrid{…}, Buoyancy{…}, @NamedTuple{…}}}; kwargs::@Kwargs{always_inl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:1862,cache,cache,1862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['cache'],['cache']
Performance,"d = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:2836,Perform,Performing,2836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['Perform'],['Performing']
Performance,"ditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},CenteredFourthOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},TimeStepWizard{Float64},Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/Simulations/run.jl:102; [21] top-level scope at /central/home/guptam/ocean_floes/turb-closures/expt/biharmonic_1e5_4thOrder_kappaV_profile1_Z_2p5.jl:135; [22] include(::Function, ::Module, ::String) at ./Base.jl:380; [23] include(::Module, ::String) at ./Base.jl:368; [24] exec_options(::Base.JLOptions) at ./client.jl:296; [25] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/turb-closures/expt/biharmonic_1e5_4thOrder_kappaV_profile1_Z_2p5.jl:135; Loaded all modules; ```. which occurs because `TimeStepWizard` doesn't know how to compute the maximum diffusivity when diffusivity is a function (it shouldn't even try!)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:25643,Load,Loaded,25643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['Load'],['Loaded']
Performance,"duce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4_14TwicePrecisionIS4_ES10_IS4_E5Int64EES3_IS4_Li1ES9_IS4_S10_IS4_ES10_IS4_ES11_EES3_IS4_Li1ES5_IS4_Li1ELi1EEEvE22UpwindBiasedFifthOrder6FPlaneIS4_Ev17ScalarDiffusivityI26ExplicitTimeDiscretization27ThreeDimensionalFormulation3___10NamedTupleI57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_5TupleIS17_S17_S17_S17_S17_S17_S17_S17_S17_S17_S17_EEE17BoundaryConditionI4FluxvE8BuoyancyI14BuoyancyTracer10ZDirectionES18_I23__velocities___tracers_S19_IS18_I12__u___v___w_S19_I9ZeroFieldIS11_Li3EES25_IS11_Li3EES25_IS11_Li3EEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS25_IS11_L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:1568,Load,LoadError,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['Load'],['LoadError']
Performance,"e Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.ND",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:2148,Perform,Performing,2148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['Perform'],['Performing']
Performance,e at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3941,cache,cache,3941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"e base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and merges them at the end (this seems easier than writing another output writer).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:2484,perform,performant,2484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['perform'],['performant']
Performance,"e), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3362,load,loading,3362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,e/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4135,cache,cache,4135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPIC",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1978,load,loaded,1978,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loaded']
Performance,eModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_th,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4697,cache,cache,4697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ non",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3147,load,loading,3147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,ease-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4967,cache,cache,4967,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:2023,load,loading,2023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,3,['load'],['loading']
Performance,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:2223,cache,cache,2223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,2,['cache'],['cache']
Performance,"ed/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:5386,load,loading,5386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"em like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:2130,optimiz,optimize,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2101:1856,optimiz,optimizer,1856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101,1,['optimiz'],['optimizer']
Performance,"ependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1453,load,loading,1453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"eration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:2374,cache,cache,2374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['cache'],['cache']
Performance,"erent advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:1227,perform,perform,1227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['perform'],['perform']
Performance,et_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6680,cache,cache,6680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #inv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:2297,load,loading,2297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['load'],['loading']
Performance,"fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:2348,load,loading,2348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['load'],['loading']
Performance,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:7087,load,load,7087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,2,['load'],['load']
Performance,gions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./load,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4143,cache,cache,4143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"grid); u, v, w = model.velocities. uu = @at (Center, Center, Center) u * u. # output; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Center, Center, Center) via ℑxᶜᵃᵃ;    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. which would compute `u * u` at `(Face, Center, Center)`, and subsequently interpolate to cell centers. The object `uu` would then be defined at cell centers. The main issue of this design in terms of functionality is that it produces expression trees that interpolate ""too eagerly"". A common example is a turbulent kinetic energy computation:. ```julia; U = AveragedField(u, dims=(1, 2)); V = AveragedField(v, dims=(1, 2)). tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2); ```. Inspection of this object reveals that while `u - U` does not interpolate, the squaring `(u - U)^2` would be performed at cell centers:. ```julia; julia> tke.args[1].b; 2. julia> tke.args[1].a; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:1723,perform,performed,1723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['perform'],['performed']
Performance,"h::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4857,load,loading,4857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:1281,Load,LoadError,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['Load'],['LoadError']
Performance,"his design in terms of functionality is that it produces expression trees that interpolate ""too eagerly"". A common example is a turbulent kinetic energy computation:. ```julia; U = AveragedField(u, dims=(1, 2)); V = AveragedField(v, dims=(1, 2)). tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2); ```. Inspection of this object reveals that while `u - U` does not interpolate, the squaring `(u - U)^2` would be performed at cell centers:. ```julia; julia> tke.args[1].b; 2. julia> tke.args[1].a; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _concrete_ locations such that a difference needs to be resolved. In other cases (such as a binary operation between fields at common locations, or a binary operation between a field and a number), the location of the members of the operation is preserved. In this way, `BinaryOperations` are ""stubborn"". . We thus have results like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:2333,perform,performed,2333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['perform'],['performed']
Performance,https://github.com/ali-ramadhan/Oceananigans.jl/blob/a41c604e9360ba79ce11efe6d4d6370bf79a3cc6/src/model.jl#L1. It would make model construction much more flexible. Would this hinder performance?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/42:182,perform,performance,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42,1,['perform'],['performance']
Performance,"https://painterqubits.github.io/Unitful.jl/stable/. The obvious use case would be to replace the units (e.g. `minutes` and `years`) in `Oceananigans.Utils` with ""proper units"" from Unitful.jl. Not sure if we want to use it absolutely everywhere. Would be cool and there should be no performance hit, but might take quite a bit of refactoring. Could also be useful for defining constants in examples and scripts? Might be cool to play around with it a bit. Apparently @alanedelman is gonna be making fun of us for not using it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1116:283,perform,performance,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116,1,['perform'],['performance']
Performance,ia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; send_south_halo at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julial,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:2972,cache,cache,2972,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:2749,optimiz,optimizer,2749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,ia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:1359,optimiz,optimizer,1359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,10,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"iceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:41970,cache,cache,41970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"ile), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packag",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3246,load,loading,3246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,ined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6055,cache,cache,6055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 22.507 ms (7066 allocations: 1.09 MiB). julia> @btime cfl(model); 128.361 ms (257 allocations: 41.53 KiB); ```. Resol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1561,optimiz,optimized,1561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['optimiz'],['optimized']
Performance,"ivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:2349,perform,performed,2349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['perform'],['performed']
Performance,"ization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/sha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:2162,load,loading,2162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['load'],['loading']
Performance,"kages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:2246,load,loading,2246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['load'],['loading']
Performance,l at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6270,cache,cache,6270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,l scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5195,cache,cache,5195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,lang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/bu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7964,cache,cache,7964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"lang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8869,cache,cache,8869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,lder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/b,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7147,cache,cache,7147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,lease-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5076,cache,cache,5076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"ler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:289; [14] cufunction; @ ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:283 [inlined]; [15] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:102 [inlined]; [16] #launch_heuristic#286; @ ~/.julia/packages/CUDA/3VnCC/src/gpuarrays.jl:17 [inlined]; [17] launch_heuristic; @ ~/.julia/packages/CUDA/3VnCC/src/gpuarrays.jl:17 [inlined]; [18] copyto!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:63 [inlined]; [19] copyto!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:73 [inlined]; [20] mat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:2191,cache,cache,2191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['cache'],['cache']
Performance,lid_driven_cavity & thermal_bubble: ERROR: LoadError: ArgumentError: length(size) must be 2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:43,Load,LoadError,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,1,['Load'],['LoadError']
Performance,lined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2868,cache,cache,2868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,lined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /ca,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4800,cache,cache,4800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"loat64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:48006,cache,cache,48006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"loat64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45866,cache,cache,45866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"loat64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}}); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:74; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:324; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\cache.jl:90; [11] cufunction(f::typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryC",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:10238,cache,cache,10238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['cache'],['cache']
Performance,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:1550,perform,performance,1550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['perform'],['performance']
Performance,"mark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new branch `julia --project=""environments/one_sided_branch"" --check-bounds=no`; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true; BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 16.463 ms … 18.503 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 16.466 ms ┊ GC (median): 0.00%; Time (mean ± σ): 16.878 ms ± 908.449 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆ ▁; 16.5 ms Histogram: frequency by time 18.5 ms <. Memory estimate: 250.06 KiB, allocs estimate: 676. julia> trial1 = run_model_benchmark!(tracer_kernel_test, arch;; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 6.695 ms … 7.461 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 6.789 ms ┊ GC (median): 0.00%; Time (mean ± σ): 6.908 ms ± 312.944 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ ██ █ █; █▁▁▁▁▁██▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 6.69 ms Histogram: frequency by time 7.46 ms <. Memory estimate: 46.39 KiB, allocs estimate: 231. ```. P.S. some vestigial code not used is being removed as part of this PR because not beneficial (in terms of both accuracy and performance) that is; - the JS weno formulation (dominated by the Z-weno formulation); - Velocity Upwinding for the vector invariant weno formulation (dominated by the other two formulations)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:3756,perform,performance,3756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['perform'],['performance']
Performance,"n at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:2404,load,loading,2404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['load'],['loading']
Performance,"nclude at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1458,load,loading,1458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['load'],['loading']
Performance,"ndaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/blob/main/OceanGyreTank.ipynb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:1599,cache,cache,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,2,['cache'],['cache']
Performance,ne); MPI_Isend at /orcd/data/raffaele/001/glwagner/.julia/artifacts/e85c0a68e07fee0ee7b19c2abc210b1af2f4771a/lib/libmpi.so (unknown line); MPI_Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/api/generated_api.jl:2151 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:66; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; send_south_halo at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/O,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:2480,cache,cache,2480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,ng/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7273,cache,cache,7273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,ng/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __l,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8166,cache,cache,8166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3816:1240,Load,LoadError,1240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816,2,['Load'],['LoadError']
Performance,ns.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-re,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4474,cache,cache,4474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,ns.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_tople,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4806,cache,cache,4806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"nt64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:288; [9] cufunction; @ ~/.julia/pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:3364,cache,cache,3364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['cache'],['cache']
Performance,nterpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6540,cache,cache,6540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"nuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:15540,cache,cache,15540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['cache'],['cache']
Performance,"nuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12779,cache,cache,12779,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['cache'],['cache']
Performance,"oat64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5144,optimiz,optimize,5144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['optimiz'],['optimize']
Performance,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:6553,load,loading,6553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,2,"['cache', 'load']","['cache', 'loading']"
Performance,"onAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:3962,perform,performed,3962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performed']
Performance,"ons.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::Function, ::Type{T} where T; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.Tw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:11246,cache,cache,11246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['cache'],['cache']
Performance,"ons.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9703,cache,cache,9703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['cache'],['cache']
Performance,oop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.s,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7515,cache,cache,7515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"oordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::Nothing, ::Nothing) is ambiguous. Candidates:; _fractional_indices(::Any, grid, ℓx, ::Nothing, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:187; _fractional_indices(::Any, grid, ::Nothing, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:195; _fractional_indices(::Any, grid, ℓx, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:180; _fractional_indices(::Any, grid, ::Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:1917,Load,LoadError,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Load'],['LoadError']
Performance,"opy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:1358,Load,LoadError,1358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['Load'],['LoadError']
Performance,"ostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2184,cache,cache,2184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,ot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cach,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:7855,cache,cache,7855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,ply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:3145,cache,cache,3145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,ply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5105,cache,cache,5105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"quire(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4286,Load,LoadError,4286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['Load'],['LoadError']
Performance,"rent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1108,perform,performing,1108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['perform'],['performing']
Performance,"rrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1559,load,loading,1559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['load'],['loading']
Performance,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:2476,perform,performance,2476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['perform'],['performance']
Performance,se-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/sh,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5728,cache,cache,5728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"se.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{FFTW.r2rFFTWPlan{ComplexF64, Vector{Int32}, true, 3, Vector{Int64}}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Int64, Bounded, Float64, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Int64; callbacks::Vector{Any}, euler::Bool); @ Oceananigans.TimeSteppers ~/Documents/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:91; </details>. In this example, you could achieve it by just using a normal array forcing, but there are more complicated cases where I would find this useful. I would like to do this for boundary conditions too but removing the `Forcing` from here:https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L52. and changing ; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/BoundaryConditions/boundary_condition.jl#L20. to dispatch on numbers or arrays does not work and loads of the tests fail.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3237:53085,load,loads,53085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237,1,['load'],['loads']
Performance,"sing Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:1100,optimiz,optimize,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['optimiz'],['optimize']
Performance,so (unknown line); MPI_Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/api/generated_api.jl:2151 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:66; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; send_south_halo at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:2589,cache,cache,2589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"t /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _requir",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1923,Load,LoadError,1923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['Load'],['LoadError']
Performance,t /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4935,load,loading,4935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['load'],['loading']
Performance,t /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5502,cache,cache,5502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,t /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/par,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:3254,cache,cache,3254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:119003,Perform,Performance,119003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/272:1476,Load,LoadError,1476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272,2,"['Load', 'load']","['LoadError', 'loading']"
Performance,t_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4315,cache,cache,4315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:10302,Load,LoadError,10302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['Load'],['LoadError']
Performance,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7544,perform,performance,7544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performance']
Performance,th/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4665,load,loading,4665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['load'],['loading']
Performance,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:1442,perform,performing,1442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,3,['perform'],"['performance', 'performing']"
Performance,"these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:1081,optimiz,optimizer,1081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:154,Load,LoadError,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,2,"['Load', 'load']","['LoadError', 'load']"
Performance,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:2189,load,loaded,2189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['load'],['loaded']
Performance,"thub.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:3312,Load,LoadError,3312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['Load'],['LoadError']
Performance,"tion, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1409,load,loading,1409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['load'],['loading']
Performance,tions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2971,cache,cache,2971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is important:. From https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; ![image](https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:1982,perform,performance,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,1,['perform'],['performance']
Performance,tributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3742,cache,cache,3742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"try to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:1362,Perform,Performance,1362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['Perform'],['Performance']
Performance,"ub.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/gengrid_fn.m?revision=1.1.1.1&view=markup. He also ment",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1586:1065,load,load,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586,1,['load'],['load']
Performance,"ulia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in express",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4674,load,loading,4674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"uple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:31803,Load,LoadError,31803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Load'],['LoadError']
Performance,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:2080,perform,performant,2080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['perform'],['performant']
Performance,"utedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}, precision::Type, N::Tuple{Int64, Int64, Int64}, latitude::Tuple{Int64, Int64}, z_faces::Vector{Float64}, resolution::Int64, ::Val{false}, ::Val{:DoubleDrake}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/grid_load_balance.jl:16; [9] scaling_test_simulation(resolution::Int64, ranks::Tuple{Int64, Int64, Int64}, Δt::Tuple{Int64, Float64}, stop_time::Float64; child_arch::Oceananigans.Architectures.GPU, experiment::Symbol, Depth::Int64, latitude::Tuple{Int64, Int64}, restart::String, z_faces_function::typeof(OceanScalingTests.exponential_z_faces), Nz::Int64, profile::Bool, with_fluxes::Bool, with_restoring::Bool, loadbalance::Bool, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{Strin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:5475,load,loadbalance,5475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['load'],['loadbalance']
Performance,"utputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:1532,cache,cache,1532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['cache'],['cache']
Performance,"writer should be separated from output writer ""initialization"". Currently both JLD2 and NetCDF output writers open their files and save a bunch of data when they are constructed. For example, . https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/netcdf_output_writer.jl#L300-L328. and. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L170-L181. This initialization can make ""pickup"" of a simulation annoying. For example, the JLD2 writer will _remove_ an existing file if `force=true`:. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L172. This is desirable when experimenting with a script and setting up (and thus we usually set `force=true` in examples as a matter of user-friendliness). But if you're picking up a simulation you certainly don't want to set `force=true`, since this will overwrite existing data. Another example is the warning implemented in #1162 , which I suppose one must resign themselves to always receiving if they are picking up a simulation?. Debacles such as these might be avoided if we performed initialization in `run!` rather than when the output writers are created --- because then we can implement special behavior in the case that we are picking up a simulation. More or less I think the point here is that we don't _know_ if we want to create / destroy a file until `run!` is called with appropriate arguments. If `run!` is never called, there will not be output (so maybe we don't want to create a file). If `run!` is called and we are not picking up and `force` or `overwrite_existing=true` then we should do that. But if `run!` is called and `pickup=true` we can likely assume that existing files should not be deleted. Output writing only occurs in `run!`, so it might make sense to let `run!` also manage the creation / deletion of output files.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1163:1295,perform,performed,1295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1163,1,['perform'],['performed']
Performance,"yCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, tracers::Nothing, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.NonhydrostaticModels C:\Users\parfe\.julia\packages\Oceananigans\B958I\src\Models\NonhydrostaticModels\nonhydrostatic_model.jl:204; [28] top-level scope; @ In[23]:1; [29] eval; @ .\boot.jl:373 [inlined]; [30] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1196; ```; What is wrong here?</div>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:55878,load,loading,55878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['load'],['loading']
Performance,"yStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:28412,load,loadsave,28412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['load'],['loadsave']
Performance,y_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_gen,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4043,cache,cache,4043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"ymbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4833,optimiz,optimize,4833,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['optimiz'],['optimize']
Performance,"}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3491,Load,LoadError,3491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['Load'],['LoadError']
Performance,"}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:80391,load,loadsave,80391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['load'],['loadsave']
Performance,"~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:3981,load,loading,3981,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"│ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes │ 13 │; │ GPU │ 256 │ (1, 2, 3) │ 2.982 ms │ 3.041 ms │ 3.036 ms │ 3.116 ms │ 224 bytes │ 13 │; │ GPU │ 16 │ 1 │ 14.755 μs │ 30.020 μs │ 107.932 μs │ 677.045 μs │ 96 bytes │ 5 │; │ GPU │ 64 │ 1 │ 26.521 μs │ 41.294 μs │ 114.587 μs │ 674.834 μs │ 96 bytes │ 5 │; │ GPU │ 256 │ 1 │ 9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4585,perform,performance,4585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['perform'],['performance']
Performance,"│ 7.35221 │; │ (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │; │ (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │; │ (2, 5) │ 133.803 │ 1.5155 │ 4.87734 │; │ (2, 10) │ 137.615 │ 1.44535 │ 4.0466 │; └─────────┴─────────┴─────────┴─────────┘. Arbitrary tracers relative performance (CPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ CPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ (0, 1) │ 1.09293 │ 1.39873 │ 1.17271 │; │ CPU │ (0, 2) │ 1.15948 │ 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: li",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:10893,perform,performance,10893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['perform'],['performance']
Safety," implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:1009,Abort,Aborting,1009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['Abort'],['Aborting']
Safety," into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:1609,avoid,avoid,1609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['avoid'],['avoid']
Safety," Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 51.564 s; [ Info: i: 1900, t: 4.180 hr, Δt: 8.548 s, umax = (8.7e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 53.794 s; [ Info: Simulation is stopping. Model time 4.180 hr has hit or exceeded simulation stop time 4.000 hr.; WARNING: using Plots.grid in module Main conflicts with an existing identifier.; [ Info: Making an animation from the saved data...; [ Info: Drawing frame 1 from iteration 0 ; Illegal inttoptr; %33 = ptrtoint double addrspace(13)* %32 to i64; Illegal inttoptr; %52 = inttoptr i64 %51 to i8 addrspace(13)*. signal (6): Aborted; in expression starting at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:271; gsignal at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); abort at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x7f83cc060d04); _ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm13FPPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1616; unknown function (ip: 0x7f838be529a8); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:674; _show at /home/raphael",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:2728,abort,abort,2728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['abort'],['abort']
Safety,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:5948,Safe,SafeTestsets,5948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['Safe'],['SafeTestsets']
Safety,"#2740 Introduced memory allocation in output construction of `ComputedFields` because the field was recomputed with the new indices to satisfy sliced boundary conditions constraints. This PR changes the contents of `view(f::Field, indices...)` in order to automatically satisfy sliced boundary condition constraints and avoid unnecessary memory allocation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2796:320,avoid,avoid,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2796,1,['avoid'],['avoid']
Safety,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:202,redund,redundancies,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,3,['redund'],['redundancies']
Safety,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:1875,sanity check,sanity check,1875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,1,['sanity check'],['sanity check']
Safety,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606:2721,avoid,avoid,2721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606,1,['avoid'],['avoid']
Safety,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:93768,avoid,avoid,93768,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['avoid'],['avoid']
Safety,0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.1; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:5442,Safe,SafeTestsets,5442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Safe'],['SafeTestsets']
Safety,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:19167,abort,aborted,19167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['abort'],['aborted']
Safety,"7 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Closures │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────────┼───────────┼───────────┼──────────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:11691,avoid,avoided,11691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['avoid'],['avoided']
Safety,"> Thought: we provide the sugary syntax `.top` and `.bottom` for boundary conditions in `z`. Should we also provide east, west, south, and north, and avoid using `.left` and `.right` in the code for full clarity?; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/631#pullrequestreview-362963583_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/637:150,avoid,avoid,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/637,1,['avoid'],['avoid']
Safety,"> grid_base = RectilinearGrid(size=(4, 4, 4),; x = (0, 1), y=(0, 1),; z = (0, 1),; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549:1154,risk,risk,1154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549,1,['risk'],['risk']
Safety,">The core of the method is an eigenfunction expansion of the discrete Poisson operator... I think?; >; >Perhaps we can call this a `EigenPoissonSolver`, or even `FFTPoissonSolver` --- through we should use caution to avoid misleading people into thinking that our code is spectral. This algorithm solves the Poisson equation when it has been *discretized on a staggered grid*. We should not discuss spectral methods or Fourier transforms, and the word 'spectral' should not appear anywhere in the code. I think this is very misleading. It should be a high priority to change this language.; >; >_Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/102#issuecomment-468947308_. I think `EigenPoissonSolver` is a better name. Just creating a separate issue as this should be a pretty easy item to resolve, and is separate from updating the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/106:217,avoid,avoid,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/106,1,['avoid'],['avoid']
Safety,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1232:246,predict,predictor,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232,7,['predict'],['predictor']
Safety,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522:974,avoid,avoided,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522,1,['avoid'],['avoided']
Safety,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1105:298,avoid,avoids,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105,1,['avoid'],['avoids']
Safety,A NaN checker diagnostic that aborts the simulation when NaN values are detected. We could have some shell script that look for this and sends an email or something. Julia could do this too but then we'd add a big dependency for a small diagnostic. Resolves #38,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/170:30,abort,aborts,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/170,2,"['abort', 'detect']","['aborts', 'detected']"
Safety,Aborted (core dumped) on tutorial,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:0,Abort,Aborted,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,1,['Abort'],['Aborted']
Safety,Aborting a simulation with NaNs without stacktraces,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1734:0,Abort,Aborting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1734,1,['Abort'],['Aborting']
Safety,"After discussion in #3177 I noticed that the warning only warns for Julia v1.7 and earlier... But it should warn for Julia v1.8 as well. (Although, if we decide to add a compat entry for Julia v1.9 as a response to #3184 then the warning is rendered redundant.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182:250,redund,redundant,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182,1,['redund'],['redundant']
Safety,AllSchedule for combining scheduling criteria and avoiding checkpointing with NaNs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:50,avoid,avoiding,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,1,['avoid'],['avoiding']
Safety,Also:; * Print available `CuDevice`s at startup; * Throw `ArgumentError` when attempting to construct a `Model{GPU}` when no CUDA-enabled GPU is detected. Resolves #82,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/148:145,detect,detected,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148,1,['detect'],['detected']
Safety,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157:494,predict,predictions,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157,1,['predict'],['predictions']
Safety,"At the moment, the construction of a matrix from a linear operation for the multigrid solver on the GPU involves scalar operations:. https://github.com/CliMA/Oceananigans.jl/blob/60470f4d716026f161dfd303a30d9d14fbfb97a1/src/Solvers/multigrid_solver.jl#L246-L279. This matrix construction is **only** called once upon initialization of the solver. Furthermore, this particular method that uses scalar operations is **not** used by the implicit free-surface solvers since in that case we provide the `MultigridSolver` constructor with the matrix itself, see:. https://github.com/CliMA/Oceananigans.jl/blob/60470f4d716026f161dfd303a30d9d14fbfb97a1/src/Models/HydrostaticFreeSurfaceModels/mg_implicit_free_surface_solver.jl#L77-L104. For general matrix construction that works for any linear operation, it would be nice to avoid using scalar operations on the GPU _or_ construct the matrix on the CPU and convert it to the GPU afterwards. cc @elise-palethorpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737:819,avoid,avoid,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737,1,['avoid'],['avoid']
Safety,Avoid computing hydrostatic pressure when z is Flat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2093:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093,1,['Avoid'],['Avoid']
Safety,Avoid data dep race condition in CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['Avoid'],['Avoid']
Safety,Avoid executing the lines to install dependencies within examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1316:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316,1,['Avoid'],['Avoid']
Safety,Avoid need for `data` in user-interaction with fields through dispatch on `Colon` indices,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/458:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/458,1,['Avoid'],['Avoid']
Safety,Avoid redefining `R_Earth` in the `Coriolis` module,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3046:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3046,1,['Avoid'],['Avoid']
Safety,Avoid type instability in HydrostaticSphericalCoriolis,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2926:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2926,1,['Avoid'],['Avoid']
Safety,Avoid updating hydrostatic pressure for Flat z dimensions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2092:0,Avoid,Avoid,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2092,1,['Avoid'],['Avoid']
Safety,Avoiding repeated computations in the evaluation of `AbstractOperations`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955:0,Avoid,Avoiding,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955,1,['Avoid'],['Avoiding']
Safety,Avoiding unnecessary recomputation of fields in output evaluation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:0,Avoid,Avoiding,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,1,['Avoid'],['Avoiding']
Safety,"Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; [000.00%] Time: 0.0 / 604800.0... average wall clock time per iteration: 283.890 ms; [000.05%] Time: 300.0 / 604800.0... average wall clock time per iteration: 39.199 ms; [000.10%] Time: 600.0 / 604800.0... average wall clock time per iteration: 39.270 ms; [000.15%] Time: 900.0 / 604800.0... average wall clock time per iteration: 39.172 ms; [000.20%] Time: 1200.0 / 604800.0... average wall clock time per iteration: 39.167 ms; [000.25%] Time: 1500.0 / 604800.0... average wall clock time per iteration: 39.245 ms; [000.30%] Time: 1800.0 / 604800.0... average wall clock time per iteration: 39.119 ms; [000.35%] Time: 2100.0 / 604800.0... average wall clock time per iteration: 39.181 ms; [000.40%] Time: 2400.0 / 604800.0... average wall clock time per iteration: 39.246 ms; [000.45%] Time: 2700.0 / 604800.0... average wall clock time per iteration: 45.696 ms; [000.50%] Time: 3000.0 / 604800.0... average wall clock time per iteration: 40.170 ms; [000.55%] Time: 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/273:1392,detect,detected,1392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/273,1,['detect'],['detected']
Safety,Change `TimeInterval` to avoid roundoff error issue plus some cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3616:25,avoid,avoid,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616,1,['avoid'],['avoid']
Safety,Clean up redundant errors in `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3869:9,redund,redundant,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3869,1,['redund'],['redundant']
Safety,"Closes #1995 and closes #1996. (I'm not sure when the bug was introduced, so I capped the version up to 3.3.6. Feel free to change if there's a newer version that's also safe.). Also we need to remember to remove this after the bug gets put into a tagged release. (Can we exclude only version 3.4.2 using compat?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997:170,safe,safe,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997,1,['safe'],['safe']
Safety,"CompatHelper: add new compat entry for ""SafeTestsets"" at version ""0.0.1""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:40,Safe,SafeTestsets,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,1,['Safe'],['SafeTestsets']
Safety,Construct grid parameters with `BigFloat` to avoid round-off error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499:45,avoid,avoid,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499,1,['avoid'],['avoid']
Safety,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063:864,redund,redundantly,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063,1,['redund'],['redundantly']
Safety,"Currently the `JLD2OutputWriter` labels output in a timeseries by `model.clock.iteration`. It might be easier to handle output if data is labeled by ""save point"", so it goes 0, 1, 2... This is easier to work with at the REPL, since you always know, for example, that `file[""timeseries/u/1""]` exists (rather than having to manually inspect the file to figure out the iterations that data ended up being saved at). We can add a field `iteration` so that the model iteration can be recovered, if that's needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963:479,recover,recovered,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963,1,['recover'],['recovered']
Safety,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1140:187,redund,redundancy,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140,1,['redund'],['redundancy']
Safety,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:281,avoid,avoids,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,2,['avoid'],"['avoid', 'avoids']"
Safety,Defines many identity's to avoid recursion when compiling AbstractOperations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595:27,avoid,avoid,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595,1,['avoid'],['avoid']
Safety,Do not install/load CUDA packages if no GPU is detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:47,detect,detected,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['detect'],['detected']
Safety,Drop SafeTestset from package dependency,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2601:5,Safe,SafeTestset,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2601,1,['Safe'],['SafeTestset']
Safety,ERROR: Unsatisfiable requirements detected for package CuArrays,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:34,detect,detected,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['detect'],['detected']
Safety,"ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_5Az___E9identity1S30_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLG",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4318,abort,aborted,4318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['abort'],['aborted']
Safety,"Eventually, we will need to represent the effects of surface waves in `Oceananigans.jl`. The best way to do that is to introduce a term that models the 'wave-averaged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:425,Avoid,Avoiding,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['Avoid'],['Avoiding']
Safety,"Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:2054,detect,detected,2054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['detect'],['detected']
Safety,"Following up on #1662, copied below. We should make it so that for `ShallowWaterModel`, if we set halo to (3,3), or whatever is appropriate, there is no warning. ```; [2021/05/18 12:18:29.494] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666:320,avoid,avoid,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666,1,['avoid'],['avoid']
Safety,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/404:33,avoid,avoid,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404,1,['avoid'],['avoid']
Safety,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598:546,abort,abort,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598,2,['abort'],['abort']
Safety,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:828,detect,detected,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['detect'],['detected']
Safety,"Hi,. I have been confused about what the `max_change` and `min_change` means.; I understand from the documentation that this is to avoid the time step to change too quickly, but how is it used?. Is it in time units? e.g., taking the default `max_change` of 1.1, that means that for dated simulation it will change the time step at max in 1.1 seconds? . Is it a multiplication? e.g., `new_time_step = 1.1*time_step` ?. I think we can try to be more clear about that in the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3244:131,avoid,avoid,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3244,1,['avoid'],['avoid']
Safety,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:208,avoid,avoid,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['avoid'],['avoid']
Safety,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:501,avoid,avoid,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,1,['avoid'],['avoid']
Safety,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:856,avoid,avoid,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['avoid'],['avoid']
Safety,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:1005,redund,redundant,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['redund'],['redundant']
Safety,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:1118,avoid,avoid,1118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,2,['avoid'],['avoid']
Safety,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/429:411,avoid,avoid,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429,1,['avoid'],['avoid']
Safety,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453:866,detect,detected,866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453,1,['detect'],['detected']
Safety,"I will look into this soon as I really want to avoid NaN's, as I'm getting today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307:47,avoid,avoid,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307,1,['avoid'],['avoid']
Safety,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:741,Abort,Aborted,741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,2,['Abort'],['Aborted']
Safety,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371:661,avoid,avoided,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371,1,['avoid'],['avoided']
Safety,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:226,abort,abort,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['abort'],['abort']
Safety,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799:147,avoid,avoid,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799,1,['avoid'],['avoid']
Safety,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:789,avoid,avoid,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['avoid'],['avoid']
Safety,Introduces range of acceptable CUDA packages to avoid bug in 3.4.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997:48,avoid,avoid,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997,1,['avoid'],['avoid']
Safety,Is `Architectures.next_stream()` redundant?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2748:33,redund,redundant,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2748,1,['redund'],['redundant']
Safety,Is `calc_∇²!` redundant in view of `compute_∇²!`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2638:14,redund,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638,1,['redund'],['redundant']
Safety,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595:8,redund,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595,1,['redund'],['redundant']
Safety,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958:749,avoid,avoid,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958,1,['avoid'],['avoid']
Safety,"It's annoying to constantly write things like `Face` and `Cell` in Oceananigans scripts. I wonder if we can develop some notation that allows this to be avoided in the vast majority of use cases. We can introduce notation `:u`, `:v`, `:w`, and `:c` to indicate the velocities and tracer locations. Thus we could write. ```julia; x = xnodes(:c, grid); ```. to get `x` at tracer points. Or to build a tracer field,. ```julia; c = Field(:c, GPU(), grid); ```. Note that we currently require. ```julia; c = Field(Cell, Cell, Cell, GPU(), grid); ```. (a side note is that the `grid` should probably come before the `arch`, but that's another issue.). An alternate design would use the function `location`. Right now this is defined. ```julia; location(::AbstractField{X, Y, Z}) where {X, Y, Z} = (X, Y, Z) # note no instantiation; ```. We could define a couple new methods that allow something like. ```julia; x = xnodes(location(:c), grid); ```. for example. I suppose this is the quickest route to the functionality I'm proposing, since we'd have to change almost no existing code. I also wonder if this would allow. ```julia; momentum_flux = @at(location(:w), w * c); ```. That doesn't seem very easy to read so maybe we can discuss how to specify the location of abstract operations transparently.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/766:153,avoid,avoided,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/766,1,['avoid'],['avoided']
Safety,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:119,redund,redundant,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,3,"['recover', 'redund']","['recovers', 'redundant']"
Safety,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545:352,avoid,avoid,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545,1,['avoid'],['avoid']
Safety,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534:1441,detect,detect,1441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534,1,['detect'],['detect']
Safety,PPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1616; unknown function (ip: 0x7f838be529a8); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:674; _show at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1957; show at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:215 [inlined]; png at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:7; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:20; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:18; macro expansion at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:172 [inlined]; macro expansion at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:322 [inlined]; top-level scope at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:183; unknown function (ip: 0x7f83cc10d030); unknown function (ip: 0x7f83cc0e8105); jl_load at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); include at ./Base.jl:377; exec_options at ./client.jl:288; _start at ./client.jl:484; jfptr__start_2075.clone_1 at /usr/lib/x86_64-linux-gnu/julia/sys.so (unknown line); unknown function (ip: 0x55bf459799d9); unknown function (ip: 0x55bf459795a6); __libc_start_main at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x55bf4597964d); Allocations: 259469010 (Pool: 259407383; Big: 61627); GC: 547; Aborted (core dumped); ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:4941,Abort,Aborted,4941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Abort'],['Aborted']
Safety,"PUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, Line",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:1183,avoid,avoid,1183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['avoid'],['avoid']
Safety,Poisson solver test: recovery of an analytic solution.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:21,recover,recovery,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recovery']
Safety,PoissonBCs for pressure solver are redundant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:35,redund,redundant,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,1,['redund'],['redundant']
Safety,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1835:670,detect,detection,670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835,1,['detect'],['detection']
Safety,"Prior to time-stepping we execute an ""initial"" call to `run_diagnostic` for every `simulation.diagnostics`:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/Simulations/run.jl#L80-L83. This is an edge case for calling `run_diagnostic` on the `WindowedTimeAverage` in which we are not currently collecting, but also do not wish to initialize data collection. In other words, `run_diagnostic` assumes that if it is called, the user wishes to start collecting data:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/OutputWriters/windowed_time_average.jl#L90-L92. but this assumption is not necessarily correct for the initial call to `run_diagnostic`. We thus need to check whether `run_diagnostic` has been called at the zeroth iteration --- and also whether or not we ""should"" be initializing data collection (this is true when `time_window == time_interval`, since we are then always collecting data for averaging) to avoid spurious data collection.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/962:1004,avoid,avoid,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/962,1,['avoid'],['avoid']
Safety,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:871,recover,recover,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['recover'],['recover']
Safety,Reductions and broadcasting over AbstractOperations require 4-5x invocations to avoid recompilation on GPU and CPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024:80,avoid,avoid,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024,1,['avoid'],['avoid']
Safety,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/852:96,avoid,avoid,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852,1,['avoid'],['avoid']
Safety,Remove redundant definition of `diffusive_flux_z` for divergence damping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2482:7,redund,redundant,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2482,1,['redund'],['redundant']
Safety,Removes redundant definition for `halo_size`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2130:8,redund,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130,1,['redund'],['redundant']
Safety,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:842,avoid,avoid,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,1,['avoid'],['avoid']
Safety,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107:796,detect,detected,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107,1,['detect'],['detected']
Safety,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/417:91,safe,safely,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417,1,['safe'],['safely']
Safety,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:3147,avoid,avoid,3147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['avoid'],['avoid']
Safety,Safely using @inbounds,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/164:0,Safe,Safely,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/164,1,['Safe'],['Safely']
Safety,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:26,detect,detecting,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['detect'],['detecting']
Safety,"Should probably add a note on citing Oceananigans.jl to the README and docs. A lot of other packages do this. Would also make the ""Development team"" section kinda redundant so we could remove it then.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1101:163,redund,redundant,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1101,1,['redund'],['redundant']
Safety,"Should this. https://github.com/CliMA/Oceananigans.jl/blob/e2841ca6dda4414fcd9177512faec557d6f12adc/src/Coriolis/hydrostatic_spherical_coriolis.jl#L60. be . ```Julia; 1 - f(i, j, k, grid, args...); ```; to avoid type instability?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2925:206,avoid,avoid,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2925,1,['avoid'],['avoid']
Safety,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:128,avoid,avoid,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['avoid'],['avoid']
Safety,"Some suggestions on regriding:. - Add brief docstrings with a quick example; - Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters.; - ~Export `regrid!`?~. cc: @glwagner, @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1991:168,avoid,avoid,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1991,1,['avoid'],['avoid']
Safety,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:217,avoid,avoid,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['avoid'],['avoid']
Safety,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406:446,redund,redundant,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406,1,['redund'],['redundant']
Safety,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:333,recover,recover,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,2,['recover'],['recover']
Safety,"Starting to get tests failing because of conflicting qualifiers, e.g. both `Base` and `CUDAdrv` define `@elapsed`. Would be good to revise our existing `using` and `import` statements so that we only bring in exactly what we need to avoid these kinds of issues. And I believe it's good practice anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/351:233,avoid,avoid,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/351,1,['avoid'],['avoid']
Safety,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:37,recover,recover,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recover']
Safety,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/169:988,avoid,avoid,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169,1,['avoid'],['avoid']
Safety,"The `NetCDFOutputWriter` requires the keyword argument `filename`:. https://github.com/CliMA/Oceananigans.jl/blob/ed73ad36c99b61f24c37c73e4a2d26a12c7601d9/src/OutputWriters/netcdf_output_writer.jl#L147-L163. while `JLD2OutputWriter` requires `prefix` (which is optional, even though the default `prefix=""""` would produce a file called `.jld2`:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/jld2_output_writer.jl#L56-L60. There are also some minor differences: `filename` is used for the NetCDF writer, while `filepath` is used for the JLD2 writer. We should probably even out these differences:. * I think `filename` is more descriptive than `prefix`; * I also think its redundant to require the user to specify the file suffix (`.jld2` or `.nc`) in addition to specifying `JLD2` or `NetCDF` in the output writer name. So we need to weigh the two above considerations in coming to a decision. ; * `filepath` may be a better name for the struct member if we are also going to allow the keyword argument `dir` (this is not part of `NetCDFOutputWriter` either). In general I think we should strive to make all the keywords as identical as possible so that users can switch between the writers by changing `NetCDF` to `JLD2` and vice versa.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884:731,redund,redundant,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884,1,['redund'],['redundant']
Safety,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:147,redund,redundant,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,2,['redund'],['redundant']
Safety,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250:498,avoid,avoids,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250,1,['avoid'],['avoids']
Safety,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:84,safe,safely,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,1,['safe'],['safely']
Safety,The cubed sphere grid from the MIT as read from DataDeps has the faces ordered:; 1. `+ x` direction; 2. `+ y` direction; 3. `+ z` direction (Arctic); 4. `- x` direction; 5. `- y` direction; 6. `- z` direction (Antarctica); ; So to avoid confusion for (users and developers!) I thought I make sure that the ConformalCubedSphere follows the same convention. This PR does that + it adds tests to check whether the ConformalCubedSphereGrid metrics from the grid read from file and the grid constructed in Oceananigans.jl are the same. After this is merged we'll move on to #2867 to constructing `ConformalCubedSphereGrid` using MultiRegion (an possibly nuke the `CubedSpheres` module completely). We will have a `ConformalCubedSphereGrid` (which is the same as the `cs32` grid read from file) to bench our MultiRegion implementation with!. (This PR also moves some of the spherical trigonometry utility function to `grid_utils.jl`.). Closes #1586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2871:231,avoid,avoid,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871,1,['avoid'],['avoid']
Safety,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:874,avoid,avoid,874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['avoid'],['avoid']
Safety,"The floating point type can and should be determined from `eltype(grid)`, since `grid` is a required argument for constructing `IncompressibleModel`. An independent `float_type` argument is not only redundant but creates the possibility that models can have inconsistent float types. Eliminating this argument and using `eltype(grid)` as the source of knowledge re: floating point types solves this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1786:199,redund,redundant,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1786,1,['redund'],['redundant']
Safety,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647:1479,redund,redundant,1479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647,1,['redund'],['redundant']
Safety,"There appears to be the possibility of a write/write race condition at the corners in this case. Discovered with @sandreza. No bug has yet been detected, however.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1938:144,detect,detected,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938,1,['detect'],['detected']
Safety,"There are always leftover typos :). @francispoulin, I tried to use your repo to compute the most unstable mode for k=1 and I couldn't do it...; Could you tell me what the actual growth rate for `k = 1` is? I remember 0.138? Am I right? We should report the theoretical growth rate for `k = 1` that fits this domain (and not the overall maximum growth rate) and then compare that with the best-fit prediction. What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1464:397,predict,prediction,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1464,1,['predict'],['prediction']
Safety,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:364,sanity check,sanity check,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['sanity check'],['sanity check']
Safety,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198:191,detect,detected,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198,1,['detect'],['detected']
Safety,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970:78,avoid,avoid,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970,1,['avoid'],['avoid']
Safety,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2110:197,avoid,avoids,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110,1,['avoid'],['avoids']
Safety,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:231,avoid,avoid,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,3,"['avoid', 'detect']","['avoid', 'avoiding', 'detected']"
Safety,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:473,abort,aborted,473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,1,['abort'],['aborted']
Safety,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2538:407,avoid,avoid,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538,1,['avoid'],['avoid']
Safety,"This PR changes the calculation of the diffusivities in the `SmagorinskyLilly` so that binary operations are avoided. At the moment it does so by creating a `calc_nonlinear_κᶜᶜᶜ()` kernel, similar to what is done for the AMD closure. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904:109,avoid,avoided,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904,1,['avoid'],['avoided']
Safety,This PR directly indexes the underlying Array or CuArray to avoid the issue that broadcasting over an `OffsetArray{CuArray}` is extremely inefficient. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/268:60,avoid,avoid,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/268,1,['avoid'],['avoid']
Safety,"This PR does two things:. - Changes `docs/make.jl` to only define the example names once. They were being defined twice before, with some redundancy. Now it'll be easier to comment a given example out when building the docs locally, for example.; - Speeds up the tilted BBL example. I'm doing that by starting it with some noise, which makes turbulence appear much sooner, which allows us to run it for only one day (half the previous time).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3115:138,redund,redundancy,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3115,1,['redund'],['redundancy']
Safety,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:152,avoid,avoided,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,3,"['Avoid', 'avoid']","['Avoiding', 'avoided']"
Safety,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/538:159,avoid,avoid,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538,1,['avoid'],['avoid']
Safety,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508:337,avoid,avoid,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508,1,['avoid'],['avoid']
Safety,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931:900,avoid,avoid,900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931,1,['avoid'],['avoid']
Safety,"This PR implements a fully explicit free surface quasi-second-order Adams-Bashforth time stepping algorithm for `HydrostaticFreeSurfaceModel`. It also adds `examples/geostrophic_adjustment.jl`, which produces this movie:. ![geostrophic_adjustment](https://user-images.githubusercontent.com/15271942/107706468-5c9ed100-6c8e-11eb-9329-2f439ab52858.gif). To support the example, we also now export `HydrostaticFreeSurfaceModel` (and emit a warning when its instantiated to remind users that it's experimental). Happy to take criticism on the geostrophic adjustment example. It's fairly barebones right now and more serves as a sanity check for `HydrostaticFreeSurfaceModel` physics than anything else. It'd be nice to get a little more pedagogical mileage out of it, I think, if we can. This PR also adds placeholder functions for `free_surface::ImplicitFreeSurface` and `free_surface::Nothing` (rigid lid). (Note to myself/future developers: we'll need add a the `barotropic_pressure_solver` property to use for the rigid lid case.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352:624,sanity check,sanity check,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352,1,['sanity check'],['sanity check']
Safety,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:54,avoid,avoids,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,4,"['avoid', 'redund']","['avoid', 'avoided', 'avoids', 'redundant']"
Safety,"This PR implements automatically-generated function signatures with DocStringExtensions. I think this will avoid human errors when creating docstrings and also making documenting stuff easier, which hopefully will ultimately help users and novice developers. Starting this as a draft since I wanna see what effects this will have on the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2879:107,avoid,avoid,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879,1,['avoid'],['avoid']
Safety,"This PR instead of executing, e.g.,; ```; using Pkg; pkg""add Oceananigans, JLD2, Plots""; ```; it just prints them out as markdown ""code"". This way users can have them in the docs to copy-paste but the Documentation build does not execute them and thus avoids random clutter in Docs like discussed in #1315. Closes #1315.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1316:252,avoid,avoids,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316,1,['avoid'],['avoids']
Safety,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:309,avoid,avoids,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['avoid'],['avoids']
Safety,"This PR introduces an `AveragedField` type. The intent is that this field will eventually replace `Average`. Before that occurs, we need to overhaul both output writers, but especially the NetCDFOutputWriter, so that they can properly slice all types of fields. An `AveragedField` is constructed with the syntax (for example). ```julia; avg = AveragedField(operand; dims=(1, 2)); ```. where `operand` is the object being averaged (which should also be a field), and `dims` are the dimensions over which the field is reduced. There is an optional argument `data` which would be an `OffsetArray` of the correct size which avoids extra memory allocation. We also overload `Statistics.mean`, so that the above code can be written. ```julia; avg = mean(operand; dims=(1, 2)); ```. When we have `ComputedField`s, `operand` can involve `AbstractOperations`. This will come in a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930:620,avoid,avoids,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930,1,['avoid'],['avoids']
Safety,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:215,avoid,avoid,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,1,['avoid'],['avoid']
Safety,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214:1206,redund,redundant,1206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214,1,['redund'],['redundant']
Safety,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/677:501,predict,predictor,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677,1,['predict'],['predictor']
Safety,This PR nukes the `BasicModel` legacy constructor to avoid potential confusion. I also made the `NonDimensionalModel` constructor act more like the `Model` constructor. Also fixed a typo there and added a test. Resolves #429,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496:53,avoid,avoid,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496,1,['avoid'],['avoid']
Safety,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:1051,avoid,avoids,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['avoid'],['avoids']
Safety,"This PR refactors the names we export publically. I think that many names have been added that are poorly motivated --- for example, MultiRegionGrid and cubed sphere grid are _very_ experimental yet still exported. This PR mostly removes exports. Most of the removals are motivated by one of two reasons: (i) the feature is experimental or (ii) the feature is not commonly used. For (i) we would like to avoid export because as an experimental feature we would like to fix bugs or change the API without incurring an ""officially breaking change"". For (ii), the purpose is merely to avoid over-polluting the namespace. For example, `XPartition` for `MultiRegionGrid` is very easily confused with `Partition` for `DistributedComputations` (the API here should probably be reconsidered, cc @simone-silvestri). More than once I have lost cluster time because I confused `YPartition(N)` with `Partition(y=N)`. But `YPartition` isn't really useful so there's little benefit to exporting this. Of course these changes are up for debate so I welcome comments. More detail:. * Remove `OceananigansLogger`: rarely used; * Add `PartialCellBottom`: we are using it in an example, indicating that it is ready for use (not necessarily completely bug-free but we would like to bring it into regular / default use now); * Remove `WENOThirdOrder`, `WENOFifthOrder`: the syntax `WENO(order=5)` is preferred (same for `Centered` and `UpwindBiased`); * Remove `location`: this is a low-level function that does not need to be part of the API; * Add `CATKEVerticalDiffusivity`: this is ready for use, a publication is imminent.; * Remove `StateChecker`: not used as far as I know.; * Remove multi-region and cubed sphere functionality: these are experimental.; * Remove `apply_regionally!, construct_regionally, @apply_regionally, MultiRegionObject`: experimental.; * Remove `Time`: too low-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:404,avoid,avoid,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,2,['avoid'],['avoid']
Safety,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:58,predict,predictor,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['predict'],['predictor']
Safety,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:195,predict,predictor,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,1,['predict'],['predictor']
Safety,This PR removes the calculation of the diffusivities in `DiffusivityFields()` for the SmagorinskyLilly so that binary operations are avoided. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2908:133,avoid,avoided,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2908,1,['avoid'],['avoided']
Safety,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:909,recover,recovered,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['recover'],['recovered']
Safety,"This PR updates the examples to account for the fact that `field.data` returns the full offset array including all halos so you need to use `data(field)` which returns a view into the interior of the field with no halos. cc @navidcy internal wave example works for me now. Can you try on this branch?. In hindsight, maybe a more sophisticated fields API would avoid issues like this where we're so reliant on the `data(::Field)` function. Maybe things should ""just work"" for the user. Resolves #254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/257:360,avoid,avoid,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/257,1,['avoid'],['avoid']
Safety,This PR updates the instructions for building docs locally. We should avoid `Pkg.develop()` since we are offering a `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707:70,avoid,avoid,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707,1,['avoid'],['avoid']
Safety,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752:388,avoid,avoids,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752,1,['avoid'],['avoids']
Safety,"This changes the threading structure in a kernel launch to only launch over the i,j indices to avoid race conditions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1944:95,avoid,avoid,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1944,1,['avoid'],['avoid']
Safety,"This has a few benefits:. 1. Users know when `set!` has been invoked, and how long it takes to run (if we emit timing data as well); 2. Incorrect initial conditions may be detected. In a way this would look like just a single output of @christophernhill 's ""state checker"" idea, so we might be able to combine code for those utilities (which could also pave the way for default logging in `run!`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2462:172,detect,detected,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2462,1,['detect'],['detected']
Safety,"This introduces `UpwindBiasedFirstOrder` advection, and is in part inspired by #1955. This scheme is first order accurate but has the advantage of preserving positivity and extrema. The plot for convergence is updated and we see that it does have the slope that is predicted from the theory. ![convergence_rates](https://user-images.githubusercontent.com/8239041/130524906-d3afbae0-651d-4c9a-aee8-b0fb4d9dc856.png). I set the `symmetric_interpolate`'s to zero, which I think is true, but not sure if anything else should be done here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957:265,predict,predicted,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957,1,['predict'],['predicted']
Safety,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3535:48,safe,safety,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535,1,['safe'],['safety']
Safety,This is a workaround to avoid printing `solver: Default` and instead print `solver: FFTImplicitFreeSurfaceSolver`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2212:24,avoid,avoid,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2212,1,['avoid'],['avoid']
Safety,"This likely removes some of the single device parallelism,; but decreases the risk for user mistake (everything is stream-ordered). This will cause severe merge conflicts with open PRs and depends on currently unreleased; versions of CUDA & KernelAbstractions. So I might regret doing it now, but I was curious; to see what the damage would be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924:78,risk,risk,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924,1,['risk'],['risk']
Safety,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:949,avoid,avoided,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,2,['avoid'],"['avoided', 'avoiding']"
Safety,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:49,Safe,SafeTestsets,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,2,['Safe'],['SafeTestsets']
Safety,"This redundancy creates the risk that they can be inconsistent, plus confusion about whether `previous_Δt` and `last_Δt` represent the same thing (they do). https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/clock.jl#L17. https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/quasi_adams_bashforth_2.jl#L8. We need to eliminate `previous_Δt` from `QuasiAdamsBashforth2TimeStepper`. cc @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3564:5,redund,redundancy,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3564,2,"['redund', 'risk']","['redundancy', 'risk']"
Safety,This seems a brittle:. https://github.com/CliMA/Oceananigans.jl/blob/9ffbee31bc5a2fa38dd93fa1594b94cddaebba8c/test/utils_for_runtests.jl#L34. some bug that caused MPI not to be initialized would cause the tests to be worthless but it might not be detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3879:247,detect,detected,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3879,1,['detect'],['detected']
Safety,Time step with predictor velocities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:15,predict,predictor,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['predict'],['predictor']
Safety,"To better understand [Wenegrat and Thomas, JPO 2020](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml?tab_body=pdf) (WT2020) I modifed the following examples:. 1. [Internal tide by a seamount](https://clima.github.io/OceananigansDocumentation/stable/generated/internal_tide/) and . 2. [Tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:721,avoid,avoid,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['avoid'],['avoid']
Safety,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3473:1029,avoid,avoid,1029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473,1,['avoid'],['avoid']
Safety,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:518,predict,predictor,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,3,"['avoid', 'predict']","['avoided', 'predictor']"
Safety,"We might be able to avoid the need for users to call the function `data` by dispatching on `Colon`:. ```julia; xindex(f, i) = i; xindex(f, ::Colon) = 1:f.grid.Nx. yindex(f, i) = i; yindex(f, ::Colon) = 1:f.grid.Ny. zindex(f, i) = i; zindex(f, ::Colon) = 1:f.grid.Nz. @inline getindex(f::Field, i, j, k) = getindex(f.data, xindex(f, i), yindex(f, j), zindex(f, k)); ```. Then things like. ```julia; imshow(model.velocities.u[:, 1, :]); ```. Will plot only the interior points of `u`, avoiding the need to write `imshow(data(model.velocities.u)[:, 1, :])`. Perhaps this is desirable? Or too surprising that indexing into a field is different from indexing into its `data`? I'm not sure how much we want users to be explicitly aware / interactive with halo regions. Note that in the future, we may also want to borrow the `Colon` type to mean ""all interior points"" for specifying things like slices --- or, come up with a different meaningful shorthand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/458:20,avoid,avoid,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/458,2,['avoid'],"['avoid', 'avoiding']"
Safety,We must play this annoying game of organizing the definitions to avoid mutually circular type declarations. See: https://github.com/JuliaLang/julia/issues/269,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/69:65,avoid,avoid,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/69,1,['avoid'],['avoid']
Safety,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955:801,avoid,avoid,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955,1,['avoid'],['avoid']
Safety,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:430,avoid,avoid,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,1,['avoid'],['avoid']
Safety,We'll uncomment these lines once `WENO{N}` schemes are ready to be used. And hopefully we can figure out a way to avoid frustrating users with PyCall/Conda stuff just to use Oceananigans. Resolves #990,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/996:114,avoid,avoid,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/996,1,['avoid'],['avoid']
Safety,"When using a tuple of closures, evaluation of the diffusive flux divergence for an arbitrary number of closures requires recursing into the diffusive flux operator. Currently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(ar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2101:847,abort,aborts,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101,2,"['abort', 'avoid']","['aborts', 'avoid']"
Safety,Would be good to have a feature that splits JLD2 files by size (e.g. maximum file size of 50 GiB or 100 outputs per file). Running large simulations right now is risky because the JLD2 files keeps getting appended to so it keeps growing in size (especially since JLD2 does not compress by default) and if the simulation stops/errors/is killed during IO the JLD2 file and all output is corrupted. We should probably also add an `info=false` flag to `JLD2OutputWriter` that is `false` by default in case a user does not want any JLD2 timings/statistics.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/344:162,risk,risky,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/344,1,['risk'],['risky']
Safety,"Would be nice to be able to specify a minimum time step for the `TimeStepWizard`. For me the main use is to avoid ""slow motion blowup"" where a numerical instability causes the model to blow up but the time step wizard keeps decreasing the time step so it just blows up in slow motion when you want it to NaN and stop executing.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1197:108,avoid,avoid,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1197,1,['avoid'],['avoid']
Safety,You can never avoid all typos..,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1357:14,avoid,avoid,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1357,1,['avoid'],['avoid']
Safety,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16751,abort,aborted,16751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['abort'],['aborted']
Safety,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9558,abort,aborted,9558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['abort'],['aborted']
Safety,`test/test_*.jl` is a redundant naming scheme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/871:22,redund,redundant,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871,1,['redund'],['redundant']
Safety,aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:6568,Unsafe,UnsafeAtomics,6568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Unsafe'],['UnsafeAtomics']
Safety,"again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3183,Risk,Risk,3183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['Risk'],['Risk']
Safety,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:1569,predict,predictor,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,2,['predict'],"['predictor', 'predictor-corrector']"
Safety,"ation . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:1649,redund,redundancies,1649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['redund'],['redundancies']
Safety,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:1907,avoid,avoid,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['avoid'],['avoid']
Safety,"e pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:2228,avoid,avoiding,2228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['avoid'],['avoiding']
Safety,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:1449,avoid,avoids,1449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,1,['avoid'],['avoids']
Safety,"eraged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:1130,avoid,avoid,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['avoid'],['avoid']
Safety,"es/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5542,avoid,avoid,5542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['avoid'],['avoid']
Safety,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:2678,avoid,avoids,2678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['avoid'],['avoids']
Safety,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:2806,risk,risk,2806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['risk'],['risk']
Safety,"https://github.com/CliMA/Oceananigans.jl/blob/2bb159c74774309ca1c80004e8cf5b5ae195d9f8/src/Grids/automatic_halo_sizing.jl#L40-L44. For example. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> grid = RegularRectilinearGrid(size = (10, 20), extent=(1, 2), topology=(Bounded, Bounded, Flat)); RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}; domain: x ∈ [-1.6190752442450216e-17, 0.9999999999999999], y ∈ [0.0, 2.0], z ∈ [0.0, 0.0]; topology: (Bounded, Bounded, Flat); resolution (Nx, Ny, Nz): (10, 20, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.1, 0.1, 0.0). julia> model = NonhydrostaticModel(grid=grid, advection = UpwindBiasedFifthOrder()); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/.julia/packages/Oceananigans/9o1xJ/src/Grids/automatic_halo_sizing.jl:41; NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}(Nx=10, Ny=20, Nz=1); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing; ```; while, because `topology=(Bounded, Bounded, Flat)` we need to pass `halo=(3, 3)` to grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1956:847,avoid,avoid,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1956,1,['avoid'],['avoid']
Safety,"https://github.com/CliMA/Oceananigans.jl/blob/e5a3d10df0d350af541613b5a47e963252f8f35d/src/Grids/regular_latitude_longitude_grid.jl#L33. What if we wanted to use `λ ∈ [-280, 80]`?. (Often people use this domain to avoid having the ""seam"" in the middle of the Pacific...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1815:214,avoid,avoid,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1815,1,['avoid'],['avoid']
Safety,"https://github.com/CliMA/Oceananigans.jl/pull/2740 Introduced extra memory allocation in output construction of ComputedFields to satisfy sliced boundary conditions constraints. This PR changes the definition of `view(f::Field, indices...)` in order to automatically satisfy sliced boundary condition constraints and avoid unnecessary memory allocation. closes #2794 ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2797:317,avoid,avoid,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2797,1,['avoid'],['avoid']
Safety,"in decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3158,risk,risks,3158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['risk'],['risks']
Safety,"iters`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpoi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:1685,avoid,avoid,1685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['avoid'],['avoid']
Safety,"ity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOpera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:2402,abort,aborted,2402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['abort'],['aborted']
Safety,"l(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not passing the `indices` flag (i.e. writing 3D fields instead slices) apparently gets rid of this issue. Here, even though the obvious easy solution is to separate averages from slices when writing, a user wouldn't know that since this fails silently and the wrong results can be pretty subtle (as the example above hopefully illustrates). For example, it popped up in one of my simulations and it took me a while to even realize what was happening, let alone figure out the solution. My main question is: is this expected behavior? If so, should we somehow warn users (or even throw an error) do avoid mistakes?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931:2900,avoid,avoid,2900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931,1,['avoid'],['avoid']
Safety,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:2222,avoid,avoids,2222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['avoid'],['avoids']
Safety,"ll time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 51.564 s; [ Info: i: 1900, t: 4.180 hr, Δt: 8.548 s, umax = (8.7e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 53.794 s; [ Info: Simulation is stopping. Model time 4.180 hr has hit or exceeded simulation stop time 4.000 hr.; WARNING: using Plots.grid in module Main conflicts with an existing identifier.; [ Info: Making an animation from the saved data...; [ Info: Drawing frame 1 from iteration 0 ; Illegal inttoptr; %33 = ptrtoint double addrspace(13)* %32 to i64; Illegal inttoptr; %52 = inttoptr i64 %51 to i8 addrspace(13)*. signal (6): Aborted; in expression starting at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:271; gsignal at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); abort at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x7f83cc060d04); _ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm13FPPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:2541,Abort,Aborted,2541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Abort'],['Aborted']
Safety,"o that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2432,avoid,avoid,2432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['avoid'],['avoid']
Safety,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1518,avoid,avoid,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['avoid'],['avoid']
Safety,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:2791,avoid,avoids,2791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['avoid'],['avoids']
Safety,"oint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; ```. One option to add safety is to modify `set!(model, filepath::AbstractString)` to take an option argument `skip_missing_variables = false` (or something), which would change the behavior from throwing a warning to throwing an error. @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:3759,safe,safety,3759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['safe'],['safety']
Safety,or partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/10.1007/s00703-019-00681-w); [On methods for solving the oceanic equations of motion in generalized vertical coordinates](https://www.sciencedirect.com/science/article/abs/pii/S1463500305000090); [Representation of topography by porous barriers and objective interpolation of topographic data](https://www.sciencedirect.com/science/article/pii/S1463500313000425); [Representation of Topography by Shaved Cells in a Height Coordinate,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:2613,Predict,Prediction,2613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['Predict'],['Prediction']
Safety,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2038,avoid,avoid,2038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['avoid'],['avoid']
Safety,pleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v3.100.1+0; [88015f11] LERC_jll v3.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:6601,Unsafe,UnsafeAtomicsLLVM,6601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,ptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:13690,Safe,SafeTestsets,13690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Safe'],['SafeTestsets']
Safety,"rcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). linear_u_eqn(i, j, k, grid, etc....) = (fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). v_eqn(...) = ... # in the model constructor:. if eqntype = :linear; velocities_equation = (u=linear_u_eqn, v=linear_v_eqn, w=linear_w_eqn); else; velocities_equation = (u=u_eqn, v=v_eqn, w=w_eqn); end. model.equation = (velocities=velocities_equation, tracers=...). # Inside calculate_interior_source_terms!. G.u[i, j, k] = eqn.velocities.u(i, j, k, grid, etc...). ntuple(Val(length(tracers))) do tr; Gtracer = getfield(G, keys(tracers)[tr]); tracer_equation = eqn.tracers[tr]; Gtracer[i, j, k] = tracer_equation(i, j, k, grid, etc...); end; ```. ## Equations as new types. Even more flexibility / clarity might be provided by a callable `Equation` type implementation with appropriate type parameters (`Linear`, `Hydrostatic`, etc) which would avoid the need for `if` statements as on the last line of the code above. I'm not sure exactly what that would look like. The design problem for a new `Equation` type does seem a bit more difficult and would require care --- thinking about how we would implement a nonlinear biological model might provide a nice use case to help use make our ideas concrete. Hopefully this provides food for thought and also motivates us to think carefully about our design decisions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:4067,avoid,avoid,4067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['avoid'],['avoid']
Safety,"rences in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which is quite nice, but you have to modify the original LaTeX and avoid using fancy packages. But it has `\bm` which is awesome!; 2. I'm depending on `Documenter#master` as the upcoming v0.24 has an awesome new layout and dark mode.; 3. Documentation building on Travis is failing so gotta figure this out as well. Resolves #102; Resolves #222; Resolves #240; Resolves #327; Resolves #332; Resolves #353; Resolves #354",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:3164,avoid,avoid,3164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['avoid'],['avoid']
Safety,"stead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:1412,predict,predictor-corrector,1412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,1,['predict'],['predictor-corrector']
Safety,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/272:1423,detect,detected,1423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272,1,['detect'],['detected']
Safety,"ta` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1271,avoid,avoided,1271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['avoid'],['avoided']
Safety,"then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:1435,safe,safe,1435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['safe'],['safe']
Safety,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:231,detect,detected,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,3,['detect'],"['detected', 'detecting']"
Safety,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4912,avoid,avoid,4912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['avoid'],['avoid']
Safety,"variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:1473,Safe,SafeTestsets,1473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Safe'],['SafeTestsets']
Safety,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1381,recover,recover,1381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['recover'],['recover']
Safety,"writer should be separated from output writer ""initialization"". Currently both JLD2 and NetCDF output writers open their files and save a bunch of data when they are constructed. For example, . https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/netcdf_output_writer.jl#L300-L328. and. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L170-L181. This initialization can make ""pickup"" of a simulation annoying. For example, the JLD2 writer will _remove_ an existing file if `force=true`:. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L172. This is desirable when experimenting with a script and setting up (and thus we usually set `force=true` in examples as a matter of user-friendliness). But if you're picking up a simulation you certainly don't want to set `force=true`, since this will overwrite existing data. Another example is the warning implemented in #1162 , which I suppose one must resign themselves to always receiving if they are picking up a simulation?. Debacles such as these might be avoided if we performed initialization in `run!` rather than when the output writers are created --- because then we can implement special behavior in the case that we are picking up a simulation. More or less I think the point here is that we don't _know_ if we want to create / destroy a file until `run!` is called with appropriate arguments. If `run!` is never called, there will not be output (so maybe we don't want to create a file). If `run!` is called and we are not picking up and `force` or `overwrite_existing=true` then we should do that. But if `run!` is called and `pickup=true` we can likely assume that existing files should not be deleted. Output writing only occurs in `run!`, so it might make sense to let `run!` also manage the creation / deletion of output files.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1163:1281,avoid,avoided,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1163,1,['avoid'],['avoided']
Security," 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: 6×7×2 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, 5:6) with eltype Float64 with indices -1:4×-1:5×5:6; └── max=0.0, min=0.0, mean=0.0. julia> set!(my_windowed_field, 1); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryCondition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:2244,access,accessing,2244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['accessing']
Security," FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater effici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1257,validat,validation,1257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['validat'],['validation']
Security," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2032,validat,validate,2032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['validat'],['validate']
Security," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}}, RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:6979,validat,validation,6979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['validat'],['validation']
Security," interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and `set!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:1739,access,accesses,1739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,1,['access'],['accesses']
Security," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4583,validat,validate,4583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validate']
Security," of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of a tilted geometry (take2). This case generates a boundary layer at the top as well, but it's less well resolved because I am using a stretched grid at the bottom. Not a problem, just an observation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:1567,validat,validation,1567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['validat'],['validation']
Security,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:390,inject,injection,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['inject'],['injection']
Security,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,4,['validat'],"['validate', 'validation']"
Security,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:1717,access,access,1717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['access'],['access']
Security,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:1910,access,accessing,1910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['accessing']
Security,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1309,access,access,1309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['access'],['access']
Security,"552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:9440,access,access,9440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,"> grid_base = RectilinearGrid(size=(4, 4, 4),; x = (0, 1), y=(0, 1),; z = (0, 1),; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549:1127,validat,validated,1127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549,1,['validat'],['validated']
Security,"@fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed. It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?. Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated. _Originally posted by @navidcy in https://github.com/CliMA/Oceananigans.jl/issues/3468#issuecomment-1936950079_. What do you mean by outdated or deprecated here? Can you help me understand how this relates to the CI?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3470:187,access,access,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470,1,['access'],['access']
Security,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:170,access,access,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,2,['access'],['access']
Security,"@johncmarshall54 suggested that a good validation test for an immersed boundary implementation is a topographic Rossby wave, a la:. https://journals.ametsoc.org/mwr/article/125/9/2293/104481/Representation-of-Topography-by-Shaved-Cells-in-a. which has an analytical solution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['validat'],['validation']
Security,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582:281,access,access,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582,1,['access'],['access']
Security,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:831,access,accessed,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,1,['access'],['accessed']
Security,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:152,validat,validates,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['validat'],['validates']
Security,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['validat'],['validation']
Security,About Stratified Couette Flow validation case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:30,validat,validation,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,1,['validat'],['validation']
Security,"Abstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9770,hash,hashing,9770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hashing']
Security,Accidental double hashed comments in two_dimensional_turbulence.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1167:18,hash,hashed,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1167,1,['hash'],['hashed']
Security,"Actually they're validation experiments, not verification experiments",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,1,['validat'],['validation']
Security,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:131,access,access,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,1,['access'],['access']
Security,Add a validation script and/or tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204:6,validat,validation,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204,1,['validat'],['validation']
Security,Add direct access to auxiliary fields for forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2733:11,access,access,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733,1,['access'],['access']
Security,Add validation for array-based coordinates,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:4,validat,validation,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,1,['validat'],['validation']
Security,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:858,validat,validation,858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,1,['validat'],['validation']
Security,Adds a tilted bottom boundary layer validation example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498,1,['validat'],['validation']
Security,Adds benchmark for free surface solvers on lat-lon immersed boundary + triply-bounded Poisson bench/validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2784:100,validat,validation,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2784,1,['validat'],['validation']
Security,Adds flow_over_hills validation case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402,1,['validat'],['validation']
Security,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:79,validat,validaton,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,2,"['access', 'validat']","['access', 'validaton']"
Security,"Apparently the figures in the [Convergence tests](; https://clima.github.io/OceananigansDocumentation/latest/validation/convergence_tests/) and Stratified Couette flow sections of the documentation aren't showing. I suspect it's a broken link or something (probably very easy to fix). Sorry if you guys are aware of this already, but I couldn't find any issue about it. Cheer!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1212:109,validat,validation,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212,1,['validat'],['validation']
Security,"As a convenience, we can provide constructors for different use cases. For example, we can have an `OceanModel`, which has `ConstantAnisotropicDiffusivity` as default and exposes the anisotropic coefficients directly to the user. This deals with @johncmarshall54's concern about the `ConstantIsotropicDiffusivity` default. This will also help us move some of the body of the `Model` constructor into re-useable functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/258:171,expose,exposes,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/258,1,['expose'],['exposes']
Security,"At high enough ~~vertical~~ vertical + horizontal resolution, it seems that the `zonally_averaged_baroclinic_adjustment.jl` validation test blows up with `IsopycnalSkewSymmetricDiffusivity`; specifically:. ```julia; gerdes_koberle_willebrand_tapering = FluxTapering(1e-2); gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = 1000,; κ_symmetric = 900,; slope_limiter = gerdes_koberle_willebrand_tapering); ```. For example, with 50m vertical resolution (Nz=20, Lz=1000m, 20km horizontal resolution) we find. https://user-images.githubusercontent.com/15271942/164360760-ef03fc9d-e07a-4b50-9e80-bd79997cfa1d.mp4. while at 25m resolution (same extent, horizontal resolution, time-step) we find. https://user-images.githubusercontent.com/15271942/164360772-e39a08e4-eb5e-48e4-bfc4-cde1e241ec0f.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2453:124,validat,validation,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2453,1,['validat'],['validation']
Security,"At least, this is not the current syntax for discrete diffusion function:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/validation/near_global_lat_lon/near_global_quarter_degree.jl#L131. There are also some formatting irregularities here:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/src/TurbulenceClosures/discrete_diffusion_function.jl#L57-L67",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690:162,validat,validation,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690,1,['validat'],['validation']
Security,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201:158,validat,validation,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201,1,['validat'],['validation']
Security,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1001:1745,validat,validation,1745,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001,1,['validat'],['validation']
Security,Barotropic turbulence validation tests on RegularLatitudeLongitudeGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['validat'],['validation']
Security,Better validation for `LatitudeLongitudeGrid` + add test for `sum(Azᶜᶜᵃ) ≈ 4πr²`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3240:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240,1,['validat'],['validation']
Security,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1310:319,validat,validate,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310,1,['validat'],['validate']
Security,Bugfixes for HydrostaticSphericalCoriolis and solid body rotation validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,1,['validat'],['validation']
Security,"CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS) when using Lagrangian particles under large CFL number",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:30,access,access,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['access'],['access']
Security,CUDA illegal memory access during `HydrostaticFreeSurfaceModel` construction with `Float32` and CATKE,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:20,access,access,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['access'],['access']
Security,CUDA illegal memory access when constructing a `Float32` `HydrostaticFreeSurfaceModel` + `CATKEVerticalDiffusivity` on the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:20,access,access,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['access'],['access']
Security,"Closes #3534. After this PR:. ```Julia; julia> using Oceananigans. julia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1))); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: Centered reconstruction order 2; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> model = ShallowWaterModel(grid = RectilinearGrid(size = (4, 4), extent = (1, 1), topology=(Periodic, Bounded, Flat)), gravitational_acceleration = 1); ┌ Warning: The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation.; └ @ Oceananigans.Models.ShallowWaterModels ~/Research/OC8.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) ; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── advection scheme: ; │ ├── momentum: Upwind Biased reconstruction order 5; │ └── mass: WENO reconstruction order 5; ├── tracers: (); └── coriolis: Nothing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3542:821,validat,validation,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3542,1,['validat'],['validation']
Security,Convergence test and validation experiment Buildkite pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['validat'],['validation']
Security,Correct accessing velocities from the background field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862:8,access,accessing,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862,1,['access'],['accessing']
Security,"CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45980,hash,hashing,45980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,Cubed sphere validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['validat'],['validation']
Security,"Currently a work in progress, but it has one validation experiment (Rossby-Haurwitz) and one ""for fun"" dynamics test (Bickley Jet)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570,1,['validat'],['validation']
Security,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,1,['validat'],['validation']
Security,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:267,access,access,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,1,['access'],['access']
Security,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/985:297,access,accessed,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985,2,['access'],['accessed']
Security,Curvilinear diffusion validation experiments,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1423:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423,1,['validat'],['validation']
Security,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:104,access,access,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,1,['access'],['access']
Security,"Dear Oceananigans team,. We are trying to use Oceananigans to create reference LES solutions for multiple canonical flows. We use a cubical domain and random perturbations to trigger the flow. During our validation tests, we noticed that we could not reproduce the results, i.e., running the same .jl script (same initial flow conditions) leads to different averaged solutions (see attached picture). We ran more than 16 simulations and never obtained the same solution. We tried to set the seed of the random perturbations constant, but this did not solve the problem. Do you observe this problem, and could you help us run reproducible simulations so other users can obtain the same solutions? We attached the .jl file we are using to define the simulations. Best regards,; Filipe Pereira; Luke van Roekel ; Amrapalli Garanaik; Brodie Pearson . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193599386-11eccb58-2a3f-4a1c-83d6-cde2ea429d00.png). [c16_128_128m(1).jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9698212/c16_128_128m.1.jl.zip)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766:204,validat,validation,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766,1,['validat'],['validation']
Security,Delete validation-pipeline.yml,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3176:7,validat,validation-pipeline,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3176,1,['validat'],['validation-pipeline']
Security,Delete validation/near_global_lat_lon directory,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3012:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3012,1,['validat'],['validation']
Security,Document and test numerical convergence validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,1,['validat'],['validation']
Security,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:107,validat,validation,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,1,['validat'],['validation']
Security,Error in `visualize_barotropic_gyre.jl` in validation exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:43,validat,validation,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['validat'],['validation']
Security,Fix bug for horizontal diffusivity with Flat horizontal dimension + updates baroclinic adjustment validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['validat'],['validation']
Security,Fix bug when throwing exception during grid validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,1,['validat'],['validation']
Security,Fix erroneous double hashes in two_dimensional_turbulence.jl example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1168:21,hash,hashes,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1168,1,['hash'],['hashes']
Security,Fix fatal interaction between FieldTimeSeries construction and input validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2589:69,validat,validation,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589,1,['validat'],['validation']
Security,Flux boundary conditions for HydrostaticFreeSurfaceModel and barotropic gyre validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1433:77,validat,validation,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433,1,['validat'],['validation']
Security,"For a thesis project about the migration and dispersal of fish larvae in the sea I am looking for CFD tools that allow a newcomer in this field (like myself) the simulation of agent based models (each agent represents a fish) in laminar flows and later in more realistic turbulences. I chose the following steps as milestones:. - First, as a means for validation, I will show a lid driven cavity flow (Oceananigans already does this in an example).; - After this I will combine this with an agent based model where an agent will represent a larvae. At that state the agent should follow simple rules, like drift in the direction of a laminar flow.; - If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef.; - Next, putting n agents into the water and see, if the individuals are behaving differently when put into a swarm. . I am planning to keep this in 2D since doing it in 3D would probably be to difficult given the limited time (3 months). I will not try to simulate the exact ocean currents or the bottom of the ocean. Are you capable of assessing the suitability of Oceananigans for those steps? Is it possible to deliver those steps? . For the Agent based modelling I will be working with the [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/) package probably, since it seems well documented.; Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and [WaterLily.jl](https://github.com/weymouth/WaterLily.jl)? Given my description of the project above, would you tend to use either of them?; Thank you!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438:352,validat,validation,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438,1,['validat'],['validation']
Security,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:507,access,access,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['access'],['access']
Security,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:105,validat,validation,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['validat'],['validation']
Security,"Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4183,validat,validation,4183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validation']
Security,GPU illegal memory access,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:19,access,access,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['access'],['access']
Security,Good thing to test as it exposed a typo. Resolves #539,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/549:25,expose,exposed,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549,1,['expose'],['exposed']
Security,Haine & Marshall (1998) channel validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:32,validat,validation,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,1,['validat'],['validation']
Security,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,2,['validat'],['validation']
Security,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770:525,validat,validation,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770,1,['validat'],['validation']
Security,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:685,access,access,685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,1,['access'],['access']
Security,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1669:1180,validat,validation,1180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669,2,['validat'],['validation']
Security,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:112,validat,validation,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,3,['validat'],['validation']
Security,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:1013,access,access,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,1,['access'],['access']
Security,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:289,access,access,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,3,['access'],['access']
Security,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:406,access,access,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['access'],['access']
Security,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:156,validat,validation,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,3,['validat'],['validation']
Security,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:1285,access,access,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['access'],['access']
Security,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,3,['validat'],['validation']
Security,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:614,access,access,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,1,['access'],['access']
Security,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/ep/pcg-with-multigrid/validation/elliptic_solvers/testing_preconditioner.jl)). When the initial guess is all 0s the precondition! method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here ](https://www.netlib.org/templates/templates.pdf)so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2655:270,validat,validation,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655,1,['validat'],['validation']
Security,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355:506,validat,validation,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355,1,['validat'],['validation']
Security,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:109,access,access,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,1,['access'],['access']
Security,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:801,access,access,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['access'],['access']
Security,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['validat'],['validation']
Security,"I'm trying to add some particles to a hydrostatic model on a lat-lon grid, but ran into some CUDA memory issues. After reducing down to a MWE I noticed that it also segfaults on the CPU. The MWE seems to be sensitive to the exact grid. Some lat-lon ranges lead to illegal memory accesses and others do not. I could not find a pattern though. On the CPU the segfault seems to occur after ~2 iterations. On the GPU after ~29 iterations. The particles are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:279,access,accesses,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['access'],"['access', 'accesses']"
Security,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:14,validat,validate,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['validat'],['validate']
Security,I've been meaning to raise this issue for a while. I think we export too many names. We should figure out which names truly need to be dumped into users namespaces' when `using Oceananigans` is written. . Users can easily access non-exported names via `Oceananigans.name` or `using Oceananigans: name`. This does not affect functionality; it's mainly a good-scripting-practice issue.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/364:222,access,access,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/364,1,['access'],['access']
Security,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208:61,validat,validation,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208,2,['validat'],['validation']
Security,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144:880,access,access,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144,1,['access'],['access']
Security,"Ideally the user would just define an element-wise function `closure(..., i, j, k)` that gets passed to the model and is added to the velocity or tracer source terms, acting as a forcing term in the momentum and tracer advection equations. Defining an element-wise function will allow the function to be injected into CPU and GPU kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73:304,inject,injected,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73,1,['inject'],['injected']
Security,Illegal memory access on CPU and GPU with `LagrangianParticles` + `HydrostaticFreeSurfaceModel` + `LatitudeLongitudeGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:15,access,access,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,"Implements callbacks between sub-steps as described in #2772 . I chose to add them to the model since that is the only part of the simulation they have access to when they run, and went with using the same `Callback` constructor so that parameters can still be passed to the functions despite the fact that whatever the specified schedule they have to run at every sub-step.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773:152,access,access,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773,1,['access'],['access']
Security,"In #1648 we introduced a script to show the convergence rates for the difference advection schemes. I just tried it and sadly it now gives bad results. I will workon fixing this. Also, it is probably a good idea to mention this in the docs in `Validation experiments`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1739:244,Validat,Validation,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1739,1,['Validat'],['Validation']
Security,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:198,validat,validation,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,3,['validat'],['validation']
Security,"In for `MultiRegionField`s, we often forced to do, e.g.,. ```julia; for region in 1:number_of_regions(grid); u[region] .= - ∂y(ψ[region]); v[region] .= + ∂x(ψ[region]); end; ```. We'd like to be able to simply do:. ```Julia; u .= - ∂y(ψ); v .= + ∂x(ψ); ```. See, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/validation/multi_region/cubed_sphere_tracer_advection.jl#L59-L69. cc @siddharthabishnu, @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577:357,validat,validation,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577,1,['validat'],['validation']
Security,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:71,access,access,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,3,['access'],['access']
Security,"Incorrect behavior results if, for example, a `NormalFlow` boundary condition is applied to a tracer or non-wall-normal velocity component. Conversely, only the `NormalFlow` boundary condition type is correct for a wall-normal velocity component. We may want to validate the boundary condition types in the constructors for `XFaceField`, `YFaceField`, `ZFaceField`, and `CellField`. I think this might save some users a bit of pain.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/890:262,validat,validate,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/890,1,['validat'],['validate']
Security,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:1088,access,access,1088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['access'],['access']
Security,Input validation for stretched grid dimensions breaks `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2588:6,validat,validation,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2588,1,['validat'],['validation']
Security,"Inspired by #1477 , I think it's worthwhile to add `norm` to supported functions, which will allow users to access it more easily on CPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1479:108,access,access,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1479,1,['access'],['access']
Security,Issue with out-of-bounds access and windowed field indexing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:25,access,access,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['access']
Security,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44:36,access,accessing,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44,2,['access'],"['accessed', 'accessing']"
Security,Just bumping version to 0.30.0 now that you need to use SeawaterPolynomials.jl to access `TEOS10` (a breaking change).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/750:82,access,access,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/750,1,['access'],['access']
Security,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2506:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506,1,['validat'],['validation']
Security,Keeping validation script up-to-date,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,1,['validat'],['validation']
Security,"Len{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:7380,validat,validate,7380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['validat'],['validate']
Security,Literate internal tide validation experiment?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694,1,['validat'],['validation']
Security,"Longitude values are not defined correctly at locations fca and cfa of (some particular orientations of) the orthogonal spherical shell grid (OSSG). Recall that the OSSGs constitute the individual panels of the conformal cubed sphere. The attached plots can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [60dde17](https://github.com/CliMA/Oceananigans.jl/commit/60dde179a1851bcc47a55987478d825709e3e7c6) of the Oceananigans branch [jmc-ss/cubed-sphere](https://github.com/CliMA/Oceananigans.jl/tree/jmc-ss/cubed_sphere) with the specification test_multi_region_cubed_sphere_plots = true. ![longitude_heatsphere_c](https://github.com/CliMA/Oceananigans.jl/assets/12926768/250e2ad9-530b-4e00-94da-ebfff9c8d0c6); ![longitude_panel_wise_visualization_c_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/6a3aec42-476d-4575-906b-f04ecd88ea82). ![longitude_heatsphere_u](https://github.com/CliMA/Oceananigans.jl/assets/12926768/fabf2caf-dfaf-4342-a713-1799e592e307); ![longitude_panel_wise_visualization_u_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2a83e72e-8527-45bd-bb0d-0bd120544848). ![longitude_heatsphere_v](https://github.com/CliMA/Oceananigans.jl/assets/12926768/79f91dec-0f48-4a11-9f6f-2e7f16bce000); ![longitude_panel_wise_visualization_v_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/68605b8c-34be-4d7c-9d9e-d5a84efefb56). The first, second and third pair of plots depict the longitude at locations cca, fca, and cfa respectively. The first pair of plots appear to be reasonable. That is not the case with the second and third pairs of plots, where the longitudes appear to be oriented along the latitudes (while ignoring the plotting issue resulting in a small gap).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217:410,validat,validation,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217,1,['validat'],['validation']
Security,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2312,validat,validate,2312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['validat'],['validate']
Security,Make the 3D stokes drift validation case even better,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3578:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3578,1,['validat'],['validation']
Security,Make validation/barotropic/barotropic.jl run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['validat'],['validation']
Security,Momentum dynamics validation on the CubedSphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306:18,validat,validation,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306,1,['validat'],['validation']
Security,More distributed validation scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,1,['validat'],['validation']
Security,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:138,validat,validation-experiments,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,1,['validat'],['validation-experiments']
Security,Near global quarter degree validation experiment is broken,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690,1,['validat'],['validation']
Security,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:630,access,access,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['access'],['access']
Security,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:366,Expose,Expose,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,1,['Expose'],['Expose']
Security,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534:267,validat,validation,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534,1,['validat'],['validation']
Security,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:601,access,accessible,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,1,['access'],['accessible']
Security,"Overturning, eddying channel validation test following Abernathey et al. 2011",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,1,['validat'],['validation']
Security,Patch security loophole,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1225:6,secur,security,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1225,1,['secur'],['security']
Security,"Plus some cleanup of input validation, and a test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/508:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/508,1,['validat'],['validation']
Security,"Previously, I believe I was defining fields on immersed grids. When I try now I get an error. Am I doing something silly or has something changed?. ```; julia> using Oceananigans. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> h0, L = 0.5, 0.25; (0.5, 0.25). julia> grid = RectilinearGrid(size=(16, 8), y=(-1, 1), z=(-1, 0),; topology=(Flat, Periodic, Bounded), halo=(3,3)); 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Arra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2250:908,validat,validate,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250,1,['validat'],['validate']
Security,Proposal for sustainable `validation` scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:26,validat,validation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,1,['validat'],['validation']
Security,Rehabilitating validation/cubed_sphere_eddying_aquaplanet,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['validat'],['validation']
Security,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2684:207,access,access,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684,1,['access'],['access']
Security,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3748:535,access,access,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748,1,['access'],['access']
Security,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:282,access,access,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['access'],['access']
Security,Run on GPU without network access,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:27,access,access,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,1,['access'],['access']
Security,Same typo fix as #1333 but done securely for Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1335:32,secur,securely,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1335,1,['secur'],['securely']
Security,"See, e.g., the Stratified Couette flow validation section in Docs: . <img width=""750"" alt=""Screen Shot 2021-03-13 at 4 44 11 pm"" src=""https://user-images.githubusercontent.com/7112768/111020624-6e090380-841b-11eb-8658-1130d560d86b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459,1,['validat'],['validation']
Security,Should we promote the [internal tide validation experiment](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/internal_tide.jl) to a literate one that goes into the docs?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694:37,validat,validation,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694,2,['validat'],['validation']
Security,Simplify way users have access to grid metrics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:24,access,access,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['access'],['access']
Security,Some updates in validation scripts: `AveragedField()` -> `Field(Average())`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2630:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2630,1,['validat'],['validation']
Security,Supercedes #1717 . The validation NaN's right now with the implemented immersed boundary. @christophernhill take over from here?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1723:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1723,1,['validat'],['validation']
Security,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1405:1077,access,access,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405,2,['access'],['access']
Security,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['validat'],['validation']
Security,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:403,access,accessing,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,1,['access'],['accessing']
Security,The Convergence tests and Couette flow pages (in validation) had missing figures that somehow got lost at some point. I was able to find the figures by going back to older versions of Oceananigans and reintroduced them. Resolves #1459. Resolves #1696.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797:49,validat,validation,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797,1,['validat'],['validation']
Security,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1696:4,Validat,Validation,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696,1,['Validat'],['Validation']
Security,"The [Simulation tips](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594:299,access,access,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594,1,['access'],['access']
Security,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,4,['validat'],['validation']
Security,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:201,access,accesses,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,2,['access'],['accesses']
Security,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3099:126,access,access,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099,2,['access'],['access']
Security,"The docstring example for three-dimensional Stokes drift can be improved:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/StokesDrifts.jl#L219-L226. The `v`-component (for example) is associated with a Stokes drift `vS` of the form:. ```julia; vS = p.Uˢ * exp(z / p.h) * cos(p.k * x) * sin(t); ```. For this to represent a real surface wave field, then it would have to be sinusoidally oscillating in time (hard to imagine). Also, the envelope of the surface drift is modulated in space by `cos(k * x)`. Unfortunately, this is quite confusing because `k` is typically used to represent the wavelength of the _surface wave field_ (not the envelope of the surface waves). For example, for a monochromatic wave field, `h = 2k` is the vertical scale of the Stokes drift. So in this example, `k` has a different meaning (governing the wave field envelope) then it normally does (the wavenumber of the underlying wave field). A better docstring example might represent a wavepacket that is translating at the group velocity, as done in a validation case:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/surface_wave_quasi_geostrophic_flow.jl#L5-L51",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3422:1076,validat,validation,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3422,2,['validat'],['validation']
Security,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:14,validat,validation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,3,"['access', 'validat']","['access', 'validation']"
Security,The following PR adds a new script with immersed boundaries on a lat-lon grid as a validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1880:83,validat,validation,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1880,1,['validat'],['validation']
Security,"The function `interpolate` is currently mostly used for Lagrangian particle advection:. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L186-L198. However, it's also potentially useful for many other things. Right now though it doesn't work (or make sense) for fields with `Nothing` locations:. ```julia; source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); s = Field{Center, Center, Nothing}(source_grid); set!(s, (x, y) -> x + y); loc = Tuple(L() for L in location(s)); x = y = 0.67; z = 0; interpolate(s, loc..., source_grid, x, y, z); ```. gives. ```julia; julia> interpolate(s, loc..., source_grid, x, y, z); ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] fractional_z_index; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:110 [inlined]; [3] fractional_indices; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:133 [inlined]; [4] interpolate(field::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356:758,access,access,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356,1,['access'],['access']
Security,"There's a growing number of users of Oceananigans, and we want share knowledge, share ideas, chat, science together, and maybe even work together. Currently the only way for users to ask questions is by posting an issue to github like this one. . But the issue tracker is _supposedly_ supposed to be used for issues related to the source code and code development. Other questions like:. * Why is my code slow?; * How do I implement my science idea?; * What does Oceananigans _mean_?; * Why is @navidcy so passionate about documentation?. don't have a place to be asked except for, perhaps, emailing developers and other normal humans directly. But unfortunately private emails are not accessible to all, and thus knowledge is lost or not disseminated. We do now have a channel on the julia slack:. https://julialang.slack.com/archives/C01D24C0CAH. which may, or may not, suffice for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1098:686,access,accessible,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1098,1,['access'],['accessible']
Security,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:908,Validat,Validation,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['Validat'],['Validation']
Security,This PR adds a few barotropic turbulence validation tests on `RegularLatitudeLongitudeGrid`. It also includes some miscellaneous improvements needed for these simulations:. * Bugfixes for `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (missing functions + closure shenanigans to solve type inference issues); * Allows `TimeStepWizard` to accept user-defined `cell_advection_timescale` functions; * Implements `auxiliary_fields` computed during `update_state!` for `HydrostaticFreeSurfaceModel`. Here's where we are at:. https://user-images.githubusercontent.com/15271942/116346519-4ab5d000-a79f-11eb-8c7f-91281db0ff56.mp4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:41,validat,validation,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['validat'],['validation']
Security,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463:48,validat,validation,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463,2,['validat'],['validation']
Security,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2110:571,validat,validate,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110,1,['validat'],['validate']
Security,This PR adds a set of changes so that needed dispatch paths for CubedSphereGrid are followed when CubedSphereFaceGrid tuple is wrapped in an ImmersedBoundary type. . With these changes the https://github.com/CliMA/Oceananigans.jl/blob/cnh-glw/immersed-cubed-sphere/validation/immersed_boundaries/immersed_cubed_sphere_rossby_haurwitz.jl code works identically for non-immersed and immersed cube sphere.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1737:265,validat,validation,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1737,1,['validat'],['validation']
Security,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:58,validat,validates,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['validat'],['validates']
Security,This PR adds a tilted bottom boundary layer validation based on one of the simulations in [this paper](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml). This is only a draft for now! (So not ready for review.) In particular I still need to. - [x] Add a sponge layer to the top.; - [x] Confirm that the result is still qualitatively correct; - [x] Add a tilted coriolis acceleration (implemented in #1892). This example renders here: https://clima.github.io/OceananigansDocumentation/previews/PR1498/generated/tilted_bottom_boundary_layer/. CC: @wenegrat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498,1,['validat'],['validation']
Security,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,2,['validat'],['validation']
Security,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602:35,validat,validation,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602,1,['validat'],['validation']
Security,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,1,['validat'],['validation']
Security,This PR adds biharmonic diffusion appropriate for curvilinear grids as described by the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. Looking for suggestions on more comprehensive tests / validation experiments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1531:245,validat,validation,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1531,1,['validat'],['validation']
Security,This PR adds tests for Face-Face halo filling and ensures that the `fill_halo_regions!` for Face-Face fields are done correctly. After this PR a `fill_halo_regions!` works on a Face-Face field on a `ConformalCubedSphereGrid` **with the exception** of the 2 corner points that belong in the halo regions and _do not_ correspond to any interior point!. If those corner points are filled manually. https://github.com/CliMA/Oceananigans.jl/blob/b0ff6c4874355ec69208f437be4f46fc8935f3d7/validation/multi_region/cubed_sphere_tracer_advection.jl#L32-L53. Then everything seems fine. (This is of course not a final solution but I wanted to make a note here.). (work done with @siddharthabishnu),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3324:482,validat,validation,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324,1,['validat'],['validation']
Security,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/936:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936,1,['validat'],['validation']
Security,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389:1678,Validat,Validation,1678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389,1,['Validat'],['Validation']
Security,"This PR allows simulations to hold parameters, useful if you need to access stuff from the `progress` function (e.g. see https://github.com/thabbott/JULES.jl/pull/63) going with the idea that we'll probably get rid of `model.parameters` in favor of more local parameters. It also cleans up show functions for models and simulations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/639:69,access,access,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/639,1,['access'],['access']
Security,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444:546,validat,validating,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444,1,['validat'],['validating']
Security,"This PR creates a new script that computes the convergence rates for all of the advection schemes and plots them together in one figure, which is doing what #1276 tried to do. The output is a figure and the following:; ```; Results are for the L1-norm:. Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5; ``` . ![convergence_rates](https://user-images.githubusercontent.com/8239041/117871837-dcc3db00-b26b-11eb-9307-0156e84714ee.png). The rates are very, very close to the theory. Questions:. - Can someone help me align the output so that Rate of Convergence appears in the same location?; - Any suggestions on how to improve the plot?; - I needed to add Polynomials to do this. Any problems with adding this to the Manifest?. Next Steps:. @ali-ramadhan suggested using this to validate new advection schemes, and I think it's a good idea. Things we could do next include,. - [ ] First order upwinding; - [ ] Sixth order center differencing; - [ ] Nth-order WENO",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648:1090,validat,validate,1090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648,1,['validat'],['validate']
Security,"This PR fills the metrics for the halo regions for a `OrthogonalSphericalShellGrid`. Also adds a validation example for a splash on an `OrthogonalSphericalShellGrid`, i.e., a `HydrostaticFreeSurface` model starting from rest + its free surface lifted up in the form of a Gaussian. Partially resolves #3198.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3239:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3239,1,['validat'],['validation']
Security,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:67,validat,validation,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['validat'],['validation']
Security,This PR fixes `set!` for `CubedSphereReducedField` for now which is used in the Rossby-Haurwitz validation experiment (and adds tests).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1622:96,validat,validation,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622,1,['validat'],['validation']
Security,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935:406,validat,validation,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935,3,['validat'],['validation']
Security,"This PR implements `PrescribedVelocityFields` for `HydrostaticFreeSurfaceModel` (or more precisely, moves the implementation from `validation/` to `src/`). `PrescribedVelocityFields` acts similar to the `velocities` tuple, except that `velocities.u, velocities.v, velocities.w` are prescribed functions of `x, y, z, t` and optional `parameters`. Using the kwarg `velocities=PrescribedVelocityFields(...)` in the constructor for `HydrostaticFreeSurfaceModel` causes the free surface to be set to `nothing` and elides memory allocations for velocity and free surface tendency fields. The model then amounts to tracer advection by the prescribed fields. This feature was discussed on #958, where it was envisioned this feature would be implemented in `IncompressibleModel`. Right now the implementation is specific to `HydrostaticFreeSurfaceModel`. However, I think the tracer advection-diffusion physics permitted by `IncompressibleModel` and `HydrostaticFreeSurfaceModel` are identical right now. So perhaps this PR closes #958?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1426:131,validat,validation,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1426,1,['validat'],['validation']
Security,"This PR implements a `VectorInvariant` formulation for momentum advection in `HydrostaticFreeSurfaceModel`, and also adds a `validation/bickley_jet/bickley_jet.jl` script. . `validation/bickley_jet/` also contains a preliminary implementation of `DiskTimeSeries` which might be useful to merge into the source code eventually to help users post-process their output. With `WENO5` for both `momentum_advection` and `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108126995-913ccf00-7078-11eb-8ced-ac4d51fe3bd2.mp4. This is more or less what we ""expect"" (though it'd be nice to be more quantitative at some point). With `CenteredSecondOrder` for `momentum_advection`, but `WENO5` for `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108127592-7454cb80-7079-11eb-9091-45cd93464c6e.mp4. while with `VectorInvariant` we get. https://user-images.githubusercontent.com/15271942/108127600-77e85280-7079-11eb-9f55-2fc5f8ea1a06.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366:125,validat,validation,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366,2,['validat'],['validation']
Security,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738:527,validat,validation,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738,1,['validat'],['validation']
Security,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2023:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023,1,['validat'],['validation']
Security,This PR implements the triad discretization for the Gent-McWilliams skew flux following [Griffies et al 1998](https://journals.ametsoc.org/view/journals/phoc/28/5/1520-0485_1998_028_0805_idiazc_2.0.co_2.xml?tab_body=fulltext-display). @jm-c . Running `/validation/isopycnal_skew_symmetric_diffusivity/coarse_baroclinic_adjustment.jl` produces . https://github.com/user-attachments/assets/124baffe-037c-4acd-bf97-d2b7cde36015. I think its working?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3901:253,validat,validation,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3901,1,['validat'],['validation']
Security,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1423:19,validat,validation,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423,8,['validat'],['validation']
Security,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888:1776,Validat,Validation,1776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888,1,['Validat'],['Validation']
Security,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:1279,validat,validation,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['validat'],['validation']
Security,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,2,['validat'],['validation']
Security,"This PR just updates and cleans up the lid-driven cavity script. At some point I'd like to add all the validation experiments into CI and into the docs as advanced examples, but this will have to wait for now. The issue is that the script was using `Flat` back when it did nothing but now when using `Flat` you need to pass a 2-tuple for the grid size. I switched the script from `Flat` to `Bounded` until `Flat` is fully working. cc @maeckha. Resolves #1507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1516:103,validat,validation,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516,1,['validat'],['validation']
Security,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/411:348,access,accessed,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411,2,['access'],"['accessed', 'accessing']"
Security,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,1,['validat'],['validation']
Security,"This PR makes a few major contributions:. * Fixes a bug in Anisotropic Minimum Dissipation (AMD) type closures that led to (very) wrong subgrid-scale diffusivities.; * Adds a new flavor of AMD proposed by [Verstappen (2018)](https://www.sciencedirect.com/science/article/abs/pii/S0045793016304005) and described in detail by [Vreugdenhil and Taylor (2018)](https://aip.scitation.org/doi/abs/10.1063/1.5037039). This new flavor of AMD, dubbed the ""Verstappen"" AMD, is now the default name bound to `AnisotropicMinimumDissipation`; * The closure formerly known as `AnisotropicMinimumDissipation` is now called `RozemaAnisotropicMinimumDissipation` (it was first described by [Rozema et al. (2015)](https://aip.scitation.org/doi/abs/10.1063/1.4928700)). It is not exported, but can be accessed via `Oceananigans.RozemaAnisotropicMinimumDissipation`.; * There is new Smagorinsky closure variant called `BlasiusSmagorinsky` which is untested and unexported. It can be accessed via `Oceananigans.BlasiusSmagorinsky`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383:782,access,accessed,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383,2,['access'],['accessed']
Security,"This PR makes a number of bug fixes needed to time step `HydrostaticFreeSurfaceModel` with a `RegularLatitudeLongitudeGrid`, and adds an experimental ""spherical splash"" example that uses Makie to visualize the solution on the surface of a the sphere:. https://user-images.githubusercontent.com/15271942/109041650-4553e080-769d-11eb-8c05-b169cba87153.mp4. Everything is still experimental, but we need these tools (and bug fixes) to set about validating our curvilinear finite volume numerics implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1399:442,validat,validating,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1399,1,['validat'],['validating']
Security,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:621,validat,validation,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,2,['validat'],['validation']
Security,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090:24,validat,validations,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090,1,['validat'],['validations']
Security,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:301,validat,validation,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,1,['validat'],['validation']
Security,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:1404,validat,validation,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,1,['validat'],['validation']
Security,"This PR partially generalizes the implementation of flux boundary conditions to work on curvilinear grids. The design implemented in this PR required a number of changes:. - Preservation of field locations in GPU kernels through a generalization of `adapt_structure(to, field::Field)`; - Creation of generic area and volume operators that dispatch on location like `Ax(i, j, k, grid, X, Y, Z)` (others are `Ay`, `Az`, and `volume`); - Generalization of `apply_top_z_flux!`, etc. The similar functions for `x` and `y` could also be generalized in this PR, though we don't have regression tests to ensure that they still work as before...; - Activation of `calculate_boundary_tendencies!` for `HydrostaticFreeSurfaceModel`. The new `validation/barotropic_gyre.jl` experiment is definitely a work in progress but will eventually produce a movie like. https://user-images.githubusercontent.com/15271942/110257064-a747fc00-7f61-11eb-83aa-18665f01efb4.mp4. We may want to add side and bottom drag, tweak the surface stress, and tweak the viscosity.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1433:731,validat,validation,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433,1,['validat'],['validation']
Security,"This PR puts some code into the `IncompressibleModel` constructor that adjusts the halos in `grid` so that they're valid for the specified `advection` scheme and turbulence `closure`. The changes went a little deep because of the fact that we allow fields to be passed directly to `IncompressibleModel`. We now check whether such fields have the correct grid and throw an error if they don't. I decided not to validate the `pressure_solver` input. This isn't commonly provided by users (and wasn't previously checked). There's a new function in `Solvers` that could be modified if such a check becomes desirable. Here's what happens if you use a high-order advection scheme now:. ```julia; using Oceananigans, Oceanaingans.Advection. grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)). # output --- note that halos are (1, 1, 1); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. but,. ```julia; model = IncompressibleModel(advection=WENO5(), grid=grid). model.grid. # output --- halos are (3, 3, 3); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. This PR relies on #1003 . Resolves #941",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1012:410,validat,validate,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1012,1,['validat'],['validate']
Security,"This PR splits `validation/bickley_jet.jl` into two scripts (one for the ""immersed bickley jet"" and one for the ""ordinary"" bickley jet) and somewhat improves the script for the ordinary bickley jet. @simone-silvestri I left the ""immersed bickley jet"" unchanged so you can continue to use it as is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2420:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2420,1,['validat'],['validation']
Security,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:948,inject,injecting,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['inject'],['injecting']
Security,This PR updates the baroclinic adjustment validations scripts. Closes #2291,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:42,validat,validations,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['validat'],['validations']
Security,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:602,expose,exposed,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['expose'],['exposed']
Security,"This captures a few changes, such as updates to `show`, `Callback` `parameters`, new field types, and boundary condition validation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2172:121,validat,validation,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2172,1,['validat'],['validation']
Security,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['validat'],['validation']
Security,"This input validation:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/Grids/input_validation.jl#L108. breaks the ""naive"" construction of grid domain that's used in `FieldTimeSeries`:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/OutputReaders/field_time_series.jl#L143. There, an `OffsetArray` with correct indexing (but incorrect size, according to the new restrictions on grid construction) is used to build a grid for `FieldTimeSeries` (when deserialization fails; typically this is because data was created with an old version of Oceananigans or a different Julia version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2588:11,validat,validation,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2588,1,['validat'],['validation']
Security,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:165,validat,validation,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,3,['validat'],['validation']
Security,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394:430,validat,validation,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394,2,"['Validat', 'validat']","['Validate', 'validation']"
Security,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['validat'],['validation']
Security,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:546,validat,validation,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,1,['validat'],['validation']
Security,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733:521,validat,validation,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733,3,['validat'],['validation']
Security,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1273:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273,4,['validat'],['validation']
Security,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3265:77,validat,validation,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265,3,['validat'],['validation']
Security,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1619:107,access,access,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619,1,['access'],['access']
Security,"Type#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9884,hash,hash,9884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hash']
Security,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:90,checksum,checksum,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['checksum'],['checksum']
Security,"Unlike the `NonhydrostaticModel`, which has these lines:. https://github.com/CliMA/Oceananigans.jl/blob/1c96350d03e1ee066d5c9060089e043e15f711d6/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L120-L122. It's nice to validate the halos, because sometimes there are non-intuitive constraints (eg on #1994 we may have discovered that isopycnal closures need halos of size 2). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2041:225,validat,validate,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2041,1,['validat'],['validate']
Security,Update SWE immersed boundaries validation scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985,1,['validat'],['validation']
Security,Update `baroclinic_adjustment.jl` in validations exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545:37,validat,validations,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545,1,['validat'],['validations']
Security,Update cubed sphere 32 grid file sha256 checksum,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:40,checksum,checksum,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['checksum'],['checksum']
Security,Update lid-driven cavity validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1516:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516,1,['validat'],['validation']
Security,Update validation for distributed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3428:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3428,1,['validat'],['validation']
Security,Updates `validation/periodic_advection.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1811:9,validat,validation,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1811,1,['validat'],['validation']
Security,Updates the `near_global_quarter_degree.jl` validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2743:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2743,1,['validat'],['validation']
Security,Updates to validation and docs for distributed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429:11,validat,validation,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429,1,['validat'],['validation']
Security,Uses ValueBoundaryCondition in stratified couette flow validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1982:55,validat,validation,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1982,1,['validat'],['validation']
Security,"Using the `FFTBasedPoissonSolver` in complex domains on the `ImmersedBoundaryGrid` leads to resulting solution that either. 1. Does not conserve tracers in the flow; or; 2. Leads to divergent flow along the immersed boundary. On the other hand, using the `PreconditionedConjugateGradientSolver` on complex domains leads to exact solution at a much slower speed on the GPU. This PR implements an `ImmersedPressureSolver` that uses the `FFTBasedPoissonSolver` as a preconditioner, then iterates `PreconditionedConjugateGradientSolver` to arrive at the correct solution. This approach is much faster than using a vanilla `PreconditionedConjugateGradientSolver` as the number of iterations scale much more slowly with grid size on the GPU. This PR will include the `ImmersedPressureSolver`, a few validation examples for benchmarking purposes and a number of example use cases where this solver would be useful. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188:793,validat,validation,793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188,1,['validat'],['validation']
Security,Validate Implementation of Orthogonal Spherical Shell Grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3222:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222,1,['Validat'],['Validate']
Security,Validate `boundary_conditions` argument to model constructors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3788:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3788,1,['Validat'],['Validate']
Security,Validate boundary conditions on Fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['Validat'],['Validate']
Security,Validate field boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['Validat'],['Validate']
Security,Validate the convergence rates for advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650,1,['Validat'],['Validate']
Security,Validation + Convergence tests: images not showing up,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459,1,['Validat'],['Validation']
Security,Validation Experiments in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1696:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696,1,['Validat'],['Validation']
Security,Validation and performance benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['Validat'],['Validation']
Security,Validation script for flow over immersed hills fails in `bottom_drag` case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Validat'],['Validation']
Security,Validation test: Abernathey et al 2011,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['Validat'],['Validation']
Security,Validation tests for immersed boundary implementations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['Validat'],['Validation']
Security,Validation tests of numerical convergence,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767,1,['Validat'],['Validation']
Security,"VectorInvariant momentum advection ""scheme"" and Bickley jet validation example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366:60,validat,validation,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366,1,['validat'],['validation']
Security,"WE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface = ExplicitFreeSurface(; gravitational_acceleration = 10),; closure = nothing,; tracers = nothing,; buoyancy = nothing); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572:949,access,access,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572,1,['access'],['access']
Security,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682:709,access,accessible,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682,1,['access'],['accessible']
Security,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:352,access,access,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['access'],['access']
Security,"We need to overhaul the way we specify advection schemes, whose current limitations were exposed when ""WENO vector invariant"" was implemented. I propose that we implement a hierarchical specification system using a new object called `AdvectionScheme` that specifies. 1. The ""form"" of the advection operator for momentum and tracers (either `VectorInvariant` or `FluxForm` for momentum, always `FluxForm` for tracers); 2. For `FluxForm`, the reconstruction scheme for the advected component ; 3. For `VectorInvariant`, the stencil for _computing_ vorticity, as well as the method for _reconstructing_ vorticity at the momentum locations; 4. For `VectorInvariant` with WENO reconstruction, the type of the smoothness stencil (vorticity or velocity); 5. The method for reconstruction velocities in mass conservation (continuity) as well as tracer advection. We also may want to specify how we reconstruction _advecting_ velocities for flux form momentum advection (right now we use centered advection with an accuracy one order lower than the accuracy of the advected component reconstruction --- ie with `UpwindBiasedFifthOrder()` we reconstruct advecting components with a centered fourth order scheme). Finally, we need to allow different schemes for every tracer. This modular design will allow more detailed specification of an advection scheme and also us to remove the option for WENO reconstruction for vector invariant more easily, which @simone-silvestri pointed out is experimental. We also would like to explore alternative discretization for the continuity equation. For this we need a ""mass"" reconstruction scheme, and the advecting scheme for tracers needs to reconstruct `advected_velocity` in a way that's consistent with the mass reconstruction. Here's a sketch of what these new types might look like:. ```julia; """""" Specifies a reconstruction scheme for fluxes of the form u * c,; where u is the `advecting_velocity` and c is the `advected_quantity` """"""; struct FluxFormAdvection; adv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454:89,expose,exposed,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454,1,['expose'],['exposed']
Security,We should figure out an interface to help users access grid metrics. We shouldn't have to write things like `grid.Δxᵃᵃᶜ` in the examples. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/2050#issuecomment-967266791_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:48,access,access,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['access'],['access']
Security,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['validat'],['validation']
Security,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280:305,access,access,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280,1,['access'],['access']
Security,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:698,access,access,698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['access'],['access']
Security,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,1,['validat'],['validation']
Security,"Working with @arnscheidt to output vorticity to NetCDF the code below is what we came up with but it feels quite cumbersome and required us to define some boilerplate `get_vorticity` function so it can all be accessed on demand by the `NetCDFOutputWriter`. I wonder if we can improve the interface to allow users to easily pipe the output of abstract operations to disk. One approach might be to add explicit support for abstract operations to output writers. `NetCDFOutputWriter` already knows what to do if you give it a field or a function. We can tell it to do all this in the background if given an abstract operation like `vorticity_operation = ∂x(v) - ∂y(u)`. ```julia; u, v, w = model.velocities; vorticity_operation = ∂x(v) - ∂y(u); ω = Field(Face, Face, Cell, model.architecture, model.grid, TracerBoundaryConditions(grid)); vorticity_computation = Computation(vorticity_operation, ω). function get_vorticity(model); compute!(vorticity_computation); return Array(interior(ω)); end. fields = Dict(..., ""vorticity"" => get_vorticity); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/653:209,access,accessed,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653,1,['access'],['accessed']
Security,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728:354,validat,validation,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728,1,['validat'],['validation']
Security,"X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:2736,validat,validation,2736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['validat'],['validation']
Security,`LatitudeLongitudeGrid` validation seems to be leaky,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:24,validat,validation,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,1,['validat'],['validation']
Security,"`NetCDFOutputWriter` constructor says that ""`outputs` (which can be a; `Dict` or `NamedTuple`)"" but this line does not work on named tuples. https://github.com/climate-machine/Oceananigans.jl/blob/a511fdd2fedc9aae49a76905be24fdc60c2d60b0/src/OutputWriters/netcdf_output_writer.jl#L162. ```julia; julia> nt = (a=2, b=4, c=8); (a = 2, b = 4, c = 8). julia> for (i, j) in nt; @show i, j; end; ERROR: BoundsError: attempt to access Int64; at index [2]; Stacktrace:; [1] indexed_iterate(::Int64, ::Int64, ::Nothing) at ./tuple.jl:72; [2] top-level scope at ./REPL[4]:1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/553:421,access,access,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553,1,['access'],['access']
Security,`Nz=1` is probably broken for `DistributedFFTPoissonSolver` right now:. https://github.com/CliMA/Oceananigans.jl/blob/a94d27afcd5c2c26f2a6cbd65a54acc4394f592f/src/Distributed/distributed_fft_based_poisson_solver.jl#L49-L50. We want to support this case to make implementing a distributed FFT-based implicit free surface solver straightforward. We're hashing it out on https://github.com/jipolanco/PencilFFTs.jl/issues/43.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2533:350,hash,hashing,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2533,1,['hash'],['hashing']
Security,"all to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5448,validat,validate,5448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validate']
Security,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:2708,Validat,Validate,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['Validat'],['Validate']
Security,"ast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:3098,validat,validate,3098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['validat'],['validate']
Security,"buted grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:2590,validat,validation,2590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['validat'],['validation']
Security,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:2111,access,access,2111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['access'],['access']
Security,closes #3681. We can probably use this PR to add also a validation for the `PartialCellBottom` and the bug-fixes in the implementation.; What do people think?. cc @jm-c,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682:56,validat,validation,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682,1,['validat'],['validation']
Security,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:1449,access,access,1449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['access'],['access']
Security,"cs, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordinates other than `z`. We can either call the new field `model.stokes_drift` or `model.surface_waves`. We can validate our implementation by reproducing results in [McWilliams et al (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), [Polton and Belcher (2007)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2007JC004205), and [Skyllingstad and Denbo (1995)](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94JC03202?casa_token=EqggenV30loAAAAA:Qu8czM4PvMqLP486Ma1BUZen0CPIuGZgyVDXrIoYnopbmOUDzbwwmH1BiftvEvIpzuV1_l9J6LgXkGE). cc @johncmarshall54",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:2269,validat,validate,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['validat'],['validate']
Security,"dic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.Com",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:4780,validat,validation,4780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validation']
Security,"dition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}:; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:9406,access,access,9406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,1,['access'],['access']
Security,"e a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1454,access,accessible,1454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['access'],['accessible']
Security,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:1922,validat,validation,1922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,5,['validat'],['validation']
Security,"enceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, CPU, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, Nothing, Nothing, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64. ... @ Oceananigans.Simulations ~/LocalDocs/code/Oceananigans.jl/src/Simulations/run.jl:86; [10] top-level scope; @ ~/LocalDocs/code/Oceananigans.jl/validation/immersed_boundaries/flow_over_hills_test.jl:146; ```. Any pointers would be helpful! I'm happy to contribute to an updated example once I sort this out. The relevant code was included in https://github.com/CliMA/Oceananigans.jl/commit/737ee905167ed44d61940098c32b108befbf1a26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:24118,validat,validation,24118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['validat'],['validation']
Security,"eredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:7915,hash,hashing,7915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,getindex and setindex! much slower than just accessing array contents directly.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/13:45,access,accessing,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13,1,['access'],['accessing']
Security,https://github.com/CliMA/Oceananigans.jl/blob/bb35dcbefad63c038cd311c5eed43ac5326bb824/validation/mesoscale_turbulence/eddying_channel.jl#L96-L97,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974:87,validat,validation,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974,1,['validat'],['validation']
Security,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:2018,access,accessing,2018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['access'],['accessing']
Security,"ivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:7962,hash,hashing,7962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,"m the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3282,validat,validation,3282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['validat'],['validation']
Security,"ma.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycna",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:1350,validat,validation,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['validat'],['validation']
Security,moving mpi example to validation folder,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1661:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1661,1,['validat'],['validation']
Security,"nanigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12960,hash,hash,12960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hash']
Security,"nc), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method. If I set-up exactly the same code but using a `NonhydrostaticModel` things work as expected. Things also work if I set the `OpenBoundaryCondition` using a constant, such as:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)); u₀ = 1; u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u₀), west = OpenBoundaryCondition(u₀)); model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. Am I missing something obvious here, or is something wrong? Also I couldn't find any scripts in the repo that exemplify `OpenBoundaryConditions`, so I'm happy to set-up a validation script or something once this is figured out if you guys think it's a good addition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:2713,validat,validation,2713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,1,['validat'],['validation']
Security,"ng),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTradi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12893,hash,hashing,12893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hashing']
Security,"nhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:1969,access,access,1969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['access'],['access']
Security,"nsBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6367,validat,validation,6367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['validat'],['validation']
Security,"oat64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45933,hash,hashing,45933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,"oat64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5173,validat,validate,5173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validate']
Security,"odel::HydrostaticFreeSurfaceModel{…}, grid::RectilinearGrid{…}, callbacks::Tuple{}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:72; [8] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:64 [inlined]; [9] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:29 [inlined]; [10] time_step!(model::HydrostaticFreeSurfaceModel{…}, Δt::Float64; callbacks::Tuple{}, euler::Bool); @ Oceananigans.TimeSteppers ~/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:123; [11] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:122; [12] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}; pickup::Bool); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:97; [13] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:85; [14] top-level scope; @ ~/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; [15] include(fname::String); @ Base.MainInclude ./client.jl:489; [16] top-level scope; @ REPL[1]:1; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:3565,validat,validation,3565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,2,['validat'],['validation']
Security,"olver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditione",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1402,validat,validation,1402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['validat'],['validation']
Security,"oposed / described by [Breivik et al., 2016](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500316X00042/1-s2.0-S1463500316000159/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAoaCXVzLWVhc3QtMSJGMEQCIEuzyjjMiYKjWncqy3fB9gow3kA5926WXv4VBHU9V0HoAiBgSB%2BFi9CNjS0smrtpCWSh2fziUgRWzaTpBid40ar%2FnSr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMRVnsHhFNYBpkm%2B7%2BKtcDEI3fj7WLlfM53vSXM70Jkta7qu8fr%2BZ4CiPp4EQEEdZO6gUvY4SodH4tbdylMZ16%2B6i0LOoNoyjZ%2FVjIVIr%2BzT90aJhP4POuZeDrpUxWfNYUqCXOyJ%2Bl4Uz3BCrk0e4ciQXjvEtJzlNbQDfq48BbAPBlW6B4SZ8q5Tui7pe1OvlCCs299aJ8749qPcCrKO5zN5QGE0iDQ2PAN0c2L53i%2BjjNPA0EOYaa0HdQWwO0tF14tTe79EjPEgl%2BMv%2BtlDH3XbTE595%2FdFEfPieVxLQJxNVWwvBZn2docHqGUXgcMsjOQVus7E%2FLZymGWm5cdHIJeB1d5VhK27LB4laC%2FhKCYsRVY59KDzsKVDR0jp6Rz6Ot6MjCwTVKuDTt6Gz0lsC02z3Q52EEIwxsWwpFJytxblTwDDGU5vu0nC%2BXSaZAA4rt8uytZSBR%2BO5ePkeRpOR04IF45ZmZw6w8TTlQXDewatkd64cUrRc6FQw0krDJ4eP%2FCDJKSd1h02HjU7C7GH6Q26NhNyFNw6Arxd173SQ43s7JMYW%2BOqY5%2BPj791sOnT7e5unKOSlnygc9ByJ5nr1mjt8aEaX9kxW5ZcaWnRZ%2Fue3NGi3ZQZvmkfZXITWkG1JzW%2BQUXxBUMObG1JAGOqYBlOoU8BHgt%2FoqN5rPBE1L0boNzjsSZWd3Mvv%2FJL1puzzfMbVoxGXMWcCRTcGyUDKA5eKG261EWk8WXCHK77FpXfb67tIFjOPUqtQRYpPDw10p39jA2oX168yKgrQZe1OVbIrw4uM%2FzGI57WdgefB3HgcwUgAacmIOndn5YvNpMZIRU4ExzrHGrCb1%2BwKJjRNm4WjEnfczrQPDhzPx6kTK9RnxkpCWvA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T190618Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYUWF4GJ7K%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=23dc65f5c0ed27e40381ce3eafb4d99c62faa368fa7ca21d3b635b3b05731127&hash=c2a51e264c7e095492ef97c3cb63571bfba4a5379b4090b7ad3b20ff588c2db6&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500316000159&tid=spdf-69dccd42-cfb6-4987-9af5-8ccdc6d81ccf&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=5306520250050e5302&rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290:344,Secur,Security-Token,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,"othing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12846,hash,hashing,12846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hashing']
Security,rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAsaCXVzLWVhc3QtMSJGMEQCIBRKxiRGfmCqFI08tnCQqlwbVGk%2Bm8YOAG57p4smh3cHAiAC%2B9pA%2FCQMsYbtGWN4kUfk%2FIAKtiQzgv56vUWJpK03NCr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMtkIfmex2gMV%2FyYy6KtcD496P%2F695JO%2BGnHHg3hAcKNGkmiiEA8fjZyLcowzIG1pT5TS%2Ft%2BElYms%2FLx0gMtbZFbl3ks8ifVzTgoC0pM3zCN2TCTyxCPFUUB2j0PmnsyNtq9v5ljKcSf2eolUGpQlINrUrJ170CMAGYA7XjRWzC8YJCZBRF7iThfHpYOvqkjO5BJyW8p52vOlmz%2FRfy%2FSMbW0kVlgEef5PcIWTff3BSKQ5BA%2BdekJjdRrZDVaSwNIcQjE4l%2Ff38F%2Bp%2BlY75UZft0%2Fd1I18PyELQS5rWPmCIPNkmsePvN1rgPnhqldC5ozV0OO2Anr8oBoxmnmwNwnrfk5yUwJWc%2Fhsk4zmTD96nmzDgS3IOgCjh8b1TIhBEvYlZlCVkXouGc8M0%2BN7tCEZqvdjxKVkulq2BqwXW9bbYoPmp9ufV9A96mGmBWzqbJpRBLg%2FZHX5%2BDFDPoFc1vZ4gPCz9JSS8xyyayG1JtaZ6etf%2F%2FbmN2IcTbPh0lqf9B5O7DqisxWMCKadJvgsr5oVghbvkEd%2FjjFL7KrspUdfonTXuY5C5U2TiLkOIVlg2bFaEP9QemD8FVljVjKLrUr8K99rJnaPC1uQncZXj%2FL%2FF%2BKfi9k9bIQe0uhDrmwNpigQzgOdZy1GMJDS1JAGOqYB3PXXbyBFFFdkUJqOFawxA9rk4s0ZqMS4J8%2BpTJxrUG%2F3KL8SAYJh9PmjeekbuM1lz8q1TlsQNM50q4UiPr0Ld7Wt5PrqC01LwdIFgbhr1l1GltNfCH9vWLEasPpjc2O6MGHwNpmrCNVstzsTQ%2FbiELElpjrhNjLZUaIOPWHKUTVTcIBmQf%2B5AVSebzQWwEX2aaFc8HYk5XfmfFwJoKdlO%2F3oR%2FOsnQ%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T191639Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY34KZ3BVM%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290:2167,Secur,Security-Token,2167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1758,access,accesses,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['access'],['accesses']
Security,see #3141 ; closes #3141 . The results from `validation/immersed_boundaries/immersed_couette_flow.jl` from this branch. https://github.com/CliMA/Oceananigans.jl/assets/33547697/e50beac1-4d22-4581-9715-5f541e8dcf01,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142,1,['validat'],['validation']
Security,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8651,secur,security-vulnerabilities,8651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['secur'],"['security-updates', 'security-vulnerabilities']"
Security,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:6148,validat,validation,6148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['validat'],['validation']
Security,"t64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:46047,hash,hash,46047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hash']
Security,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:10343,access,access,10343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:1732,validat,validation,1732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,1,['validat'],['validation']
Security,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:1376,validat,validation,1376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,3,['validat'],['validation']
Security,"validation/barotropic/barotropic.jl currently errors when you try and run it. 1. The Flux() type is not imported; 2. The explicit stepper and timestep aren't in sync and code NaNs. The timestep is set for implicit free surface. . These two tweaks make it run and produce something ""reasonable"". ; It could be good to have it set so it runs as cloned?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:0,validat,validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['validat'],['validation']
Security,"ymbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4862,validat,validate,4862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validate']
Security,"ys.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, SmallSlopeIsopycnalTensor{Int64}}, VerticalScalarDiffusivity{ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}}}, BoundaryCondition{Flux, Nothing}, Buoyancy{SeawaterBuoyancy{Float64, SeawaterPolynomials.BoussinesqEquationOfState{TEOS10SeawaterPolynomial{Float64}, Int64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:T, :S), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Tuple{NamedTuple{(:νₑ,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Nothing}, typeof(Oceananigans.Forcings.zeroforcing), NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/XyxTy/src/validation.jl:139. ```. Note that the equivalent code works fine on CPU. Any ideas? Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:8164,validat,validation,8164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['validat'],['validation']
Security,"ze=3, z=(0, 1), topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Regular, with spacing 0.3333333333333333; ```. so `grid in x:` isn't aligned with the rest of the ""data table"". Here's what we get when `z` is stretched:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Stretched, with spacing min=0.2, max=0.5; ```. So here's a few ideas:. #### Include ""spacing"" information under the `domain` row?. One idea would be to show something like. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], Δz: 0.33; ```. instead of `domain:` (for the regularly-spaced case), and. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], extrema(Δz): (0.2, 0.5); ```. for the stretched case. We could also increase the length of the table and put the spacings on their own lines, eg. ```julia; x: Flat; y: Flat; z: [0.0, 1.0]; extrema(Δz): (0.2, 0.5); ```. We might also just hide flattened directions (we already express that the directions are `Flat` so why print this again?). #### Eliminate `topology` row because this information is already printed in the type signature. #### Compactify how we show the size + halo. I've always found the way we write `(Nx, Ny, Nz)` to negatively impact readability. . I think it's ok to just write `size`, because we want to move towards providing a function-based API rather than expecting users to access struct properties directly. Eg we could have just. ```julia; size: (1, 1, 1); halo: (0, 0, 1); ```. What do others think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064:1971,access,access,1971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064,1,['access'],['access']
Security,"},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:8029,hash,hash,8029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hash']
Security,"},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9817,hash,hashing,9817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hashing']
Testability," # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110909,benchmark,benchmark,110909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability," (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5126,test,test,5126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability, 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 9379,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3437,test,test,3437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability," 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat, rows::Vector{Int64}, cols::Vector{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64, ncols::Int64); @ Base ./arrayshow.jl:68; [11] _print_matrix(io::IOContext{Base.TTY}, X::AbstractVecOrMat, pre::String, sep::String, post::String, hdots::String, vdots::String, ddots::Strin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1749,assert,assertscalar,1749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['assert'],['assertscalar']
Testability," 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12137,test,test,12137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:11587,benchmark,benchmark,11587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmark']
Testability," 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111914,benchmark,benchmark,111914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability," 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106943,Test,Test,106943,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability," 755.937 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 1 │ 61.083 ms │ 63.464 ms │ 63.969 ms │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4124,benchmark,benchmark,4124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmark']
Testability," ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1657,log,log,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['log'],['log']
Testability," FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14667,test,test,14667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability, GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:4404,Mock,Mocking,4404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Mock'],['Mocking']
Testability," I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_strat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1075,test,test,1075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:1343,log,logical,1343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['log'],['logical']
Testability," LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 FieldTimeSeries{Chunked} located at (Face, Center, Center) on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── indices: (Colon(), Colon(), Colon()); └── data: 23×22×16×4 OffsetArray(::Array{Float64, 4}, -2:20, -2:19, -2:13, 1:4) with eltype Float64 with indices -2:20×-2:19×-2:13×1:4; └── max=8.0, min=0.0, mean=1.67984; ```. This is not final and all open to suggestions/changes/improvement. maybe interesting for @yuchenma23",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:1983,test,testfile,1983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['test'],['testfile']
Testability," Receiving objects: 100% (103248/103248), 119.80 MiB | 1.54 MiB/s, done.; Resolving deltas: 100% (78348/78348), done.; (base) $ du -sh Oceananigans-6.jl; 131M	Oceananigans-6.jl; ```. I run [a script](https://dev.to/jakecarpenter/shrinking-your-git-repository-with-bfg-repo-cleaner-145e) to find the big files. There are some `.jld2` files in the GitHub repo... and also some `report-....nsys-rep` files.... (@simone-silvestri?). ```; All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.; size pack SHA location; 48992 16829 1dd3f4706ebc79549624bee40f78b5aa2c0d644d report-last.sqlite; 48916 16814 839a363a9dd693e35abb48f4822be360ac313a4c report-shared-memory.sqlite; 20694 12212 950954a5d3ef4fac9d6d0480886b95e66d7ec510 report-shufflin.nsys-rep; 20664 12149 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:1459,test,test,1459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability," The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @ben",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:1514,benchmark,benchmark,1514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['benchmark'],['benchmark']
Testability," WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23169,test,test,23169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _concrete_ locations such that a difference needs to be resolved. In other cases (such as a binary operation between fields at common locations, or a binary operation between a field and a number), the location of the members of the operation is preserved. In this way, `BinaryOperations` are ""stubborn"". . We thus have results like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:2974,stub,stubborn,2974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['stub'],['stubborn']
Testability," `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 Fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:1052,test,testfile,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['test'],['testfile']
Testability, `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:13094,Log,LogExpFunctions,13094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Log'],['LogExpFunctions']
Testability," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7301,benchmark,benchmarks,7301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['benchmark'],['benchmarks']
Testability," benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110025,test,test,110025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability," benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110343,Test,Test,110343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability," benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32.9KiB; 64x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:1153,benchmark,benchmarks,1153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['benchmark'],['benchmarks']
Testability," bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:1084,Test,Test,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,1,['Test'],['Test']
Testability," definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23394,test,test,23394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1508,test,tests,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['tests']
Testability," discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17577,test,test,17577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002 ms │ 881.88 KiB │ 1514 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 7.747 ms │ 7.970 ms │ 8.234 ms │ 10.968 ms │ 1.28 MiB │ 2103 │ 10 │; │ CPU │ RectilinearGrid │ ImplicitFreeSurface │ 151.499 ms │ 165.772 ms │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3525,Benchmark,Benchmarks,3525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['Benchmark'],['Benchmarks']
Testability," from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:1258,log,log,1258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['log'],['log']
Testability," if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7274,test,testing,7274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['testing']
Testability," improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with Regular",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:1011,Benchmark,Benchmarking,1011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['Benchmark'],['Benchmarking']
Testability," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23859,test,test,23859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,5,"['Test', 'test']","['Test', 'Testing', 'test', 'tests']"
Testability," libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwrit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14022,test,test,14022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21006,test,test,21006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20792,test,test,20792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20583,test,test,20583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:2874,benchmark,benchmarks,2874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability," schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:1499,Benchmark,BenchmarkTools,1499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['Benchmark'],['BenchmarkTools']
Testability," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:3171,benchmark,benchmark,3171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['benchmark'],['benchmark']
Testability," t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107160,Test,Test,107160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability," time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:1020,log,log,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['log'],['log']
Testability," tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:4498,stub,stubborn,4498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['stub'],['stubborn']
Testability," to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16911,test,test,16911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:3456,test,tested,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tested']
Testability," top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114683,Benchmark,Benchmark,114683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:14808,Log,Logging,14808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,2,"['Log', 'Test']","['Logging', 'Test']"
Testability," way that will not overwrite the original pressures. . I tried to start with the second term ($p_r'$) in the RHS of the equation. This term is the component that results from rapid distortion by the current shear. For this term, the vertical boundary condition is $\partial p_r' / \partial x_3 = 0$ (see more details about boundary conditions in Appendix A in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). So the goal is to solve an equation $\nabla^2p_r' = -2\frac{\partial U_i}{\partial x_j}\frac{\partial u_j'}{\partial x_i}$ with applying the boundary condition $\partial p_r' / \partial x_3 = 0$. I have written a part of the code (I start from the calculation of $p_r'$ because there is no need to consider the boundary conditions, and the calculation I think can directly follow the calculation of $p_{NHS}$). Now I have tested it on the CPU, and output the pressure (I call it “prapid” in my code) like ```model.pressures.prapid ```, but there are also some problems. I add part of the code in [https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/solve_for_pressure.jl](url) following the cacluation of $p_{NHS}$ like: . ```julia; @kernel function calculate_pressure_source_term_fft_based_solver_rapid!(rhs, grid, Δt, U★); i, j, k = @index(Global, NTuple); U = Field(Average(U★.u, dims=(1, 2))); V = Field(Average(U★.v, dims=(1, 2))); W = Field(Average(U★.w, dims=(1, 2))); u_prime = Field(U★.u - U); v_prime = Field(U★.v - V); w_prime = Field(U★.w - W). @inbounds rhs[i, j, k] = -2*( ∂xᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂x",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:2079,test,tested,2079,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['test'],['tested']
Testability," we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:1198,test,tests,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['test'],['tests']
Testability," μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4253,benchmark,benchmarks,4253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability," │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` directory. # References. Jahn et al. (2015): https://doi.org/10.5194/gmd-8-317-2015; Klemp et al. (2007): https://doi.org/10.1175/MWR3440.1; Satoh (2003): https://doi.org/10.1175/1520-0493(2003)131%3C1033:CSFACN%3E2.0.CO;2; Skamarock et al. (2019): https://opensky.ucar.edu/islandora/object/opensky%3A2898; Sod (1978): https://doi.org/10.1016/0021-9991(78)90023-2; Straka et al. (1993): https://doi.org/10.1002/fld.1650170103; Wicker and Skamarock (1998): https://doi.org/10.1175/1520-0493(1998)126%3C1992:ATSSFT%3E2.0.CO;2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:10917,test,tests,10917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tests']
Testability,"!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 usin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113608,test,test,113608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:6125,Log,Logging,6125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['Log'],['Logging']
Testability,"###; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113825,test,test,113825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:21,test,tests,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,5,['test'],"['test', 'tests']"
Testability,"$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oceananigans` and nothing happens. I have tested this with other packages but this only happens with Oceananigans. Something ever weirder: after I get impatient I can cancel the command (pressing `Ctrl+C` repeatedly) and then if I issue the line again it works!:. ```julia; julia> using Oceananigans; ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C; ^C^C^C^CWARNING: Force throwing a SIGINT. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(1,1,1), extent=(1,1,1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0). julia> ; ```. So basically I'm very lost on this one. Two main questions are:. - Why is the `using` command hanging in the first place? (And then working if I cancel and try again?); - Why is the behavior different between these two machines? I thought I was ensuring that I was starting from a fresh environment in b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:3236,test,tested,3236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['test'],['tested']
Testability,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:942,test,test,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,2,['test'],['test']
Testability,"(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDif",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1190,log,logic,1190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['log'],['logic']
Testability,(0.90.11) Tests for a distributed Immersed boundary grid + fix some `on_architecture` bugs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3487:10,Test,Tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3487,1,['Test'],['Tests']
Testability,(0.91.14) Extend Lagrangian advection to immersed grids and add tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3765:64,test,tests,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3765,1,['test'],['tests']
Testability,(0.92.2) Add more advection scheme tests; fix order adapting with tracer-specific schemes; fix WENOVectorInvariant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3864:35,test,tests,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3864,1,['test'],['tests']
Testability,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:2602,Test,Test,2602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,9,"['Test', 'test']","['Test', 'test']"
Testability,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:42594,test,tests,42594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['test'],['tests']
Testability,"(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and paramet",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106726,Test,Test,106726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:70,sandbox,sandbox,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['sandbox'],['sandbox']
Testability,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:338,test,tested,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['test'],['tested']
Testability,"), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106605,test,test,106605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114042,test,test,114042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:3015,Test,Testing,3015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,", 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9291,Test,Test,9291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,", :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37420,test,test,37420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,", Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104631,benchmark,benchmarks,104631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:3723,log,log,3723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['log'],['log']
Testability,", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107471,benchmark,benchmark,107471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:1373,test,tests,1373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,6,['test'],"['test', 'tests']"
Testability,",3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37996,test,test,37996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,",Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Dict{String,Field{X,Y,Z,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:101916,test,test,101916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,- Fix doc test; - Revert GPUCompiler 359,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2906:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2906,1,['test'],['test']
Testability,- Uses NCDatasets.jl; - Allows slicing; - Should be fast because a new file is not created for every output time-step (I guess the previous netcdf writer was slow because it created a new file for every output time-step which added a lot of overhead); - See example for usage (it works on CPU!). TODO:; - Global and per variable attributes. Edit:; - Needs to be tested; - We need to discuss halo regions (the dimension lengths are not consistent with the array sizes thanks to halo regions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433:362,test,tested,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433,1,['test'],['tested']
Testability,- [x] Changes `mode` and `force` to overwrite existing; - [x] Change `prefix` to something clearer (maybe `filename`); - [x] Separate keyword `filepath` in `NetcdfOutputWriter` into `dir` and `filename` (or whatever is replacing `prefix`); - [x] Maybe add a couple more tests for `NetcdfWriter`. Closes https://github.com/CliMA/Oceananigans.jl/issues/884; Closes https://github.com/CliMA/Oceananigans.jl/issues/2427,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416:270,test,tests,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416,1,['test'],['tests']
Testability,"- [x] Try comparing with an analytical solution, e.g. Poiseuille flow or Couette flow. This would test the pressure solver.; - [x] See if there's a difference between `Float64` on the CPU and GPU beyond machine epsilon.; - [x] Compare with MITgcm, both running `Float64` on the same CPU.; - [ ] Try comparing with MITgcm at different time steps to look at time-dependence.; - [ ] Try `Float128`. Might not play nice with the GPU.; - [x] We can try some of the stuff from #161 but that might be more work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/168:98,test,test,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168,1,['test'],['test']
Testability,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1880,benchmark,benchmarks,1880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['benchmark'],['benchmarks']
Testability,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1309,test,tests,1309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['test'],['tests']
Testability,". To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that av",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1797,Test,Test,1797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['Test'],['Test']
Testability,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:2073,log,log,2073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,5,['log'],['log']
Testability,".; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Si",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:2954,Test,Testing,2954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,".CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4669,test,test,4669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['test'],['test']
Testability,".com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1547,Benchmark,Benchmark,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['Benchmark'],['Benchmark']
Testability,".jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18563,test,test,18563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,".jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15248,test,test,15248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,".pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:6774,test,tests,6774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['test'],['tests']
Testability,"/ (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo())",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104128,Benchmark,Benchmark,104128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1100,Test,Test,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Test'],['Test']
Testability,"/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.955788617241",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6500,test,test,6500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18765,test,test,18765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15444,test,test,15444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,03c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2724,test,test,2724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"07508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8534,Test,Test,8534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:1789,Log,Logging,1789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Log'],['Logging']
Testability,"1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11397,Test,Test,11397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"11, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7923,test,test,7923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5956,Test,Test,5956,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10164,Test,Test,10164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7228,test,test,7228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111117,benchmark,benchmark,111117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"2 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simula",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:3068,Test,Test,3068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"2 │ 1.60842 │ 3.28596 │; │ Float64 │ 32 │ 1.72783 │ 1.58487 │ 3.00478 │; │ Float64 │ 64 │ 11.0611 │ 1.57428 │ 3.02521 │; │ Float64 │ 128 │ 84.2143 │ 1.5844 │ 3.53368 │; ```; Tracers, with grid size being 256 x 256 x 128:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ┌───────────────┬─────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ tracers │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (0, 0) │ 1.439 s │ 1.440 s │ 1.440 s │ 1.441 s │ 908.03 KiB │ 1656 │ 4 │; │ CPU │ (0, 1) │ 1.539 s │ 1.574 s │ 1.575 s │ 1.613 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (0, 2) │ 1.668 s │ 1.669 s │ 1.670 s │ 1.671 s │ 1.76 MiB │ 2291 │ 3 │; │ CPU │ (1, 0) │ 1.527 s │ 1.532 s │ 1.532 s │ 1.536 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (2, 0) │ 1.690 s │ 1.697 s │ 1.695 s │ 1.698 s │ 1.77 MiB │ 2301 │ 3 │; │ CPU │ (2, 3) │ 2.234 s │ 2.239 s │ 2.241 s │ 2.251 s │ 3.59 MiB │ 3928 │ 3 │; │ CPU │ (2, 5) │ 2.755 s │ 2.838 s │ 2.838 s │ 2.921 s │ 5.18 MiB │ 4908 │ 2 │; │ CPU │ (2, 10) │ 3.588 s │ 3.748 s │ 3.748 s │ 3.908 s │ 10.39 MiB │ 7682 │ 2 │; │ GPU │ (0, 0) │ 9.702 ms │ 12.755 ms │ 12.458 ms │ 12.894 ms │ 1.59 MiB │ 12321 │ 10 │; │ GPU │ (0, 1) │ 13.863 ms │ 13.956 ms │ 14.184 ms │ 16.297 ms │ 2.20 MiB │ 14294 │ 10 │; │ GPU │ (0, 2) │ 15.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:7879,benchmark,benchmarks,7879,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 47,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2569,test,test,2569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,3.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```. ### GPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ GPU │ RectilinearGrid │ ExplicitFreeSurface │ 1.455 ms │ 1.632 ms │ 1.786 ms │ 3.695 ms │ 1.07 MiB │ 3495 │ 10 │; │ GPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 2.277 ms │ 2.315 ms │ 2.472 ms │ 3.774 ms │ 1.56 MiB │ 5257 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 3.285 ms │ 3.347 ms │ 3.543 ms │ 5.177 ms │ 1.70 MiB │ 7742 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 6.804 ms │ 6.924 ms │ 7.050 ms │ 8.149 ms │ 1.74 MiB │ 14313 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.323 ms │ 6.400 ms │ 6.639 ms │ 7.688 ms │ 1.68 MiB │ 12378 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:4160,benchmark,benchmarks,4160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability,"3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104553,Benchmark,Benchmark,104553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['Benchmark']
Testability,"3340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9334,test,test,9334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"3; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = Incom",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107414,benchmark,benchmark,107414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"3; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108078,benchmark,benchmark,108078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"3b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:11018,Test,Test,11018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Test'],['Test']
Testability,"3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76781,Test,Test,76781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"4,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16437,sandbox,sandbox,16437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Testability,"4/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Print",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110560,Test,Test,110560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1056,Test,Test,1056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['Test'],['Test']
Testability,"40103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11440,test,test,11440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"4096 │ 185.419 │ 1.83529 │ 21.2678 │; │ Float64 │ 8192 │ 189.573 │ 3.52748 │ 86.6092 │; │ Float64 │16384 │ 193.026 │ 10.376 │ 350.986 │; └─────────────┴──────┴──────────┴─────────┴─────────┘; ```; Benchmarkable incompressible model:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 6.121 ms │ 6.225 ms │ 6.393 ms │ 7.995 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 64 │ 39.352 ms │ 39.706 ms │ 39.950 ms │ 42.529 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 128 │ 323.897 ms │ 325.763 ms │ 325.708 ms │ 327.232 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 32 │ 6.517 ms │ 6.661 ms │ 6.892 ms │ 9.248 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 45.077 ms │ 45.430 ms │ 45.821 ms │ 49.910 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 390.134 ms │ 390.948 ms │ 391.456 ms │ 395.682 ms │ 1.77 MiB │ 2301 │ 10 │; │ GPU │ Float32 │ 32 │ 3.543 ms │ 3.679 ms │ 3.813 ms │ 5.210 ms │ 2.23 MiB │ 6920 │ 10 │; │ GPU │ Float32 │ 64 │ 3.732 ms │ 3.782 ms │ 3.907 ms │ 4.982 ms │ 2.22 MiB │ 6939 │ 10 │; │ GPU │ Float32 │ 128 │ 3.940 ms │ 4.023 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:5129,benchmark,benchmarks,5129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,"42207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6428,Test,Test,6428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5819,test,test,5819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10027,test,test,10027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,49 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2256,test,test,2256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"4; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:77063,test,test,77063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38134,test,test,38134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3743,benchmark,benchmark,3743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['benchmark'],['benchmark']
Testability,"59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117228,test,test,117228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 171.290 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 2.341 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; ```. We see that the particles with x- and y- coordinates larger than 0.5 get moved after the first time step when I think it shouldn't be. This is because of the following lines:; https://github.com/CliMA/Oceananigans.jl/blob/3e2650373e9c73231681535aadb5b720a830dc97/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L102C4-L104C27. Instead of ; ```julia; iᴿ = length(f, tx, Nx); jᴿ = length(f, ty, Ny); kᴿ = length(f, tz, Nz); ```; I think it should be ; ```julia; iᴿ = length(f, tx, Nx) + ifelse(tx == Periodic(), 1, 0); jᴿ = length(f, ty, Ny) + ifelse(ty == Periodic(), 1, 0); kᴿ = length(f, tz, Nz) + ifelse(tz == Periodic(), 1, 0); ```; The change gives an output log of; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 59.256 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (58.949 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (86.845 ms).; i: 1, t: 100 ms, wall time: 91.015 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 152.524 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 3.068 ms, max(u)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3415:3630,log,log,3630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415,1,['log'],['log']
Testability,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:3328,test,test,3328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,5,['test'],['test']
Testability,"64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51446,sandbox,sandbox,51446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Testability,"7 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9751,Test,Test,9751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8060,Test,Test,8060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_m,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3324,test,test,3324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,"77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117690,Benchmark,BenchmarkTools,117690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['BenchmarkTools']
Testability,"8317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12746,Test,Test,12746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12818,test,test,12818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,8,"['Test', 'test']","['Test', 'test', 'tests']"
Testability,"9, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12274,Test,Test,12274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"93167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.90",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10638,Test,Test,10638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,": 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, titl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:112018,benchmark,benchmark,112018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,": Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UI",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:1201,test,test,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,1,['test'],['test']
Testability,":v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:3788,log,log,3788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['log'],['log']
Testability,"; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107300,benchmark,benchmark,107300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4526,test,testing,4526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['test'],['testing']
Testability,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5913,test,test,5913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['test'],['test']
Testability,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:1913,benchmark,benchmark,1913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,5,"['benchmark', 'test']","['benchmark', 'benchmarks', 'tested', 'tests']"
Testability,"== 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:116506,benchmark,benchmark,116506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,4,"['Test', 'benchmark']","['Test', 'benchmark', 'benchmarks']"
Testability,"> Another thing I noticed is that `@inbounds` is used in places where it can't really be guaranteed, like *inside* [difference operator functions](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid.jl). I couldn't figure out how to test this, but I wonder if `@inbounds` propagates to all of the functions that are called inside its scope (is that the right language)? ; > ; > Specifically I'm referring to patterns like the [RHS calculation for u](https://github.com/climate-machine/Oceananigans.jl/blob/2220ee62685a0570d4dec944f148634a539e9220/src/time_steppers.jl#L160), which is `@inbounds`, but subsequently calls operators like [this](https://github.com/climate-machine/Oceananigans.jl/blob/2220ee62685a0570d4dec944f148634a539e9220/src/operators/ops_regular_cartesian_grid.jl#L71) that are *also* have `@inbounds`.; > ; > In other words, we only need *one* `@inbounds` statement; we don't need multiple nested `@inbounds` statements. @vchuravy can you confirm/deny this? ; > ; > A separate issue with `@inbounds` in places where it can't be guaranteed is that if users write functions / analysis tools using those operators, they might screw up and give out-of-bounds indices to functions that have guaranteed `@inbounds` (and in consequence get mysterious segfaults?) It seems the natural place for `@inbounds` is in the scope of a loop.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/163#issuecomment-479829199_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/164:285,test,test,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/164,1,['test'],['test']
Testability,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/611:53,test,test,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611,1,['test'],['test']
Testability,> The link to benchmarks.jl in the README.md file is broken.; >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/608:14,benchmark,benchmarks,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/608,1,['benchmark'],['benchmarks']
Testability,"@arnscheidt reported this error when running this script. https://github.com/ali-ramadhan/antarctic-ice-shelf-meltwater-outflow/blob/eae17968349d72613ccbd0d5b856cc76b30b7850/ice_shelf_meltwater_outflow_2d.jl. ```; InvalidIRError: compiling _set_gpu!(Cassette.Context{nametype(Ctx),Nothing,Nothing,GPUifyLoops.var""##PassType#422"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields._set_gpu!), OffsetArrays.OffsetArray{Float64,3,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_apply_type); ```. Looking at the full stacktrace it looks like `threadIdx` is undefined so maybe we just forgot to import CUDAnative.jl in the Fields submodule following the big reorganization in #591. There should have been a test for this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/634:1043,test,test,1043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634,1,['test'],['test']
Testability,"@francispoulin @navidcy let's manually test whether this resolves #1780. (It'd be better to have a test that fails, but the tests #1782 stubbornly refuse to fail.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790:39,test,test,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790,4,"['stub', 'test']","['stubbornly', 'test', 'tests']"
Testability,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:46,benchmark,benchmark,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,9,['benchmark'],"['benchmark', 'benchmarked', 'benchmarks']"
Testability,@francispoulin this will hopefully test the question you've raised on #1780 .,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1782:35,test,test,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1782,1,['test'],['test']
Testability,@glwagner I'm testing in this PR using https://github.com/glwagner/OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3553:14,test,testing,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3553,1,['test'],['testing']
Testability,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/126:50,test,tests,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126,5,['test'],"['test', 'tests']"
Testability,@glwagner and I found a factor of 2 bug in the triply periodic pressure solver which now works and passes the convergence test. I also added and cleaned up some pressure solver tests. In doing so I ended up doing a bit of reorganizing and cleanup. Helps with #586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/834:122,test,test,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/834,2,['test'],"['test', 'tests']"
Testability,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/737:30,test,test,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737,3,['test'],['test']
Testability,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:486,test,test,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,4,"['Test', 'test']","['Test', 'test']"
Testability,"@johncmarshall54 suggested that a good validation test for an immersed boundary implementation is a topographic Rossby wave, a la:. https://journals.ametsoc.org/mwr/article/125/9/2293/104481/Representation-of-Topography-by-Shaved-Cells-in-a. which has an analytical solution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:50,test,test,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['test'],['test']
Testability,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1105:575,test,test,575,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105,1,['test'],['test']
Testability,"@mukund-gupta has been trying to run some model tests but might need to set Dirchlet/`Value` boundary conditions for the velocities at the top and bottom. @glwagner would this be easy to add in? For `Flux` boundary conditions I assume we'd have to use 𝜈 instead of κ so something like; ```julia; Gϕ[i, j, 1] += 𝜈*top_gradient.condition / grid.Δz; ```; instead of; ```julia; Gϕ[i, j, 1] += κ*top_gradient.condition / grid.Δz; ```; And for `Value` boundary conditions I assume it's just the line below?; ```julia; ϕ[i, j, 1] = top_value.condition # Note we're setting ϕ, not adding to Gϕ.; ```. I can try adding these in, shouldn't be too hard but just want to double check.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/166:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/166,1,['test'],['tests']
Testability,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:475,Test,Test,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,5,"['Benchmark', 'Test', 'test']","['Benchmark', 'Test', 'test', 'tests']"
Testability,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2418:1070,log,logic,1070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418,1,['log'],['logic']
Testability,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:74,benchmark,benchmarks,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,2,['benchmark'],['benchmarks']
Testability,@tomchor You pointed out that `KernelComputedField` + `TimeAveragedInterval` seemed to be accumulating over time in #1517. This PR just explicitly zeroes out the `KernelComputedField`'s data in `compute!` so everything should still work since `compute!` should recompute everything. Might help uncover accumulation-related bugs?. I couldn't find much wrong otherwise so this is just a shot in the dark. Designing a `KernelComputedField` + `TimeAveragedInterval` test might be better than continuing to try different hacks 😅,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1520:462,test,test,462,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1520,1,['test'],['test']
Testability,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57:259,test,test,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57,1,['test'],['test']
Testability,"A Simple preliminary way to use our advection reconstruction stencils to do high-order Coriolis reconstruction. ```; advection = WENO(grid); coriolis = HydrostaticSphericalCoriolis(scheme = advection); ```. this PR is here just to test the idea, but the design will probably change",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729:231,test,test,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729,1,['test'],['test']
Testability,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:326,test,test-call,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['test'],['test-call']
Testability,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271:734,test,testing,734,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271,1,['test'],['testing']
Testability,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2012:200,test,tests,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012,1,['test'],['tests']
Testability,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['test'],['test']
Testability,"A preliminary implementation of (constant) smagorinsky.; - temporary arrays to be revisited; - need to improve the way to disable it (without loss of performance); - no attempt to try it on GPU. ; Tested with deep_convection example, running nicely with smag_coeff=3.3e-2 and Prandtl_num=1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218:197,Test,Tested,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218,1,['Test'],['Tested']
Testability,"A recent PR broke the user-facing `diffusivity()` function for `SmagorinskyLilly` and this fixes it. It also adds a test to catch this in the future and exports `diffusivity()` at the `TurbulenceClosure` level, since it's a user-facing function.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2913:116,test,test,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2913,1,['test'],['test']
Testability,A thermal wind example where a vertical velocity profile is set up to exactly balance a horizontal temperature gradient. Eventually supposed to become a test. Initially authored by: @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/179:153,test,test,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/179,1,['test'],['test']
Testability,Abstract operations `compute_kinetic_energy` test fails with CUDA error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:45,test,test,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,1,['test'],['test']
Testability,Accidently merged PR #1091 with examples disabled (I was testing docs) and it made its way into v0.46.0 so the stable docs have no examples now. This PR revives the examples. I'll tag v0.46.1 so the examples show up in the stable docs again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1319:57,test,testing,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1319,1,['test'],['testing']
Testability,Add Appveyor for Windows testing and Coveralls for cooler code coverage.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/52:25,test,testing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/52,1,['test'],['testing']
Testability,Add Enzyme test for differentiating a single column model with CATKEVerticalDiffusivity,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837:11,test,test,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837,1,['test'],['test']
Testability,Add Multi GPU testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2526:14,test,testing,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2526,1,['test'],['testing']
Testability,Add Y-partition and XY-partition tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3338:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338,1,['test'],['tests']
Testability,Add a bathymetry test for `ShallowWaterModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1716:17,test,test,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1716,1,['test'],['test']
Testability,Add a test to check surface bc continuous functions work with ImmersedBoundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:6,test,test,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,1,['test'],['test']
Testability,Add a validation script and/or tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204:31,test,tests,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204,1,['test'],['tests']
Testability,Add distributed test pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3326:16,test,test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3326,1,['test'],['test']
Testability,Add documentation section on how to run tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1176:40,test,tests,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1176,1,['test'],['tests']
Testability,Add possible option to test with one file,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2122:23,test,test,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2122,1,['test'],['test']
Testability,Add steady-state test case for the cubed sphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302:17,test,test,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302,1,['test'],['test']
Testability,Add test for autodifferentiating hydrostatic turbulence simulation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867:4,test,test,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867,1,['test'],['test']
Testability,Add test for implicit free surface with immersed boundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2712:4,test,test,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2712,1,['test'],['test']
Testability,Add test of enzyme flux bc,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3643:4,test,test,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3643,1,['test'],['test']
Testability,Add test of tracer advection-diffusion for Enzyme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480:4,test,test,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480,1,['test'],['test']
Testability,Add testing for MultiRegionGrids with `YPartition`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3202:4,test,testing,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3202,1,['test'],['testing']
Testability,Add tests for Face-Face halo filling,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3324:4,test,tests,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324,1,['test'],['tests']
Testability,Add tests for biogeochemistry on lat/lon grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179:4,test,tests,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179,1,['test'],['tests']
Testability,Add tests for computations on slices,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2521:4,test,tests,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2521,1,['test'],['tests']
Testability,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:426,test,tested,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,2,"['benchmark', 'test']","['benchmark', 'tested']"
Testability,Added adapt method for scalar and scalar biharmonic diffusvity + test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:65,test,test,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['test'],['test']
Testability,Added an additional test to the enzyme test set for differentiating a `HydrostaticFreeSurfaceModel` with tracer advection and diffusion.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480:20,test,test,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480,2,['test'],['test']
Testability,Adding norm for fields with some tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1557:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1557,1,['test'],['tests']
Testability,Adding regression test to lat-lon grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2032:18,test,test,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2032,1,['test'],['test']
Testability,"Addressing some of the issues on #3892, though we need tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3893:55,test,tests,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3893,1,['test'],['tests']
Testability,Adds AveragedField test for 256 x 256 x 128 Field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1784:19,test,test,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784,1,['test'],['test']
Testability,"Adds Value Boundary Condition (BC), improves BC function signatures, GPU BC tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/237:76,test,tests,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237,1,['test'],['tests']
Testability,Adds `KernelComputedField <: AbstractField` which is computed using a user-defined `@kernel` function via `KernelAbstractions.jl`. To do:. - [x] Implementation; - [x] Testing; - [x] Example / Docs; - [x] Test complex examples on GPUs. Closes #1246,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1293:167,Test,Testing,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293,2,['Test'],"['Test', 'Testing']"
Testability,Adds a test for broadcasting fields with arrays with singleton dimensions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1947:7,test,test,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947,1,['test'],['test']
Testability,Adds benchmark for free surface solvers on lat-lon immersed boundary + triply-bounded Poisson bench/validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2784:5,benchmark,benchmark,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2784,1,['benchmark'],['benchmark']
Testability,Adds documentation page for convergence tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/782:40,test,tests,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782,1,['test'],['tests']
Testability,Adds momentum equation test for Enzyme extension,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3822:23,test,test,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3822,1,['test'],['test']
Testability,Adds some tests too. Resolves #637,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/984:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984,1,['test'],['tests']
Testability,Adds test for race condition in `compute!(::AveragedField)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1805:5,test,test,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1805,1,['test'],['test']
Testability,Adds tests for Poisson solvers with Flat topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560,1,['test'],['tests']
Testability,"Adds tests for splitting output based on time-interval, e.g., . ```Julia; ow = JLD2OutputWriter(model, (; u);; filename = ""test.jld2"",; ...; file_splitting = TimeInterval(3seconds); ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3523:5,test,tests,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523,2,['test'],"['test', 'tests']"
Testability,Advection scheme benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/934:17,benchmark,benchmarks,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/934,1,['benchmark'],['benchmarks']
Testability,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:53,test,tests,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,9,"['Test', 'test']","['Test', 'test', 'testing', 'tests']"
Testability,"Ah sorry I accidently merged yesterday without addressing this point. Dellar (2011) and other literature I've read commonly use f and f̃ (`\tilde{f}`) to refer to `fz` and `fy`, although I think `fz` and `fy` is clearer and we did decide to switch to `fz` and `fy` at some point. Following the same logic, `βz` and `βy` would be both consistent and clearer. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/899#discussion_r483949249_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/918:299,log,logic,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918,1,['log'],['logic']
Testability,"Allow linear time interpolation between different indices of the field time series triggered by a Float64 (AbstractTime not supported at the moment) index. ; ```julia; julia> fts2 = FieldTimeSeries(""testfile.jld2"", ""u"");. julia> fts2[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts2[2]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 2), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=4.0, min=4.0, mean=4.0. julia> fts2[1.35]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 23×22×16 OffsetArray(::Array{Float64, 3}, -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.7, min=2.7, mean=2.7. julia> fts2[1, 1, 1, 13]; 26.0. julia> fts2[1, 1, 1, 14]; 28.0. julia> fts2[1, 1, 1, 13.67]; 27.34; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236:199,test,testfile,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236,1,['test'],['testfile']
Testability,Allow testing of just a single file,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:6,test,testing,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['testing']
Testability,Allow v1.3 GPU tests to fail on GitLab CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/467:15,test,tests,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/467,1,['test'],['tests']
Testability,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:105,test,tests,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['test'],['tests']
Testability,Also:. * Changes test_examples.jl to spew example file into the build log on error.; * Makes a minor correction to the replace strings for the `ocean_wind_mixing_ and_convection.jl` example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/748:70,log,log,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748,1,['log'],['log']
Testability,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:238,test,tests,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,3,['test'],"['test', 'testing', 'tests']"
Testability,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/13:747,benchmark,benchmark,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13,4,"['Benchmark', 'benchmark']","['BenchmarkTools', 'benchmark']"
Testability,"Apparently the figures in the [Convergence tests](; https://clima.github.io/OceananigansDocumentation/latest/validation/convergence_tests/) and Stratified Couette flow sections of the documentation aren't showing. I suspect it's a broken link or something (probably very easy to fix). Sorry if you guys are aware of this already, but I couldn't find any issue about it. Cheer!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1212:43,test,tests,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212,1,['test'],['tests']
Testability,"Array conversions when fetching output trigger `copyto!` and then `getindex`, which is in turn disallowed. This PR fixes an issue with output on the GPU on master. I'm a bit perplexed why the `jld2_field_output` test didn't pick this up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1025:212,test,test,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1025,1,['test'],['test']
Testability,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:298,log,logic,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['log'],['logic']
Testability,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662:0,Assert,Assert,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662,2,"['Assert', 'test']","['Assert', 'test']"
Testability,"At high enough ~~vertical~~ vertical + horizontal resolution, it seems that the `zonally_averaged_baroclinic_adjustment.jl` validation test blows up with `IsopycnalSkewSymmetricDiffusivity`; specifically:. ```julia; gerdes_koberle_willebrand_tapering = FluxTapering(1e-2); gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = 1000,; κ_symmetric = 900,; slope_limiter = gerdes_koberle_willebrand_tapering); ```. For example, with 50m vertical resolution (Nz=20, Lz=1000m, 20km horizontal resolution) we find. https://user-images.githubusercontent.com/15271942/164360760-ef03fc9d-e07a-4b50-9e80-bd79997cfa1d.mp4. while at 25m resolution (same extent, horizontal resolution, time-step) we find. https://user-images.githubusercontent.com/15271942/164360772-e39a08e4-eb5e-48e4-bfc4-cde1e241ec0f.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2453:135,test,test,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2453,1,['test'],['test']
Testability,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] 2D QG turbulence: explore energy and enstrophy cascades; - [ ] lee wave generation and breaking (will require large-scale flow field and bathymetry),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/159:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/159,1,['test'],['tests']
Testability,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Munk gyre; - [ ] Stommel gyre,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/158:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/158,1,['test'],['tests']
Testability,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157:48,test,tests,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157,1,['test'],['tests']
Testability,At some point we'd need to revisit the benchmarks. (https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/). We might wanna discuss what to include there and how we could perhaps automate the procedure? It doesn't need to be completely automated but perhaps we should have a workflow that we could run every now and again that produces a set of figures that are stored in OceananigansArtifacts.jl or somewhere so the docs update automatically?. (Feel free to convert this to a Discussion if it's more appropriate.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3166:39,benchmark,benchmarks,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166,2,['benchmark'],['benchmarks']
Testability,"At the moment . `ΔF[i-1] = C[i] - C[i-1]` where `C` and `F` are the center and face coordinate, respectively. On the other hand, the derivative on the face `[i]` is calculated with `(c[i] - c[i-1]) / ΔF[i]` (where `c` is the value of the derived variable at the centers). therefore, it has to be that `ΔF[i] = C[i] - C[i-1]`. Because of how we test, this bug was miraculously eluding all testing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2150:344,test,test,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150,2,['test'],"['test', 'testing']"
Testability,At the moment only `XPartition` is tested:. https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/test/test_multi_region_unit.jl#L14-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3202:35,test,tested,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3202,2,['test'],"['test', 'tested']"
Testability,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3112:1006,test,test,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112,5,['test'],"['test', 'testhelpers']"
Testability,"At the moment, supposedly we can change. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/dependencies_for_runtests.jl#L82. to. ```julia; test_file = ""test_some_new_feature.jl""; ```. and then. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/test/runtests.jl#L6-L10. will run that test file. But then, the `runtest.jl` *will continue* running the whole test suite!. We'd like to stop after testing the `test_file`, right?. cc @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507:128,test,test,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507,5,['test'],"['test', 'testing']"
Testability,"At the moment, the fill halo regions follow a particular ordering where. Flux, Value, Gradient > Periodic; Periodic > Halo Communication. where > indicates the priority of execution.; We also fill the two sides of one direction together. ; This execution order cannot be respected in case:; ```julia; bc.west isa Periodic; bc.east isa Periodic; bc.south isa Flux; bc.north isa DistributedCommunication; ```. The possible solutions are two:; - eliminate the order requirements between Flux, Value, Gradient and Periodic by including corners in all local `fill_halo_regions!` (at the moment only `Periodic` fills the corners); - do not fill two sides together. probably the first solution is better because it leads to simpler code both in terms of actual implementation and in terms of logic of execution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3342:785,log,logic,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342,1,['log'],['logic']
Testability,Attempt and making tests on https://github.com/CliMA/Oceananigans.jl/pull/2865 pass,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2898:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2898,1,['test'],['tests']
Testability,Barotropic turbulence validation tests on RegularLatitudeLongitudeGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:33,test,tests,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['test'],['tests']
Testability,"Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:102158,test,test,102158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750:1163,test,test,1163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750,2,['test'],['test']
Testability,"Begs the question of whether this code was tested? When users pass a tuple to `forcings`, we wrap it inside `MultipleForcings`. Thus we need this method to unwrap the tuple when adding advective forcings to the total velocity field. @jagoosw @simone-silvestri . Should we add a test?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259:43,test,tested,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259,2,['test'],"['test', 'tested']"
Testability,Benchmark abstract operations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/870:0,Benchmark,Benchmark,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870,1,['Benchmark'],['Benchmark']
Testability,Benchmark script for immersed boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1699:0,Benchmark,Benchmark,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1699,1,['Benchmark'],['Benchmark']
Testability,Benchmark script that also calculates CPU->GPU speedup.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:0,Benchmark,Benchmark,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['Benchmark'],['Benchmark']
Testability,Benchmark scripts should report CPU and GPU being used,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/466:0,Benchmark,Benchmark,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/466,1,['Benchmark'],['Benchmark']
Testability,Benchmark tests: Just do small sizes on GPU models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/733:0,Benchmark,Benchmark,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733,2,"['Benchmark', 'test']","['Benchmark', 'tests']"
Testability,Benchmarking forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/370:0,Benchmark,Benchmarking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/370,1,['Benchmark'],['Benchmarking']
Testability,Benchmarking fully loaded simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089:0,Benchmark,Benchmarking,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089,1,['Benchmark'],['Benchmarking']
