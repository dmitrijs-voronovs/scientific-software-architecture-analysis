quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:197,redund,redundant,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263,1,['redund'],['redundant']
Safety,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:534,avoid,avoid,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801,1,['avoid'],['avoid']
Safety,I don't think so.; Now both `h` and `z` are just floats so the `.` you suggest is redundant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662:82,redund,redundant,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662,1,['redund'],['redundant']
Safety,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:61,avoid,avoid,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108,1,['avoid'],['avoid']
Safety,"I guess part of the confusion is that some kwargs are for users while others were introduced for checkpointer usage. I agree that `timestepper_method` and `timestepper` are redundant. We should be able to just do something like `time_stepper = AdamsBashforth2()` for something. Or go with your suggestion on Slack of having the choice of either passing a Symbol for a full struct. Users might usually pass `tracers = (:a, :b)` but checkpointer might pass `tracers = TracerFields(...)`. > It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. I'm totally on board with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852:173,redund,redundant,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852,1,['redund'],['redundant']
Safety,"I guess we can avoid using `Flat` for the moment and that looks to fix the problem. @fadaie91 , did you want to try this with the example and your original problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1306151916:15,avoid,avoid,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1306151916,1,['avoid'],['avoid']
Safety,"I guess we talked on Slack but yeah the `depends_on` keyword argument idea does seem nicer and more general than just a `field_in_signature` or `field_dependent` kwarg. I guess to avoid interpolation issues we could just not interpolate for now which would still work for a large number of common boundary condition functions, e.g.; ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; τ₁₃_linear_drag(x, y, t, u, p) = p.μ * p.H * u; ```. Maybe interpolating these fields tangentially at the boundary would become easy once we have something like a lazy field or `ReducedField` implementation (#525)?. Are you thinking of resolving this issue as part of PR #894?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685742271:180,avoid,avoid,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-685742271,1,['avoid'],['avoid']
Safety,I guess when there are no tracers you want to avoid showing kappa.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033:46,avoid,avoid,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033,1,['avoid'],['avoid']
Safety,"I have a revision to my original post. Rather than add the size of the grid as types in the `RegularCartesianGrid` signature, we perhaps should come up with a `Topology` type indicator, eg:. ```julia; abstract type AbstractTopology end. struct Bounded <: AbstractTopology end; struct Flat <: AbstractTopology end; struct Periodic <: AbstractTopology end; ```. `AbstractGrid` then becomes. ```julia; abstract type AbstractGrid{FT, Tx, Ty, Tz} end; ```. where `(Tx, Ty, Tz)` denote the ""topology"" of the grid in their respect directions. For `Flat` grids, differentiation will return `0`, and interpolation will be reduced to an identity function. Distinguishing between `Periodic` and `Bounded` topologies will be useful for the implementation of higher-order operators that need to limit to a second-order derivative near non-periodic boundaries (this is important for avoiding the dreaded ""halo filling explosion""). I think this also corresponds more closely to the mathematical meaning of a ""Periodic"" and ""Flat"" dimension. Another thought is that we should make the constructor more verbose, eg. ```julia; RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz), topology=(Tx, Ty, Tz)).; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-541196529:869,avoid,avoiding,869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-541196529,1,['avoid'],['avoiding']
Safety,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:501,avoid,avoid,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,1,['avoid'],['avoid']
Safety,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:352,detect,detected,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['detect'],['detected']
Safety,"I have tried to follow the discussion but think I missed an important bit, sorry if it was stated above. @navidcy : what's the motvation for building `A` explicitly in the multigrid method? . As has been said before, this is very expensive in 3D and hope we can avoid it if possible. But I say this having forgotten most of what I used to know about mulgrid methods. ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525:262,avoid,avoid,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525,1,['avoid'],['avoid']
Safety,"I like it! The concept a function name that is something like `take_action_on(argument)` is typical, eg the function `fill!(array, value)` rather than `fill_value!(array, value)` (which is redundant for the reader). I liek the readability of `mask_immersed = 0`, as in ""mask immersed [grid cells with] = value"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585:189,redund,redundant,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585,1,['redund'],['redundant']
Safety,I like kwarg because it’s more verbose. ; Is there any other reason why it should be positional?; As you said `grid=grid` can be avoided although some people like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077:129,avoid,avoided,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077,1,['avoid'],['avoided']
Safety,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:503,avoid,avoid,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690,1,['avoid'],['avoid']
Safety,I merged main but cancelled the CI to avoid clutter. We should restart the CI when there is no other PR running CI tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179:38,avoid,avoid,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179,1,['avoid'],['avoid']
Safety,"I noticed there was a problem with the halos so I hard coded it to be `(3,3)`, which is appropriate for the default advection scheme. Now the example seems to yield `NaNs`, which is another mystery. Maybe the halos are not set correctly?. ```; Time stepping ShallowWaterModel: Time stepping ShallowWaterModel: Error During Test at Error During Test at Time stepping ShallowWaterModel: /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/test/test_distributed_models.jl:496; --; &nbsp; | Got exception outside of a @test; &nbsp; | Time stepping ShallowWaterModel: time = 1.9999999999999998, iteration = 2: NaN found in field uh. Aborting simulation.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] error_if_nan_in_field at /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/src/Diagnostics/nan_checker.jl:22 [inlined]; &nbsp; | [3] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:uh,),Tuple{Field{Face,Center,Center,CPU,OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}},BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}}},CoordinateBoundaryConditions{Nothing,Nothing}}}}}}}, ::ShallowWaterModel{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},MultiCPU{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534:648,Abort,Aborting,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534,1,['Abort'],['Aborting']
Safety,"I prefer the three letter notation because it's more explicit. I'm worried that mistakes might be easier to make, since the current format has a redundancy that in my experience often catches hard to find bugs when coding and formatting long expressions. I guess I also feel it helps me ""visualize"" terms but maybe that's just me. Here's an example of such an expression:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L262-L301. I agree though that the ""minimal"" notation is more readable for short expressions like the example above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105:145,redund,redundancy,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105,1,['redund'],['redundancy']
Safety,"I propose. ```julia; xspacing(X, Y, Z, grid); yspacing(X, Y, Z, grid); zspacing(X, Y, Z, grid); ```. where `X, Y, Z` are all _instantiated_ locations eg. ```julia; x = xspacing(Center(), Center(), Center(), grid); ```. I propose we avoid ""one location"" versions that only work for rectilinear / lat-lon grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384:232,avoid,avoid,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384,1,['avoid'],['avoid']
Safety,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:856,avoid,avoid,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['avoid'],['avoid']
Safety,"I see @glwagner's point. I'm a bit skeptical in that part of the PR (which claims that trig functions should be avoided). Perhaps we can elaborate a bit more on that or point the reader to some other source? I'm a bit on the fence. On the other hand, if I was trying to code up something and was ending up having my code 100 slower because I was doing `cos(pi/4)` instead of `sqrt(2)/2`, then I'd be very grateful if somebody pointed it out in a ""Tips"" section!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101:112,avoid,avoided,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101,1,['avoid'],['avoided']
Safety,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:1005,redund,redundant,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['redund'],['redundant']
Safety,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:921,predict,predictable,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,1,['predict'],['predictable']
Safety,I think a doctest is a good idea... just avoided it here because they're often finnicky and I didn't feel like I had the time to debug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824:41,avoid,avoided,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824,1,['avoid'],['avoided']
Safety,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:90,avoid,avoiding,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652,1,['avoid'],['avoiding']
Safety,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:365,Recover,Recovering,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187,1,['Recover'],['Recovering']
Safety,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:1085,avoid,avoid,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554,1,['avoid'],['avoid']
Safety,I think it's not the end of the world if we go a few days without docs. It's a risk but it's not worth losing sleep and mental health over this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908:79,risk,risk,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908,1,['risk'],['risk']
Safety,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760:903,avoid,avoid,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760,1,['avoid'],['avoid']
Safety,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:1118,avoid,avoid,1118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,2,['avoid'],['avoid']
Safety,"I think that's a fine strategy. We can add a kwarg to `NonhydrostaticModel` called `hydrostatic_pressure_anomaly`. We can set it to `CenterField(grid)` to preserve existing behavior, or set it to `nothing` to avoid the separation. And we should probably make `nothing` default so that triply periodic problems can be done out of the box. Then we don't have to re-do the regression tests either because we preserve existing behavior... I think that's also a less invasive change than this PR because we don't have to change `pressures` to `pressure` everywhere, hmm. Since you've done most of the legwork I think you have prerogative to open a new PR if you like (and I can help once you do).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088540295:209,avoid,avoid,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088540295,1,['avoid'],['avoid']
Safety,"I think the conclusion is that we need to use `mapreduce` to avoid Tullio, but we can't use `AbstractOperations` (because the CFL formula involves an operation between fields at different locations, which `AbstractOperations` are not designed to do)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362:61,avoid,avoid,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362,1,['avoid'],['avoid']
Safety,I think the outer one just transforms `kwargs` in positional `args` by requiring a `time` specified and filling the type of time in the parametric type `T`. . I think we can safely delete the interior constructor (if we have no need of something like `Clock(0)`),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149:174,safe,safely,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149,1,['safe'],['safely']
Safety,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:1018,safe,safer,1018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072,1,['safe'],['safer']
Safety,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136:587,avoid,avoid,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136,1,['avoid'],['avoid']
Safety,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:95,avoid,avoid,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['avoid'],['avoid']
Safety,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:661,avoid,avoiding,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,2,['avoid'],"['avoiding', 'avoids']"
Safety,"I think this problem is more general than just `AveragedField`. It appears to apply to all reductions and broadcasting with `AbstractOperations`. For example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.43",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:517,avoid,avoid,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['avoid'],['avoid']
Safety,"I think we may want to regenerate the regression data, and perhaps use `test_steps=10`. . I can open a new PR that will avoid adding the old, unused regression data to the repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542926505:120,avoid,avoid,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542926505,1,['avoid'],['avoid']
Safety,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/429:411,avoid,avoid,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429,1,['avoid'],['avoid']
Safety,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:545,avoid,avoiding,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['avoid'],['avoiding']
Safety,I think we should use `return nothing` at the end of every function to avoid confusion.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364:71,avoid,avoid,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364,1,['avoid'],['avoid']
Safety,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:50,recover,recover,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481,1,['recover'],['recover']
Safety,"I took those values from the Model Setup-Turbulent diffusivity closures and large eddy simulation models-constant anisotropic diffusivity section of the documentation. Probably should have sanity checked them beforehand. > julia> using Oceananigans.TurbulenceClosures; >; >julia> closure = AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1); >AnisotropicDiffusivity: (νx=0.001, νy=0.001, νz=0.05), (κx=0.002, κy=0.002, κz=0.1). Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The kinematic viscosity `νh=1e-3` looks to be much too big, though, with typical values ranging from `1.8 *10^-6` m^2/sec at 0ºC to `1.0*10^-6` m^2/ sec at 20ºC. However, substituting those measured values in results in an even more fantastic blowup than before:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763049-b720fa80-2aae-11eb-860e-ce707cd9d874.gif). Substituting in a larger value (1) for the kinematic viscosity while keeping the above eddy diffusivities also leads to mayhem:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763726-5c889e00-2ab0-11eb-9a97-a6368ea470a3.gif). I should also note that the simulation issues happening in areas of strong temperature contrast are not exclusive to this specific kind of simulation. Even a simple wind stress simulation I tried to set up earlier with a fairly normal thermocline exhibits bizarre behavior at it (you'll probably have to view the gif frame by frame):; ![More Degeneracy](https://user-images.githubusercontent.com/55706146/99763478-cfdde000-2aaf-11eb-964f-b5c3e76c9e83.gif). Given the above results, i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824:189,sanity check,sanity checked,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824,1,['sanity check'],['sanity checked']
Safety,"I tried to use CUDA's [`compute-sanitizer`](https://cuda.juliagpu.org/stable/development/debugging/#compute-sanitizer) to debug the memory issue, but couldn't get anything useful out of it so I went back to debug print statements lol. I printed out the value of `maximum(CuArray(randn(100)))` which should error after the illegal memory access occurs. So I peppered these statements around to try and find where the error happens. The issue happens somewhere here:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L246-L252. Adding. ```julia; κu★ = convert(eltype(grid), κu★); κc★ = convert(eltype(grid), κc★); κe★ = convert(eltype(grid), κe★); ```. causes the MWE to work, which is weird because `@show` on the CPU tells me that they are `Float32` anyways. And I'm not sure on the GPU because `@cushow` can't show strings. Commenting out. ```julia; # κu★ = mask_diffusivity(i, j, k, grid, κu★); # κc★ = mask_diffusivity(i, j, k, grid, κc★); # κe★ = mask_diffusivity(i, j, k, grid, κe★); ```. also causes the MWE to work. I haven't been able to isolate the problematic line/operation yet. And as far as I can tell, the code used to compute `κuᶜᶜᶠ`, `κcᶜᶜᶠ`, and `κeᶜᶜᶠ` is all type-safe. Will continue later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361:1339,safe,safe,1339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361,1,['safe'],['safe']
Safety,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453:866,detect,detected,866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453,1,['detect'],['detected']
Safety,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:803,avoid,avoid,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,1,['avoid'],['avoid']
Safety,"I will look into this soon as I really want to avoid NaN's, as I'm getting today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307:47,avoid,avoid,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307,1,['avoid'],['avoid']
Safety,"I wish I left more info in PR #1229 haha but I think keeping the file open between writes was actually an oversight. My thinking was that you don't want to leave the file open when you don't explicitly need it to be open in case the simulation or Julia crashes. In some cases, this could corrupt the file or could leave the file unreadable by other processes until the Julia process exits. NetCDF files and NCDatasets.jl may not suffer from these issues, but I was probably doing it to be safe. If downgrading `NetCDF_jll` works that seems like a fine temporary fix? I don't think Oceananigans.jl needs super new features from NetCDF?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242:489,safe,safe,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242,1,['safe'],['safe']
Safety,"I wonder if we can lean on the compiler to avoid having to store objects directly, eg. ```julia; struct SumOfFields{N, F}; fields :: F; function SumOfFields{N}(fields...) = new{N, typeof(fields)}(fields); end. @inline getindex(s::SumOfFields{1}, i, j, k) = @inbounds s.fields[1][i, j, k]; @inline getindex(s::SumOfFields{2}, i, j, k) = @inbounds s.fields[1][i, j, k] + s.fields[2][i, j, k]; @inline getindex(s::SumOfFields{3}, i, j, k) = @inbounds s.fields[1][i, j, k] + s.fields[2][i, j, k] + s.fields[3][i, j, k]; ```. then inside kernels maybe it'll be enough to write. ```julia; i, j, k = @index(Global, NTuple). U = SumOfFields{2}(velocities, background_fields.velocities). div_Uc(i, j, k, grid, U, c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1435106594:43,avoid,avoid,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1435106594,1,['avoid'],['avoid']
Safety,"I would also experiment with the 'molecular' diffusivity/viscosities. What happens when they are all set to the same number? Some mixing up of the constants could cause a bug. Along the same lines, it could be good to try a simulation with `Δx = Δy = Δz` to make sure mixing those up isn't causing a bug. Changing the reference density might be a good sanity check. It drops out of the incompressible Navier-Stokes equations so it's value shouldn't change results (ie it could be 1 or it could be κh)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136#issuecomment-478706459:352,sanity check,sanity check,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136#issuecomment-478706459,1,['sanity check'],['sanity check']
Safety,"I would have rather left the volume in the flux divergence to avoid this type of confusion. In a finite volume scheme, the advection tendency is $\frac{\sum_k F_k}{V_c}$ , where there is no mention of areas because they should be embedded in the fluxes calculation. Then the cell volume $V_c$ is a 1D metric in a 1D problem, a 2D metric in a 2D problem and a 3D metric in a 3D problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928:62,avoid,avoid,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928,1,['avoid'],['avoid']
Safety,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990:39,avoid,avoid,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990,1,['avoid'],['avoid']
Safety,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:632,detect,detected,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,1,['detect'],['detected']
Safety,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:81,avoid,avoids,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,1,['avoid'],['avoids']
Safety,"I'll wait till it's ready to review in detail, but my main high-level comment is that we need to ensure that, at the end of a time-step, both the prognostic state (horizontal velocities and tracers) and auxiliary state (pressure, vertical velocity, eddy diffusivities) are all consistent and available for output at the current model time. If we intertwine communication with the computation of the auxiliary state and tendencies, then we should _define_ the tendencies as part of the auxiliary state. This will change the semantics and logic of the time stepping loop. But I think it at least as rational as our previous organization of events. The main change is that tendencies will now be computed one ""extra"" time in a simulation (at the very last time-step, the tendencies are not needed if no further time-steps will be taken). In the vast majority of cases this extra cost is negligible because simulations run for hundreds or hundreds of thousands of time-steps. There is the slightly possibility of pessimizing the edge case of a simulation that takes one time step, which may be useful for parameter estimation. For that purpose we may want to avoid computing the ""extra"" tendency. I'm thinking though that we should save that additional optimization until we need it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616:1155,avoid,avoid,1155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616,1,['avoid'],['avoid']
Safety,I'm detecting also a massive slow down in model execution and out of control allocations on the CPU. Type inference failure? Unfortunate to find it this late after the PRs are merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093:4,detect,detecting,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093,1,['detect'],['detecting']
Safety,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:27,Avoid,Avoid,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544,4,"['Avoid', 'avoid', 'redund', 'safe']","['Avoid', 'avoid', 'redundant', 'safely']"
Safety,I'm having trouble following your example. Can you come up with a simpler illustration of the issue and avoid constructions with many operations on a line?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837:104,avoid,avoid,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837,1,['avoid'],['avoid']
Safety,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:116,redund,redundant,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['redund'],['redundant']
Safety,"I'm not planning on running simulations with surface waves any time soon, so this doesn't directly affect me for now. That said, I think `stokes_drift` is the more correct term (regardless of the possibility of a free surface feature in the future). After all what is imposed is a Stokes drift, so I think calling it `stokes_drift` avoids confusion/ambiguity!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692:332,avoid,avoids,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692,1,['avoid'],['avoids']
Safety,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:175,safe,safe,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,2,['safe'],"['safe', 'safest']"
Safety,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:450,avoid,avoiding,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961,1,['avoid'],['avoiding']
Safety,I'm only concerned the warning is confusing rather than helpful. The problem on #1554 was solved by avoiding `BackgroundField`... ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1556#issuecomment-815862625:100,avoid,avoiding,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1556#issuecomment-815862625,1,['avoid'],['avoiding']
Safety,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:741,Abort,Aborted,741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,2,['Abort'],['Aborted']
Safety,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024:261,redund,redundancies,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024,1,['redund'],['redundancies']
Safety,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:335,avoid,avoid,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,1,['avoid'],['avoid']
Safety,"I've been thinking on how to divide the function, but it will require the duplication of the lines: ; ```; filename = first(split(basename(filepath),""."")) * ""_part""; filelist = filter(startswith(filename), readdir(folder)); existing_files = length(filelist) > 0; ```; within the code, how important is it to avoid duplication vs clarity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2416111586:308,avoid,avoid,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2416111586,1,['avoid'],['avoid']
Safety,"I've realized that it doesn't make sense to include either the tendencies or pressures in `state`, as neither of these is actually known at the time that boundary condition functions or forcing functions are called. so we just have `state = (velocities=U, tracers=C, diffusivities=K)`. This also means that we need a special solution for implementing predictor velocity boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-598943018:351,predict,predictor,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-598943018,1,['predict'],['predictor']
Safety,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:612,redund,redundantly,612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,1,['redund'],['redundantly']
Safety,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371:661,avoid,avoided,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371,1,['avoid'],['avoided']
Safety,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:217,predict,predictor,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,2,"['avoid', 'predict']","['avoid', 'predictor']"
Safety,"In the HDF5 outputs for dedalus, we have a ""tasks"" group that contains the specified output tasks, to avoid any name collisions like you mentioned. HDF5 also lets you attach multiple scales to each dimension of the dataset, so in the ""time"" dimension we have scales for the output index, simulation iteration, simulation time, and real-world time. BTW I really like that indexing from zero stuff :grin:.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702087194:102,avoid,avoid,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702087194,1,['avoid'],['avoid']
Safety,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:226,abort,abort,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['abort'],['abort']
Safety,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799:147,avoid,avoid,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799,1,['avoid'],['avoid']
Safety,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:789,avoid,avoid,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['avoid'],['avoid']
Safety,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:48,avoid,avoided,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103,1,['avoid'],['avoided']
Safety,"Interesting that `mutable`s can't be `isbits`. But `Array` is mutable and `isbits`? Maybe some exceptions... I do think you should avoid fields with abstract or unspecified types in all cases (when simple, like this one) though, even if just for style points, but also to avoid an unexpected performance gotcha. `Clock{T}` seems appropriate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073:131,avoid,avoid,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073,2,['avoid'],['avoid']
Safety,"Interesting. We have deliberately avoided operations for field time series but we can consider it. How does this work for operations that involve both a Field and a FieldTimeSeries? I'm worried this will be a bit brittle and potentially lead to some wasted time for users, since it may only work for the simplest cases. Another issue is that we don't have a time derivative operator. Another way to implement a time series computation is to make a new/empty FieldTimeSeries, and then loop over the time-index to compute each field in the time series. Is this PR merely a convenience to avoid that loop? Are there other solutions / syntax we could think about supporting that might be more useful / generalize better for users?. Note I think for big feature changes like this it's best to discuss in an issue first before having a PR, but we can discuss here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393:34,avoid,avoided,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393,2,['avoid'],"['avoid', 'avoided']"
Safety,Introduces range of acceptable CUDA packages to avoid bug in 3.4.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997:48,avoid,avoid,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997,1,['avoid'],['avoid']
Safety,Is `Architectures.next_stream()` redundant?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2748:33,redund,redundant,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2748,1,['redund'],['redundant']
Safety,Is `calc_∇²!` redundant in view of `compute_∇²!`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2638:14,redund,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638,1,['redund'],['redundant']
Safety,Is it also safer to infer `FT` from `grid`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060:11,safe,safer,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060,1,['safe'],['safer']
Safety,"Is the server headless? Have you tried writing. ```julia; ENV[""GKSwstype""] = ""100""; ```. before running the script?. This is a known issue with GR on headless systems:. * https://github.com/jheinen/GR.jl/issues/278; * https://discourse.julialang.org/t/deactivate-plot-display-to-avoid-need-for-x-server/19359",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867130275:279,avoid,avoid-need-for-x-server,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867130275,1,['avoid'],['avoid-need-for-x-server']
Safety,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595:8,redund,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595,1,['redund'],['redundant']
Safety,"It can, it needs either to be modified, or for the closures themselves to be modified to avoid spitting `NaN`s (constant Smagorinsky has the same issue as AMD in that fields cannot be constant, which is why this test was failing). I think it makes sense to modify the closure implementation to solve this problem, since I think the resulting behavior will actually be more correct (the `NaN` is a numerical issue rather than a mathematical feature of the model) and the computational cost of the if statements are hopefully in the noise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260#issuecomment-520832351:89,avoid,avoid,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260#issuecomment-520832351,1,['avoid'],['avoid']
Safety,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:601,avoid,avoid,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['avoid'],['avoid']
Safety,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:775,risk,risk,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['risk'],['risk']
Safety,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:173,Avoid,Avoid-global-variables,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,1,['Avoid'],['Avoid-global-variables']
Safety,It seems like the `Δt` that is calculated in `accumulate_result!` does not agree with the simulation `Δt` because of finite precision arithmetic. Wouldn't it be better to pass the simulation `Δt` to the schedule so everything becomes more consistent and we avoid discrepancies between schedule time and simulation time?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303:257,avoid,avoid,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303,1,['avoid'],['avoid']
Safety,"It seems this updates a lot of versions, including StructArrays. Seems like a good idea but there are some failed tests. When I looked at the errors one of them seemed to be about `OffsetArrays`, copied below right before the stacktrace. Not sure how to resolve this but I suspect others have ideas. ```; ┌ Warning: Could not use exact versions of packages in manifest, re-resolving;   | └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1526;   | ERROR: Unsatisfiable requirements detected for package OffsetArrays [6fe1bfb0]:;   | OffsetArrays [6fe1bfb0] log:;   | ├─OffsetArrays [6fe1bfb0] has no known versions!;   | └─restricted to versions 1.4.0-1 by Oceananigans [9e8cae18] — no versions left;   | └─Oceananigans [9e8cae18] log:;   | ├─possible versions are: 0.58.5 or uninstalled;   | └─Oceananigans [9e8cae18] is fixed to version 0.58.5;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627:543,detect,detected,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627,1,['detect'],['detected']
Safety,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:1054,avoid,avoid,1054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['avoid'],['avoid']
Safety,"It was my impression that `Δx` worked differently. I even asked a similar question [here](https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1368277630) about it. But if it returns the same thing, maybe indeed `xspacing` is redundant. I believe the functions `xspacings()` and such (which return an array) are novel and necessary though, right @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435:239,redund,redundant,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435,1,['redund'],['redundant']
Safety,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958:749,avoid,avoid,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958,1,['avoid'],['avoid']
Safety,"It's a bit hard to tell what's gone wrong here at this point. I'd do something like; * Create a local branch with `git branch logging_orig $some_hash_or_branch_name` or something to keep this safe. If you've lost the original branch or hash name, don't panic (and don't delete your .git directory)! You can use `git reflog` to find it again.; * Create and check out another local branch as a work in progress `git checkout -b logging_wip logging_orig`; * Squash your changes with `git rebase -i` on `logging_wip` branch into a single commit.; * Reset your master (this PR) to the new rewritten upstream master `git checkout master; git reset --hard origin/master` (presuming origin is `git@github.com:climate-machine/Oceananigans.jl.git`); * Cherry pick the single commit from `logging_wip` onto this new master with `git cherry-pick logging_wip`.; * Force push your new master up to this pull request. (By the way, this would probably be clearer for you if you'd made the original pull request off a branch rather than your master branch. Generally that's a good idea, especially if you want to do multiple PRs)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496:192,safe,safe,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496,1,['safe'],['safe']
Safety,"It's annoying to constantly write things like `Face` and `Cell` in Oceananigans scripts. I wonder if we can develop some notation that allows this to be avoided in the vast majority of use cases. We can introduce notation `:u`, `:v`, `:w`, and `:c` to indicate the velocities and tracer locations. Thus we could write. ```julia; x = xnodes(:c, grid); ```. to get `x` at tracer points. Or to build a tracer field,. ```julia; c = Field(:c, GPU(), grid); ```. Note that we currently require. ```julia; c = Field(Cell, Cell, Cell, GPU(), grid); ```. (a side note is that the `grid` should probably come before the `arch`, but that's another issue.). An alternate design would use the function `location`. Right now this is defined. ```julia; location(::AbstractField{X, Y, Z}) where {X, Y, Z} = (X, Y, Z) # note no instantiation; ```. We could define a couple new methods that allow something like. ```julia; x = xnodes(location(:c), grid); ```. for example. I suppose this is the quickest route to the functionality I'm proposing, since we'd have to change almost no existing code. I also wonder if this would allow. ```julia; momentum_flux = @at(location(:w), w * c); ```. That doesn't seem very easy to read so maybe we can discuss how to specify the location of abstract operations transparently.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/766:153,avoid,avoided,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/766,1,['avoid'],['avoided']
Safety,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:815,avoid,avoid,815,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,1,['avoid'],['avoid']
Safety,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:119,redund,redundant,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,3,"['recover', 'redund']","['recovers', 'redundant']"
Safety,"It's coming from this annoying function:. https://github.com/CliMA/Oceananigans.jl/blob/30e3e05fe661cb5f7a0db37ab6c3f42ac8c5f80e/src/Fields/field_tuples.jl#L56-L83. which we can certainly simplify. We can also play around this avoiding hitting this line altogether, at least for a certain class of models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214:227,avoid,avoiding,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214,1,['avoid'],['avoiding']
Safety,"It's used for some of the simulations in this paper to mitigate a too-low subgrid tracer flux prediction in free convection:. https://journals.ametsoc.org/view/journals/phoc/51/5/JPO-D-20-0178.1.xml. In cases that lack sufficient shear it seems that AMD can underpredict the eddy viscosity near boundaries. Almost all cases of interest have some mean shear though --- free convection is essentially an edge case. Others may use it too, I don't know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829:94,predict,prediction,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829,1,['predict'],['prediction']
Safety,"I’m happy with output_writers.jl; I think all the code in that file is appropriately related. The checkpointer could provide its own constructor to avoid excess memory allocation. . For GPU problems I don’t think there is an issue: checkpointed arrays can b loaded into CPU memory rather than GPU memory, and then the data can be copied into the fields allocated by the model constructor. So at first glance the excess memory allocation does not seem like a major issue on modern CPUs. . I am particularly concerned about the maintainability of the checkpointer, since it will need to be updated every time a new feature is added. Let’s make sure the design is easy to maintain before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579:148,avoid,avoid,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-517777579,1,['avoid'],['avoid']
Safety,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:826,avoid,avoid,826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491,1,['avoid'],['avoid']
Safety,"Just a note on this PR: It's kind of hacky but to avoid images and videos taking up space in git history (they take up a lot!) I'd advocate for uploading images into an issue (effectively hosting them on GitHub's servers) and then linking/embedding them. In an ideal world the validation experiment CI pipeline would run and produce figures for all validation experiments which would then be automatically embedded into the docs with every version release. But setting up this infrastructure would take time and effort which I suspect no one can spare right now. Unfortunately it's a thankless job haha. > We try to fix this issue and keep the validation experiments and benchmarks up-to-date. I've always wanted to do this and wish I had the time to do it... This was the original motivitation for setting up the validation experiment CI pipeline: https://buildkite.com/clima/oceananigans-validation-experiments. It only runs the convergence tests right now and it still runs every night but it's been neglected so stuff is failing. I personally think we should be reviving the validation experiments one-by-one starting with the most important ones by running them as part of that CI pipeline and fixing it when it fails. But without the ability to dedicate the time I can see why reducing our maintenance burden would be desirable. I've also always wanted to set up a benchmarking CI pipeline, but I don't think we have the proper computational resources to set it up right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226:50,avoid,avoid,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226,1,['avoid'],['avoid']
Safety,"Just looked into this briefly. I don't see any typos in either the biharmonic diffusivity implementation:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Operators/derivative_operators.jl. or in the implementation of the fourth-order derivatives:. https://github.com/CliMA/Oceananigans.jl/blob/8f4432eff4a2bc4775cc722080318ee1cb7dee5b/src/Operators/derivative_operators.jl#L78. The odd thing is that this problem occurs even when the grid spacing is uniform, which means, I suppose, that it can't be due to a misplaced ""c"" or ""f"". Can you try halos of size 3 just for a sanity check?. We really need to overhaul how ""biharmonic"" diffusion is implemented soon...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574#issuecomment-826103006:580,sanity check,sanity check,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574#issuecomment-826103006,1,['sanity check'],['sanity check']
Safety,"Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228:149,predict,prediction,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228,1,['predict'],['prediction']
Safety,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:481,avoid,avoiding,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['avoid'],['avoiding']
Safety,Just tested the script and it runs! I haven't tested that the outputs are correct but I think it's safe to leave this closed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273:99,safe,safe,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273,1,['safe'],['safe']
Safety,"Just to avoid confusion:; length (in second) of minute, hour and day are well defined, as well as the; ""second"" (but it's more complicated) and are independent of which planet you are. ; They are not ""planetary constants"".; On the other hand, the rotation period (which, BTW, on earth, is not 1 day; but ~86164.s, so a bit less) is a planetary constant. On Thu, Jul 25, 2019 at 04:20:39PM -0700, Ali Ramadhan wrote:; > > Only ???day??? is specific to Earth.; > ; > That's true. If you think it's a good idea to include these constants, maybe `planetary_constants.jl` is a better place? `day` or `seconds_per_day` can sit inside the `PlanetaryConstants` struct.; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/climate-machine/Oceananigans.jl/pull/315#issuecomment-515249682",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515298959:8,avoid,avoid,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515298959,1,['avoid'],['avoid']
Safety,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:876,avoid,avoid,876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612,2,['avoid'],"['avoid', 'avoids']"
Safety,"Let's get to the blackboard together and sort it out. Don't code things; that are not clear. On Thu, May 23, 2019, 8:41 AM Ali Ramadhan <notifications@github.com> wrote:. > Ali, Please explain why it's x delt rather than divide. John; >; > I think when you discretize you get ∂u/∂t you get 1/Δt but then I think; > you're solving for the *predictor* or intermediate velocity *u**, which; > is fed into the right hand side, has a Δt multiplying the *Gu* source; > terms. It's not super clear to me yet, probably a good reason to actually; > write out all the equations and properly document this step.; >; > I ended up following the MITgcm manual:; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#equation-elliptic-pnh; >; > Equation (2.52) gives the 3D elliptic equations, and if you expand the; > right hand side using (2.53-2.55) and (2.58-2.59), and set *η=0* (we have; > no free surface) then we get ∇²ϕNH = ∇·u(n) + Δt*∇·Gu(n+½).; >; > What's worrying me right now is that this all seems to work great when *Δt; > = 1* but otherwise it doesn't work. I tried dividing by *Δt* just to make; > sure but it also didn't work (you get very high velocity divergences and it; > eventually blows up).; >; > Ps Does it work for 32bit now?; >; > It works better (the velocity divergence accumulates 10-20x more slowly); > but we might still need further fixes.; >; > Before:; >; > [ Info: Velocity divergence after 1 time steps (CPU(), Float32): min=-2.6085445e-10, max=-2.6085445e-10, sum=-2.683187e-11, abs_sum=7.933663e-7; >; > [ Info: Velocity divergence after 10 time steps (CPU(), Float32): min=-1.2560122e-9, max=-1.2560122e-9, sum=1.3686829e-12, abs_sum=3.0624833e-6; >; > [ Info: Velocity divergence after 100 time steps (CPU(), Float32): min=-5.4315024e-9, max=-5.4315024e-9, sum=1.2459012e-10, abs_sum=2.1301974e-5; >; > [ Info: Velocity divergence after 1000 time steps (CPU(), Float32): min=-6.495975e-8, max=-6.495975e-8, sum=-3.066242e-8, abs_sum=0.0002503319; >; >; > Afte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146:339,predict,predictor,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146,1,['predict'],['predictor']
Safety,"Let's table this, one nice thing about numbers is that we avoid the need for ""x"" and ""lambda""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890:58,avoid,avoid,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890,1,['avoid'],['avoid']
Safety,"Link shortener are commercial entities which can either go under any time, can maliciously tamper with the link or make money by tracking people who click the link. When You Interact With a Bitly Link. Bitly automatically collects personal information about the interaction (such as clicks or views) with every Bitly Link created through the Services (either our bit.ly links or one of our branded domains) on a third-party website. This information includes, but is not limited to: . (i) the IP address and location derived from the IP address; . (ii) the referring websites or services; . (iii) the time and date of each access; . (iv) device settings, such as browser type, operating system, and language; . (v) cookies, as described below, and mobile advertising identifiers and (v) information about sharing of the Bitly Link on Third Party Services such as Twitter and Facebook (collectively, “Bitly Link Metrics”). . As described in this policy, we use Bitly Link Metrics to provide the Services, to understand and analyze how our Services are used and to identify trends, and to detect, deter and prevent malicious, fraudulent or unlawful activity. Please see the “Information We May Share” section of this Privacy Policy for a description of how we may share information we collect when you create, view or interact with Bitly Links.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/773#issuecomment-645895985:1087,detect,detect,1087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/773#issuecomment-645895985,1,['detect'],['detect']
Safety,"Looks great! I think we still don't want images like `validation/convergence_tests/convergence_rates.png` getting into the repo but we can ""squash and merge"" this PR to avoid this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522:169,avoid,avoid,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522,1,['avoid'],['avoid']
Safety,Looks like I forgot this in #3847. The performance should be identical if using both the methods provided the methods are precompiled correctly. The method in [`tracer_advection_operators.jl:11`](https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Advection/tracer_advection_operators.jl#L11) avoids the immersed boundary check with `nothing` advection so probably it's a tad better.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798:332,avoid,avoids,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798,1,['avoid'],['avoids']
Safety,"Looks pretty good! A 1% violation in the BCs due to the projection seems; reasonable (as in - I would think something had gone wrong if it was 20%).; This is expected due to the issues we discussed on Zoom. While it will; certainly impact force predictions and the near wall solution slightly, the; impact should be fairly minor and might be controlled by a second BC; enforcement and projection step. The characteristics of the pressure solution within the body are; nonphysical, and so down entirely to the implementation of the pressure; solver. My guess is that the asymmetry is due to an index sweep in the; solver smearing this error ahead of itself. Is the solution outside the; body perfectly symmetric?. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Dec 4, 2020 at 12:08 AM Chris Hill <notifications@github.com> wrote:. > @wenegrat <https://github.com/wenegrat> and @whitleyv; > <https://github.com/whitleyv> sounds good - is the angle dependence maybe; > due to time dependence of flow, does it move around as the flow changes?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738463407>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJZWCFPECYN4I4ZBG2DSTAR6HANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738638208:245,predict,predictions,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738638208,1,['predict'],['predictions']
Safety,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422:98,avoid,avoid,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422,1,['avoid'],['avoid']
Safety,"Maybe I misunderstood your suggestion but the problem with a kernel like; ```julia; integral[k] += field[i, j, k] * A_cell[i, j]; ```; is that it's not thread-safe on a GPU. You can't have multiple threads incrementing the same variable, you get a race condition. You can do that using atomic CUDA operations (e.g. an `atomic_add`) but I don't think they're part of CUDAnative.jl yet. That's why I went with a parallel reduction prefix sum algorithm which I essentially took and modified from https://github.com/JuliaGPU/CUDAnative.jl/blob/master/examples/scan.jl. Another way to calculate that horizontal integral on the GPU is to use 1 thread per vertical level, but I coded that up and it's slow as you'll need ~5000 vertical layers to saturate an Nvidia V100 GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520512225:159,safe,safe,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520512225,1,['safe'],['safe']
Safety,"Maybe we can design a custom `Clock` object that opts-in to this kind of behavior, when warranted. The default could be our original clock, but if you know what basis to use and you'd like to avoid rounding issues for very long running simulations, you can opt-in to `ExactSteppingClock` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338:192,avoid,avoid,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338,1,['avoid'],['avoid']
Safety,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:862,avoid,avoid,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,1,['avoid'],['avoid']
Safety,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:68,sanity check,sanity check,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262,1,['sanity check'],['sanity check']
Safety,"My decision to use Sigma rather than S was not to avoid confusion in the code, but to avoid confusion in documentation and papers, where it will not be possible to use S for both salinity and strain rate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592708184:50,avoid,avoid,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654#issuecomment-592708184,2,['avoid'],['avoid']
Safety,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:77,abort,abort,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645,4,['abort'],['abort']
Safety,No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438718756:89,avoid,avoid,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438718756,1,['avoid'],['avoid']
Safety,"No, it was due to the alignment process but note that the time step is aligned with both output writing and the simulation stop time. The simulation reached `simulation.stop_time` but it was forced to do more iterations in this loop (see below) so so the aligned time step turned out to be 0 (to avoid overshooting `simulation.stop_time`). https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Simulations/run.jl#L158-L166. Now the simulation won't end up in this situation anymore since it stops time stepping early if `simulation.stop_time` is reached.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551:296,avoid,avoid,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551,1,['avoid'],['avoid']
Safety,"No, the method looks correct to me. This is some kind of bug. As a sanity check, you might try defining. ```julia; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```. However, we definitely want to get the method working for `grid::AbstractGrid{FT, TX, TY, Flat}` so that we don't have to redefine `ΔzF` for every grid type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204:67,sanity check,sanity check,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204,1,['sanity check'],['sanity check']
Safety,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545:352,avoid,avoid,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545,1,['avoid'],['avoid']
Safety,"Note: this PR does not touch the algorithm. It only adds a test. Also note that the major component that is different between the CPU and GPU is the poisson solver, and the poisson solver functionality is untouched by both #241 and this PR. Because this PR does not touch the algorithm and only adds a test, we are ensured that this PR is orthogonal to the issue of fixing the GPU tests. In addition, it is unlikely that the bug fixed by #241 is related to the failure of the GPU tests. I would like this PR merged because it will be useful for integrating the turbulence closure functionality into the code, which is what I am working on now. Unless the CPU-GPU difference is associated with the diffusive terms in the solver, the integration of turbulence closures should also be orthogonal to GPU issue. So we can work on both problems at the same time without risking merge conflicts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496232282:864,risk,risking,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239#issuecomment-496232282,1,['risk'],['risking']
Safety,"OK, with the help of detective @glwagner we figured this out. The change that happened between those versions is that `with_halos = false` became the default in output writers. To post process saved buoyancy to compute $|\boldsymbol{\nabla} b|^2$ we *crucially* need the boundary conditions on $b$ to be correct in the HC example! Thus, saving output `with_halos = false` was not doing the job right... #2734 fixes this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584:21,detect,detective,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584,1,['detect'],['detective']
Safety,"OK. All these is great!. So all this info you just shared is it anywhere else written? E.g. ""StretchedSmoothness is much less efficient... another reason to avoid it"". Btw, what exactly is ""StretchedSmoothness""?. We should have a docs section on advection schemes (#1318) and perhaps this PR is not the right place to deal with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531:157,avoid,avoid,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531,1,['avoid'],['avoid']
Safety,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534:1441,detect,detect,1441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534,1,['detect'],['detect']
Safety,"Oh. I didn't realize that the time-step was aligned with `simulation.stop_time`. I see then that the problem is intractable with the current ""sub iterations"" design. This problem is avoided by the design proposed in #1138.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870:182,avoid,avoided,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870,1,['avoid'],['avoided']
Safety,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:269,avoid,avoid,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,"['avoid', 'predict']","['avoid', 'predictor']"
Safety,"Ok, I found in the docs for MPI.jl that. > Calling [MPI.Finalize()](https://juliaparallel.org/MPI.jl/stable/reference/environment/#MPI.Finalize) at the end of the program is optional, as it will be called automatically when Julia exits. This is good news. So we can call `MPI.Init()` when we build the architecture, and avoid `MPI.Finalize()`. This brings us one step closer to the ""one line to distributed simulations"" goal. https://github.com/JuliaParallel/MPI.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370:320,avoid,avoid,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370,1,['avoid'],['avoid']
Safety,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823:692,detect,detect,692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823,1,['detect'],['detect']
Safety,"Okay, sounds good!. Let's not focus *too much* on optimization prematurely, though if I understand you I think you are really talking about the obvious things, like avoiding memory allocation and transfers to/from the CPU to GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470793646:165,avoid,avoiding,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470793646,1,['avoid'],['avoiding']
Safety,"One extra consideration is that we also allow users to specify diffusive fluxes across boundaries. This is especially important for geophysical problems at LES scales and larger, where its appropriate to employ a ""wall model"" to predict momentum and tracer fluxes at boundaries where there's an unresolved or partially-resolved turbulent boundary layer (rather than prescribing a particular value or gradient). That said, I think if we are able to specify the gradients of a field across a boundary it will likely be straightforward to extend that implementation to specifying fluxes. The paper. > [""Moving from momentum transfer to heat transfer – A comparative study of an advanced Graetz-Nusselt problem using immersed boundary methods""](https://www.sciencedirect.com/science/article/pii/S0009250918306250) by Lu et al. (2019). may also be relevant. Their conclusion is a bit confusing. They state. > In all simulations, excellent agreement are reached between CFM and DFM results, with the deviation being below 10%. which suggests that _accuracy_ may not be an important factor in deciding which method to use. But the next sentence is. > Considering the nature of capturing the discontinuity at the fluid-solid interface, DFM might offer a more accurate result, which however requires more follow-up simulations to give a solid investigation. which is difficult to interpret. I suppose all they can say is that their results are similar to one another, but they cannot say which one is more accurate (and perhaps it doesn't matter which method is more accurate in their case, if both methods return similar results). That said, I think time-step considerations are really important, and seem like a good reason to choose DFM over CFM. . Balaras (2004)'s pressure equation is. <img width=""868"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/95799302-36f2c280-0cc2-11eb-9342-a2b47a1cfdfa.png"">. where, crucially, `Ω` is the _computational_ domain (irrespective of the immersed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128:229,predict,predict,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707401128,1,['predict'],['predict']
Safety,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:12,avoid,avoid,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898,1,['avoid'],['avoid']
Safety,"One small note --- while I agree that the buoyancy frequency criterion is more restrictive, it just happens that the internal waves that arise at coarse resolutions have frequencies closer to the inertial frequency rather than the buoyancy frequency. In other words, the buoyancy frequency restriction, while guaranteed to be safe, is often _overly_ restrictive. When running expensive simulations one almost certainly has to increase the time-step beyond this number to obtain results in a reasonable amount of time. I think it's fine to use a conservative estimate for the example, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1594#issuecomment-820531717:326,safe,safe,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1594#issuecomment-820531717,1,['safe'],['safe']
Safety,"Originally I was against types like `AbstractGrid` and still am, but it seems to be what the Julia ecosystem uses so would be good to adopt to avoid surprises. I agree . That PR should only introduce operators that will be used (otherwise they can't be tested so what's the point).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-525538923:143,avoid,avoid,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330#issuecomment-525538923,1,['avoid'],['avoid']
Safety,PPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1616; unknown function (ip: 0x7f838be529a8); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:674; _show at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1957; show at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:215 [inlined]; png at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:7; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:20; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:18; macro expansion at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:172 [inlined]; macro expansion at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:322 [inlined]; top-level scope at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:183; unknown function (ip: 0x7f83cc10d030); unknown function (ip: 0x7f83cc0e8105); jl_load at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); include at ./Base.jl:377; exec_options at ./client.jl:288; _start at ./client.jl:484; jfptr__start_2075.clone_1 at /usr/lib/x86_64-linux-gnu/julia/sys.so (unknown line); unknown function (ip: 0x55bf459799d9); unknown function (ip: 0x55bf459795a6); __libc_start_main at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x55bf4597964d); Allocations: 259469010 (Pool: 259407383; Big: 61627); GC: 547; Aborted (core dumped); ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:4941,Abort,Aborted,4941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Abort'],['Aborted']
Safety,PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup). So we usually open and merge branches from the repo itself.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240:110,avoid,avoid,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240,1,['avoid'],['avoid']
Safety,"PS a minor tweak that would help with the issues above would be to add a kwarg to `update_state!` like. ```julia; function update_state!(model; compute_tendencies=true); ```. Then under some circumstances (ie in `set!` or for the last time-step potentially) we can avoid computing the tendencies if we want. PS PS should we use ""compute"" rather than ""calculate"" ? We use both words to mean the same thing which is silly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1453642566:265,avoid,avoid,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1453642566,1,['avoid'],['avoid']
Safety,"PS, you can always create a new branch from this one and merge main there. You don't need anybody's permission to run a simulation with certain code. Development is always welcome but we should avoid manufacturing a ""sense of urgency""!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356:194,avoid,avoid,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356,1,['avoid'],['avoid']
Safety,"PUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, Line",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:1183,avoid,avoid,1183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['avoid'],['avoid']
Safety,Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359:64,avoid,avoids,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359,1,['avoid'],['avoids']
Safety,"Personally I don't see a problem with warnings in the docstrings if that's how the code behaves. > Strikes me that we could also change the log level so that warnings are not emitted. I'm not sure what the expected result of this is. But if this will create a situation where a given docstring won't have warnings, while users copy-pasting the contents from that same docstring may get a warning, then I think it'll be confusing and we should probably avoid that solution. If not, then that sounds like a great solution :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287861310:452,avoid,avoid,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287861310,1,['avoid'],['avoid']
Safety,Poisson solver test: recovery of an analytic solution.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:21,recover,recovery,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recovery']
Safety,PoissonBCs for pressure solver are redundant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:35,redund,redundant,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,1,['redund'],['redundant']
Safety,"Previously the functions `viscous_flux_u*` and `diffusive_flux_*` dispatched on `AbstractPrimaryGrid`. `AbstractPrimaryGrid` (now called `AbstractUnderlyingGrid` is an abstract type for distinguishing between `ImmersedBoundaryGrid` and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with `ImmersedBoundaryGrid` were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on `grid` (except where necessary, where the dispatched type was changed from `AbstractPrimaryGrid` to `AbstractGrid`). It also nukes the fallbacks (which were the reason this issue escaped detection originally). The original motivation for dispatching on `AbstractPrimaryGrid` is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason `TwoDimensionalLeith` was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1835#issuecomment-877174564:690,detect,detection,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835#issuecomment-877174564,1,['detect'],['detection']
Safety,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1835:670,detect,detection,670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835,1,['detect'],['detection']
Safety,"Prior to time-stepping we execute an ""initial"" call to `run_diagnostic` for every `simulation.diagnostics`:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/Simulations/run.jl#L80-L83. This is an edge case for calling `run_diagnostic` on the `WindowedTimeAverage` in which we are not currently collecting, but also do not wish to initialize data collection. In other words, `run_diagnostic` assumes that if it is called, the user wishes to start collecting data:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/OutputWriters/windowed_time_average.jl#L90-L92. but this assumption is not necessarily correct for the initial call to `run_diagnostic`. We thus need to check whether `run_diagnostic` has been called at the zeroth iteration --- and also whether or not we ""should"" be initializing data collection (this is true when `time_window == time_interval`, since we are then always collecting data for averaging) to avoid spurious data collection.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/962:1004,avoid,avoid,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/962,1,['avoid'],['avoid']
Safety,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:871,recover,recover,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['recover'],['recover']
Safety,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:871,recover,recover,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['recover'],['recover']
Safety,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:539,avoid,avoid,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['avoid'],['avoid']
Safety,Reductions and broadcasting over AbstractOperations require 4-5x invocations to avoid recompilation on GPU and CPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024:80,avoid,avoid,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024,1,['avoid'],['avoid']
Safety,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/852:96,avoid,avoid,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852,1,['avoid'],['avoid']
Safety,Remove redundant definition of `diffusive_flux_z` for divergence damping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2482:7,redund,redundant,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2482,1,['redund'],['redundant']
Safety,Removes redundant definition for `halo_size`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2130:8,redund,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130,1,['redund'],['redundant']
Safety,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233:251,avoid,avoid,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233,1,['avoid'],['avoid']
Safety,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:842,avoid,avoid,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,1,['avoid'],['avoid']
Safety,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107:796,detect,detected,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107,1,['detect'],['detected']
Safety,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/417:91,safe,safely,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417,1,['safe'],['safely']
Safety,"Right, I see. I wonder if we could use a `MovingTimeAverage` that wraps around an `OutputWriter`. I think we probably want to avoid the complexity of weaving together objects in `.diagnostics` and objects in `.output_writers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-585975293:126,avoid,avoid,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-585975293,1,['avoid'],['avoid']
Safety,"Right. I think consistency checking would be a nice feature. I think that’d be best implemented in the constructor for ModelBoundaryConditions. . When consistent/valid boundary conditions are ensured, we can then safely infer the Poisson pressure solver type from the velocity boundary conditions without the need for an intermediate PoissonBCs type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311#issuecomment-511138029:213,safe,safely,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311#issuecomment-511138029,1,['safe'],['safely']
Safety,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:3147,avoid,avoid,3147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['avoid'],['avoid']
Safety,Safely using @inbounds,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/164:0,Safe,Safely,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/164,1,['Safe'],['Safely']
Safety,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:26,detect,detecting,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['detect'],['detecting']
Safety,Should be safe to bump as long as you don't use `unsafe_wait`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/924#issuecomment-689767311:10,safe,safe,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/924#issuecomment-689767311,1,['safe'],['safe']
Safety,"Should probably add a note on citing Oceananigans.jl to the README and docs. A lot of other packages do this. Would also make the ""Development team"" section kinda redundant so we could remove it then.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1101:163,redund,redundant,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1101,1,['redund'],['redundant']
Safety,"Should this. https://github.com/CliMA/Oceananigans.jl/blob/e2841ca6dda4414fcd9177512faec557d6f12adc/src/Coriolis/hydrostatic_spherical_coriolis.jl#L60. be . ```Julia; 1 - f(i, j, k, grid, args...); ```; to avoid type instability?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2925:206,avoid,avoid,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2925,1,['avoid'],['avoid']
Safety,"Simple kernels are safe (in fact, faster). ```julia; using Oceananigans; using Oceananigans.Architectures: device; using Oceananigans.Utils: launch!; using Oceananigans.Operators: ∇²ᶜᶜᶜ. using KernelAbstractions: @kernel, @index; using BenchmarkTools. @kernel function _diffuse!(c, Δt); i, j, k = @index(Global, NTuple); @inbounds c[i, j, k] += Δt * ∇²ᶜᶜᶜ(i, j, k, grid, c); end. function diffuse!(c, Δt); grid = c.grid; arch = grid.architecture; ev = launch!(arch, grid, :xyz, _diffuse!, c, Δt); wait(device(arch), ev); return nothing; end. function lots_of_steps!(c, Δt, steps=100); for _ = 1:steps; diffuse!(c, Δt); end; end. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); c = CenterField(grid); @btime lots_of_steps!(c, 0.01); ```. yields. ```julia; 447.763 ms (9832300 allocations: 975.37 MiB) # KA 0.8; 499.522 ms (9832300 allocations: 1.81 GiB) # KA 0.7; ```. adding `fill_halo_regions!` doesn't change much either",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481333405:19,safe,safe,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481333405,1,['safe'],['safe']
Safety,"Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?. Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882:292,avoid,avoid,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882,1,['avoid'],['avoid']
Safety,So is `taper_factor_ccc` function redundant now? Seems like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600:34,redund,redundant,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600,1,['redund'],['redundant']
Safety,"Some nice detective work @glwagner , and I agree that the initial profile looks much better and therefore justifies this improvement. As for the growth rate plot, in the movies, both cases have an intial perturbation O(1e-3) or so. I can believe this has a norm of O(1e-2). However, initially, the value is much smaller and I'm guessing it's zero. This is probably because we don't compute it at the first index. I will have to look at the plotting script and see why that is. . One easy fix is to start plotting at the second point. A more satisfying fix would be to actually compute the norm at the first index. I will try and figure this out later today, but now breakfast!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377:10,detect,detective,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377,1,['detect'],['detective']
Safety,"Some notes regarding the velocity correction / pressure solver method:. * As @weymouth mentioned, we can't get both the boundary condition and the pressure distribution correct without modifying the pressure solver. * One possibility is just to ""not worry too much"", since:; - LES often makes approximations at the boundary anyways, and the pressure gradient error may be small compared to the error associated with the wall model or LES closure; - the error may scale with the time-step and magnitude of wall-normal pressure gradients, which may be small. * One method for getting correct boundary conditions + pressure gradients is to iterate the prediction-correction algorithm that both corrects for the immersed boundary, and then projects out the divergence:; - this could work for non-moving boundaries; - if boundary motion drives the flow, this might fail; - possibly preconditioning with a coarse but accurate boundary-aware pressure solver can help (eg using multigrid solvers developed by @weymouth)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-726849747:649,predict,prediction-correction,649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-726849747,1,['predict'],['prediction-correction']
Safety,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: Δx. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx2 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / Δx`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1367,avoid,avoid,1367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106,2,"['avoid', 'detect']","['avoid', 'detecting']"
Safety,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:128,avoid,avoid,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['avoid'],['avoid']
Safety,"Some suggestions on regriding:. - Add brief docstrings with a quick example; - Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters.; - ~Export `regrid!`?~. cc: @glwagner, @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1991:168,avoid,avoid,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1991,1,['avoid'],['avoid']
Safety,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:217,avoid,avoid,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['avoid'],['avoid']
Safety,"Somewhat related but; ```julia; julia> range(10f0, 20f0, length=5) |> typeof; StepRangeLen{Float32,Float64,Float64}; ```; so even if `eltype` is `Float32`, `Float64` values may be used to store the step sizes to produce a range that is ""free of roundoff error"" (see `help?> StepRangeLen`). To avoid mixing precisions I wonder if it's better to move from ranges to 1D arrays (tiny memory storage cost but guaranteed to not mix different precision).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/544#issuecomment-560520512:293,avoid,avoid,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/544#issuecomment-560520512,1,['avoid'],['avoid']
Safety,"Sorry about the confusion @tomchor! Opening a new issue might actually be a good idea since it's true we currently only support a subset of the 3^3 = 27 possible topologies (I went ahead and quoted your post in this new issue). I actually might avoid using the `Flat` topology right now since until it's fully tested (see e.g. #1023). You can substitute `Bounded` for `Flat` and your simulation should do the same thing except it will take up some extra memory and slow down your model by a tiny bit. The functional difference is that halo regions have non-zero size along `Bounded` dimensions (and derivatives are computed along `Bounded` dimensions which will evaluate to zero unless you have some weird boundary conditions). Yeah currently the four supported topologies are:; 1. `(Periodic, Periodic, Periodic)`; 2. `(Periodic, Periodic, Bounded)`; 3. `(Periodic, Bounded, Bounded)`; 4. `(Bounded, Bounded, Bounded)` (unfortunately only works on the CPU, see #1007). We could support all possible topology combinations. The only bottleneck is implementing pressure solver that work for all topologies (see #586). This is on my current list of things to do but is not super trivial (see https://github.com/JuliaGPU/CUDA.jl/issues/119 and possibly related #1170) so it's taking some time... 😅 . Hopefully I can refactor the pressure solver(s) to support all topologies soon but either way it might be good to be explicit about which topologies are actually supported.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732260751:245,avoid,avoid,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732260751,1,['avoid'],['avoid']
Safety,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1312,avoid,avoiding,1312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312,1,['avoid'],['avoiding']
Safety,"Specifically `ifelse(a==1, n, a - 1)`. This should always be faster than `mod`. In ShallowWaterBench, we consciously choose to use OffsetArrays, to avoid any wrap around and implement ghost cells.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/57#issuecomment-466256607:148,avoid,avoid,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57#issuecomment-466256607,1,['avoid'],['avoid']
Safety,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406:446,redund,redundant,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406,1,['redund'],['redundant']
Safety,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:333,recover,recover,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,2,['recover'],['recover']
Safety,"Starting to get tests failing because of conflicting qualifiers, e.g. both `Base` and `CUDAdrv` define `@elapsed`. Would be good to revise our existing `using` and `import` statements so that we only bring in exactly what we need to avoid these kinds of issues. And I believe it's good practice anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/351:233,avoid,avoid,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/351,1,['avoid'],['avoid']
Safety,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:310,predict,predictably,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702,1,['predict'],['predictably']
Safety,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:578,Safe,SafeTestsets,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Safe'],['SafeTestsets']
Safety,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:37,recover,recover,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recover']
Safety,"Thank you @ali-ramadhan and @glwagner for the solutions. They worked!. However, calling `Model` twice was more memory intensive. I ran into out of memory error. Is the first instance not overwritten when the second instance is defined?. Since I have a uniform grid, I was able to manually define `xC`, `yC`, and `zC` and avoid the out of memory error. . ```julia; # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them; xF, yF, zF = collect(0:Lx/Nx:Lx), collect(0:Ly/Ny:Ly), collect(0:Lz/Nz:Lz); xC, yC, zC = 0.5.*(xF[2:end] .+ xF[1:end-1]), 0.5.*(yF[2:end] .+ yF[1:end-1]), 0.5.*(zF[2:end] .+ zF[1:end-1]); xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]; r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2); bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). # Create boundary conditions; Tbcs = FieldBoundaryConditions(z=ZBoundaryConditions(; bottom = BoundaryCondition(Flux, bottom_flux))). # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; bcs = BoundaryConditions(T=Tbcs),; ν=1e-4, κ=1e-4); ```. To accommodate spatially variable boundary conditions, may be `Model` can be split up into a `geometry` component and `dynamics` component?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515246317:321,avoid,avoid,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515246317,1,['avoid'],['avoid']
Safety,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256:213,avoid,avoid,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256,1,['avoid'],['avoid']
Safety,"Thank you for bringing this up! I am interested in running simulations with `FT=Float32`. In many of my simulations, the spatial resolution is limited by GPU memory, and thus using `FT=Float32` will hopefully double the number of grid points for a given GPU. \(Although multiple-GPU should be the solution.\). It seems to me that the document does not tell people how to setup a simulation with `FT=Float32`. It only tells people to avoid mixed-precision operations. I am willing to give a try if there is a detailed instruction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389467592:433,avoid,avoid,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389467592,1,['avoid'],['avoid']
Safety,Thanks @ali-ramadhan . There is a `ShallowWaterModel` specific version of the wizard but it uses a lot that was developed for `IncompressibleModel`. I guess I should look at that in more detail and see if anything needs to be generalized. I agree that `Simulation` should hopefully protect the user from this and I hope that the user would want to avoid this as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-779873995:348,avoid,avoid,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-779873995,1,['avoid'],['avoid']
Safety,"Thanks @glwagner. I certainly don't want to make any changes that would either slow down code or make things harder to maintain. I can't say that I know this is the right direction to go but let me try and articulate what I want to do and maybe you can suggest a direction to proceed?. The basic idea can be found by looking at `shallow_water_Bickley_jet.jl`. In this example we define a `perturbation_norm` in line 134 that computes the norm of `v`. Then in line 158 we define an output_writer to output this norm. There is nothing special about v and I might want to use use `u` as well. To do this requires two steps:. 1. Defining a new analogous function for the perturbation norm of `u`. I'm hoping we can avoid these functions completely with `using Statistics: norm` but I don't know if that's the case.; 2. In line 161 we need to list these two norms. When I tried that there was an error message, and hence what inspired this PR. I don't think this PR needs to happen and there are probably better ways of addressing points 1 and 2. Any advice?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868:711,avoid,avoid,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868,1,['avoid'],['avoid']
Safety,"Thanks @jm-c. I’ve used “siderealday” in the past for that number. It seems the calendar day is the most important number for scripts and simulation set up. I haven’t used either sidereal day (or rotation period, equivalently) yet. . I think planetary constants concepts is problematic and over-specific anyways for our humble code; we probably just want to have “constants”. Being more general will avoid confusion. . Thanks for finding that @ali-ramadhan. Feel free to make those changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515505940:400,avoid,avoid,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515505940,1,['avoid'],['avoid']
Safety,"Thanks @kburns for the reference. . Nicholas Kevlahan and I are collaborating on a problem now and we have used his wavelet based model. I agree that it does do a lot of things very well. It deals with topography and coastlines using Brinkman penalization, which is quite distinct from our immersed boundary method. I don't know how he preserves positivity in the height field but I will find out. **Update:** their model uses a vertical coordiante in the vertical to avoid layer collapse. Also, in the multi-layer case they use a discretization of vertical diffusion, to also prevent layer collapse (depths going to zero).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993:468,avoid,avoid,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993,1,['avoid'],['avoid']
Safety,"Thanks @simone-silvestri !. > So, the wind stress has a negative sign in the script lines 104 and 105 which has to be removed; > ; > ```; > τˣ = arch_array(arch, - τˣ); > τʸ = arch_array(arch, - τʸ); > ```; > ; > to; > ; > ```; > τˣ = arch_array(arch, τˣ); > τʸ = arch_array(arch, τʸ); > ```; > ; > The negative sign was there because in the hydrostatic model wind stress is a boundary condition and, at the top, a negative flux is a source of momentum. In the shallow water model, this wind stress is a forcing so it does not follow the same convention (we should do something about this convention someday....) and the minus should be removed. (By boundary conditions I meant the forcings); > . That makes sense. I can push the change this afternoon. > to color the continents, if `ζ′` is your vorticity, you should do:; > ; > ```; > Z = interior(ζ′); > Z[Z .== 0] .= NaN; > heatmap!(ax, x, y, Z, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:black); > ```. Very nice. . I had to modify it a little bit (vorticity is not an offset array) but I was able to paint the continents black. . When I make `iter` an Observable, then the vorticity becomes an Observable or a matrix. Unfortunately, it doesn't like this line and I'm not sure how to get it to work with using `@lift`. . ```Z[Z .== 0] .= NaN```. To avoid this in the future, is there a way to do this before we save the data?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971:1316,avoid,avoid,1316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971,1,['avoid'],['avoid']
Safety,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:431,risk,risky,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['risk'],['risky']
Safety,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:611,Avoid,Avoid,611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,2,['Avoid'],"['Avoid', 'Avoid-fields-with-abstract-containers-']"
Safety,"Thanks for the heads up again @navidcy!. Indeed #558 didn't exactly solve the problem as it only deleted the JLD2 file after it was already pushed to `gh-pages` by `makedocs`. I added a `.gitignore` to the `gh-pages` branch a while back so JLD2 and NetCDF files aren't pushed, but didn't purge the JLD2 files. I just did it again and repo size is down to 53 MB now. As all the files were on `gh-pages`, no pull requests should be affected. Just to be safe @glwagner @suyashbire1 @sandreza we should probably `git clone` a fresh copy of repository. Cloning just the `master` branch is ~20 MB uncompressed mostly because of regression test files (although they're all <1 MB each). Cloning just the `gh-pages` branch is ~80 MB because each tutorial/example in the example has an embedded mp4. The branch will grow in size with time, but we can revisit the issue of what to do about documentation size in the future. PS: Thanks again for the tips @c42f and for the branch size measuring commands!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-576424204:451,safe,safe,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-576424204,1,['safe'],['safe']
Safety,"Thanks for the suggestion @jmbeckers! Since we can now use broadcasting on fields, another possibility is. ```julia; u₀(x, y, z) = rand(); set!(model, u = u₀, v = u₀). model.velocities.u .-= mean(model.velocities.u); model.velocities.v .-= mean(model.velocities.v); ```. This emphasizes using function input, which is generally a better way to work, and avoids annoyances associated with `size` (and is shorter and possibly clearer). However, I agree that @jmbeckers suggestion is better if we want to provide an example of array input. I like the idea of providing such an example, but I'm not sure if we want to put it in such a prominent place as the two dimensional turbulence example because it can be annoying and inconvenient to use them, as this issue illustrates...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253:354,avoid,avoids,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253,1,['avoid'],['avoids']
Safety,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302:53,avoid,avoid,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302,1,['avoid'],['avoid']
Safety,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/169:988,avoid,avoid,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169,1,['avoid'],['avoid']
Safety,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:1281,avoid,avoid,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847,1,['avoid'],['avoid']
Safety,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:181,safe,safety,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189,1,['safe'],['safety']
Safety,"That should be an easy fix. Not sure, but `BinaryOperation` might be preferred over mulitiary because it avoids the `ntuple` magic unrolling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/892#issuecomment-684866382:105,avoid,avoids,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/892#issuecomment-684866382,1,['avoid'],['avoids']
Safety,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:1571,avoid,avoid,1571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326,1,['avoid'],['avoid']
Safety,"That's definitely a good idea. I think your tests would have already caught it if we ran the tests on the GPU as well, which I tried to do as part of #140 but ended up avoiding it as it meant having to resolve #64 (which is an easy issue) so we can run GPU models on any grid size.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/150#issuecomment-476197034:168,avoid,avoiding,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/150#issuecomment-476197034,1,['avoid'],['avoiding']
Safety,"That's right @navidcy, nice detective work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944553636:28,detect,detective,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944553636,1,['detect'],['detective']
Safety,That's sweet!. I think we should avoid punctuation where possible in `summary` (mirroring Julia Base) so maybe. ```; ImplicitFreeSurface; gravitational acceleration 9.80665 m s⁻²; ```. should be. ```; ImplicitFreeSurface with gravitational acceleration = 9.80665 m s⁻²; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847:33,avoid,avoid,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847,1,['avoid'],['avoid']
Safety,"That's true that `xspacing` etc are redundant. We could also change `xspacings` to `Δx(grid, loc...)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468296362:36,redund,redundant,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468296362,1,['redund'],['redundant']
Safety,"The `NetCDFOutputWriter` requires the keyword argument `filename`:. https://github.com/CliMA/Oceananigans.jl/blob/ed73ad36c99b61f24c37c73e4a2d26a12c7601d9/src/OutputWriters/netcdf_output_writer.jl#L147-L163. while `JLD2OutputWriter` requires `prefix` (which is optional, even though the default `prefix=""""` would produce a file called `.jld2`:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/jld2_output_writer.jl#L56-L60. There are also some minor differences: `filename` is used for the NetCDF writer, while `filepath` is used for the JLD2 writer. We should probably even out these differences:. * I think `filename` is more descriptive than `prefix`; * I also think its redundant to require the user to specify the file suffix (`.jld2` or `.nc`) in addition to specifying `JLD2` or `NetCDF` in the output writer name. So we need to weigh the two above considerations in coming to a decision. ; * `filepath` may be a better name for the struct member if we are also going to allow the keyword argument `dir` (this is not part of `NetCDFOutputWriter` either). In general I think we should strive to make all the keywords as identical as possible so that users can switch between the writers by changing `NetCDF` to `JLD2` and vice versa.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884:731,redund,redundant,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884,1,['redund'],['redundant']
Safety,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:147,redund,redundant,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,2,['redund'],['redundant']
Safety,"The algorithm is also described in . [""PoisFFT – A free parallel fast Poisson solver"" by V Fuka (Appl Math and Comp 2015).](https://www.sciencedirect.com/science/article/abs/pii/S0096300315003057). There is also [code corresponding to this paper on github](https://github.com/LadaF/PoisFFT). The core of the method is an eigenfunction expansion of the discrete Poisson operator... I think?. Perhaps we can call this a `EigenPoissonSolver`, or even `FFTPoissonSolver` --- through we should use caution to avoid misleading people into thinking that our code is spectral. This algorithm solves the Poisson equation when it has been *discretized on a staggered grid*. We should not discuss spectral methods or Fourier transforms, and the word 'spectral' should not appear anywhere in the code. I think this is very misleading. It should be a high priority to change this language. By the way, it may make sense to put the Poisson solver a separate package. It will be useful to other people, and implementing it as a stand-alone package will allow us to benefit from community development. Is there a reason why we can't do this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-468947308:504,avoid,avoid,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-468947308,1,['avoid'],['avoid']
Safety,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:723,avoid,avoided,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914,2,"['avoid', 'safe']","['avoided', 'safe']"
Safety,"The argument `grid` is required --- of course --- in model constructors. Our current API makes `grid` a keyword argument. Originally (and it was a long time ago now) it was argued that keyword arguments are just better and that's why we should keep it. Also, we don't dispatch on it. However, we violate that concept in `Simulation`, where the `model` is a positional argument. I think it's more natural to input `grid` as a positional argument in the models. It's a relatively minor thing, but it avoids anti-patterns like `grid=grid`, which appeared in many scripts before `; grid` was possible. It looks better. This has come up because we are adding more Oceananigans-based `AbstractModel`s over in [`ClimaSeaIce`](https://github.com/CliMA/ClimaSeaIce.jl), and my first intuition there was to make `grid` a required positional argument. Ultimately though, we should strive for all models to have uniform interfaces, so either we change `Oceananigans` or we change `ClimaSeaIce`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250:498,avoid,avoids,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250,1,['avoid'],['avoids']
Safety,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:84,safe,safely,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,1,['safe'],['safely']
Safety,The cubed sphere grid from the MIT as read from DataDeps has the faces ordered:; 1. `+ x` direction; 2. `+ y` direction; 3. `+ z` direction (Arctic); 4. `- x` direction; 5. `- y` direction; 6. `- z` direction (Antarctica); ; So to avoid confusion for (users and developers!) I thought I make sure that the ConformalCubedSphere follows the same convention. This PR does that + it adds tests to check whether the ConformalCubedSphereGrid metrics from the grid read from file and the grid constructed in Oceananigans.jl are the same. After this is merged we'll move on to #2867 to constructing `ConformalCubedSphereGrid` using MultiRegion (an possibly nuke the `CubedSpheres` module completely). We will have a `ConformalCubedSphereGrid` (which is the same as the `cs32` grid read from file) to bench our MultiRegion implementation with!. (This PR also moves some of the spherical trigonometry utility function to `grid_utils.jl`.). Closes #1586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2871:231,avoid,avoid,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871,1,['avoid'],['avoid']
Safety,"The discussion on #2410 reminded me: to complete this implementation, we are going to need to make some modification to the hydrostatic pressure integral. There are two possibilities. We can either. 1) use the MITgcm method, which _avoids_ using the modified grid spacing in the bottom cell for the hydrostatic pressure integral. Using ""underlying"" grid spacing avoids pressure gradient errors that would otherwise induce flow even for horizontally uniform density stratification. 2) Implement Lin 1997 to evaluate the hydrostatic pressure integral: https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=_4v_YF-yx0cAAAAA:vC9wnmpvE_2HqoKudORNBfVCkxK4_YgRfp5_Lh2hIFFNc0ZyST-D7nwEqt1No4FculdvrohhKVF2wT9r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825:362,avoid,avoids,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825,1,['avoid'],['avoids']
Safety,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:874,avoid,avoid,874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['avoid'],['avoid']
Safety,"The floating point type can and should be determined from `eltype(grid)`, since `grid` is a required argument for constructing `IncompressibleModel`. An independent `float_type` argument is not only redundant but creates the possibility that models can have inconsistent float types. Eliminating this argument and using `eltype(grid)` as the source of knowledge re: floating point types solves this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1786:199,redund,redundant,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1786,1,['redund'],['redundant']
Safety,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:904,avoid,avoid,904,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,1,['avoid'],['avoid']
Safety,"The logic should be reversed, we should have to include ""compute_tendencies=false"" as an _optimization_. Rather than what's implemented here, which does the unsafe thing by default. The problem with this logic is that it makes it harder to implement new models. The optimizations should be the optional thing basically, if one is naive, then things should work even if they are slower than they could be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515:157,unsafe,unsafe,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515,1,['unsafe'],['unsafe']
Safety,The paper that I cited used periodic boundary conditions for the deviations in the horizontal. Not physically meaningful but it is one way to avoid the walls.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083326801:142,avoid,avoid,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083326801,1,['avoid'],['avoid']
Safety,"The real problem I think is with `model.parameters` --- the use of `model.parameters` is extremely open ended (but this creates problems when we think it *must* be used only for certain applications). Maybe we should require objects for all user-defined forcing functions and boundary condition functions? Then we can get rid of `model.parameters` to avoid ""confusion"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564734601:351,avoid,avoid,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564734601,1,['avoid'],['avoid']
Safety,"The risk of doing something automatic is that _in theory_ someone could think ""oh, I only have 2 grid poits in the y direction, but I still expect to observe WENO advection in that direction"". Will someone think that? It doesn't really make sense, with 2 grid points in a direction there won't be advection at all anyways. I don't think this is a big risk. Big risks are like, simulations are dead wrong when they present an illusion that makes them seem ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2310605591:4,risk,risk,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2310605591,3,['risk'],"['risk', 'risks']"
Safety,"The shorter, the better for hello ocean! . This example does a bit more because it adds a plot and uses different numerics (could avoid the need to specify good numerical manually by changing defaults?). I think hello ocean should plot (otherwise there's no ""hello"") but we could combine some lines for sure. Still not sure the best problem. A rising hot patch produces decent viz but not particularly oceanic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-754017135:130,avoid,avoid,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-754017135,1,['avoid'],['avoid']
Safety,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647:1479,redund,redundant,1479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647,1,['redund'],['redundant']
Safety,"There appears to be the possibility of a write/write race condition at the corners in this case. Discovered with @sandreza. No bug has yet been detected, however.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1938:144,detect,detected,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938,1,['detect'],['detected']
Safety,"There are a few more `0.0` in the code. Question:. If there is. ```Julia; fill!(var, 0.0); ```. where `var::Array` and if we don't have access to grid, then is . ```Julia; fill!(var, 0); ```; safe to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416:192,safe,safe,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416,1,['safe'],['safe']
Safety,"There are always leftover typos :). @francispoulin, I tried to use your repo to compute the most unstable mode for k=1 and I couldn't do it...; Could you tell me what the actual growth rate for `k = 1` is? I remember 0.138? Am I right? We should report the theoretical growth rate for `k = 1` that fits this domain (and not the overall maximum growth rate) and then compare that with the best-fit prediction. What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1464:397,predict,prediction,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1464,1,['predict'],['prediction']
Safety,"There are some differences between how this algorithm is implemented and how we do the stepping for the `NonhydrostaticModel` --- do you have any comment about that? We could try implementing this kind of algorithm for the NonhydrostaticModel as well. The implicit free surface solve can be interpreted as a 2D pressure solve, which in the nonhydrostatic context is replaced by a 3D pressure solve. In particular, it seems that the intermediate predictor velocities $u^\star$ are computed differently and different coefficients are used (1/4, 3/4, 1/3, 2/3) than what we currently use for RK3 in the NonhydrostaticModel:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TimeSteppers/runge_kutta_3.jl#L57-L62. PS `^\star` is superior to *!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441601967:445,predict,predictor,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441601967,1,['predict'],['predictor']
Safety,"There is a script at https://github.com/CliMA/Oceananigans.jl/blob/ncc-glw/cubed-sphere-dynamics/validation/multi_region/cubed_sphere_vorticity.jl. ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/7112768/fcf66cf7-c257-4fd0-bc5a-39cb79a6bc92). So computing the vorticity there are 6 holes on the 2 corners that do not correspond to an interior point. These are the. `i = 1, j = Ny+1` points for odd panels and `i = Nx+1, j = 1` for even panels. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. One idea is to have each panel of the cubed sphere span until, e.g., `Nx+1` or `Ny+1`. We will have redundancy in the computations but will sort the other issue. Otherwise we just want to call the vorticity kernel on those 3 points; do we do it in a different kernel? Before calling the kernel we need to ensure that the horizontal velocities have their halo regions filled right as the circulation around those points involves some velocities in the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341:718,redund,redundancy,718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341,1,['redund'],['redundancy']
Safety,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:161,predict,predict,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,2,"['avoid', 'predict']","['avoid', 'predict']"
Safety,"These resutls are great @whitleyv , well done! A few thoughts. First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419:215,avoid,avoid,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419,1,['avoid'],['avoid']
Safety,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:364,sanity check,sanity check,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['sanity check'],['sanity check']
Safety,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198:191,detect,detected,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198,1,['detect'],['detected']
Safety,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970:78,avoid,avoid,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970,1,['avoid'],['avoid']
Safety,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2110:197,avoid,avoids,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110,1,['avoid'],['avoids']
Safety,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:231,avoid,avoid,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,3,"['avoid', 'detect']","['avoid', 'avoiding', 'detected']"
Safety,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:473,abort,aborted,473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,1,['abort'],['aborted']
Safety,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2538:407,avoid,avoid,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538,1,['avoid'],['avoid']
Safety,"This PR changes the calculation of the diffusivities in the `SmagorinskyLilly` so that binary operations are avoided. At the moment it does so by creating a `calc_nonlinear_κᶜᶜᶜ()` kernel, similar to what is done for the AMD closure. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904:109,avoid,avoided,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904,1,['avoid'],['avoided']
Safety,This PR directly indexes the underlying Array or CuArray to avoid the issue that broadcasting over an `OffsetArray{CuArray}` is extremely inefficient. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/268:60,avoid,avoid,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/268,1,['avoid'],['avoid']
Safety,"This PR does two things:. - Changes `docs/make.jl` to only define the example names once. They were being defined twice before, with some redundancy. Now it'll be easier to comment a given example out when building the docs locally, for example.; - Speeds up the tilted BBL example. I'm doing that by starting it with some noise, which makes turbulence appear much sooner, which allows us to run it for only one day (half the previous time).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3115:138,redund,redundancy,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3115,1,['redund'],['redundancy']
Safety,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:152,avoid,avoided,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,3,"['Avoid', 'avoid']","['Avoiding', 'avoided']"
Safety,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/538:159,avoid,avoid,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538,1,['avoid'],['avoid']
Safety,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508:337,avoid,avoid,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508,1,['avoid'],['avoid']
Safety,This PR helps avoid the error; not sure if you want it or not. https://github.com/CliMA/Oceananigans.jl/pull/2110,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451:14,avoid,avoid,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451,1,['avoid'],['avoid']
Safety,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931:900,avoid,avoid,900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931,1,['avoid'],['avoid']
Safety,"This PR implements a fully explicit free surface quasi-second-order Adams-Bashforth time stepping algorithm for `HydrostaticFreeSurfaceModel`. It also adds `examples/geostrophic_adjustment.jl`, which produces this movie:. ![geostrophic_adjustment](https://user-images.githubusercontent.com/15271942/107706468-5c9ed100-6c8e-11eb-9329-2f439ab52858.gif). To support the example, we also now export `HydrostaticFreeSurfaceModel` (and emit a warning when its instantiated to remind users that it's experimental). Happy to take criticism on the geostrophic adjustment example. It's fairly barebones right now and more serves as a sanity check for `HydrostaticFreeSurfaceModel` physics than anything else. It'd be nice to get a little more pedagogical mileage out of it, I think, if we can. This PR also adds placeholder functions for `free_surface::ImplicitFreeSurface` and `free_surface::Nothing` (rigid lid). (Note to myself/future developers: we'll need add a the `barotropic_pressure_solver` property to use for the rigid lid case.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352:624,sanity check,sanity check,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352,1,['sanity check'],['sanity check']
Safety,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:54,avoid,avoids,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,4,"['avoid', 'redund']","['avoid', 'avoided', 'avoids', 'redundant']"
Safety,"This PR implements automatically-generated function signatures with DocStringExtensions. I think this will avoid human errors when creating docstrings and also making documenting stuff easier, which hopefully will ultimately help users and novice developers. Starting this as a draft since I wanna see what effects this will have on the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2879:107,avoid,avoid,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879,1,['avoid'],['avoid']
Safety,"This PR instead of executing, e.g.,; ```; using Pkg; pkg""add Oceananigans, JLD2, Plots""; ```; it just prints them out as markdown ""code"". This way users can have them in the docs to copy-paste but the Documentation build does not execute them and thus avoids random clutter in Docs like discussed in #1315. Closes #1315.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1316:252,avoid,avoids,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316,1,['avoid'],['avoids']
Safety,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:309,avoid,avoids,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['avoid'],['avoids']
Safety,"This PR introduces an `AveragedField` type. The intent is that this field will eventually replace `Average`. Before that occurs, we need to overhaul both output writers, but especially the NetCDFOutputWriter, so that they can properly slice all types of fields. An `AveragedField` is constructed with the syntax (for example). ```julia; avg = AveragedField(operand; dims=(1, 2)); ```. where `operand` is the object being averaged (which should also be a field), and `dims` are the dimensions over which the field is reduced. There is an optional argument `data` which would be an `OffsetArray` of the correct size which avoids extra memory allocation. We also overload `Statistics.mean`, so that the above code can be written. ```julia; avg = mean(operand; dims=(1, 2)); ```. When we have `ComputedField`s, `operand` can involve `AbstractOperations`. This will come in a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930:620,avoid,avoids,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930,1,['avoid'],['avoids']
Safety,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:215,avoid,avoid,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,1,['avoid'],['avoid']
Safety,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214:1206,redund,redundant,1206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214,1,['redund'],['redundant']
Safety,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/677:501,predict,predictor,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677,1,['predict'],['predictor']
Safety,This PR nukes the `BasicModel` legacy constructor to avoid potential confusion. I also made the `NonDimensionalModel` constructor act more like the `Model` constructor. Also fixed a typo there and added a test. Resolves #429,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496:53,avoid,avoid,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496,1,['avoid'],['avoid']
Safety,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:1051,avoid,avoids,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['avoid'],['avoids']
Safety,"This PR refactors the names we export publically. I think that many names have been added that are poorly motivated --- for example, MultiRegionGrid and cubed sphere grid are _very_ experimental yet still exported. This PR mostly removes exports. Most of the removals are motivated by one of two reasons: (i) the feature is experimental or (ii) the feature is not commonly used. For (i) we would like to avoid export because as an experimental feature we would like to fix bugs or change the API without incurring an ""officially breaking change"". For (ii), the purpose is merely to avoid over-polluting the namespace. For example, `XPartition` for `MultiRegionGrid` is very easily confused with `Partition` for `DistributedComputations` (the API here should probably be reconsidered, cc @simone-silvestri). More than once I have lost cluster time because I confused `YPartition(N)` with `Partition(y=N)`. But `YPartition` isn't really useful so there's little benefit to exporting this. Of course these changes are up for debate so I welcome comments. More detail:. * Remove `OceananigansLogger`: rarely used; * Add `PartialCellBottom`: we are using it in an example, indicating that it is ready for use (not necessarily completely bug-free but we would like to bring it into regular / default use now); * Remove `WENOThirdOrder`, `WENOFifthOrder`: the syntax `WENO(order=5)` is preferred (same for `Centered` and `UpwindBiased`); * Remove `location`: this is a low-level function that does not need to be part of the API; * Add `CATKEVerticalDiffusivity`: this is ready for use, a publication is imminent.; * Remove `StateChecker`: not used as far as I know.; * Remove multi-region and cubed sphere functionality: these are experimental.; * Remove `apply_regionally!, construct_regionally, @apply_regionally, MultiRegionObject`: experimental.; * Remove `Time`: too low-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:404,avoid,avoid,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,2,['avoid'],['avoid']
Safety,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:58,predict,predictor,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['predict'],['predictor']
Safety,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:195,predict,predictor,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,1,['predict'],['predictor']
Safety,This PR removes the calculation of the diffusivities in `DiffusivityFields()` for the SmagorinskyLilly so that binary operations are avoided. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2908:133,avoid,avoided,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2908,1,['avoid'],['avoided']
Safety,This PR should be merged first before to avoid any more JLD2 files being committed to git history.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/558#issuecomment-562856985:41,avoid,avoid,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/558#issuecomment-562856985,1,['avoid'],['avoid']
Safety,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:909,recover,recovered,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['recover'],['recovered']
Safety,"This PR updates the examples to account for the fact that `field.data` returns the full offset array including all halos so you need to use `data(field)` which returns a view into the interior of the field with no halos. cc @navidcy internal wave example works for me now. Can you try on this branch?. In hindsight, maybe a more sophisticated fields API would avoid issues like this where we're so reliant on the `data(::Field)` function. Maybe things should ""just work"" for the user. Resolves #254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/257:360,avoid,avoid,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/257,1,['avoid'],['avoid']
Safety,This PR updates the instructions for building docs locally. We should avoid `Pkg.develop()` since we are offering a `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707:70,avoid,avoid,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707,1,['avoid'],['avoid']
Safety,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752:388,avoid,avoids,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752,1,['avoid'],['avoids']
Safety,"This can be implemented by implementing a new method for [`update_source_terms!`](https://github.com/climate-machine/Oceananigans.jl/blob/341c17410189528bb07cdcfc42e7e55fb81c730e/src/time_steppers.jl#L161) that dispatches on `forcing::Forcing{Tu} where Tu <: AbstractArray`. No changes are needed to the code except for this addition. When the user passes arrays to the `Forcing` constructor, the code will do the right thing as long as this method is implemented. I would note unless we write *a lot* of new code, the user will be essentially limited to either providing an array for *all* fields, or forcing for *all* fields. To allow the user to implement either forcing functions or forcing arrays requires writing 5! = 120 new methods (right?) which is not desirable. A convenience constructor for `Forcing` that detects when the user passes arrays for any of the fields will help users avoid accidentally specifying forcing arrays for some fields and functions for others. However, once we resolve the `isbitstype` problem (perhaps also using `FieldVectors` or `LabeledArrays` for `velocities` and `tracers` to retain high performance) we can introduce abstractions for the idea of an `equation` function for each field individually (which would also be stored in a `LabeledArray`), and permit more flexible equation specification by the user without inducing a combinatorial explosion of code length.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470324259:818,detect,detects,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470324259,2,"['avoid', 'detect']","['avoid', 'detects']"
Safety,"This changes the threading structure in a kernel launch to only launch over the i,j indices to avoid race conditions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1944:95,avoid,avoid,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1944,1,['avoid'],['avoid']
Safety,"This has a few benefits:. 1. Users know when `set!` has been invoked, and how long it takes to run (if we emit timing data as well); 2. Incorrect initial conditions may be detected. In a way this would look like just a single output of @christophernhill 's ""state checker"" idea, so we might be able to combine code for those utilities (which could also pave the way for default logging in `run!`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2462:172,detect,detected,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2462,1,['detect'],['detected']
Safety,"This introduces `UpwindBiasedFirstOrder` advection, and is in part inspired by #1955. This scheme is first order accurate but has the advantage of preserving positivity and extrema. The plot for convergence is updated and we see that it does have the slope that is predicted from the theory. ![convergence_rates](https://user-images.githubusercontent.com/8239041/130524906-d3afbae0-651d-4c9a-aee8-b0fb4d9dc856.png). I set the `symmetric_interpolate`'s to zero, which I think is true, but not sure if anything else should be done here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957:265,predict,predicted,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957,1,['predict'],['predicted']
Safety,"This is a great feature, though I think it should be implemented as optional functionality rather than hard coded. We can also make it default if we like. > when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs). I don't think this PR will solve this issue, because when the time-limit is up the job abruptly ends whether or not `run!` has completed. I don't know if there is a SLURM option to send a signal to your job with some waiting time before quitting (ie, giving you time to Checkpoint before the job ends).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713:276,avoid,avoid,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713,1,['avoid'],['avoid']
Safety,"This is a small nicety for friendliness^TM. For safety^TM we throw a warning if we reshaped. Just in case it wasn't intended. This allows things like. ```julia; julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1)); 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> c = Field{Nothing, Nothing, Center}(grid); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> set!(c, rand(4)); ┌ Warning: Reshaped 4-element Vector{Float64} to set! its data to; │ 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; └ @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/set!.jl:86; 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×10 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:7) with eltype Float64 with indices 1:1×1:1×-2:7; └── max=0.172696, min=0.00231136, mean=0.0906944; ```. which is nice when working with 1D data.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3535:48,safe,safety,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3535,1,['safe'],['safety']
Safety,This is a workaround to avoid printing `solver: Default` and instead print `solver: FFTImplicitFreeSurfaceSolver`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2212:24,avoid,avoid,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2212,1,['avoid'],['avoid']
Safety,"This issue is cropping up now that we regularly timeout on Travis (max runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max runtime is 60 minutes, @maleadt might be able to increase that but it's a shared resource and we probably shouldn't be hogging it up). Surprisingly Appveyor is always fast now. I think free CI servers are just generally underpowered. We definitely want to keep our tests and make them even more comprehensive so here are some ideas we can discuss (probably in January):; 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem to give out more runtime (up to 360 minutes I think) although they might always reduce that in the future if they get more users. CliMA and @simonbyrne seem to be having a good experience with Azure.; 2. Split tests into a fast smaller test set (regression only?) and the full comprehensive test set. But we still need a place to run the comprehensive test set (maybe Azure runs the comprehensive tests?). We'll probably have to do this at some point.; 3. Split up the tests into jobs that run in <50 minutes each. You can have unlimited jobs on Travis. But this feels like a lot of work to set up and the tests would still take long as you can't have that many parallel builds. We'll have to test Oceananigans + MPI pretty soon but we can worry about that later. Slurm CI or setting something up with our 4xTitan V server might be a good option here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671:48,timeout,timeout,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566810671,1,['timeout'],['timeout']
Safety,This issue is redundant with #372.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/258#issuecomment-530358056:14,redund,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/258#issuecomment-530358056,1,['redund'],['redundant']
Safety,"This likely removes some of the single device parallelism,; but decreases the risk for user mistake (everything is stream-ordered). This will cause severe merge conflicts with open PRs and depends on currently unreleased; versions of CUDA & KernelAbstractions. So I might regret doing it now, but I was curious; to see what the damage would be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924:78,risk,risk,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924,1,['risk'],['risk']
Safety,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:949,avoid,avoided,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,2,['avoid'],"['avoided', 'avoiding']"
Safety,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:49,Safe,SafeTestsets,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,2,['Safe'],['SafeTestsets']
Safety,"This redundancy creates the risk that they can be inconsistent, plus confusion about whether `previous_Δt` and `last_Δt` represent the same thing (they do). https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/clock.jl#L17. https://github.com/CliMA/Oceananigans.jl/blob/1ee317b9b6986436f18dd12d7fcdd7067d9234b7/src/TimeSteppers/quasi_adams_bashforth_2.jl#L8. We need to eliminate `previous_Δt` from `QuasiAdamsBashforth2TimeStepper`. cc @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3564:5,redund,redundancy,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3564,2,"['redund', 'risk']","['redundancy', 'risk']"
Safety,This seems a brittle:. https://github.com/CliMA/Oceananigans.jl/blob/9ffbee31bc5a2fa38dd93fa1594b94cddaebba8c/test/utils_for_runtests.jl#L34. some bug that caused MPI not to be initialized would cause the tests to be worthless but it might not be detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3879:247,detect,detected,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3879,1,['detect'],['detected']
Safety,"This works on sverdrup:. ```julia; (base) glwagner@sverdrup:Oceananigans.jl$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.1 (2021-04-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0, 0, 1), buoyancy=Buoyancy(model=SeawaterBuoyancy(Float64)), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /archive1/glwagner/Projects/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0) ; ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1). julia> ; ```. @francispoulin can you confirm this solves #1780 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-870953652:1169,avoid,avoid,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-870953652,1,['avoid'],['avoid']
Safety,"Those look great and very similar, as they should be. Each if them should compute a growth rate of the instability. Did you see what that numbers were? Theory predicts 0.139 and before we had 0.138. As long as they are 0.13 ish, then I think we have two working models!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951:159,predict,predicts,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951,1,['predict'],['predicts']
Safety,Time step with predictor velocities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:15,predict,predictor,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['predict'],['predictor']
Safety,To avoid `Manifest.toml` merge conflicts should we update NCDatasets.jl (#1217) and StaticArrays.jl (#1222) in this PR as well?. I actually don't think we use StaticArrays.jl...? I used it for the `WENO{N}` implementation but it's currently commented out until it can be made efficient (also users did not like the sympy dependency).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432:3,avoid,avoid,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-735389432,1,['avoid'],['avoid']
Safety,"To better understand [Wenegrat and Thomas, JPO 2020](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml?tab_body=pdf) (WT2020) I modifed the following examples:. 1. [Internal tide by a seamount](https://clima.github.io/OceananigansDocumentation/stable/generated/internal_tide/) and . 2. [Tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:721,avoid,avoid,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['avoid'],['avoid']
Safety,"To fill the halos of sliced fields we call `fill_halo_size`:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L335-L337. However, that code incorrectly assumes that an indices of `:` means that the whole dimension should be filled. This is wrong for fields with `Nothing` locations, which have only 1 point in the `Nothing` direction, but can still have indices `:`. There is also logic for `Nothing` locations:. https://github.com/CliMA/Oceananigans.jl/blob/6b22a796001f9cbd49aea1e44c931ccb8e8e374e/src/BoundaryConditions/fill_halo_regions.jl#L339-L352. But this is never used because of the incorrect assumption about the meaning of indices. One possibility is to convert indices in `Nothing` directions to `nothing`. That would permit dispatching on the type of the indices like we're trying to do. Another possibility is to fix the logic here. Dispatch is annoying because `loc` is a tuple, but it can be done. A third possibility is just to avoid the symbol sizes `:yz`, `xz` and `:xy`. That last seems maybe like the best choice. This bug would prevent anyone from using `ImmersedBoundaryGrid`. So I'm confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3473:1029,avoid,avoid,1029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3473,1,['avoid'],['avoid']
Safety,"To my mind there are three main ways to approach this:. 1. design simulations such that the output can be directly compared with analytical solutions;; 2. design simulations such that the statistics of the output can be compared with theory; or; 3. design simulations to mimic published results. Option 1 restricts us to systems with tractable analytical solutions, but still contains a wealth of feasible problems, such as:; 1. Munk gyre; 2. Spin down of a flow-field under the influence of friction; 3. Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; 4. Rayleigh–Bénard convection (as mentioned previously); 5. Onset of baroclinic instability: compare growth rates with analytical predictions. Option 2 lets us explore dynamics in the presence of turbulence. Potential test cases here include:; 1. 2D QG turbulence: explore energy and enstrophy cascades; 2. lee wave generation and breaking (will require large-scale flow field and bathymetry). Option 3 lets you do whatever you want - you just need to find a published result and try to reproduce it. It's unlikely that you'll get the exact same answer, so this option is more difficult to implement in a testing framework that doesn't require eyeballs to validate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237:745,predict,predictions,745,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237,1,['predict'],['predictions']
Safety,"To summarize a little more: the issue is not that `Pr` is an empty tuple --- this is perfectly fine. The bug is just in showing an empty `NamedTuple` of `Field`. The reason why . ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; ```. works is because `closure` and `model.closure` are different:. ```julia; julia> closure === model.closure; false; ```. This is generically true because we call `with_tracers` on the user-defined closure to build `model.closure`. We can fix this by avoiding `with_tracers` in the model constructor for empty `tracers`, but I'd argue we'll be better off (right now) fixing the bug in `show` for empty `NamedTuple` of `Field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227:500,avoid,avoiding,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227,1,['avoid'],['avoiding']
Safety,"True , we should avoid `reverse`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669:17,avoid,avoid,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669,1,['avoid'],['avoid']
Safety,"True, those would be good additions to the regression tests. But I might wait until we truly need to regenerate regression data as regenerating regression data adds to the size of the git repo that can only be recovered by rewriting git history. We did this once but probably don't want to do again as it pollutes git history and we may need to run tests on old versions(?). I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867:210,recover,recovered,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867,1,['recover'],['recovered']
Safety,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:28,avoid,avoid,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420,1,['avoid'],['avoid']
Safety,"Two small notes:. - It could be nice (more Julian) to use `isapprox` with the `rtol` keyword for some of the validations, rather than `minimum`. - It save work in the future to write doc strings above the function definition rather than comment sections (typically enclosed between triple quotes, ie. ```; """"""; f(x). Returns `x^2`.; """"""; f(x) = x^2; ```; Doc strings are automatically detected and compiled to documentation by Julia's `Documenter.jl` package. Next, I'm having a little trouble with the logic of these functions:. What is happening under the flag `wavenumbers=:second_order`? If derivatives are calculated with second-order finite differences, then we have no need for Fourier wavenumbers --- correct? What does this flag mean?. Why are the square wavenumbers equal to `k² = @. (4 / Δx^2) * sin(π*n / N)^2`? These are not equispaced and not equal to the Fourier wavenumbers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440808299:385,detect,detected,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440808299,1,['detect'],['detected']
Safety,"Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. It then occurred to me that we are using centre differencing for the divergence of the transport in the evolution equation for the height. That suggests that we would probably want to use 4-th order approximations to those terms as well. Question: Since we are chaging from approximations at faces to approximations at centers, should the formuals change? I don't think they should but wanted to ask, just in case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419:190,predict,predicted,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419,1,['predict'],['predicted']
Safety,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1156:518,predict,predictor,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156,3,"['avoid', 'predict']","['avoided', 'predictor']"
Safety,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:343,avoid,avoid,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,1,['avoid'],['avoid']
Safety,We can continue with the current nomenclature to avoid breaking changes and discuss again for a future PR. @glwagner This PR is now ready for review. We should also run GPU tests manually. The PR was opened from a fork so GitLab CI won't run on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-659046005:49,avoid,avoid,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-659046005,1,['avoid'],['avoid']
Safety,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:186,detect,detected,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,1,['detect'],['detected']
Safety,"We have to keep masking for velocities in the hydrostatic model. In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Models/NonhydrostaticModels/pressure_correction.jl#L12-L14",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421:139,predict,predictor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421,1,['predict'],['predictor']
Safety,"We might be able to avoid the need for users to call the function `data` by dispatching on `Colon`:. ```julia; xindex(f, i) = i; xindex(f, ::Colon) = 1:f.grid.Nx. yindex(f, i) = i; yindex(f, ::Colon) = 1:f.grid.Ny. zindex(f, i) = i; zindex(f, ::Colon) = 1:f.grid.Nz. @inline getindex(f::Field, i, j, k) = getindex(f.data, xindex(f, i), yindex(f, j), zindex(f, k)); ```. Then things like. ```julia; imshow(model.velocities.u[:, 1, :]); ```. Will plot only the interior points of `u`, avoiding the need to write `imshow(data(model.velocities.u)[:, 1, :])`. Perhaps this is desirable? Or too surprising that indexing into a field is different from indexing into its `data`? I'm not sure how much we want users to be explicitly aware / interactive with halo regions. Note that in the future, we may also want to borrow the `Colon` type to mean ""all interior points"" for specifying things like slices --- or, come up with a different meaningful shorthand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/458:20,avoid,avoid,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/458,2,['avoid'],"['avoid', 'avoiding']"
Safety,We must play this annoying game of organizing the definitions to avoid mutually circular type declarations. See: https://github.com/JuliaLang/julia/issues/269,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/69:65,avoid,avoid,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/69,1,['avoid'],['avoid']
Safety,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955:801,avoid,avoid,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955,1,['avoid'],['avoid']
Safety,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:430,avoid,avoid,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,1,['avoid'],['avoid']
Safety,"We should probably find these figures and add them back in, but probably not as part of the repo to avoid inflating the repo size. We could use a GitHub issue for figures or we could use https://github.com/CliMA/OceananigansArtifacts.jl for figures as well. X-Ref: https://github.com/CliMA/Oceananigans.jl/issues/1212",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046:100,avoid,avoid,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046,1,['avoid'],['avoid']
Safety,We'll uncomment these lines once `WENO{N}` schemes are ready to be used. And hopefully we can figure out a way to avoid frustrating users with PyCall/Conda stuff just to use Oceananigans. Resolves #990,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/996:114,avoid,avoid,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/996,1,['avoid'],['avoid']
Safety,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:211,avoid,avoids,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['avoid'],['avoids']
Safety,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:1005,predict,predict,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,1,['predict'],['predict']
Safety,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514:76,avoid,avoid,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514,2,"['avoid', 'predict']","['avoid', 'predictor-corrector']"
Safety,What about just `overwrite`? `force_overwrite` seems kinda redundant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-718723587:59,redund,redundant,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-718723587,1,['redund'],['redundant']
Safety,"When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?. ```; [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614:348,avoid,avoid,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614,1,['avoid'],['avoid']
Safety,"When `data` returns a view, all of the redundant `@views` should be removed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496893100:39,redund,redundant,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496893100,1,['redund'],['redundant']
Safety,"When using a tuple of closures, evaluation of the diffusive flux divergence for an arbitrary number of closures requires recursing into the diffusive flux operator. Currently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(ar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2101:847,abort,aborts,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101,2,"['abort', 'avoid']","['aborts', 'avoid']"
Safety,"Which document are you referring to @Yixiao-Zhang ? . I think its important to enable Float32 for science applications. It's important enough that I think this could be the subject of a paper, especially since it does not seem trivially achievable. Multi-GPU is the safe solution right now. Single precision may also accelerate multi-GPU simulations though, because it reduces the amount of information that has to be communicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160:266,safe,safe,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160,1,['safe'],['safe']
Safety,"Why do model tests have to be long runs? Surely a few timesteps is enough; to see if anything is broken. On Tue, Dec 17, 2019, 7:26 PM Ali Ramadhan <notifications@github.com> wrote:. > This issue is cropping up now that we regularly timeout on Travis (max; > runtime is 50 minutes) and we almost always time out on GitLab GPU CI (max; > runtime is 60 minutes, @maleadt <https://github.com/maleadt> might be; > able to increase that but it's a shared resource and we probably shouldn't; > be hogging it up). Surprisingly Appveyor is always fast now. I think free; > CI servers are just generally underpowered.; >; > Unfortunately it seems like paying for CI will never happen but we; > definitely want to keep our tests and make them even more comprehensive so; > here are some ideas we can discuss (probably in January):; >; > 1. See if we can move Travis CI pipelines onto Azure DevOps. They seem; > to give out more runtime (up to 360 minutes I think) although they might; > always reduce that in the future if they get more users. CliMA and; > @simonbyrne <https://github.com/simonbyrne> seem to be having a good; > experience with Azure.; > 2. Split tests into a fast smaller test set (regression only?) and the; > full comprehensive test set. But we still need a place to run the; > comprehensive test set (maybe Azure runs the comprehensive tests?). We'll; > probably have to do this at some point.; > 3. Split up the tests into jobs that run in <50 minutes each. You can; > have unlimited jobs on Travis. But this feels like a lot of work to set up; > and the tests would still take long as you can't have that many parallel; > builds.; >; > We'll have to test Oceananigans + MPI pretty soon but we can worry about; > that later. Slurm CI or setting something up with our 4xTitan V server; > might be a good option here.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638:233,timeout,timeout,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-566848638,1,['timeout'],['timeout']
Safety,Why do we need to show an `OffsetArray` of a `CuArray`? Can we avoid that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175:63,avoid,avoid,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175,1,['avoid'],['avoid']
Safety,"Working on implementing halo regions with OffsetArrays.jl right now. Got a minimal working example running with GPUifyLoops so it should be a pretty straightforward upgrade from here. The performance benchmarks will be interesting. Will open a PR soon. Some notes for myself:; * The binary and NetCDF output writers will have to be modified to avoid writing out the halo regions.; * We'll just need a kernel that fills in the halo regions at the end of each time step.; * The ""halo size"" will be part of the `Grid` and we'll probably have to make sure that the model runs with a large enough halo, e.g. halo of size 1 is enough for second-order advection schemes, but you need a halo of size 2 for fourth-order advection schemes.; * This should also make https://github.com/climate-machine/Oceananigans.jl/issues/57 redundant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-480235335:344,avoid,avoid,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/104#issuecomment-480235335,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,Would be good to have a feature that splits JLD2 files by size (e.g. maximum file size of 50 GiB or 100 outputs per file). Running large simulations right now is risky because the JLD2 files keeps getting appended to so it keeps growing in size (especially since JLD2 does not compress by default) and if the simulation stops/errors/is killed during IO the JLD2 file and all output is corrupted. We should probably also add an `info=false` flag to `JLD2OutputWriter` that is `false` by default in case a user does not want any JLD2 timings/statistics.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/344:162,risk,risky,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/344,1,['risk'],['risky']
Safety,"Would be nice to be able to specify a minimum time step for the `TimeStepWizard`. For me the main use is to avoid ""slow motion blowup"" where a numerical instability causes the model to blow up but the time step wizard keeps decreasing the time step so it just blows up in slow motion when you want it to NaN and stop executing.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1197:108,avoid,avoid,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1197,1,['avoid'],['avoid']
Safety,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1055,safe,safe,1055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['safe'],['safe']
Safety,"Yea agree that it might be considered an ""abuse of abstraction"" to define `end` to mean ""the grid point corresponding to the physical edge of the domain"". That's what @sandreza expected, however? #UsersComeFirst . Maybe what we need is a section in the docs about working with underlying discrete data structures that includes a practical discussion about halos and the staggered grid, with examples. And we'll recommend using continuous interfaces as much as possible to avoid mistakes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691067868:472,avoid,avoid,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691067868,1,['avoid'],['avoid']
Safety,"Yeah I think that's kind of what I was thinking, much more for the GPU though. Dunno what the final element-wise kernels will look like but if the kernels are shared with the CPU and GPU then I'm not sure how memory will be managed (would be nice to avoid handling GPU shared memory manually). I think you're right, we just want a ""struct of arrays"" optimization. For what it's worth @christophernhill says that the MITgcm already does this, and it doesn't seem to noticeably boost performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462545133:250,avoid,avoid,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462545133,1,['avoid'],['avoid']
Safety,"Yeah adding the Unicode symbols broke the test, since the tests group detection doesn't recognize them",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616673693:70,detect,detection,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616673693,1,['detect'],['detection']
Safety,"Yep, the immersed boundary condition `ImmersedBoundaryCondition` has fields `west, east, south, north, top, bottom`, in that case the `south` immersed bc will be active (all the others will do nothing). Apparently if you construct it with the `immersed = BC` keyword (in the `FieldBoundaryConditions` constructor) that will copy the same BC for all directions, otherwise you can specify different BCs for different directions using the `ImmersedBoundaryCondition` constructor (or avoid them if, for example, you do not want side drag in that instance). For this reason the functions to be passed in the BC have to be 3D",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106:480,avoid,avoid,480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106,1,['avoid'],['avoid']
Safety,"You can also define a function `stop_if_nan(simulation)` that returns `true` if a NaN is detected, and then add this function to a simulation's stop criteria via `push!(simulation.stop_criteria, stop_if_nan)`. A few ways to do the same thing, which is why resolving #1138 would be nice for users. . Sorry if I implied that #1138 had to be resolved first. The problem right now is there are _too many_ ways to stop a simulation, which makes the user interface confusing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733258279:89,detect,detected,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733258279,1,['detect'],['detected']
Safety,You can never avoid all typos..,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1357:14,avoid,avoid,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1357,1,['avoid'],['avoid']
Safety,"You can try incorporating the background buoyancy field into the forcing functions (formulated using the discrete form). You may also try inserting the parameters as globals rather than using the kwarg `parameters` (not sure if that will help). I'd also suggest testing whether the Smagorinsky closure affects the results of the simulation; if you can avoid using that you might be able to compile more complexity. After that, we may have to either divide up the kernels or pursue https://github.com/JuliaGPU/CUDA.jl/issues/267",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401327463:352,avoid,avoid,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401327463,1,['avoid'],['avoid']
Safety,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:777,avoid,avoid,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['avoid'],['avoid']
Safety,"You don't need to give the grid as an argument. You are calling; ```; FieldBoundaryConditions(default_bounded_bc = NoFluxBoundaryCondition();; west = DefaultBoundaryCondition(default_bounded_bc),; east = DefaultBoundaryCondition(default_bounded_bc),; south = DefaultBoundaryCondition(default_bounded_bc),; north = DefaultBoundaryCondition(default_bounded_bc),; bottom = DefaultBoundaryCondition(default_bounded_bc),; top = DefaultBoundaryCondition(default_bounded_bc),; immersed = DefaultBoundaryCondition(default_bounded_bc)) = ; FieldBoundaryConditions(west, east, south, north, bottom, top, immersed); ```; This should be enough; ```; v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0)); ```. But good catch, we should probably force a type on `default_bounded_bc` to avoid this error, since we also have a `FieldBoundaryConditions(grid, location, indices=default_indices(3))` method which might be confusing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558:785,avoid,avoid,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558,1,['avoid'],['avoid']
Safety,"You're right, it will be best if the code does not assume a constant time step anywhere. This probably just affects reading output because the current time is used when naming output files. If the time step is a constant integer then reading the files in order is easy as the file names follow a predictable pattern if you know Δt. If Δt is not constant then you'd have to glob all the files and sort them to process them in order. @christophernhill suggested to just use the iteration number to name the output files. This would fix this problem, and if a list of times is saved then you know exactly the times that corresponds with each time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462839627:296,predict,predictable,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37#issuecomment-462839627,1,['predict'],['predictable']
Safety,[49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; [1e83bf80] + StaticArraysCore v1.4.1; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v2.0.1; [4db3bf67] + StridedViews v0.1.2; [09ab397b] + StructArrays v0.6.15; [856f2bd8] + StructTypes v1.10.0; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.10.1; [6aa5eb33] + TaylorSeries v0.15.2; [a759f4b9] + TimerOutputs v0.5.23; [3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:3683,Unsafe,UnsafeAtomicsLLVM,3683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,"[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2130,avoid,avoid,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['avoid'],['avoid']
Safety,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16751,abort,aborted,16751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['abort'],['aborted']
Safety,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9558,abort,aborted,9558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['abort'],['aborted']
Safety,_jll v2.16.8+1; [442fdcdd] Measures v0.3.1; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [e1d29d7a] Missings v0.4.5; [85f8d34a] NCDatasets v0.11.3; [872c559c] NNlib v0.7.18; [77ba4419] NaNMath v0.3.5; [7243133f] NetCDF_jll v400.701.400+0; [ca575930] NetworkOptions v1.2.0; [9e8cae18] Oceananigans v0.54.2; [6fe1bfb0] OffsetArrays v1.6.2; [e7412a2a] Ogg_jll v1.3.4+2; [fe0851c0] OpenMPI_jll v4.0.2+2; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.3+4; [91d4177d] Opus_jll v1.3.1+3; [bac558e1] OrderedCollections v1.4.0; [2f80f16e] PCRE_jll v8.42.0+4; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.3; [4a48f351] PencilFFTs v0.12.2; [30392449] Pixman_jll v0.40.0+0; [ccf2f8ad] PlotThemes v2.0.1; [995b91a9] PlotUtils v1.0.10; [91a5bcdd] Plots v1.12.0; [21216c6a] Preferences v1.2.1; [ea2cea3b] Qt5Base_jll v5.15.2+0; [3cdcf5f2] RecipesBase v1.1.1; [01d81517] RecipesPipeline v0.3.2; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [992d4aef] Showoff v1.0.2; [a2af1166] SortingAlgorithms v0.3.1; [276daf66] SpecialFunctions v1.3.0; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.1.1; [15972242] StaticPermutations v0.3.0; [2913bbd2] StatsBase v0.33.5; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.1; [fa267f1f] TOML v1.0.3; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.8; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.13; [5c2747f8] URIs v1.2.0; [a2964d1f] Wayland_jll v1.17.0+4; [2381bf8a] Wayland_protocols_jll v1.18.0+4; [02c8fc9c] XML2_jll v2.9.10+3; [aed1982a] XSLT_jll v1.1.33+4; [4f6342f7] Xorg_libX11_jll v1.6.9+4; [0c0b7dd1] Xorg_libXau_jll v1.0.9+4; [935fb764] Xorg_libXcursor_jll v1.2.0+4; [a3789734] Xorg_libXdmcp_jll v1.1.3+4; [1082639a] Xorg_libXext_jll v1.3.4+4; [d091e8ba] Xorg_libXfixes_jll v5.0.3+4; [a51aa0fd] Xorg_l,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:3711,Safe,SafeTestsets,3711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Safe'],['SafeTestsets']
Safety,"` is to provide a way for users to define a function of `x, y, z, t`. However, there are other cases, perhaps less common but still important, where one might want `x, y, z, t, parameters`. . In the case that parameters are `nothing` (the default), the `SimpleForcing` function assumes that `func` is a function of `x, y, z, t`. If parameters are specified in the construction of the `SimpleForcing` object, eg. ```julia; forcing = SimpleForcing((x, y, z, t, p) -> p.a * x^2, parameters = (a=2,)); ```; then `func` must have the signature `x, y, z, t, parameters`, where `parameters` corresponds to the parameters object passed by the user to `SimpleForcing`. We could delete the `parameters` field in `SimpleForcing` and replace it with a boolean type parameter, say `with_parameters`, which indicates that `func` is a function of `x, y, z, t, p` and that `p` corresponds to `model.parameters`. Do you think this is better? . At the time this code was written I considered this possibility, but I felt the ""non-locality"" of that usage made it a bit trickier (ie, one builds `SimpleForcing` but adds `parameters` to `Model`, rather than building `SimpleForcing` and specifying parameters in `SimpleForcing`). . It seems local straightforward things like that are preferred over seemingly more elaborate interlocking systems --- but maybe I'm wrong? The advantage of local usage realizes itself when you might consider many alternative `SimpleForcing` functions. Then, rather than having to change two lines when you want to change the forcing function (since you'd have to both change the definition of your forcing function *and* change `model.parameters`), you can just change the definition of a single `SimpleForcing` object. This seems better to me. But maybe its not. Note that we have common names for subfields in many other places. For example, each field has a subfield called `data`, and we know through context that `u.data` is not the same as `v.data`. Doesn't the same logic apply here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564733831:1364,interlock,interlocking,1364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564733831,1,['interlock'],['interlocking']
Safety,"`0` is almost always safe. But neither case is really an issue. The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. ~`fill(var, 0)`~ `fill!(var, 0)` is cheap and unlikely to affect performance. That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988:21,safe,safe,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988,1,['safe'],['safe']
Safety,"`TimeAverage` suggests a single output to me, a time averaged scalar or 3D field, etc. kinda analogous to `HorizontalAverage`. `MovingTimeAverage` suggests multiple outputs to me, i.e. that the output is also a time series but it has been smoothed. So maybe naming it e.g. `MovingAverageTimeSeries` would make it more analogous to `TimeSeries`?. I like the names you proposed in your second post: `sample_frequency` and `diagnostic_frequency`. To be consistent with existing terminology, these are frequencies as in number of iterations, right? Will there also be `sample_interval` and `diagnostic_interval`? Those could be trickier to get completely right as the time step might not always coincide with a sampling or diagnostic interval unless you detect that you're going to overshoot a sampling interval and change the time step appropriately (I think OceanTurb.jl does this for time-stepping).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-584345092:750,detect,detect,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-584345092,1,['detect'],['detect']
Safety,"`^` is one of the operations we define on `AbstractField`:. https://github.com/CliMA/Oceananigans.jl/blob/927630699aac7d071b87cc87350fce6f69dbbd07/src/AbstractOperations/AbstractOperations.jl#L71. I think users will hit `Float64` exponentiation if they use this (unless they convert to `Int32`) since it the operation doesn't get compiled until after the exponent is stored:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> op = c^2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree:; ^ at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 2. julia> op.b; 2; ```. Also just as a sanity check:. ```julia; julia> op32 = c^Int32(2); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree:; ^ at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 2. julia> typeof(op32.b); Int32; ```. Further work needed to dig into this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876057623:1330,sanity check,sanity check,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876057623,1,['sanity check'],['sanity check']
Safety,"```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ C:\Users\ADMIN\.julia\packages\OffsetArrays\rMTtC\src\OffsetArrays.jl:422 [inlined]; [10] getindex; @ C:\Users\ADMIN\.julia\packages\Oceananigans\E4XVr\src\Fields\field.jl:540 [inlined]; [11] rescale!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Fl... (repeats 1 time); [12] top-level scope; @ In[10]:9; ```. This is an error message I am getting from my code. Please share your comments on how to resolve this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299:286,avoid,avoided,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299,1,['avoid'],['avoided']
Safety,`clobber=false` is probably safer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-563226943:28,safe,safer,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-563226943,1,['safe'],['safer']
Safety,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:753,avoid,avoid,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,2,['avoid'],['avoid']
Safety,`test/test_*.jl` is a redundant naming scheme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/871:22,redund,redundant,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871,1,['redund'],['redundant']
Safety,aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:6568,Unsafe,UnsafeAtomics,6568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Unsafe'],['UnsafeAtomics']
Safety,"again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen issues in scenarios that we haven't tested, or rather are impossible to ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3183,Risk,Risk,3183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['Risk'],['Risk']
Safety,"antFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: Linux (x86_64-redhat-linux); CPU: Intel(R) Xeon(R) Platinum 8268 CPU @ 2.90GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_DEPOT_PATH = /g/data/v45/nc3020/.julia:/share/julia/site/; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_LOAD_PATH = @:@v#.#:@stdlib:@site; JULIA_NUM_THREADS = 48. shell> nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Tue Feb 21 07:30:33 2023; Driver Version : 525.60.13; CUDA Version : 12.0. Attached GPUs : 1; GPU 00000000:3D:00.0; Product Name : Tesla V100-SXM2-32GB; Product Brand : ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:18245,Safe,SafeTestsets,18245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:1569,predict,predictor,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,2,['predict'],"['predictor', 'predictor-corrector']"
Safety,"ation . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:1649,redund,redundancies,1649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['redund'],['redundancies']
Safety,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2448,avoid,avoided,2448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,1,['avoid'],['avoided']
Safety,"best to avoid lowercase `l` I think. Why don't we just keep capital `N` for now. I think we could have some changes coming down the pipe that would greatly facilitate this change (macro that pastes our triple loop, so reduce that massive amount of boilerplate and can change syntax in single place rather than 30 different locations). I thought `RegularCartesianGrid(FT, nx, ny, nz; length) ` could dispatch on its 4 positional args. What is the conflicting function `RegularCartesianGrid` that has 4 positional args, and why can't dispatch be used there?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333:8,avoid,avoid,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204333,1,['avoid'],['avoid']
Safety,c] LogExpFunctions v0.3.15; [e6f89c97] LoggingExtras v1.0.0; [da04e1cc] MPI v0.19.2; [3da0fdf6] MPIPreferences v0.1.7; [1914dd2f] MacroTools v0.5.9; [739be429] MbedTLS v1.1.7; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.5; [85f8d34a] NCDatasets v0.12.4; [77ba4419] NaNMath v1.0.0; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [4d8831e6] OpenSSL v1.3.3; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v2.3.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [b98c9c47] Pipe v1.3.0; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.3.4; [91a5bcdd] Plots v1.36.0; [21216c6a] Preferences v1.3.0; [94ee1d12] Quaternions v0.5.6; [74087812] Random123 v1.5.0; [e6cf234a] RandomNumbers v1.5.3; [3cdcf5f2] RecipesBase v1.2.1; [01d81517] RecipesPipeline v0.6.9; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.0; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.1.1; [d496a93d] SeawaterPolynomials v0.2.3; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [66db9d55] SnoopPrecompile v1.0.3; [a2af1166] SortingAlgorithms v1.1.0; [276daf66] SpecialFunctions v2.1.5; [aedffcd0] Static v0.6.5; [90137ffa] StaticArrays v1.4.4; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.5.0; [2913bbd2] StatsBase v0.33.21; [5e0ebb24] Strided v1.2.2; [09ab397b] StructArrays v0.6.7; [856f2bd8] StructTypes v1.8.1; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.7.0; [6aa5eb33] TaylorSeries v0.10.13; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.9.1; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.9.6; [bc48ee85] Tullio v0.3.4; [9d95972d] TupleTools v1.3.0; [5c2747f8] URIs v1.4.2; [1cfade01] UnicodeFun v0.4.1; [41fe7b60] Unzip v0.1.2; [81def892] VersionParsing v1.3.0; [6e34b625] Bzip2_jll v1.0.8+0; [83423d85] Cairo_jll v1.16.1+1; [2e619515] Ex,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:4826,Safe,SafeTestsets,4826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2201,avoid,avoids,2201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,1,['avoid'],['avoids']
Safety,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:1907,avoid,avoid,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['avoid'],['avoid']
Safety,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1263,recover,recovered,1263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,1,['recover'],['recovered']
Safety,dd2f] MacroTools v0.5.6; [739be429] MbedTLS v1.0.3; [c8ffd9c3] MbedTLS_jll v2.16.8+1; [442fdcdd] Measures v0.3.1; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [e1d29d7a] Missings v0.4.5; [85f8d34a] NCDatasets v0.11.3; [872c559c] NNlib v0.7.14; [77ba4419] NaNMath v0.3.5; [7243133f] NetCDF_jll v400.701.400+0; [9e8cae18] Oceananigans v0.54.2; [6fe1bfb0] OffsetArrays v1.6.1; [e7412a2a] Ogg_jll v1.3.4+2; [fe0851c0] OpenMPI_jll v4.0.2+2; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.3+4; [91d4177d] Opus_jll v1.3.1+3; [bac558e1] OrderedCollections v1.4.0; [2f80f16e] PCRE_jll v8.42.0+4; [69de0a69] Parsers v1.0.15; [0e08944d] PencilArrays v0.7.0; [4a48f351] PencilFFTs v0.12.2; [30392449] Pixman_jll v0.40.0+0; [ccf2f8ad] PlotThemes v2.0.1; [995b91a9] PlotUtils v1.0.10; [91a5bcdd] Plots v1.9.0; [ede63266] Qt_jll v5.15.2+3; [3cdcf5f2] RecipesBase v1.1.1; [01d81517] RecipesPipeline v0.2.1; [189a3867] Reexport v0.2.0; [ae029012] Requires v1.1.2; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [992d4aef] Showoff v0.3.2; [a2af1166] SortingAlgorithms v0.3.1; [276daf66] SpecialFunctions v0.10.3; [90137ffa] StaticArrays v0.12.5; [15972242] StaticPermutations v0.2.1; [2913bbd2] StatsBase v0.33.3; [09ab397b] StructArrays v0.5.0; [856f2bd8] StructTypes v1.4.0; [3783bdb8] TableTraits v1.0.0; [bd369af6] Tables v1.3.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.8; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.13; [a2964d1f] Wayland_jll v1.17.0+4; [2381bf8a] Wayland_protocols_jll v1.18.0+4; [02c8fc9c] XML2_jll v2.9.10+3; [aed1982a] XSLT_jll v1.1.33+4; [4f6342f7] Xorg_libX11_jll v1.6.9+4; [0c0b7dd1] Xorg_libXau_jll v1.0.9+4; [935fb764] Xorg_libXcursor_jll v1.2.0+4; [a3789734] Xorg_libXdmcp_jll v1.1.3+4; [1082639a] Xorg_libXext_jll v1.3.4+4; [d091e8ba] Xorg_libXfixes_jll v5.0.3+4; [a51aa0fd] Xorg_libXi_jll v1.7.10+4; [d1454406] Xorg_libXinerama_jll v1.1.4+4; [ec84b674],MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:3927,Safe,SafeTestsets,3927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Safe'],['SafeTestsets']
Safety,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:1905,avoid,avoid,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,2,['avoid'],['avoid']
Safety,"e pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/403:2228,avoid,avoiding,2228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403,1,['avoid'],['avoiding']
Safety,"e would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in this PR, this is not enough to fix issues with the immersed boundary MWE... but whether or not that is because of problems with the setup itself, I'm not sure... - All of that said, taking @tomchor suggestion to be more careful in updating the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1211,avoid,avoided,1211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,['avoid'],"['avoid', 'avoided']"
Safety,"e). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_mask_cos(x, y, z); if z₀ >= z > z₁; return 1/2 * (1 - cos( π*(z-z₀)/(z₁-z₀) )); elseif z₁ >= z #> z₂; return 1.0; else; return 0.0; end ; end. @inline sponge_u(x, y, z, t, u, p) = -bottom_mask_cos(x, y, z) * p.σ * u; @inline sponge_v(x, y, z, t, v, p) = -bottom_mask_cos(x, y, z) * p.σ * v; @inline sponge_w(x, y, z, t, w, p) = -bottom_mask_cos(x, y, z) * p.σ * w; @inline sponge_b(x, y, z, t, b, p) = -bottom_mask_cos(x, y, z) * p.σ * (b - b∞(0, 0, z, 0, p)). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; params.σ)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; params.σ)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; params.σ)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; params.σ, params.N²∞)); ```. The above are the forcing functions, and below is the background field. There are also parameters passed for the boundary conditions. ```julia; @inline b_bg(x, y, z, t, p) = p.M² * x; B_field = BackgroundField(b_bg, parameters = (; params.M²)); ```. Changing things so that variables that are currently passed as parameters are set as `const`ants helps (as you can see I did with `z₀`, etc.). However, that also means I can't run back-to-back simulations where those parameters differ, which is something that makes my workflow way more streamlined, so I'm trying to avoid that. (Although I'll ultimately have to do that if we can't figure this error out...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:3349,avoid,avoid,3349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['avoid'],['avoid']
Safety,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5663,timeout,timeout,5663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['timeout'],['timeout']
Safety,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:2354,abort,aborted,2354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889,1,['abort'],['aborted']
Safety,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1436,avoid,avoid,1436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['avoid'],['avoid']
Safety,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:1449,avoid,avoids,1449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,1,['avoid'],['avoids']
Safety,"eraged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:1130,avoid,avoid,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['avoid'],['avoid']
Safety,"es/jest</code> from 29.5.11 to 29.5.12 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/210"">julia-actions/setup-julia#210</a></li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5542,avoid,avoid,5542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['avoid'],['avoid']
Safety,"ess, should be the same for 1D, 2D, and 3D. So in the 2D turbulence example the domain is decomposed in y since that's the only decomposition currently supported. > Also (again correct me if I'm missing something) from my talks with you guys about this it seems that the primary goal of MPI-distributed parallelism is to run multi-GPU simulations, since GPUs have a relatively low memory limit. In this case, I think the way to use MPI is very different from the traditional multi-CPU runs. That is, I think the important capabilities when distributing a simulation across a few GPUs are different from the important capabilities when distributing it across hundreds of CPU cores. Yeah for sure. If you can only decompose in y and you want to run on hundreds of CPU ranks then each rank gets a very thin domain, almost a slice. The surface-to-volume ratio of each rank is high which means lots of communication overhead. If you're running a huge simulation on a moderate number of GPUs then each rank gets a pretty thick slice so the surface-to-volume ratio is smaller, leading to less communication overhead. Definitely agree that it's probably not a huge deal for now. > In principle I completely agree with this. In principle communicating with another sub-domain is treated exactly the same as you treat BCs, right? Which is to fill the halo region accordingly. The only difference being that the proper way to fill it now depends on other processes, instead of depending on the user definitions of the BCs. ; >; > This is also true when a subdomain is, say, `Periodic` on the left and communicating on the right. Both the left and right halo regions have to filled using information outside of that particular subdomain. So I think treating that subdomain direction as `Bounded` is appropriate!. Thanks for the thoughts! I think using `Bounded` makes a lot of sense for the reasons you mentioned. Also would be good to avoid adding a new non-physical topology to do with halo communication haha.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786128856:2310,avoid,avoid,2310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786128856,1,['avoid'],['avoid']
Safety,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:2678,avoid,avoids,2678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['avoid'],['avoids']
Safety,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11329,Safe,SafeTestsets,11329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Safe'],['SafeTestsets']
Safety,"han having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of introducing anything now (maybe actually showing how to integrate workflow management tools into Oceananigans scripts is a better solution). But I thought it would be useful to open this up for discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:2806,risk,risk,2806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['risk'],['risk']
Safety,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:1293,avoid,avoiding,1293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,1,['avoid'],['avoiding']
Safety,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:240,Abort,Abort,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289,1,['Abort'],['Abort']
Safety,"https://github.com/CliMA/Oceananigans.jl/blob/2bb159c74774309ca1c80004e8cf5b5ae195d9f8/src/Grids/automatic_halo_sizing.jl#L40-L44. For example. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> grid = RegularRectilinearGrid(size = (10, 20), extent=(1, 2), topology=(Bounded, Bounded, Flat)); RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}; domain: x ∈ [-1.6190752442450216e-17, 0.9999999999999999], y ∈ [0.0, 2.0], z ∈ [0.0, 0.0]; topology: (Bounded, Bounded, Flat); resolution (Nx, Ny, Nz): (10, 20, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.1, 0.1, 0.0). julia> model = NonhydrostaticModel(grid=grid, advection = UpwindBiasedFifthOrder()); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/.julia/packages/Oceananigans/9o1xJ/src/Grids/automatic_halo_sizing.jl:41; NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}(Nx=10, Ny=20, Nz=1); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing; ```; while, because `topology=(Bounded, Bounded, Flat)` we need to pass `halo=(3, 3)` to grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1956:847,avoid,avoid,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1956,1,['avoid'],['avoid']
Safety,"https://github.com/CliMA/Oceananigans.jl/blob/e5a3d10df0d350af541613b5a47e963252f8f35d/src/Grids/regular_latitude_longitude_grid.jl#L33. What if we wanted to use `λ ∈ [-280, 80]`?. (Often people use this domain to avoid having the ""seam"" in the middle of the Pacific...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1815:214,avoid,avoid,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1815,1,['avoid'],['avoid']
Safety,"https://github.com/CliMA/Oceananigans.jl/pull/2740 Introduced extra memory allocation in output construction of ComputedFields to satisfy sliced boundary conditions constraints. This PR changes the definition of `view(f::Field, indices...)` in order to automatically satisfy sliced boundary condition constraints and avoid unnecessary memory allocation. closes #2794 ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2797:317,avoid,avoid,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2797,1,['avoid'],['avoid']
Safety,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:1713,redund,redundantly,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,1,['redund'],['redundantly']
Safety,"in decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pressures in https://github.com/CliMA/Oceananigans.jl/pull/1910. However, buoyancy was not reconstructed properly in the momentum equations (buoyancy is at tracer points; thus the buoyancy force has to be interpolated to by included in the vertical momentum balance). and thus the discretization was incorrect and produced spurious dynamics. This bug was fixed by https://github.com/CliMA/Oceananigans.jl/pull/3079. In all of our tests so far, the ""dynamics seem clean"". However, it's not clear whether there are unforeseen i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:3158,risk,risks,3158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['risk'],['risks']
Safety,"iters`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpoi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:1685,avoid,avoid,1685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['avoid'],['avoid']
Safety,"ity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOpera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:2402,abort,aborted,2402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['abort'],['aborted']
Safety,"ized to the JLD2 file, and cannot be read outside of Julia. You might want to serialize the grid when checkpointing to easily restore from a checkpoint file. But when saving the grid to a JLD2 output file, which may be read by a language other than Julia, the grid properties should be saved in a language-agnostic manner. Same for boundary conditions. So I changed the way structs are saved to disk for both the JLD2 output writer and the checkpointer. It's all done recursively via multiple dispatch so it should be flexible enough to work for all current `Model` properties and it should accomodate future changes to `Model` with minor changes. When saving stuff to disk like a JLD2 file, `saveproperty!` is used, which converts Julia objects to language-agnostic objects. When checkpointing, `serializeproperty!` is used, which serializes objects, with fields and boundary conditions require special treatment. We checkpoint structs that are important for timestepping. Diagnostics and output writers are not checkpointed, as they are not essential and can be added in any time after model constructions. But if one or more boundary conditions contain a function, `model.boundary_conditions` are not serialized and must be manually restored. There is one mess bits associated with restoring from a checkpoint:; * Fields cannot be passed to the `Model` constructor. When restoring fields we want to avoid loading a field from disk and allocating `Model` memory for it at the same time, as we won't be able to restore models whose memory footprint exceed ~half the CPU/GPU memory. Thus restoring fields is treated as a special case (see `restore_fields!`). It is done after model creation where fields are read from disk and used to fill up existing model fields. Unfortunately, `model.timestepper` doesn't fit the pattern and is treated as an extra special case. @glwagner Let me know what you think. This PR has been open for a while so I'd like to merge it ASAP and work on more pressing issues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524941619:1535,avoid,avoid,1535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524941619,1,['avoid'],['avoid']
Safety,"l(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not passing the `indices` flag (i.e. writing 3D fields instead slices) apparently gets rid of this issue. Here, even though the obvious easy solution is to separate averages from slices when writing, a user wouldn't know that since this fails silently and the wrong results can be pretty subtle (as the example above hopefully illustrates). For example, it popped up in one of my simulations and it took me a while to even realize what was happening, let alone figure out the solution. My main question is: is this expected behavior? If so, should we somehow warn users (or even throw an error) do avoid mistakes?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931:2900,avoid,avoid,2900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931,1,['avoid'],['avoid']
Safety,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:2222,avoid,avoids,2222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['avoid'],['avoids']
Safety,"ll time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 51.564 s; [ Info: i: 1900, t: 4.180 hr, Δt: 8.548 s, umax = (8.7e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 53.794 s; [ Info: Simulation is stopping. Model time 4.180 hr has hit or exceeded simulation stop time 4.000 hr.; WARNING: using Plots.grid in module Main conflicts with an existing identifier.; [ Info: Making an animation from the saved data...; [ Info: Drawing frame 1 from iteration 0 ; Illegal inttoptr; %33 = ptrtoint double addrspace(13)* %32 to i64; Illegal inttoptr; %52 = inttoptr i64 %51 to i8 addrspace(13)*. signal (6): Aborted; in expression starting at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:271; gsignal at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); abort at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x7f83cc060d04); _ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm13FPPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:2541,Abort,Aborted,2541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Abort'],['Aborted']
Safety,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ┌───────────────┬─────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Stretched │ 7.122 s │ 7.122 s │ 7.122 s │ 7.122 s │ 949.91 KiB │ 1716 │ 1 │; │ CPU │ StretchedSmoothness │ 11.042 s │ 11.042 s │ 11.042 s │ 11.042 s │ 956.47 KiB │ 1716 │ 1 │; │ CPU │ Uniform │ 6.373 s │ 6.373 s │ 6.373 s │ 6.373 s │ 945.38 KiB │ 1706 │ 1 │; │ CPU │ ZFormulation │ 7.725 s │ 7.725 s │ 7.725 s │ 7.725 s │ 945.38 KiB │ 1706 │ 1 │; │ GPU │ Stretched │ 25.646 ms │ 25.920 ms │ 26.501 ms │ 32.101 ms │ 2.15 MiB │ 30442 │ 10 │; │ GPU │ StretchedSmoothness │ 109.080 ms │ 109.493 ms │ 109.676 ms │ 111.118 ms │ 3.78 MiB │ 134069 │ 10 │; │ GPU │ Uniform │ 25.133 ms │ 25.394 ms │ 25.468 ms │ 26.710 ms │ 2.06 MiB │ 27799 │ 10 │; │ GPU │ ZFormulation │ 30.554 ms │ 32.780 ms │ 32.569 ms │ 32.922 ms │ 2.20 MiB │ 37382 │ 10 │; └───────────────┴─────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5499,avoid,avoid,5499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['avoid'],['avoid']
Safety,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:3692,predict,predictor-corrector,3692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186,1,['predict'],['predictor-corrector']
Safety,"lp, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1230,Safe,SafeTestsets,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"n't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to accommodate array forcings with the current framework somehow (and avoid complicating the time stepping code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:2067,avoid,avoid,2067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,1,['avoid'],['avoid']
Safety,net/ productionresultssa8.blob.core.windows.net/ productionresultssa9.blob.core.windows.net/ productionresultssa10.blob.core.windows.net/ productionresultssa11.blob.core.windows.net/ productionresultssa12.blob.core.windows.net/ productionresultssa13.blob.core.windows.net/ productionresultssa14.blob.core.windows.net/ productionresultssa15.blob.core.windows.net/ productionresultssa16.blob.core.windows.net/ productionresultssa17.blob.core.windows.net/ productionresultssa18.blob.core.windows.net/ productionresultssa19.blob.core.windows.net/ github-production-repository-image-32fea6.s3.amazonaws.com github-production-release-asset-2e65be.s3.amazonaws.com insights.github.com wss://alive.github.com; font-src github.githubassets.com; form-action 'self' github.com gist.github.com copilot-workspace.githubnext.com objects-origin.githubusercontent.com; frame-ancestors 'none'; frame-src viewscreen.githubusercontent.com notebooks.githubusercontent.com; img-src 'self' data: github.githubassets.com media.githubusercontent.com camo.githubusercontent.com identicons.github.com avatars.githubusercontent.com github-cloud.s3.amazonaws.com objects.githubusercontent.com secured-user-images.githubusercontent.com/ user-images.githubusercontent.com/ private-user-images.githubusercontent.com opengraph.githubassets.com github-production-user-asset-6210df.s3.amazonaws.com customer-stories-feed.github.com spotlights-feed.github.com objects-origin.githubusercontent.com *.githubusercontent.com; manifest-src 'self'; media-src github.com user-images.githubusercontent.com/ secured-user-images.githubusercontent.com/ private-user-images.githubusercontent.com github-production-user-asset-6210df.s3.amazonaws.com gist.github.com; script-src github.githubassets.com; style-src 'unsafe-inline' github.githubassets.com; upgrade-insecure-requests; worker-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; Transfer-Encoding: chunked; X-GitHub-Request-Id: 85AA:37E5AB:1E9255C:2BAFBE6:6674307A; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:4181,unsafe,unsafe-inline,4181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,1,['unsafe'],['unsafe-inline']
Safety,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1643,avoid,avoid,1643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['avoid'],['avoid']
Safety,"ntal_averages`, `volume_averages`). # Saving collections of slices. For number 1, I can imagine an abstraction, perhaps a collection of output writers like `NetCDFOutputWriters`, that allows you to specify a number of slice outputs for all fields:. ```julia; slices = (all = FieldSlicer(),; xy_surface = FieldSlicer(k=grid.Nz),; xy_subsurface = FieldSlicer(k=k_subsurface),; xy_middepth = FieldSlicer(k=round(Int, grid.Nz/2)),; xy_bottom = FieldSlicer(k=1),; xz = FieldSlicer(j=1),; yz = FieldSlicer(i=1)). simulation.output_writers[:slices] = NetCDFOutputWriters(filepath_prefix=""eady_turbulence"", slices=slices, ...); ```. This would save all fields in `merge(model.velocities, model.tracers)` to `eady_turbulence_all.nc`, `eady_turbulence_xy_surface.nc`, etc. with appropriate slicing. You could pass in one schedule for all slices, or a named tuple of schedules if you want different schedules for different output writers. I think it makes sense to have a `filepath_prefix` for the collection of output writers, e.g. `NetCDFOutputWriters`, while just `filepath` for individual output writers, e.g. `NetCDFOutputWriter`. I thought about adding this functionality to the `Simulation` constructor with kwargs like `output=:netcdf` or `output=:jld2` but felt like the number of extra kwargs would just make it messy. # Saving collections of computed fields. For number 2, we could perhaps automate some of this to avoid boilerplate like https://github.com/glwagner/EadyTurbulence/blob/6581af1cd867d8ad69dac7ea09deb3078c505c24/initial_value_problem/eady_initial_value_problem.jl#L149-L163. Not sure if we want yet another super-constructor but one idea is to add something like `AveragedNetCDFOutputWriter`. ```julia; averages = (u=u, v=v, b=b, ζ²=ζ², b²=b², bz=∂z(b)). simulations.output_writers[:horizontal_averages] = AveragedNetCDFOutputWriter(model, averages, dims=(1, 2), ...). simulations.output_writers[:volume_averages] = AveragedNetCDFOutputWriter(model, averages, dims=(1, 2, 3), ...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256:1747,avoid,avoid,1747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171#issuecomment-726162256,1,['avoid'],['avoid']
Safety,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2705,recover,recover,2705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['recover'],['recover']
Safety,"o that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2432,avoid,avoid,2432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['avoid'],['avoid']
Safety,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:1518,avoid,avoid,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['avoid'],['avoid']
Safety,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:2791,avoid,avoids,2791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['avoid'],['avoids']
Safety,"oint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; ```. One option to add safety is to modify `set!(model, filepath::AbstractString)` to take an option argument `skip_missing_variables = false` (or something), which would change the behavior from throwing a warning to throwing an error. @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:3759,safe,safety,3759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['safe'],['safety']
Safety,"on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = Rectilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1191,interlock,interlocked,1191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['interlock'],['interlocked']
Safety,"oops - pasted this in the wrong place earlier! . @glwagner and @ali-ramadhan I took a quick look.; I think you should go ahead and merge, but quick comments for future reference -. there are a bunch of changes unrelated to the PR in the PR. They are probably there by accident, but the Git gods really don't like that. When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Most git projects more diligent about avoiding polluted PRs, which can be useful. I think ultimately we want halos to just be a thing that does a slightly more general form of what is in ::PBC mode. Everything else is not in halo rules. This is where we ended up in MITgcm and is similar to what is in MPIStateArray in the DG work (I am fairly sure!). A distinction to maybe think about is a set of halo() functions that just do the stuff that does not appear in any of the equations. Anything in equations turns out to be stuff that people may want to tinker with in surprisingly interesting ways. For example someone ultimately might want to do a numerical experiment that has flux BC on some set of the one bit of a boundary, something else on another bit etc.... (people do do things like this). For better or worse having bc's better separated from halos may ultimately prove the right thing. For now I wouldn't worry about it though!. Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Types are good for simple things, but Type::ItsComplicated is often also needed eventually. summary - +1 for merge, ; per https://github.com/google/eng-practices/blob/master/review/reviewer/standard.md ""its a step forward, its not a step backward, its maybe not the ultimate answer""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853:531,avoid,avoiding,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853,1,['avoid'],['avoiding']
Safety,"or both Oceananigans.Operators and; > closure_operators.jl. This will test that the finite volume operators; > reduce down to the operators that currently work, but doesn't test them on; > a stretched grid.; > 5. Implement a VerticallyStretchedCartesianGrid. Might have to iterate; > bit to figure out what we need, e.g. I think we'll want ΔzC to include the; > distance between the first cell center and the halo cell center, etc.; > 6. Implement CPU and GPU pressure solvers for vertically stretched; > grids with tests. There will be two: one for horizontally periodic domains; > and another for channel models. I've figured most of this stuff out in; > Jupyter notebooks.; > 7. Ensure that models with vertically stretched grids pass basic; > tests: e.g. incompressibility, tracer conservation, etc. This will test the; > finite volume operators.; > 8. Run a model with a VerticallyStretchedCartesianGrid but with; > uniform grid spacing and make sure it produces the same numbers as a model; > with RegularCartesianGrid. This is a sanity check.; > 9. Run additional tests for vertically stretched grids: e.g. vertical; > diffusion, internal wave, etc. This will also test boundary conditions with; > stretched grids.; > 10. Rerun the stratified Couette flow verification experiment but with; > a stretching factor matching Vreugdenhil & Taylor (2018). This will test; > the AMD closure on stretched grids.; >; > Let me know if anyone has any thoughts. cc @jm-c <https://github.com/jm-c>; > @rafferrari <https://github.com/rafferrari>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/471?email_source=notifications&email_token=AKXUEQULGTW4EOYLESVYBPTQOI5CRA5CNFSM4JAEMMD2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HRMSY6Q>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTYMTRQSQIOMRLIHPTQOI5CRANCNFSM4JAEMMDQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187:2547,sanity check,sanity check,2547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187,1,['sanity check'],['sanity check']
Safety,or partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-d-15-0226.1.xml); [Large-eddy simulations with ClimateMachine v0.2.0: a new open-source code for atmospheric simulations on GPUs and CPUs](https://gmd.copernicus.org/articles/15/6259/2022/); [Medium range forecasts using cut-cells: a sensitivity study](https://link.springer.com/article/10.1007/s00703-019-00681-w); [On methods for solving the oceanic equations of motion in generalized vertical coordinates](https://www.sciencedirect.com/science/article/abs/pii/S1463500305000090); [Representation of topography by porous barriers and objective interpolation of topographic data](https://www.sciencedirect.com/science/article/pii/S1463500313000425); [Representation of Topography by Shaved Cells in a Height Coordinate,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:2613,Predict,Prediction,2613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['Predict'],['Prediction']
Safety,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2038,avoid,avoid,2038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['avoid'],['avoid']
Safety,pleBufferStream v1.1.0; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.3.1; [aedffcd0] Static v0.8.10; [0d7ed370] StaticArrayInterface v1.5.0; [90137ffa] StaticArrays v1.9.3; [1e83bf80] StaticArraysCore v1.4.2; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [2913bbd2] StatsBase v0.34.2; [5e0ebb24] Strided v2.0.4; [4db3bf67] StridedViews v0.2.2; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [53d494c1] StructIO v0.3.0; [856f2bd8] StructTypes v1.10.0; [dc5dba14] TZJData v1.1.0+2023d; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.11.1; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.13.0; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.10.4; [9d95972d] TupleTools v1.5.0; [5c2747f8] URIs v1.5.1; [1cfade01] UnicodeFun v0.4.1; [1986cc42] Unitful v1.19.0; [45397f5d] UnitfulLatexify v1.6.3; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.3; [41fe7b60] Unzip v0.2.0; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; ⌅ [4ee394cb] CUDA_Driver_jll v0.7.0+1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; [83423d85] Cairo_jll v1.18.0+1; [7cc45869] Enzyme_jll v0.0.102+0; [2702e6a9] EpollShim_jll v0.0.20230411+0; [2e619515] Expat_jll v2.5.0+0; ⌅ [b22a6f82] FFMPEG_jll v4.4.4+1; [f5851436] FFTW_jll v3.3.10+0; [a3f928ae] Fontconfig_jll v2.13.93+0; [d7e528f0] FreeType2_jll v2.13.1+0; [559328eb] FriBidi_jll v1.0.10+0; [0656b61e] GLFW_jll v3.3.9+0; [d2c73de3] GR_jll v0.73.3+0; [78b55507] Gettext_jll v0.21.0+0; [7746bdde] Glib_jll v2.80.0+0; [0951126a] GnuTLS_jll v3.8.3+0; [3b182d85] Graphite2_jll v1.3.14+0; [0234f1f7] HDF5_jll v1.14.3+1; [2e76f6c2] HarfBuzz_jll v2.8.1+1; [e33a78d0] Hwloc_jll v2.10.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.0.2+0; [aacddb02] JpegTurbo_jll v3.0.2+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [c1c5ebd0] LAME_jll v3.100.1+0; [88015f11] LERC_jll v3.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:6601,Unsafe,UnsafeAtomicsLLVM,6601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,prTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] + LLVM v4.6.0; [2ab3a3ac] + LogExpFunctions v0.3.3; [da04e1cc] + MPI v0.19.0; [1914dd2f] + MacroTools v0.5.8; [85f8d34a] + NCDatasets v0.11.7; [77ba4419] + NaNMath v0.3.5; [9e8cae18] + Oceananigans v0.63.1; [6fe1bfb0] + OffsetArrays v1.10.7; [bac558e1] + OrderedCollections v1.4.1; [69de0a69] + Parsers v2.0.5; [0e08944d] + PencilArrays v0.10.0; [4a48f351] + PencilFFTs v0.12.5; [21216c6a] + Preferences v1.2.2; [74087812] + Random123 v1.4.2; [e6cf234a] + RandomNumbers v1.5.3; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base6,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:2619,Safe,SafeTestsets,2619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Safe'],['SafeTestsets']
Safety,ptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:13690,Safe,SafeTestsets,13690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Safe'],['SafeTestsets']
Safety,"rcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). linear_u_eqn(i, j, k, grid, etc....) = (fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). v_eqn(...) = ... # in the model constructor:. if eqntype = :linear; velocities_equation = (u=linear_u_eqn, v=linear_v_eqn, w=linear_w_eqn); else; velocities_equation = (u=u_eqn, v=v_eqn, w=w_eqn); end. model.equation = (velocities=velocities_equation, tracers=...). # Inside calculate_interior_source_terms!. G.u[i, j, k] = eqn.velocities.u(i, j, k, grid, etc...). ntuple(Val(length(tracers))) do tr; Gtracer = getfield(G, keys(tracers)[tr]); tracer_equation = eqn.tracers[tr]; Gtracer[i, j, k] = tracer_equation(i, j, k, grid, etc...); end; ```. ## Equations as new types. Even more flexibility / clarity might be provided by a callable `Equation` type implementation with appropriate type parameters (`Linear`, `Hydrostatic`, etc) which would avoid the need for `if` statements as on the last line of the code above. I'm not sure exactly what that would look like. The design problem for a new `Equation` type does seem a bit more difficult and would require care --- thinking about how we would implement a nonlinear biological model might provide a nice use case to help use make our ideas concrete. Hopefully this provides food for thought and also motivates us to think carefully about our design decisions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:4067,avoid,avoid,4067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['avoid'],['avoid']
Safety,"rences in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which is quite nice, but you have to modify the original LaTeX and avoid using fancy packages. But it has `\bm` which is awesome!; 2. I'm depending on `Documenter#master` as the upcoming v0.24 has an awesome new layout and dark mode.; 3. Documentation building on Travis is failing so gotta figure this out as well. Resolves #102; Resolves #222; Resolves #240; Resolves #327; Resolves #332; Resolves #353; Resolves #354",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:3164,avoid,avoid,3164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['avoid'],['avoid']
Safety,"rpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't follow, but if there's something to improve about picking simulations up we should pursue that. PS @milankl may be interested in this discussion, because it illustrates the importance of being able to modify tracer fields mid-run rather than requiring that they are initialized when the model is built.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:1922,safe,safe,1922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680,1,['safe'],['safe']
Safety,"s:. ```Julia; julia> using Oceananigans; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/E3Wer/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Ocean",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:1047,avoid,avoid,1047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['avoid'],['avoid']
Safety,"stead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:1412,predict,predictor-corrector,1412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,1,['predict'],['predictor-corrector']
Safety,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1032,predict,predictor,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,1,['predict'],['predictor']
Safety,"stol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (109.482 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.840 seconds).; iteration: 1, time: 0.1000, U_max=(1.19e-02, 5.23e-03, 5.19e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-1.78e-03, abs(max)=1.06e-02); iteration: 2, time: 0.2000, U_max=(1.21e-02, 4.93e-03, 5.20e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-9.30e-04, abs(max)=5.56e-03); iteration: 3, time: 0.3000, U_max=(1.25e-02, 5.02e-03, 5.32e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-4.85e-04, abs(max)=2.74e-03); iteration: 4, time: 0.4000, U_max=(6.23e+24, 4.49e+24, 6.19e+24); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-2.39e+23, abs(max)=1.51e+24); iteration: 5, time: 0.5000, U_max=(5.48e+179, 4.19e+179, 9.91e+179); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=-1.70e+174, abs(max)=1.13e+181); ERROR: LoadError: time = 0.6, iteration = 6: NaN found in field u. Aborting simulation.; ```. I tried reducing the time step from 0.1 to 0.01 but now it always blows up at iteration 1. Increasing the time step kept it blowing up after ~5 iterations. ---. > You can test this by omitting the preconditioner. Running with `preconditioner = nothing` causes it to always blow up on iteration 1 no matter the time step (after 4096 iterations). ```; [ Info: Initializing simulation...; iteration: 0, time: 0.0000, U_max=(0.00e+00, 0.00e+00, 0.00e+00); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (99.042 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.896 seconds).; ERROR: LoadError: time = 0.1, iteration = 1: NaN found in field u. Aborting simulation.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112:3576,Abort,Aborting,3576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112,2,['Abort'],['Aborting']
Safety,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:4022,avoid,avoiding,4022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoiding']
Safety,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/272:1423,detect,detected,1423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272,1,['detect'],['detected']
Safety,"tVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` is a tuple of `ZeroField` should return zero. By avoiding any attempt to compile a stencil for `div_Uw` when `U` is a tuple of `ZeroField` it also skips the step that produces the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:2174,avoid,avoiding,2174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,1,['avoid'],['avoiding']
Safety,"ta` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1271,avoid,avoided,1271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['avoid'],['avoided']
Safety,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1538,detect,detecting-axes-from-dataset-attributes,1538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['detect'],['detecting-axes-from-dataset-attributes']
Safety,"tecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, par",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2394,avoid,avoided,2394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoided']
Safety,ternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [189a3867] Reexport v1.2.2; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.1; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.5; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.4.0; ⌅ [aedffcd0] Static v0.8.9; [0d7ed370] StaticArrayInterface v1.5.1; [90137ffa] StaticArrays v1.9.7; [1e83bf80] StaticArraysCore v1.4.3; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [5e0ebb24] Strided v2.1.0; [4db3bf67] StridedViews v0.3.1; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [856f2bd8] StructTypes v1.10.0; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.12.0; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [a759f4b9] TimerOutputs v0.5.24; [3bb67fe8] TranscodingStreams v0.11.0; [24ddb15e] TransmuteDims v0.1.16; [9d95972d] TupleTools v1.5.0; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.5; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; [4ee394cb] CUDA_Driver_jll v0.9.1+1; [76a88914] CUDA_Runtime_jll v0.14.1+0; [f5851436] FFTW_jll v3.3.10+0; [0951126a] GnuTLS_jll v3.8.4+0; ⌃ [0234f1f7] HDF5_jll v1.14.2+1; [e33a78d0] Hwloc_jll v2.11.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.2.0+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [dad2f222] LLVMExtra_jll v0.0.30+0; [1d63c593] LLVMOpenMP_jll v15.0.7+0; [94ce4f54] Libiconv_jll v1.17.0+0; [5ced341a] Lz4_jll v1.9.4+0; [856f044c] MKL_jll v2024.2.0+0; [7cb0a576] MPICH_jll v4.2.1+1; [f1f71cc9] MPItrampoline_jll v5.4.0+0; [9237b28f] MicrosoftMPI_jll v10.1.4+2; [e98f9f5b] NVTX_jll v3.1.0+2; ⌃ [7243133f] NetCDF_jll v400.902.209+0; ⌅ [4c82536e] Nettle_jll v3.7.2+0; [fe0851c0] OpenMPI_jll v5.0.3+0; [458c3c95] OpenSSL_jll v3.0.14+0; [efe28fd5] OpenSpecFun_jll v0.5.5+0; [c2071276] P11Kit_jll v0.24.1+0; [02c8fc9c] XML2_jll v2.13.1+0; [ffd25f8,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:19214,Unsafe,UnsafeAtomics,19214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Unsafe'],['UnsafeAtomics']
Safety,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1142,avoid,avoid,1142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861,2,['avoid'],['avoid']
Safety,"the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as yo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2604,avoid,avoid,2604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoid']
Safety,"then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:1435,safe,safe,1435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['safe'],['safe']
Safety,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:231,detect,detected,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,3,['detect'],"['detected', 'detecting']"
Safety,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1273,timeout,timeouts,1273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['timeout'],['timeouts']
Safety,"u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4912,avoid,avoid,4912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['avoid'],['avoid']
Safety,"ur talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1599,avoid,avoids,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,1,['avoid'],['avoids']
Safety,"ut it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:1335,avoid,avoid,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,1,['avoid'],['avoid']
Safety,"variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:1473,Safe,SafeTestsets,1473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Safe'],['SafeTestsets']
Safety,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1381,recover,recover,1381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['recover'],['recover']
Safety,"writer should be separated from output writer ""initialization"". Currently both JLD2 and NetCDF output writers open their files and save a bunch of data when they are constructed. For example, . https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/netcdf_output_writer.jl#L300-L328. and. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L170-L181. This initialization can make ""pickup"" of a simulation annoying. For example, the JLD2 writer will _remove_ an existing file if `force=true`:. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L172. This is desirable when experimenting with a script and setting up (and thus we usually set `force=true` in examples as a matter of user-friendliness). But if you're picking up a simulation you certainly don't want to set `force=true`, since this will overwrite existing data. Another example is the warning implemented in #1162 , which I suppose one must resign themselves to always receiving if they are picking up a simulation?. Debacles such as these might be avoided if we performed initialization in `run!` rather than when the output writers are created --- because then we can implement special behavior in the case that we are picking up a simulation. More or less I think the point here is that we don't _know_ if we want to create / destroy a file until `run!` is called with appropriate arguments. If `run!` is never called, there will not be output (so maybe we don't want to create a file). If `run!` is called and we are not picking up and `force` or `overwrite_existing=true` then we should do that. But if `run!` is called and `pickup=true` we can likely assume that existing files should not be deleted. Output writing only occurs in `run!`, so it might make sense to let `run!` also manage the creation / deletion of output files.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1163:1281,avoid,avoided,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1163,1,['avoid'],['avoided']
Safety,"yeah, #2795 does supersede this PR, although #2795 has a custom implementation of transpose + FFT which we might want to avoid now that pencilFFT supports CuArrays",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780:121,avoid,avoid,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780,1,['avoid'],['avoid']
Safety,~~~; (Oceananigans) pkg> status; Project Oceananigans v0.40.0; Status `/gpfs7kw/linkhome/rech/genbes01/use25mx/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics. shell> module list; Currently Loaded Modulefiles:; 1) cuda/10.2 2) julia/1.5.2 ; ~~~,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295:417,Safe,SafeTestsets,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707688295,1,['Safe'],['SafeTestsets']
Safety,"⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4407,risk,risk,4407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['risk'],['risk']
Safety,── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed LaTeXStrings ──────────────── v1.3.1; Installed OrderedCollections ────────── v1.6.3; Installed NVTX ──────────────────────── v0.3.4; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed CEnum ─────────────────────── v0.5.0; Installed InvertedIndices ───────────── v1.3.0; Installed Reexport ──────────────────── v1.2.2; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed BFloat16s ─────────────────── v0.5.0; Installed MacroTools ────────────────── v0.5.13; Installed DataStructures ────────────── v0.18.20; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed RandomNumbers ─────────────── v1.5.3; Installed Missings ──────────────────── v1.2.0; Installed Compat ────────────────────── v4.15.0; Installed StringManipulation ────────── v0.3.4; Installed SortingAlgorithms ─────────── v1.2.1; Installed UnsafeAtomics ─────────────── v0.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Installed CUDA ──────────────────────── v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml`; [052768ef] + CUDA v5.4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:2175,Unsafe,UnsafeAtomicsLLVM,2175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaTeXStrings ──────────────── v1.3.1; Installed NVTX ──────────────────────── v0.3.4; Installed CEnum ─────────────────────── v0.5.0; Installed Random123 ─────────────────── v1.7.0; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed InvertedIndices ───────────── v1.3.0; Installed BFloat16s ─────────────────── v0.5.0; Installed Reexport ──────────────────── v1.2.2; Installed CUDA_Runtime_jll ──────────── v0.14.1+0; Installed GPUArrays ─────────────────── v10.2.3; Installed RandomNumbers ─────────────── v1.5.3; Installed DataFrames ────────────────── v1.6.1; Installed DataStructures ────────────── v0.18.20; Installed Compat ────────────────────── v4.15.0; Installed Requires ──────────────────── v1.3.0; Installed ExprTools ─────────────────── v0.1.10; Installed MacroTools ────────────────── v0.5.13; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed CUDA ──────────────────────── v5.4.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:1950,Unsafe,UnsafeAtomicsLLVM,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Unsafe'],['UnsafeAtomicsLLVM']
Security," 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: 6×7×2 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, 5:6) with eltype Float64 with indices -1:4×-1:5×5:6; └── max=0.0, min=0.0, mean=0.0. julia> set!(my_windowed_field, 1); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryCondition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:2244,access,accessing,2244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['accessing']
Security," AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.H",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1871,validat,validate,1871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security," BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; --;   | Stacktrace:;   | [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{});   | @ Base ./abstractarray.jl:651;   | [2] checkbounds;   | @ ./abstractarray.jl:616 [inlined];   | [3] _setindex!;   | @ ./abstractarray.jl:1289 [inlined];   | [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::String);   | @ Base ./abstractarray.jl:1267;   | [5] find_local_cuda();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:156;   | [6] macro expansion;   | @ ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:51 [inlined];   | [7] macro expansion;   | @ lock.jl:209 [inlined];   | [8] toolkit();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:14;   | [9] toolkit_version();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:209;   | [10] versioninfo(io::Base.TTY) (repeats 2 times);   | @ CUDA ~/.julia-3060/packages/CUDA/mVgLI/src/utilities.jl:35;   | [11] top-level scope;   | @ none:1; ```. On CUDA@3.3.0 this comes from a line that looks like. ```julia; __temp_libcusolver[] = ...; ```. I don't this this construct is valid in julia 1.6:. ```; julia> __temp_libcusolver = Ref{Union{Nothing,String}}[]; Ref{Union{Nothing, String}}[]. julia> __temp_libcusolver[] = nothing; ERROR: BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; Stacktrace:; [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] _setindex!; @ ./abstractarray.jl:1289 [inlined]; [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::Nothing); @ Base ./abstractarray.jl:1267; [5] top-level scope; @ REPL[4]:1; ```. But on CUDA#master the bug may have been fixed:. https://github.com/JuliaGPU/CUDA.jl/blob/3c251c1c210ff3fc75cef8dad688d170caadc275/deps/bindeps.jl#L180. So we might just need to update CUDA. Looking into it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612:1421,access,access,1421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612,1,['access'],['access']
Security," FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater effici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1257,validat,validation,1257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['validat'],['validation']
Security," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2032,validat,validate,2032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['validat'],['validate']
Security," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}}, RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:6979,validat,validation,6979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['validat'],['validation']
Security," as 0.1? Comparing the two solutions, it looks like they are quite close in magnitude. Is the difference computed correctly? Or perhaps this is a relative (normalized) difference?. So the differences are not normalized. I just evaluate the analytical expressions for $u$ and $v$ at the same locations as the numerical fields (`u` at `xF` and `v` at `xC`) and take their differences. Resolution (from 1 km down to 10 m) doesn't improve things much, but increasing the vertical viscosity does (ignoring the sponge layer on the left boundary). Note that I'm actually changing $A_v = f(D/\pi)^2/2$ indirectly through $D$, so the horizontal and vertical coordinates also change. This is because the analytical solution is in terms of $D$. **1. Changing viscosity:**. ![changeD](https://github.com/user-attachments/assets/a0e3cac9-e94c-44b5-b67a-1081c76ade7b). **2. Changing resolution:**. ![changedx](https://github.com/user-attachments/assets/0c032c9d-dadc-4b4e-9362-ed51f159db3d). > Honestly though, the solution looks decent to me. I hope that cut cells would improve it! In this case the boundary is linear? So cut cells should provide an ""exact"" representation (in the sense that as resolution is decreased, the numerical problem limits exactly to the analytical one). I'm less sure that this property holds for the grid fitted bottom, but a small resolution study would help us figure that out... Right, the boundary is a planar slope. I think the solution looks qualitatively pretty good too, though it does not improve by choosing pbcs over a grid fitted bottom. And it doesn't look like the numerical solution converges to the analytical one with resolution, since changes are minimal even after refining by 100x. From looking at the MITgcm docs and the references in #3123, it does seem that cut cells improve representation of flow close to topography, so this could perhaps be a good validation case for that as well. What would be needed to merge #3146? cc @siddharthabishnu @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2394395493:1944,validat,validation,1944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2394395493,1,['validat'],['validation']
Security," fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole sta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2598,access,access,2598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2867,validat,validation,2867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,2,['validat'],"['validate', 'validation']"
Security," interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and `set!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:1739,access,accesses,1739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,1,['access'],['accesses']
Security," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4583,validat,validate,4583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validate']
Security," of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of a tilted geometry (take2). This case generates a boundary layer at the top as well, but it's less well resolved because I am using a stretched grid at the bottom. Not a problem, just an observation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:1567,validat,validation,1567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['validat'],['validation']
Security," runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1570,validat,validate,1570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security," there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:1834,access,access,1834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security, those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415cf4ec09165130e634648ef&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500302000604&tid=spdf-7940fbcd-96cc-4ec2-bbf0-16d073dd8922&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWV,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:528,Secur,Security-Token,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:1610,access,access,1610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,1,['access'],['access']
Security," underlying_grid = RectilinearGrid(CPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> slope(x) = x; slope (generic function with 1 method). julia> grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)); 4×1×4 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo:; ├── immersed_boundary: PartialCellBottom(mean(z)=0.5, min(z)=0.125, max(z)=0.875, ϵ=0.2); ├── underlying_grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = HydrostaticFreeSurfaceModel(; grid); ERROR: BoundsError: attempt to access 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1 at index [1, 0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:1212,access,access,1212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['access'],['access']
Security,# 2. Inviscid Burgers equation developing a shock. Was expecting only one shock to form (the one on the left) but probably due to bad setup there's another one on the right that blows up. So probably not the best validation experiment lol. ![burgers_equation](https://user-images.githubusercontent.com/20099589/96395301-4c6c5e80-1192-11eb-9c51-395b67926f74.gif),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-711477133:213,validat,validation,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-711477133,1,['validat'],['validation']
Security,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:886,inject,injects,886,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injects']
Security,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:390,inject,injection,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['inject'],['injection']
Security,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,4,['validat'],"['validate', 'validation']"
Security,"(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))). # Plotting longitude values using λnodes. Hx, Hy, Hz = grid.Hx, grid.Hy, grid.Hz. for region in 1:6; ; for i in 1-Hx:Nx+Hx, j in 1-Hy:Ny+Hy; getregion(c, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(u, region).data[i, j, 1] = λnodes(getregion(grid, region), Face(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(v, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Face(), Center(); ; with_halos=true)[i, j, 1]; end. end. @info ""Plotting longitude values using λnodes"". @info ""c values""; display(rotl90(view(getregion(c, region).data, :, :, 1))). @info ""u values""; display(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))); ```. Here's the output:. ```Julia; julia> include(""validation/multi_region/multi_region_longitude.jl""); [ Info: Plotting longitude values using the set function; [ Info: c values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -38.0887 -20.9234 -9.30769e-16 20.9234 38.0887 0.0; 0.0 -36.589 -18.9205 -2.33529e-15 18.9205 36.589 0.0; 0.0 -36.3047 -18.488 -3.50835e-15 18.488 36.3047 0.0; 0.0 -36.589 -18.9205 -4.68142e-15 18.9205 36.589 0.0; 0.0 -38.0887 -20.9234 -6.08594e-15 20.9234 38.0887 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: u values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -27.4907 -9.3003 9.3003 27.4907 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: v values; 7×7 OffsetArray(::Matrix{Float64}, 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850:1982,validat,validation,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850,1,['validat'],['validation']
Security,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:1717,access,access,1717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['access'],['access']
Security,"/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2213,validat,validate,2213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security,"/home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:586); Stacktrace:; [1] getindex at /home/glwagner/.julia/packages/Oceananigans/cLFd3/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /home/glwagner/.julia/packages/Oceananigans/cLFd3/src/Fields/computed_field.jl:86; [3] gpu__compute! at /home/glwagner/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:80; [4] overdub at /home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] macro expansion at /home/glwagner/.julia/packages/Oceananigans/cLFd3/src/Fields/computed_field.jl:86; [2] gpu__compute! at /home/glwagner/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:80; [3] overdub at /home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/glwagner/.julia/packages/TimerOutputs/ZmKD7/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:39; [6] compile at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:35 [inlined]; [7] cufunction_compile(::GPUCompiler.FunctionSpec; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/glwagner/.julia/packages/CUDA/YeS8q/src/compiler/execution.jl:3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053:10570,validat,validation,10570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053,1,['validat'],['validation']
Security,"00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2584,validat,validated,2584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['validat'],['validated']
Security,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:1910,access,accessing,1910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['accessing']
Security,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2063,validat,validation,2063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,2,['validat'],['validation']
Security,"1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:2205,validat,validated,2205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['validat'],['validated']
Security,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1309,access,access,1309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['access'],['access']
Security,"44 successful checks :rocket:. I think this PR is ready to be merged. All the existing convergence tests are now in CI and pass, and the plots are uploaded as Buildkite artifacts. This PR might conflict with @francispoulin's PR #1276 (I'm happy to fix conflicts no matter which PR is merged first). There are a few tests that take a long time. This can be shortened in a future PR as it might involve some trial and error and fiddling with rate of convergence tolerances. Other validation experiments should also be added. Right now I have set the validation pipeline to only run on master (and every night at 3am ET).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769873005:478,validat,validation,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769873005,2,['validat'],['validation']
Security,"552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:9440,access,access,9440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQCIEQMBR002B0LthnumUbBVDoR4U3VR1%2BG2xH%2FbIDI1AFoAiAuoSQfiKqWKf3m%2FVE%2FTNJYYLsXkWY1mN6C20bNTWXrbyq9Awi9%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDA1OTAwMzU0Njg2NSIMv%2BDAm8ISlbHKF3xLKpED2bpaqVDlCq%2FGp3Dc9u5Zu5HLtx2oVIXcHmg%2FTY8WZmZ9N7cEwhcNyX8qTIQqVETB6a7wofc0JLX%2BnIscRSocQijV63Kn3N%2BIoojUYHSNuwuOBcx2J5subwAr8fzzOXkoFYw9nrd6y%2Bjx8t8ZkxhpAFa4WTZf0z8CWCNi059xlb20ESLxmGI2lGxglJK%2BDwLQub5TqE0fNqGjBUg6d2A7Uw9SgLQyhQGkB0DhCAGSbcskYQD2nlQcrJGiDFzXDDU6Z8u%2FeZiBvZFKr59%2F2l%2BZWAcaToBhjSNPbwZSKPJu0Il7192olWKVgcN%2FPV%2Ff69n9WRzSxUjzcTPeQeWHBcL6CqQSs74smvUq4Pps9wGacAXCYIITEJvNgLWJ3a8IPMogAr9T32a0v432lo4jKqxWoLaFN9utt9yTc9z05QEh6mh%2FUWs%2BWHNvxajljyqICd5vRgW9kfQ4rOGocjXbDJGWbvKsmEWC2cO42BTOOkAoTuZZHG61V2GBXmuuYprD%2FEENCU4yv0omCCorRGVj9fOwnLAwuvbuhAY67AFEMpZuxL1UHoFniFEKR%2B3JadvLhS03QquHGbY4m2mwchN96GFOgyaaISUwmAv8dSlX0eAKHqbAli90Bt%2BI761m0NTUUKF%2BxcPqtcNcaZr7nOZgUr8OjNP55mXnURmklGmB1NgYkgrYwe37IsYt1H5t4ii1ZmYHStJUGpL5nzv3OwLdsQsVit5xTsBGdGraNgsk%2F6fxNyUX8ZAO96BOnMEr4KfFLtXxOd3Cqd5rwf9%2FsUSRYUgEbMET2MFZE7LtoPrv9Y4YbnZZPuROvaePIFOVQL1lzBFEqwOL%2BAlsbBIO%2FTUEl4nkFuLft3wUJg%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124741Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWCZJM4U7%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=78f17eb8a6139a663a8bce25fad0a2e3ce9da7be82563c990973904a96e0e4ea&hash=9376e9734a2dea82bcc8fb808ef803104cf448fd971c2d8d0c5c6776c8c920c1&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500311000801&tid=spdf-f5035413-aea3-427f-a9ac-13d0a85a5ca6&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:4126,Secur,Security-Token,4126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIFOWdyS3a22deEBXjBCSg9JkqHU7kKI82ao5VmOhVBCJAiEAkMrWigQVK4lU%2BXCC27bRmvm32M0zTk4bVzllPXcV16cqvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDFW%2FMJYjQWUkPx9JGCqRA%2B2gfPEHupvIbgmLh8Ea3HcYZNAkacD7N0Bj1%2By4O8SRtGO1gVirrSZbMJOEuywRDXWbUVHyy7mqKd5c4noCV127vH97IoV6GNMzLS04SZzrHaxNf87iMHuvQSac1ryMPdyiRVXjGVKD%2FK9WUOD9pCuwkbJ1Xq9fIFUBDpIpf6YsziUbag80uMnrgLDdI4bi0Od%2BycFCl8l135%2BiBSJ1nXr2i1d0KoM%2FwxqRhZe3eJnFkqIjBKZMTnaYXcNkBQ4OnVMdp6iNwqDluofhE86ze0DxkmKmwDIlOY6BmAZldUxJNOtojkAkoK%2BggRqDF9RpNh7eUBfmpajcmW%2Fs93jRxiBwxtkolmdDmsSYNOZyJxHn1l9VX0PpWFmhvYuzxVIxKWwhDu2jq1JUO9HWjCSOb5cu4iXr%2FY6UtLVk0zBA%2FUhBFJvYBpTFKCB%2FTZ2nm1VQ05HIq0CdMWngU2%2BPGtb8boOqEZYSJuxcW9liUpegyLYEDrFuQ5zD1PokanBmvQb4nbl3JIfRff6RQTs7I39ruWFvMO3w7oQGOusBq4rh3NlN%2BL771IAdhwa5OXPw6Dtu1rnK8mq15ILN7oUZoGlSoGGHmC9iCauDZZ0S7JRYJvBBlp3zMbH5gPzKtgbHOcfreLqawi%2FXQsNSwLrv8kMK7xtgAtq9KwZNCba%2BezOii00IhPulhEgoRpf32NORW2hf9xvSrh6O7J%2BpFl13%2BgZGv2C9YWQFtiowI1giCVrkqvdAzLIQTemllWlG4BocEdlXsIPbMTqVRy%2BPJeOoDFCEJfa3GEulzYOD7wBM8Mzcs8oPGrs32RGTKanWlrNurlGoWt9LD1yRpHRBW0W3KGW77dYPRa9WMw%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124707Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYU4SXGKKT%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=61ac35b7b8d6de69c863c18a7ac278cfcfcba8c8e333851a5dc0b0fb1a0fec5d&hash=40f925060e5aa979f6c2f65ee083626803b350750f9d24f55b22337096ac841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:2339,Secur,Security-Token,2339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,":39; [6] gpu_calculate_pressure_right_hand_side! at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/macros.jl:80; [7] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] Int64 at float.jl:710; [3] _permute_index at /home/alir/Oceananigans.jl/src/Solvers/index_permutations.jl:11; [4] permute_index at /home/alir/Oceananigans.jl/src/Solvers/index_permutations.jl:24; [5] macro expansion at /home/alir/Oceananigans.jl/src/Solvers/solve_for_pressure.jl:39; [6] gpu_calculate_pressure_right_hand_side! at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/macros.jl:80; [7] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.Com",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:3689,validat,validation,3689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['validat'],['validation']
Security,"::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:329; [11] #VideoStream#909; @ ~/.julia/packages/Makie/umL6V/src/display.jl:342 [inlined]; [12] Record(func::var""#5#10""{Observable{Int64}, Vector{Int64}}, scene::Figure, iter::Vector{Int64}; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:589; [13] #record#915; @ ~/.julia/packages/Makie/umL6V/src/display.jl:584 [inlined]; [14] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:72; [15] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:3346,validat,validation,3346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,3,['validat'],['validation']
Security,"= (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to keep some code around is to add a ""validation"" case. If you're up for that, I'll move your code there, along with the above example. Let me know and then we can possibly merge this great addition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:3069,validat,validation,3069,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['validat'],['validation']
Security,"=== true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1331,access,access,1331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['access'],['access']
Security,"> ""Flattening"" the model setup section by bringing its sections out into the main list. I agree with absolutely everything except with this. Flattening out the sections makes it hard to situate yourself and find things in the docs. This isn't a problem if you're assuming that users will just read everything from beginning to end, but I think that happens very very rarely, and the overwhelming majority of accesses to the docs are just for consultation. I remember at some point reading about this and how some (non-rigorous) surveys/studies pointed out a preference for a few nested menus in websites, as opposed to a long flat list of sections. But I can't find it right now and until I can find it again you're free to take this as a personal preference :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108:408,access,accesses,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108,1,['access'],['accesses']
Security,"> # 2. Inviscid Burgers equation developing a shock; > Was expecting only one shock to form (the one on the left) but probably due to bad setup there's another one on the right that blows up. So probably not the best validation experiment lol.; > ; > ![burgers_equation](https://user-images.githubusercontent.com/20099589/96395301-4c6c5e80-1192-11eb-9c51-395b67926f74.gif). Just a remark: I doubt this is inviscid 1D Burgers, i.e., ∂u/∂t + u ∂u/∂x = 0... Are you sure @ali-ramadhan that you set this up correctly?. When I solve the 1D Burgers (using my own little script; not with Oceananigans.jl) I get something like:; ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/96794090-49e75e80-1449-11eb-8b8e-575077d352eb.gif). Also, @ali-ramadhan in your solution above I see noise forming for negative parts of the solution first. This might hint some biased in the scheme towards certain-sign velocities?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-713914516:217,validat,validation,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079#issuecomment-713914516,1,['validat'],['validation']
Security,"> #1900 brings the finite-volume discussion further up in the Docs/Numerical Implementations. I think that's a great idea. Also, it occurs to me that it would be nice to have another validation code for `ShallowWaterModel`. The Bickley jet example was good and we confirmed the growth rates, but perhaps a propagatoing equatorial Rossby wave would be fun. This is an exact solution to the equations and we can ensure that the phase speed matches that with theory. Maybe this would help us to ensure that all the integrals are done correctly. I don't think this would be interesting enough to become an example but it might interest some people.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071:183,validat,validation,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071,1,['validat'],['validation']
Security,"> (not sure where best to put this/if you'd want it in the examples folder). The right place would be `validation/`, as we only use `examples/` for features that are widely-used and well-tested (examples are expensive, because they have to run during CI).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992:103,validat,validation,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992,1,['validat'],['validation']
Security,"> * Implementation of zero laplacians on the immersed boundaries to allow a biharmonic closure with immersed boundaries. Do we also need to zero the Laplacian on _non-immersed_ (ie ordinary) boundaries?. Relatedly, I don't think we need to `@unroll` when we fill halos for `FluxBoundaryCondition`:. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/BoundaryConditions/fill_halo_regions_flux.jl#L33. The only point of filling points _beyond_ the first halo point is for `AnisotropicBiharmonicDiffusivity`. So if we aren't using it we can get rid of `@unroll` and just fill the first halo point, I think. I think we also need to throw an error if the _only_ closure if `ScalarBiharmonicDiffusivity` and the boundary condition is anything _but_ `FluxBoundaryCondition`. It's kind of complex because it's still ok to have biharmonic and non-flux, provided that there's _another_ closure (in a closure tuple) present. Maybe we can just open an issue about validating boundary conditions + closures and figure out an algorithm there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134:992,validat,validating,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134,1,['validat'],['validating']
Security,"> 1. purpose of `Field`: data structure, plus infrastructure for building expression trees; > 2. `Field` basics; > ; > * The staggered grid, `Field` locations; > * Field size + data, staggered nodes, staggered spacings; > 3. AbstractOperations and expression trees; > ; > * The concept of a lazy operator; > * Arithmetic and derivatives; > * Difference between a Field and Operation; > * KernelFunctionOperation; > * what else?; > 4. Averaging, intergrals, and reduced fields; > ; > What else?; > ; > @navidcy @simone-silvestri. Visualization always helps, so I recommend adding plots of various grid types (periodic, non-periodic, stretched, etc.) directly below the corresponding code snippets that generate them. Additionally, it would be nice to illustrate how to access the different components of `Field`s and the output of abstract operations with code snippets.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263532747:768,access,access,768,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263532747,1,['access'],['access']
Security,"> 44 successful checks ; > ; > I think this PR is ready to be merged. All the existing convergence tests are now in CI and pass, and the plots are uploaded as Buildkite artifacts. This PR might conflict with @francispoulin's PR #1276 (I'm happy to fix conflicts no matter which PR is merged first).; > ; > There are a few tests that take a long time. This can be shortened in a future PR as it might involve some trial and error and fiddling with rate of convergence tolerances. Other validation experiments should also be added.; > ; > Right now I have set the validation pipeline to only run on master (and every night at 3am ET). Please go ahead and don't wait for me. I will work around whatever you have done here in my PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769875267:485,validat,validation,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769875267,2,['validat'],['validation']
Security,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:452,access,access,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330,2,['access'],['access']
Security,"> > > > Hmm, I think my parameters are silly because they aren't hydrostatic, I don't think. Thinking rather than typing is needed now.; > > > ; > > > ; > > > Callum would know. I can ask him about parameters, dt, etc that should work OK.; > > ; > > ; > > I believe to be hydrostatic we need a small aspect ratio and forcing far from N.; > ; > Well Callum actually ran the simulation with the parameters above on MITgcm in hydrostatic mode.; > ; > I put it there because it might give a hint for something going wrong if, eg, you meed 100 times less `Δt` to get a stable simulation with everything else the same. Ah I missed the `Δt` --- is that maybe limited by advection / CFL? It's certainly very far from 1 / 12.421 hours... For my above example I realized I was also using `ExplicitFreeSurface` which I think was likely providing the time step restriction... I think for this validation case I will target a linear regime in which the time step is limited by the highest-frequency internal waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841704503:881,validat,validation,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841704503,1,['validat'],['validation']
Security,"> > > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > > ; > > ; > > As this new PR will change this current PR, I will work on the new PR first and then come back here.; > ; > @glwagner Should I work on this PR first and then when make the new implementation update the validation scripts again?. Up to you but it seems like you will save yourself some effort if you first update the user interface, and then update the validation scripts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473:395,validat,validation,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473,2,['validat'],['validation']
Security,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:422,access,access,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,1,['access'],['access']
Security,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:1005,validat,validation,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613,1,['validat'],['validation']
Security,"> > @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?; > ; > Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`. Yes, do that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216:46,validat,validation,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216,1,['validat'],['validation']
Security,"> > @fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed.; > > It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?; > > Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated.; > ; > I'll check settings. Have you noticed your main branch fails CI?. Main branch doesn’t fail. It starts. Just the GPU server that we run CI was down yesterday. . The CI on this branch doesn’t even start. Not even the CPU CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094:196,access,access,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094,1,['access'],['access']
Security,"> > @glwagner, do you think a bit more elaborate validation test is in order?; > > I'll approve at this point and let this to your judgment.; > ; > I am currently working on a more elaborate validation / example (I'd like to implement an overturning, eddying channel example that uses this closure in a 3D setting) so I think we are ok to merge this PR now as is. Let's work on the eddying channel together!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863628504:49,validat,validation,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863628504,2,['validat'],['validation']
Security,"> > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > ; > As this new PR will change this current PR, I will work on the new PR first and then come back here. @glwagner ; Should I work on this PR first and then when make the new implementation update the validation scripts again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915090633:378,validat,validation,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915090633,1,['validat'],['validation']
Security,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313,1,['validat'],['validation']
Security,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:286,validat,validation,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,3,['validat'],['validation']
Security,"> > @siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl; > > if I run this on this branch I get:; > > ```julia; > > julia> include(""multi_region_cubed_sphere.jl""); > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; > > [ Info: φᶠᶠᵃ_difference_MITg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980:142,validat,validation,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980,1,['validat'],['validation']
Security,"> > @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > > Is this a temporary solution?; > > cc @glwagner, @simone-silvestri; > ; > I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them. In the end all this will have to live in a kernel. Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data. @simone-silvestri and @navidcy, I totally agree. I only introduced CUDA.@allowscalar under the impression it was necessary for certain GPU tests to pass. However, now understanding that isn’t the case, I've removed it in commit [7f54c3c](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/7f54c3c451c9753524056d45c6578a9cf865be68).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379:598,access,access,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379,1,['access'],['access']
Security,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:553,validat,validation,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['validat'],['validation']
Security,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1438,validat,validation,1438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586,1,['validat'],['validation']
Security,"> > Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl; > ; > Was curious to have a look but I think the link might be dead?. I forgot to make the repo public, it should work now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318:100,validat,validation,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318,1,['validat'],['validation']
Security,"> > Here's a first attempt at Lagrangian-averaged dynamic Smagorinsky: https://github.com/CliMA/Oceananigans.jl/tree/ss-xk/dynamic-smagorinsky It doesn't run due to `StackOverflorError`, likely due to the way we are taking the averages. I think if we write custom functions to take each of the averages it would run, just haven't got to it yet.; > ; > Nice, I wasn't aware of that effort. I see you're starting with the scale-independent version, correct?; > ; > I think starting with the lagrangian-averaged version is bold though. From what I've seen the lagrangian vs directional averaged versions of the model are very close in results for most LES we run for the ocean (i.e. doubly periodic), but the lagrangian average can be significantly more expensive. So I think for most cases we'd actually prefer the directionally-averaged one in order to save on computational costs. The use cases where lagrangian average really shines are the heterogeneous flows (like with immersed boundaries) and laminar-turbulent transitions.; > ; > Also, if you open a PR I can help you guys with that. I think I caught a couple of typos in the `𝒥ᴿᴺ` and `𝒥ᴺᴺ` forcing functions for example. Why don't you implement `DynamicSmagorinsky` and abstract the notion of the `Averaging` to `LagrangianAveraging` and `DirectionalAveraging`. Note, you should expect to spend your time validating the closures by running simulations --- not software design and abstraction. If you're having difficulties with the software design I can help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2189645959:1363,validat,validating,1363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2189645959,1,['validat'],['validating']
Security,"> > I agree with these!; > > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.; > ; > Ah, yes, I forgot about that...; > ; > So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?. No, we don't have to require that. But we do need to know what the extension is in order to produce new filenames. We can either ""infer"" the extension, or assume that it's `.jld2`. Do we want to allow other extensions? What's the benefit of that? It might be nice to enforce uniformity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967:201,validat,validate,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967,1,['validat'],['validate']
Security,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954,2,['validat'],['validation']
Security,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:53,access,access,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023,2,['access'],"['access', 'accessed']"
Security,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:569,access,access,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237,1,['access'],['access']
Security,"> > I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):; > ; > Hmmmm it has to do with switching `stream` from your stream pool in the GPU you are in. That always worked for the clusters I tried. Any instance of `@apply_regionally` should fail for you. If you can give me a MWE I can take a look at it. Here's a MWE:. ```julia; using Oceananigans; using CUDA. if CUDA.has_cuda_gpu(); arch = GPU(); n_partitions = CUDA.ndevices(); else; arch = CPU(); n_partitions = 2; end . grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(n_partitions), devices = n_partitions). model = NonhydrostaticModel(grid = grid); ```. Running this on a CPU works, but on a GPU is throws me this error:. ```; ERROR: TaskFailedException. nested task error: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(2, 4)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:871,access,access,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['access'],['access']
Security,"> > Is there any syntax change need to be made in; > > https://github.com/CliMA/Oceananigans.jl/blob/jsw/different-velocities/validation/lagrangian_particles/particles_in_convection.jl; > > I'm actually thinking now that if the name of the module didn't change, moving the module from `LagrangianParticleTracking` to `Models.LagrangianParticleTracking` might not imply any syntax change _given_ that the module name is exported.; > > @glwagner?; > ; > Does it run?. I see. The brute force approach. I'll try!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533877371:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533877371,1,['validat'],['validation']
Security,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:526,access,access,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['access'],['access']
Security,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:177,validat,validation,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132,5,['validat'],"['validate', 'validation']"
Security,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:66,access,access,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805,1,['access'],['access']
Security,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:64,validat,validate,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913,1,['validat'],['validate']
Security,"> > Thanks @glwagner for merging main into this branch.; > > I have returned to the global simulations and have learned something.; > > Using all the same parameters as before, I get `NaNs` after just over an hour.; > > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > > Do you think I should play around with other advection schemes, say some high order upwinding schemes?; > ; > You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation. Thanks @simone-silvestri. . The validation script was set up with `hmin = 10` and that did go unstable. I tried `20` and `30` and they both go unstable. I'm tring `40` and it seems better. I thought if this at least runs, and shows us the ACC going on the right direction, thsi would be a big leap forward. Then we can worry abou thow to minimize the minimum h, if we like. . I will keep you posted. Update: 50 is still unstable after just under 3 hours. I'm now going to try 100. It seems like a pretty big cushion but I am curious what it takes. . And 100 yields negative height after less than 4 hours. Not good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163:839,validat,validation,839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163,1,['validat'],['validation']
Security,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685,3,['validat'],['validation']
Security,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:410,access,access,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,1,['access'],['access']
Security,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:145,access,access,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180,1,['access'],['access']
Security,"> > We can delete this validation test too after this: https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/internal_tide.jl; > ; > The validation script includes a multi region example. Shall I still delete it? I could also clean it up and add toml files in the validation script directory (see #3076). Yeah, that's a random place for a multi region example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577474331:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577474331,4,['validat'],['validation']
Security,> > We might not. Where is interpolate used?; > ; > Its not used anywhere in the source code but in quite a few validation scripts. Can you point us to a few?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1371166618:112,validat,validation,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1371166618,1,['validat'],['validation']
Security,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401:821,hash,hash,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401,1,['hash'],['hash']
Security,"> @ali-ramadhan, should we re-run the validation tests?. I'm sure they're fine. They passed earlier today: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128. They take a while to run. And we'll know tomorrow morning if they fail! They're set to run nightly at 3am ET.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161:38,validat,validation,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161,2,['validat'],"['validation', 'validation-experiments']"
Security,"> @christophernhill do you think you could produce a script with non-trivial dynamics involving the `HydrostaticFreeSurfaceModel` and the implicit solver?; > ; > We should also come up with something that exercises the tridiagonal solver on a vertically-stretched grid. @glwagner @francispoulin and @hennyg888, we could start from https://github.com/CliMA/Oceananigans.jl/blob/master/validation/barotropic_gyre/barotropic_gyre.jl ? I'll check that it is still healthy. We can make the number of points bigger or smaller to look at problem size. Do we want to also try `RegularLatitudeLongitudeGrid` or should we do a box first . This also has an `ImmersedBoundaryGrid` bump in the domain - we can get rid of that for now, but could include that too down the road. . We should be able to add some vertical levels to this and turn on some implicit vertical diffusion - which is another tridiagonal solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059:384,validat,validation,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059,1,['validat'],['validation']
Security,> @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?. Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039,1,['validat'],['validation']
Security,"> @fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed.; > ; > It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?; > ; > Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated. I'll check settings. Have you noticed your main branch fails CI?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969599:196,access,access,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969599,1,['access'],['access']
Security,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:99,validat,validation,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478,3,['validat'],['validation']
Security,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:106,validat,validation,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['validat'],['validation']
Security,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:235,access,accessing,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511,3,"['access', 'validat']","['access', 'accessing', 'validation']"
Security,"> @glwagner could I be added to the buildkite organisation so I can rerun the test please?. Unfortunately I think we have to limit access to that to Clima folks, but it affects all Clima software (not just Oceananigans). As an example, none of us have permissions to add people to the buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911171883:131,access,access,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911171883,1,['access'],['access']
Security,"> @glwagner, do you think a bit more elaborate validation test is in order?; > I'll approve at this point and let this to your judgment. I am currently working on a more elaborate validation / example (I'd like to implement an overturning, eddying channel example that uses this closure in a 3D setting) so I think we are ok to merge this PR now as is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627568:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627568,2,['validat'],['validation']
Security,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492,1,['validat'],['validation']
Security,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184:38,validat,validation,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184,1,['validat'],['validation']
Security,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:288,validat,validation,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,2,['validat'],['validation']
Security,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:642,validat,validation,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,1,['validat'],['validation']
Security,"> @siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl; > ; > if I run this on this branch I get:; > ; > ```julia; > julia> include(""multi_region_cubed_sphere.jl""); > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; > [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; > [ Info: φᶠᶠᵃ_difference_MITgcm panel 2: 1.4784702873954643e-7; > [ Info: φᶠᶠᵃ_di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2013122448:140,validat,validation,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2013122448,1,['validat'],['validation']
Security,"> @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > ; > Is this a temporary solution?; > ; > cc @glwagner, @simone-silvestri. I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them.; In the end all this will have to live in a kernel.; Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615:596,access,access,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615,1,['access'],['access']
Security,"> @siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?. Done. 😊",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446:53,validat,validation,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446,2,['validat'],['validation']
Security,"> @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?. Yes. Consider the following sources for the grid metrics:. 1. the `cs32` grid with one halo layer, used by:; - Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; - yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; 3. the `cc32` grid created by Oceananigans. In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018:520,validat,validation,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018,1,['validat'],['validation']
Security,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234:188,validat,validation,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234,1,['validat'],['validation']
Security,"> @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of |S| is). Where does it come from?. That was my bad, forgot to cite the source. It comes from [Chamecki et al. 2019](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2019RG000655). But you're right that the definition is identical. I misinterpreted the code. > It'd be fine to change the constant because there's no validation test. I indeed think we should change constant default to match the most common value used in the literature. I'd also like to change the notation used in the code from `ς` to `\Upsilon`, so as to match [the docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) (just to make the code easier for contributors). I'll open a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321:434,validat,validation,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321,1,['validat'],['validation']
Security,"> @xkykai so you're saying the fix for the instability exists already and it's just a matter of implementing it in #3188? Is that right?. Yes, and it’s here at https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac. This should work and fix the numerical issues, but has not been extensively validated yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270195995:333,validat,validated,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270195995,1,['validat'],['validated']
Security,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:1001,validat,validation,1001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957,1,['validat'],['validation']
Security,"> Ah ok, thanks for that info! I guess that means this internal tide validation experiment wouldn't benefit from GPU parallelization?. Not at this stage but hopefully sometime soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677869:69,validat,validation,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677869,1,['validat'],['validation']
Security,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:573,validat,validation,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748,1,['validat'],['validation']
Security,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1330,validat,validation,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257,1,['validat'],['validation']
Security,"> Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. That's an interesting consideration. I believe MATLAB, Python, and Julia all support Unicode, but perhaps languages like R do not? This could be a thorny question...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872:160,access,access,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872,1,['access'],['access']
Security,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:915,access,access,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,1,['access'],['access']
Security,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:638,expose,exposed,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,1,['expose'],['exposed']
Security,> Are the artifacts downloaded even if we don't use them?. Yeah apparently so. I think for some reason CUDA artifacts are downloaded first but certain calls like `CUDA.versioninfo()` can trigger further artifact downloads of CUDNN and CUTENSOR. > I think the disadvantage of using artifacts is that we are a bit more exposed to bugs and I think that's the cause of at least some of our pain here. The advantage is that it's less work to maintain our local CUDA software and our test environment might be more realistic / relevant since users typically use artifacts (I think). The CUDA.jl docs recommend using artifacts (https://cuda.juliagpu.org/dev/installation/overview/#CUDA-toolkit) but this may be because new users are less likely to encounter issues if they use the artifacts (which usually work out of the box) instead of fidgeting with local installs especially on servers without root access. For CI maintaining a local toolkit installation may be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461:317,expose,exposed,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461,2,"['access', 'expose']","['access', 'exposed']"
Security,"> As pointed in ny little comment, when we are happy with code changes, we need to update the reference output (I think it's just few netcdf files) to get the regression test to pass. I can do this by uncommenting these lines; https://github.com/climate-machine/Oceananigans.jl/blob/7b4a28db959c1ad67b9940b42b24b8be49633dde/test/test_golden_master.jl#L72-L73. Edit: Well I'd need push access to your branch @jm-c but yeah uncommenting the line produces the required NetCDF file which should overwrite the old one. It will also produce an unwanted file for iteration 0 which I delete.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-491630922:385,access,access,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-491630922,1,['access'],['access']
Security,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. For inlets a `ValueBoundaryCondition` or `GradientBoundaryCondition` works well. For outlets an Upwind advective boundary condition does the trick.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263400235:222,validat,validation,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263400235,1,['validat'],['validation']
Security,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729:222,validat,validation,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729,2,['validat'],['validation']
Security,"> But I guess you mean higher order derivatives? Where, like you pointed out, you'd need more points in the halo region?. Not exactly... derivatives of too high an order may actually segfault because they'll try to access memory that doesn't exist. That's also a problem... The problem here is that derivatives of `ComputedField` are not correct (note that your example doesn't use derivatives of `ComputedField`, it only uses derivatives of `Field`). Here's an example:. ```julia; using Oceananigans; using Oceananigans.Fields; using Oceananigans.AbstractOperations: ∂x. grid = RegularCartesianGrid(size=(3, 1, 1), extent=(2π, 1, 1), halo=(2, 2, 2)) . model = IncompressibleModel(grid=grid). set!(model, T = (x, y, z) -> sin(x)). T, S = model.tracers. d²T_dx² = ComputedField(∂x(∂x(T))). dT_dx = ComputedField(∂x(T)); d²T_dx²_computed_derivative = ComputedField(∂x(dT_dx)). compute!(d²T_dx²); compute!(d²T_dx²_computed_derivative). @show interior(d²T_dx²); @show interior(d²T_dx²_computed_derivative); ```. I find that. ```; interior(d²T_dx²) = [-0.5922903530864669; 2.385416011097638e-16; 0.5922903530864667]; ```. but. ```; interior(d²T_dx²_computed_derivative) = [-0.5922903530864669; 2.385416011097638e-16; 0.19743011769548882]; ```. This occurs because the second calculation uses the value of `dT_dx` at `i=4` (the right boundary) where `dT_dx[4, 1, 1]; 0.0` --- despite that . ```; julia> dT_dx_op = ∂x(T); Derivative at (Face, Center, Center); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=3, Ny=1, Nz=1); │ └── domain: x ∈ [1.1842378929335e-15, 6.283185307179587], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᵃᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> dT_dx_op[4, 1, 1]; 0.8269933431326884; ```. In this case, we _are_ able to evaluate `dT_dx_op` outside the interior because I used halos of size 2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-773450036:215,access,access,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-773450036,1,['access'],['access']
Security,"> But it's the same solver in the validations script also, right? The FFT solver... Is there any other difference?. not the implicit free surface solver, the vertical tridiagonal solver that solves for implicit diffusion of tracer and momentum in the vertical",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486713707:34,validat,validations,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486713707,1,['validat'],['validations']
Security,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475:520,validat,validation,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475,2,['validat'],['validation']
Security,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:330,validat,validation,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984,1,['validat'],['validation']
Security,"> Can you put @inline in front of sponge_u_disc, etc?. Done. Same result. I also tried `ContinuousForcing` with `bottom_mask(x, y, z) = 1` and it's slower than its discrete counterpart. Apparently `DiscreteForcing` is a bit faster than `ContinuousForcing`, everything else being the same. > Again unsure if it affects performance but since rate is referenced as global it needs to be const; eg const rate = 1/10. Yes! That makes a big difference! I feel silly that I forgot that. With `const rate=1/10` and `DiscreteForcing` things are as fast as with no forcing. Using the same ""trick"" with `ContinuousForcing` doesn't change things though. So it does seem like the source of the issue is `ContinuousForcing`. I should say though, I'm having some trouble securing a GPU right now, so I haven't been able to run these tests on a GPU. Would a MWE help here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050:756,secur,securing,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050,1,['secur'],['securing']
Security,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:219,validat,validation,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,1,['validat'],['validation']
Security,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:341,validat,validation,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['validat'],['validation']
Security,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:608,access,access,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['access'],['access']
Security,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:223,validat,validate,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191,1,['validat'],['validate']
Security,"> Discourse might be a little overkill: you need a decent server(>2 GB RAM), a mail delivery service, SSL certificate, etc. so might not be worth it for a project like this?. We can also create a subcategory on the JuliaLang discourse.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/114#issuecomment-470904019:106,certificate,certificate,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/114#issuecomment-470904019,1,['certificate'],['certificate']
Security,> Does CATKE modify the hydrostatic pressure integral?. No CATKE-specific change I know of. https://github.com/CliMA/Oceananigans.jl/blob/0c1f4fd5b34eb576e1f705c99672204e8288e6d4/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. > Seeing that made me think that it wasn't the integral and that the illegal memory access happened elsewhere. I think that is possible since diffusivities are computed just prior to the pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/0c1f4fd5b34eb576e1f705c99672204e8288e6d4/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L82-L85,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439685128:335,access,access,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439685128,1,['access'],['access']
Security,"> Does `ImmersedBoundaryGrid` + `GridFittedBoundary` only work with `CenteredSecondOrder` advection for now? If so, is it worth adding a warning in case users accidently use higher-order advection schemes with immersed boundaries?. Unclear --- we need to validate that. You might be right that we need to short-circuit the advective fluxes to generalize to higher-order advection schemes, and/or limit to second-order differencing near an immersed boundary. (This is also the case for the existing implementation, if this restriction exists.). We should probably add a more general warning to _any_ usage of `ImmersedBoundaryGrid`. I'll do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843529391:255,validat,validate,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843529391,1,['validat'],['validate']
Security,"> Does the magnitude of the velocity error scale with the time-step, or resolution?. I think the expected behavior is that the velocity error in the object scales with the non-hydrostatic pressure gradient times the timestep of the Runge-Kutta substep. Presumably the non-hydrostatic pressure gradient in the object scales as the non-hydrostatic pressure over the length scale of the object. If the strength of the non-hydrostatic pressure field on the object of the boundary is a function of the outer-flow and object configuration, then I don't think grid refinement will help much. We should do a more rigorous validation of this at some point, but at least the dependence on the timestep gives a way to control the velocity error. I also suspect the pattern of the normal velocities in the plot shown may be spurious, as we know the velocity gets very small in all 'solid' nodes fully inside the object. The apparent error on the boundary as a function of angle may have to do with the how the current first-pass implementation sets the solid boundary location on the c-grid. . @christophernhill thanks very much for the offer! It will be good to take you up on that down the line, but let @whitleyv and I do a bit of digging first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012:614,validat,validation,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-738460012,1,['validat'],['validation']
Security,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:2,Expose,Expose,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032,1,['Expose'],['Expose']
Security,"> Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. It's a very breaking change!. > Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though. This PR doesn't remove `StateChecker`, it just stops exporting it. > I use it in almost every script I write haha, but that's because I wrote it to my liking. Touche, but none of the examples use it so it isn't very visible. I'm not even quite sure what the application is, which might be part of the issue? Anyways the point is not to remove this functionality but just not stop exporting it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194,1,['validat'],['validation']
Security,> Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?; > ; > . I haven't run that case on GPU but would have thought it will run if you change the grid architecture and adapt the initial particle positions (which is described in the simulation tips part of the docs). I can have a look later to see if I can run it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430:146,validat,validation,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430,1,['validat'],['validation']
Security,> Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. Was curious to have a look but I think the link might be dead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929,1,['validat'],['validation']
Security,"> Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:30,validat,validation,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,3,['validat'],['validation']
Security,> How about #1696? There was never any substantial discussion about it (other than a thumbs up ;)). I wasn't aware of that one tbh. I'm okay with nuking everything except the convergence tests. But also we can approve and merge this one first (since it's obviously an improvement) and discuss what to do with the other validation after that. Both work for me.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871874171:319,validat,validation,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871874171,1,['validat'],['validation']
Security,> How permanent is the Bickley jet validation experiment? Is it worth adding to the validation experiment Buildkite pipeline in the future?. Let's hold off but discuss with @francispoulin about potentially turning it into something more quantitative (we can use [Poulin and Flierl (2003)](https://journals.ametsoc.org/view/journals/phoc/33/10/1520-0485_2003_033_2173_tneobu_2.0.co_2.xml) as a reference!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324:35,validat,validation,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324,2,['validat'],['validation']
Security,> I agree that `HydrostaticLinearFreeSurfaceModel' does not. But should it in case the user specifies the wrong halos?. In that case users will get a segmentation fault. We've introduced a lot of new grids to be used with `HydrostaticFreeSurfaceModel` so I think this is just a matter of convenience for developers. We don't have any real validation experiments for `HydrostaticFreeSurfaceModel` so it's not really ready for general use yet... If people are using `HydrostaticFreeSurfaceModel` they should be setting up validation experiments!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819:339,validat,validation,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819,2,['validat'],['validation']
Security,"> I agree that creating the file when the simulation starts to run is better than the current behavior (I think right now it creates the file as soon as you create the netCDF writer, right?). Ah the NetCDF file will still be created when the `NetCDFOutputWriter` is constructed. There was an actual bug as you reported in that the `NetCDFOutputWriter` was not respecting the `mode` passed in. > That still wouldn't allow one to access the file while the simulation is running though, right? I think that's important since we need to check the simulations, etc. Do you have any workarounds for that?. Yeah this would be good. I suppose the best we can do is open the NetCDF file right before output writing, then close it once output writing is done?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735430011:428,access,access,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735430011,1,['access'],['access']
Security,"> I agree with docs changes. But it would disrupt a lot of important ongoing work to remove the `validation` directory from the repo without providing an alternative place / way to collaborate on new features. So I think we should leave the `validation` scripts in the repo and discuss what to do next before removing them. Is there ongoing work there? I thought all ongoing work was supposed to be confined to PRs. That's what I've been doing. If that's true and we need to keep the `validation` dir, then at the very least we should make it obvious that those scripts aren't ready for users. The name ""validation"" kinda implies that users can use those scripts to validate their installation, so it's not a surprise that a lot of newcomers try those scripts out and get error. Maybe rename that dir to `work_in_progress`? And then put a `README.md` file in it explaining that most of the scripts are out-of-date?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393,5,['validat'],"['validate', 'validation']"
Security,"> I agree with these!; > ; > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > ; > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting. Ah, yes, I forgot about that... So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935:203,validat,validate,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935,1,['validat'],['validate']
Security,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980,1,['validat'],['validation']
Security,> I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. It'd be great to clean this up and I can help; we can zoom or you can ask questions here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875:44,validat,validations,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875,1,['validat'],['validations']
Security,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:201,validat,validation,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,1,['validat'],['validation']
Security,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:446,access,access,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241,1,['access'],['access']
Security,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:309,access,access,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783,1,['access'],['access']
Security,> I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. I don't see it; did you push?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077,1,['validat'],['validation']
Security,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:51,access,access,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,2,['access'],"['access', 'accessed']"
Security,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:476,validat,validation,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462,2,['validat'],['validation']
Security,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:100,access,access,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071,1,['access'],['access']
Security,"> I sent a flurry of updates once I had the validation case coded up! It should work now. Wait, what should I do to test that? haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978,1,['validat'],['validation']
Security,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:571,access,access,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,1,['access'],['access']
Security,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:375,validat,validation,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731,1,['validat'],['validation']
Security,"> I thought we used the word state since inside the time stepping kernels, state includes the tendencies as well?. Looks like `state` doesn't currently include tendencies. I think this actually makes sense since the tendencies are actually an auxiliary variable. In other words, at the time that a tendency is being calculated, the _current_ value of the tendency is not available (it's being calculated!) Due to that there's probably no advantage to having access to the tendencies in a forcing function or boundary condition function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/985#issuecomment-699500682:458,access,access,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985#issuecomment-699500682,1,['access'],['access']
Security,"> I tried to create a lat-lon grid that is flat in `z` but got this...; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); > ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; > Stacktrace:; > [1] getindex(A::Vector{Any}, i1::Int64); > @ Base ./array.jl:805; > [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; > [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; > [4] top-level scope; > @ REPL[5]:1; > [5] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```; > ; > @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?. Hmm, I have done this with help from @simone-silvestri . I'll go look at our example and get back with some details in a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669:259,access,access,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669,1,['access'],['access']
Security,"> I used `validation/mesoscale_turbulence/baroclinic_adjustment.jl` but I reduced the grid size. The big problem of main is the implicit solver, so if you don't use it you see only the difference given by the tracer tendencies, which is smaller. The results above, however, are obtained using exactly the same code you posted (on a mac M1 with one thread though, you use 6, so maybe that is the root cause of the difference). with one thread. ### on `main`; ```Julia; julia> include(""/Users/navid/Desktop/bench_BCI.jl""); [ Info: Running the simulation...; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 7.775 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (3.851 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (18.536 seconds).; [01.17%] i: 100, t: 11.193 hours, wall time: 1.978 minutes, max(u): (6.965e-01, 3.325e-01, 3.423e-03) m/s, next Δt: 8.858 minutes; [03.04%] i: 200, t: 1.217 days, wall time: 1.597 minutes, max(u): (5.961e-01, 3.542e-01, 2.452e-03) m/s, next Δt: 14.266 minutes; [06.04%] i: 300, t: 2.415 days, wall time: 1.589 minutes, max(u): (5.953e-01, 2.532e-01, 1.842e-03) m/s, next Δt: 20 minutes; [09.51%] i: 400, t: 3.804 days, wall time: 1.582 minutes, max(u): (5.110e-01, 2.416e-01, 1.716e-03) m/s, next Δt: 20 minutes; ```. ### on v0.79.2 (with KernelAbstractions v0.7.2, CUDAKernels v0.3.3); ```Julia; julia> include(""/Users/navid/Desktop/bench_BCI.jl""); [ Info: Running the simulation...; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 5.919 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (1.889 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (35.835 seconds).; [01.17%] i: 100, t: 11.193 hours, wall time: 1.815 minutes, max(u): (6.956e-01, 3.317e-01, 3.438e-03) m/s, next ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486160028:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486160028,1,['validat'],['validation']
Security,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900,1,['validat'],['validation']
Security,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:291,validat,validation,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799,1,['validat'],['validation']
Security,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:1077,validat,validation,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,2,['validat'],['validation']
Security,"> I've added a test for this in `test_dynamics` but not sure if that's the right place for it, or if we even want a test.; > ; > I haven't tried the test on GPU either so suspect it may fail. I think a validation case would be appropriate. Ideally we would run some kind of convergence test but we don't have capacity for that now I think. The validation case could go here: https://github.com/CliMA/Oceananigans.jl/tree/main/validation/advection",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493405980:202,validat,validation,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493405980,3,['validat'],['validation']
Security,"> If I want to test out multi-region nonhydrostatic simulations on a GPU cluster with immersed boundaries, is my best bet to start from [validation/multi_region/multi_region_les.jl](https://github.com/CliMA/Oceananigans.jl/blob/ss/multi-region-nonhydrostatic/validation/multi_region/multi_region_les.jl) in this PR and just add something like; > ; > ```julia; > grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBottom(bump)); > mrg_with_bump = MultiRegionGrid(grid_with_bump, partition=XPartition(2), devices=(0, 1)); > ```; > ; > from the hydrostatic multi-region internal tide validation to include immersed boundaries?; > ; > Like @mmr0, this is pretty much what I've been waiting for to go all in on Oceananigans 100. Yes, that's how I was able to get this working for me. One note is that `grid.Nx` must be even atm. Another note is that so far no `OutputWriter` works with this, so as far as I can tell the functionality here is very limited. @glwagner @simone-silvestri I tried to merge main here but couldn't really figure out the proper way to do it. Could any of you do it? I wanna try to at least get `NetCDFWriter` working so that I can write results with this PR and analyze them!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1367288146:137,validat,validation,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1367288146,3,['validat'],['validation']
Security,"> If we are going to update this example, it's probably better to use `ImmersedBoundaryGrid` like in the other immersed boundary validation experiments... Good point and I can look into that before this is reviewed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871638633:129,validat,validation,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871638633,1,['validat'],['validation']
Security,> If we can't come up with a good validation test then maybe this script can just serve as a baseline for future channel setups?. We could turn it into an example for the near future! How does that sound?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-647674427:34,validat,validation,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-647674427,1,['validat'],['validation']
Security,"> In the case that no directions are periodic, the corner points do not need to be filled. Hmm... I'm wondering --- perhaps corner points need to be filled by both `Periodic` and `NormalFlow`?. Some care is needed if we do convert these kernels. Also, we may have an issue running with non-zero `NormalFlow` and fully enclosed domains with Coriolis. We should probably put together a test or validation test for this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/811#issuecomment-691072305:392,validat,validation,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811#issuecomment-691072305,1,['validat'],['validation']
Security,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:882,access,access,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440,1,['access'],['access']
Security,"> Is the vertical velocity generated over the piecewise constant topogrpahy something that is of a concern? When I increased the resolution I believe I saw the vertical velocity generated increased as well. I agree with @glwagner that it's concerning at least for your current configuration. My guess is that with bottom drag and a more turbulent simulation that might not be a huge problem. But as it stands it's definitely affecting the dynamics. (Btw, I say that because I've run a fair amount of turbulent simulations with immersed boundaries at this point and I've never seen this being an issue in my simulations. But they are always turbulent.). > I think so! Is this with GridFittedBottom or PartialCellBottom? I feel like this motivated cut / shaved cells. @glwagner reading the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl) it seems that it's a `GridFittedBottom`. @francispoulin Like Greg mentioned, shaved cells would be ideal here, but since we don't have that yet, I'd suggest trying out the `PartialCellBottom`. I expect some improvement there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617:878,validat,validation,878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617,1,['validat'],['validation']
Security,"> Is there any syntax change need to be made in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/jsw/different-velocities/validation/lagrangian_particles/particles_in_convection.jl; > ; > I'm actually thinking now that if the name of the module didn't change, moving the module from `LagrangianParticleTracking` to `Models.LagrangianParticleTracking` might not imply any syntax change _given_ that the module name is exported.; > ; > @glwagner?. Does it run?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533815468:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533815468,1,['validat'],['validation']
Security,"> Is there ongoing work there? I thought all ongoing work was supposed to be confined to PRs. That's what I've been doing. Sometimes work spans multiple PRs, such as implementing a CubedSphere abstraction, or immersed boundaries. The validation experiments are being used to validate incremental advances in these features. The problem is not that the scripts aren't ready for users, but that the scripts grow stale as the API changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873253514:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873253514,2,['validat'],"['validate', 'validation']"
Security,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:406,validat,validated,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['validat'],['validated']
Security,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:784,validat,validation,784,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,1,['validat'],['validation']
Security,"> It's coming from the hydrostatic pressure integral. Does CATKE modify the hydrostatic pressure integral? Seeing that made me think that it wasn't the integral and that the illegal memory access happened elsewhere but was ""caught"" in the hydrostatic pressure integral kernel. Not sure if it'll be useful but I'll try prodding around the `model` to see if there's a `Float64` somewhere as a hint. > but you can confirm that it doesn't happen with `closure=nothing`?. I can confirm that this MWE works and does not produce an error:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = nothing; ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501:189,access,access,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501,1,['access'],['access']
Security,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:147,validat,validation,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203,3,"['expose', 'validat']","['expose', 'validation']"
Security,"> It's just a small detail...; > ; > if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`.; > ; > This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately); > ; > So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs. Makes sense. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001:691,access,access,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001,1,['access'],['access']
Security,"> It's ready @navidcy; > ; > @francispoulin right, that's why it's so hard to understand the problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:152,validat,validation,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,2,['validat'],['validation']
Security,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:508,access,access,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['access'],['access']
Security,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:342,expose,exposed,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['expose'],['exposed']
Security,"> Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull. Yes but since the object I'm suggesting is even smaller in memory than an integer (almost 0 in size except for `field_id` and possibly `z_indices`), why would you skip the intermediate abstraction? You're thinking that an integer is ""simple"" but its not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416:64,hash,hash,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416,1,['hash'],['hash']
Security,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659:137,access,access,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659,1,['access'],['access']
Security,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:162,validat,validation,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928,5,['validat'],"['validate', 'validation']"
Security,"> Nice find! Fix makes sense to me so I'm approving.; > ; > If it's non-trivial to design a good test for these open boundary conditions, then to me it make sense to merge this obvious fix and discuss how to more thoroughly test in a separate issue or PR. I think creating a test is non-trivial, but modifying the existing validation script to be more expansive is trivial since I pretty much have the code ready. Should I just do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2430095333:323,validat,validation,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2430095333,1,['validat'],['validation']
Security,"> Nope, that is without the halo (with_halo=False), when using with_halo=true the indexes passed are (Colon(), Colon(), Colon()) so there is no issue accessing the indexes of the output. Sorry, I meant `with_halo=false`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902:150,access,accessing,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902,1,['access'],['accessing']
Security,"> Not sure what ""squash and merge"" means . Ah it's one of the three merge options, e.g. ![image](https://user-images.githubusercontent.com/20099589/117980914-70e08180-b302-11eb-9179-9e8cbad457a3.png). where it combines all the commits into one commit then merges. Then intermediate changes (like a file that was created then deleted) do not enter git history. > I deleted the file locally and then wanted to push the change but couldn't. If someone can tell me how to delete it I'm happy to do it. That should be all it takes... What error does git produce? I can also try locally. > Also, I see that the tests pass so my use of `Polynomials` presumably worked?. Ah I don't think `plot_rates_convergence_advection.jl` is actually run as part of CI right now. We could add it in this PR if you're interested. I think we'd want to actually add it to the validation pipeline (not the main pipeline) so we would add a new test set in https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_convergence.jl and add a new build step in https://github.com/CliMA/Oceananigans.jl/blob/master/.buildkite/validation-pipeline.yml then it would show up in these builds with plots, e.g.: https://buildkite.com/clima/oceananigans-validation-experiments/builds/208. > Anything else that people would like done before someone approves this PR?. I think it looks good to merge, just without the extra image file!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128:852,validat,validation,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128,3,['validat'],"['validation', 'validation-experiments', 'validation-pipeline']"
Security,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:64,access,access,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417,1,['access'],['access']
Security,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:740,inject,injects,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['inject'],['injects']
Security,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:437,access,access,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['access'],['access']
Security,"> Out of curiousity, is the plan for this PR to add an example as an eddying baroclinic double gyre on the GPU with `IncompressibleModel` while #1433 adds a viscous barotropic double gyre with `HydrostaticFreeSurfaceModel` as a validation experiment?. As a first step why not set up both `IncompressibleModel` and `HydrostaticFreeSurfaceModel` for a barotropic double gyre? Since there will be much in the way of nonhydrostatic effects, it would be a way to compare the two models in terms of the accuracy and the efficiency. Then it should be easy to change both to do a baroclinic double gyre.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-799538928:228,validat,validation,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-799538928,1,['validat'],['validation']
Security,"> Pardon if this question is naive but why is it important that users to exposed to the Field infrastructure?. Because that way they are prepared to do sophisticated post-processing! But I think you're right, maybe it's not a real ""downside"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707:73,expose,exposed,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707,1,['expose'],['exposed']
Security,"> Related to this, I wanted to point something out:; > ; > ```julia; > ; > julia> struct Test; > a::Array{Float64, 1}; > end; > ; > julia> import Base: getindex; > ; > julia> getindex(t::Test, inds...) = getindex(t.a, inds...); > getindex (generic function with 196 methods); > ; > julia> t = Test(rand(4)); > Test([0.502462, 0.632246, 0.585965, 0.845577]); > ; > julia> @code_lowered t.a[2]; > CodeInfo(; > 731 1 ─ %1 = (Base.arrayref)($(Expr(:boundscheck)), A, i1) │; > └── return %1 │; > ); > ; > julia> @code_lowered t[2]; > CodeInfo(; > 1 1 ─ %1 = (Base.getproperty)(t, :a) │; > │ %2 = (Core.tuple)(%1) │; > │ %3 = (Core._apply)(Main.getindex, %2, inds) │; > └── return %3 │; > ); > ; > julia> @code_lowered @inbounds t.a[2]; > CodeInfo(; > 538 1 ─ nothing │; > │ %2 = (Base.Expr)(:inbounds, true) │; > │ %3 = (Base.esc)(blk) │; > │ %4 = (Base.Expr)(:(=), :val, %3) │; > │ %5 = (Base.Expr)(:local, %4) │; > │ %6 = (Base.Expr)(:inbounds, :pop) │; > │ %7 = (Base.Expr)(:block, %2, %5, %6, :val) │; > └── return %7 │; > ); > ; > julia> @code_lowered @inbounds t[2]; > \CodeInfo(; > 538 1 ─ nothing │; > │ %2 = (Base.Expr)(:inbounds, true) │; > │ %3 = (Base.esc)(blk) │; > │ %4 = (Base.Expr)(:(=), :val, %3) │; > │ %5 = (Base.Expr)(:local, %4) │; > │ %6 = (Base.Expr)(:inbounds, :pop) │; > │ %7 = (Base.Expr)(:block, %2, %5, %6, :val) │; > └── return %7 │; > ); > ```; > ; > Note that the lowered code for an *inbounds* `getindex` call is exactly the same for `Test` as it is for it's field, `Test.a`. There is a difference when the array access is not inbounds. So we probably shouldn't see slow down for using `getindex` on `Field` directly if its inbounds.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/163#issuecomment-479825567_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/13#issuecomment-479850168:1540,access,access,1540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13#issuecomment-479850168,1,['access'],['access']
Security,"> Relative vorticity plot from before (with non-essential halos) ![vorticity](https://user-images.githubusercontent.com/12926768/276471090-687faff4-f50d-492e-a024-1e67c4e24da0.png); > ; > Relative vorticity plot now (with non-essential halos filled with NaNs) ![vorticity](https://user-images.githubusercontent.com/12926768/276471138-aa5fac3f-b948-429c-a3e1-4f33a75bd0f4.png); > ; > At least the south-east corners of the odd panels are incorrect. Based on discussion with @navidcy, I overwrote the vorticity computation at the corners of all panels using only interior values in the validation script validation/multi_region/cubed_sphere_vorticity.jl. The vorticity field looks better now. However, the source code still needs to be fixed. . ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2f8a203f-08f4-4541-9022-388b58fcbd50)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208:584,validat,validation,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208,2,['validat'],['validation']
Security,"> Should we also move `Plots.jl` to the docs environment?. I thought it was used for benchmarking or the validations/verifications. If nothing uses Plots.jl in the main repo's test then, yes, it should go away.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724335785:105,validat,validations,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-724335785,1,['validat'],['validations']
Security,"> Should we include the Stommel gyre? It seems there are simpler flow fields for an advection validation test (eg sin x sin y). How are we going to evaluate the thermal bubble validation? ""Not blowing up"" is pretty good, but I think we have decide that validation tests should be quantitative. Qualitative validation experiments can perhaps be put in `examples/`?. Yeah they're both ""temporary"" verification experiments that might be useful in the near future as we test advection schemes. Periodic advection is also a qualitative verification experiment. I think we should keep at least one interesting 2D advection verification to produce movies showing how different advection schemes behave. Hopefully we could embed all the movies in the docs so users can browse through them. I was thinking the Stommel gyre could be a good one (really I stole the idea from Glenn's animations) as the velocity does not go to zero at the western boundary/wall.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922:94,validat,validation,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922,4,['validat'],['validation']
Security,"> Should we limit this discussion to the names of locations and grid spacings? The issue currently only refers to ""more bugs"" which could be a bit too open-ended to make useful progress on. That's a good point, and I apologize for being too general with the title. I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801:343,validat,validate,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801,1,['validat'],['validate']
Security,"> So I tried with SplitExplicit and 1) it's _much faster_ but 2) I see this very fast motion in the beginning...; > ; > Compare this; > ; > barotropic_tide_splitexplicit.mp4 ; > with the animation at the top of this PR.; > ; > I suppose it's the gravity waves... Are they implicitly filtered out with the implicit free surface solver at the top?. Yeah, the implicit solver diffuses out all the gravity waves while the split explicit ""resolves"" them. You can also check out the validation case in `validation/implicit_free_surface/geostrophic_adjustment_test.jl` that shows quite some difference in the dynamics using the implicit solver vs split explicit solver",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575763281:477,validat,validation,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575763281,2,['validat'],['validation']
Security,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:350,validat,validation,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199,2,['validat'],['validation']
Security,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:907,sanitiz,sanitization,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,1,['sanitiz'],['sanitization']
Security,"> So, Ken and I were discussing some set of simulations that would greatly benefit from this. How hard would it be to implement this given the current state of Oceananigans?. I think it will take at least a few weeks of dedicated work by someone familiar with Oceananigans and Julia. The algorithms are more or less known, so the challenges are mainly in software development. A significant chunk of the work is developing and running validation experiments. > ; > > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf; > ; > Unless I'm missing something this seems trivial (some good news!). I believe we'll need to insert a mass correction step into our algorithm (perhaps after fill halo regions in update state?) and how to decide when we need it. I think we'll need it both for non-zero inflow conditions (so `Open` boundaries with conditions other than `nothing` / 0`) and outflow conditions like Orlanski. > ; > > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows; > ; > This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. We only support hydrostatic cubed sphere simulations, so we did not implement an algorithm for accurate non-hydrostatic pressure solves with time-dependent boundary conditions when implementing the cubed sphere. The algorithm is known (I have a sketch, though some effort should be devoted to writing it up in the documentation); we only need to design a useful software abstraction. The main issue is that the right hand side of the pressure Poisson equation depends on the _time-derivative_ of the wall-normal velocity. This means that we need to store the wall-normal velocity at a prior time-step. We can probably redesign the implementation of the `Open` boundary condition for this purpose,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920:435,validat,validation,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920,1,['validat'],['validation']
Security,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:14,validat,validations,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,1,['validat'],['validations']
Security,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:230,validat,validation,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,1,['validat'],['validation']
Security,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:167,access,access,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329,2,['access'],['access']
Security,> Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future. Does that mean it will retry the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007,1,['validat'],['validation']
Security,"> Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing).; > ; > @navidcy would be happy not to use `ς`!; > ; > `\Upsilon` is disturbingly similar to ""Y"":; > ; > ```julia; > julia> Υ = 1; > 1; > ```; > ; > maybe there's a better choice? We could also change the docs. Yeah, and I ended up realizing the same thing. I changed the docs instead.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253:110,validat,validation,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253,1,['validat'],['validation']
Security,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:83,validat,validation,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344,1,['validat'],['validation']
Security,"> Test nonlinear advection for 2D/3D schemes. You mean, validate 2D/3D high-order momentum advection for flux form schemes?. Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence. I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554:56,validat,validate,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554,1,['validat'],['validate']
Security,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136,1,['validat'],['validation']
Security,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:320,access,access,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,1,['access'],['access']
Security,"> That's true, such code has to be compiled away. However, the method that `forcing` uses is a little fragile and often fails to compile. We've just failed to come up with a better way for users to specify arbitrary forcings. But presumably you are doing something else, because otherwise your users could use `forcing`. That's why I'm asking: what outcome are you trying to achieve? Maybe we can come up with another design. Ah, I see. The problem is occurring where I've got this `update_state` for changing the negative tracers (as discussed in ). The code is currently:; https://github.com/OceanBioME/OceanBioME.jl/blob/ac8419a1ce5a06a82be31588583636b212c09598/src/Utils/negative_tracers.jl#L87-L118; But this doesn't work on GPU. The list of symbols is needed so that the group that the total is conserved in can be defined. An alternative I've thought of but not tested yet is to have functions like `conserved_tracers(bgc)` which can just return the list of symbols instead. . I currently can't access a GPU but will see if this works when I can. I'm sure I can find an alternative way todo this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513:1002,access,access,1002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513,1,['access'],['access']
Security,"> The GPU validation should be identical. You just need to; > ; > 1. Make sure you have enough gpus and the MPI installation is cuda-aware (MPI.has_cuda() == true); > 2. Switch CPU to GPU in the script.; > ; > The rest of the script does not change. We still need actual, explicit code. That way you don't have to make this comment ""it doesn't change"" every time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2088554792:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2088554792,1,['validat'],['validation']
Security,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['validat'],['validation']
Security,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098,2,['validat'],['validation']
Security,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:129,access,access,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,3,['access'],"['access', 'accessing']"
Security,> There is one that does a one-level near global ocean on a latitude-longitude grid. (in the near_global validation folder); > I haven't tried this particular script before. but that's not shallow water...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475428867:105,validat,validation,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475428867,1,['validat'],['validation']
Security,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:691,expose,exposed,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,2,['expose'],['exposed']
Security,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:856,access,access,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,1,['access'],['access']
Security,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:402,access,access,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,1,['access'],['access']
Security,"> Unfortunately I think we have to limit access to that to Clima folks, but it affects all Clima software (not just Oceananigans). As an example, none of us have permissions to add people to the buildkite. No worries makes sense!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911783084:41,access,access,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911783084,1,['access'],['access']
Security,"> We are in the process of implementing curvilinear grids, which require more specificity for the location of grid lengths, areas, and volumes. As a result we are attempting to standardize our notation, using three-letter codes to be completely explicit. These changes have been made in the vertically stretched grid and regular lat-lon grid, but not in the regular rectilinear grid yet. Would just a change from `xC` to `xᶜᵃᵃ` and so on in Regular grids do it?. Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. As an example, here's me trying to access an attribute named `u₀` using `xarray` in Python:. ```python; In [91]: vid.attrs; Out[91]: ; {'N2_inf': 4e-05,; 'f0': 0.0001,; 'σy': 1600,; 'z_0': -250.0,; 'u₀': -0.4,; 'N2_pyc': 4e-05,; 'schedule': 'TimeInterval',; 'name': 'CIintjet01',; 'interval': 5400.0,; 'Lz': 500,; 'Julia': 'This file was generated using Julia Version 1.5.2\nCommit 539f3ce (2020-09-23 23:17 UTC)\nPlatform Info:\n OS: Linux (x86_64-pc-linux-gnu)\n CPU: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\n WORD_SIZE: 64\n LIBM: libopenlibm\n LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n GPU: Tesla V100-SXM2-32GB\n',; 'output time interval': 'Output was saved every 1.500 hours.',; 'T_inertial': 62831.85307179586,; 'σz': 80,; 'u_0': -0.4,; 'Nz': 512,; 'z₀': -250.0,; 'LES': 0,; 'Ny': 8192,; 'date': 'This file was generated on 2021-03-08T15:14:07.533.',; 'Ly': 15000,; 'b0': -4e-05,; 'y₀': 5000.0,; 'Oceananigans': 'This file was generated using Oceananigans v0.52.1',; 'y_0': 5000.0}. In [92]: vid.u₀; File ""<ipython-input-92-9d34f4e5eca9>"", line 1; vid.u₀; ^; SyntaxError: invalid character '₀' (U+2080). In [93]: vid.attrs[""u₀""]; Out[93]: -0.4; ```. So as you can see it's possible, but it definitely takes some extra effort (especially since you can't type `u₀` in Python and need to copy paste from somewhere else",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339:621,access,access,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339,2,['access'],['access']
Security,> We can delete this validation test too after this: https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/internal_tide.jl. The validation script includes a multi region example. Shall I still delete it?; I could also clean it up and add toml files in the validation script directory (see #3076).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577433799:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577433799,4,['validat'],['validation']
Security,> We might not. Where is interpolate used?. Its not used anywhere in the source code but in quite a few validation scripts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370810049:104,validat,validation,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370810049,1,['validat'],['validation']
Security,"> What are the criteria of the validation test?. Hmmm, I'm not sure there's a rigid criteria. We can do a qualitative check that this channel exhibits the same behavior as Haine & Marshall (1998), e.g. figure 8 (see below). Perhaps a better check would be to do a ""volumetric census of PV and N^2 classes"", e.g. see figure 10(b) below. If we can't come up with a good validation test then maybe this script can just serve as a baseline for future channel setups?. ![image](https://user-images.githubusercontent.com/20099589/85021505-f03ff200-b13f-11ea-936d-df71a69eaefd.png). ![image](https://user-images.githubusercontent.com/20099589/85021594-0c439380-b140-11ea-8433-91d25fb85ab6.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-645994185:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-645994185,2,['validat'],['validation']
Security,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382:214,access,access,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382,1,['access'],['access']
Security,"> Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this?. We've mostly been concerned with surface ocean physics so naively it would seem nice to have the surface not be a halo cell. Might have been an issue in the past when we didn't have vertical halos because then you don't even have a cell for the surface. Out of curiousity then, would an implementation of surface wave effects (#443) have to touch the halos?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542226380:27,access,access,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542226380,1,['access'],['access']
Security,"> Why don't you implement `DynamicSmagorinsky` and abstract the notion of the `Averaging` to `LagrangianAveraging` and `DirectionalAveraging`.; > ; > Note, you should expect to spend your time validating the closures by running simulations --- not software design and abstraction. If you're having difficulties with the software design I can help. I like this idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2190185027:193,validat,validating,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2190185027,1,['validat'],['validating']
Security,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396:154,validat,validation,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396,1,['validat'],['validation']
Security,"> You're gonna want to implement a struct that's someting like; > ; > ```julia; > struct HaloFillingEvent; > location; > z_indices; > from_side; > to_side; > field_id; > end; > ```; > ; > and then a function; > ; > ```julia; > mpi_tag(hfe::HaloFillingEvent) = # number; > ```. I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298974417:733,hash,hash,733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298974417,1,['hash'],['hash']
Security,> closes #3681; > ; > We can probably use this PR to add also a validation for the `PartialCellBottom` and the bug-fixes in the implementation. What do people think?; > ; > cc @jm-c. presumably we should always use `PartialCellBottom` in examples with bathymetry. Is there a reason to ever use `GridFittedBottom`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2269888093:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2269888093,1,['validat'],['validation']
Security,"> grid_base = RectilinearGrid(size=(4, 4, 4),; x = (0, 1), y=(0, 1),; z = (0, 1),; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549:1127,validat,validated,1127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549,1,['validat'],['validated']
Security,"> only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite. No, I think we should do this for the solid body validation experiment. I will implement this after I finish a quantitative analysis of the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370:92,validat,validation,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370,2,['validat'],['validation']
Security,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:170,validat,validation,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278,2,['validat'],['validation']
Security,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:595,validat,validation,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,1,['validat'],['validation']
Security,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1174,access,accessible,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493,1,['access'],['accessible']
Security,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:273,access,access,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,2,['access'],['access']
Security,"@ali-ramadhan @christophernhill @jm-c let's return to this issue since we'll need vertically-implicit diffusion in the near future. I think we should hash out our API design to make the implementation smooth. After some thought, I think what we want to do is to implement a way to implicitly time-step components of the model term by term (rather than implementing some way to time-step _part_ of a term implicitly. This means that if we want to time-step vertical diffusion components implicitly, but horizontal diffusion component explicitly, we need a new closure called `VerticalDiffusivity`. We can then use closure tuples to implement syntax like. ```julia; vertical_diffusion = VerticalDiffusion(νz = 1e-4, timestepping=Implicit()); horizontal_diffusion = HorizontallyCurvilinearDiffusion(νh = 100). model = HydrostaticFreeSurfaceModel(closure=(vertical_diffusion, horizontal_diffusion), ...); ```. for example. Since turbulence closures are going to get a lot more complicated in the near future, I also think it's important to resolve #1381 relatively soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782865195:150,hash,hash,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587#issuecomment-782865195,1,['hash'],['hash']
Security,"@ali-ramadhan does this PR fix your issue? I will try the internal tide example on this PR, add some tests for `PartialCellBottom`, and then we can probably merge it. I am not sure whether this solves all the issues with PartialCellBottom, probably more validation is required, but this is a first step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2317976546:254,validat,validation,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2317976546,1,['validat'],['validation']
Security,@ali-ramadhan is there anything broken in validation exps in v0.53.0?. @maeckha if you try to run some example from the docs is it all ok or similar issues?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587,1,['validat'],['validation']
Security,"@ali-ramadhan, @glwagner , @johncmarshall54 : Thank you all for your very kind responses!; 1. I have no problem writing a latex document - Would a Julia Markdown with Weave.jl be good too? Here's an example I just posted [using Weave](https://miguelraz.github.io/2019/04/24/sgjbemkernel.html).; 2. If I could tackle all these problems, that would be quite cool, but as I am about to enter into finals I think I should focus on the ""spin-down"" problem as a start and then work my way up on the rest.; 3. Yes, I am on the Julia slack, and don't mind joining another.; 4. I'm interested in anything with a slightly-more-complicated-than-undergrad-class-but-not-phd-level. @glwagner I tried searching for the spin-down problem but I'm not yet too familiar with the English terms - (I study in spanish).; Would you happen to have a reference/ link to the spindown problem so I can begin a draft?. After speaking to my TA, he thinks the Rayleigh-Bernard plates problem is accessible. He also recommended the Drazin *Introduction to Hydrodynamical Stability*, Chapter 6. for his particular problem, as well as the Charru *Hydrodynamic Instabilities*, Chapter 2.5. This looks _REALLY_ cool! Let's see if we can get some of those cool hexagons showing. . Thank you all for such a kind response!; I hope I can keep contributing into the summer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-490170290:966,access,accessible,966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-490170290,1,['access'],['accessible']
Security,"@ali-ramadhan, should we re-run the validation tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567,1,['validat'],['validation']
Security,"@christophernhill Thanks for posting the gist! @mg547 and I were able to get it working with our Laplacian operator. Going to try and inject it into the pressure solver now, fingers crossed!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443903880:134,inject,inject,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443903880,1,['inject'],['inject']
Security,@elise-palethorpe also perhaps change the validation script name as @glwagner suggest?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350,1,['validat'],['validation']
Security,"@fadaie91 is going to run some more validation tests, but I think this PR is basically ready to go. @sandreza this may interest you as well for your 1 deg simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124,1,['validat'],['validation']
Security,"@fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed. It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?. Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936950079:187,access,access,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936950079,1,['access'],['access']
Security,"@fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed. It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?. Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated. _Originally posted by @navidcy in https://github.com/CliMA/Oceananigans.jl/issues/3468#issuecomment-1936950079_. What do you mean by outdated or deprecated here? Can you help me understand how this relates to the CI?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3470:187,access,access,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470,1,['access'],['access']
Security,"@francispoulin @glwagner ; > problem is that the velocity field is far from uniform at the outlet where a constant outflow of 1.0 is being prescribed. I wonder if this would cause numerical issues. To use `NormalFlow` we may either need a sponge layer, or to implement a more sophisticated outlet condition like an Orlanski condition. I have a version with a sponge layer I used for my own testing I could add. I updated the arbitrary grid branch to have the validation correct with normal flow's location specified, but the master version never got changed. > > If we are going to update this example, it's probably better to use `ImmersedBoundaryGrid` like in the other immersed boundary validation experiments...; > ; > Good point and I can look into that before this is reviewed. I was waiting for no-slip condition on the `ImmersedBoundaryGrid` before this validation is useful again, because otherwise you just get fun videos, but no actual validation. I have a work in progress script with a bunch of analysis I can add when we're ready to do so. Until then it might be best just to remove this file completely because it's so out of date.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871667459:459,validat,validation,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871667459,4,['validat'],['validation']
Security,@francispoulin Ah those two failures are unrelated to this PR (it's the validation experiments pipeline failure I mentioned above) so this should be good to merge if you're happy with the PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736777238:72,validat,validation,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736777238,1,['validat'],['validation']
Security,"@francispoulin I do not know but I think it would be good to find out. `VerticallyImplicitTimeDiscretization`, despite being verbose, is actually too terse --- what we are really implementing is a _backwards_ vertically implicit time discretization. Our implementation in `QuasiAdamsBashforth2` is a first-order backwards approximation. Note that `QuasiAdamsBashforth2` is also first-order for explicit stepping, so this implementation should not change the accuracy of the scheme, I don't think. In `RungeKutta3` we implement a scheme that is backwards ""within stages"". This corresponds to some particular choice of Butcher tableau and I am not sure if it is formally 3rd order still. We might be able to develop a convergence test to an analytical solution to investigate this problem. It needs to be relatively high spatial resolution so that time-stepping errors are larger than spatial discretization errors. I propose we implement some validation tests and convergence tests in a future PR though to avoid bogging this PR down more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675:942,validat,validation,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675,1,['validat'],['validation']
Security,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982,3,['validat'],['validation']
Security,"@francispoulin Sorry for the neglected state of this PR. It's in a half-baked state and I keep meaning to revisit it. You can decompose the domain into x, y, z cubes/slabs/pencils/etc. Then ""halo communication boundary conditions"" are injected on edges where the model needs to communicate with another rank then communication occurs as part of `fill_halo_regions!`. I was working on adding a test to verify that all halo region data was communicated properly for CPU and GPU models but encountered some deadlocking (according to latest commit message haha). Hoping to revisit soon, don't think it should be too hard to get this PR to work for a shallow water model or compressible model (pressure solver will the hard part of an MPI incompressible model).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-732934807:235,inject,injected,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-732934807,1,['inject'],['injected']
Security,"@francispoulin yes, it is serial on the CPUs. The halos are indeed 3 for the `WENO5`, but if we use a vector invariant weno formulation (so we are interpolating vorticity) we need 4 halos because calculating vorticity itself requires one halo. @glwagner there is a type inference issue with `getregion(model, 1)` (you can see it in your validation test also). I think, solving that, the only overhead will be the `fill_halo` (and launching multiple kernels which maybe will not affect too much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966:337,validat,validation,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966,1,['validat'],['validation']
Security,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129,1,['validat'],['validation']
Security,"@glwagner ; Just to confirm, following #2384 , I will fork the main repo, then I switch to your branch, add a new example on `validation/`, then ; `julia --project`; and; `julia> include(""validation/source_sinking/source_sinking.jl"")`; or something like that, right?. Once it runs, I make a PR to your branch that will come back to here, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805,2,['validat'],['validation']
Security,"@glwagner @simone-silvestri @jm-c - does this look OK for an approve 👍 ; Buildkite is back and happy now! . Its a validation update, but it will make it easier to do next steps (i.e. add new and improved immersed etc.. ) with some tests. . Thx,. Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768:114,validat,validation,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768,1,['validat'],['validation']
Security,"@glwagner I have opened a PR with the branch sb/cut-cells-experiment, on which I have been working on implementing the cut cells. To summarize the progress:. - The two-dimensional [tracer advection test case](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/tracer_advection_over_bump.jl) over a Gaussian bump is run successfully using the low resolution from the [Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) paper and a relatively higher resolution. Both partial cells and full cells are used. Time evolution of the passive tracer concentration is visualized. - CutCellBottom is implemented in the ImmersedBoundary module similar to PartialCellBottom, and the tracer advection test case is repeated with cut cells. No noticeable difference in the results is detected so far (with the simulation using partial cells). So, tasks 1 (a) and 2 (b) have been completed so far. Tasks 2(b) and 2(c) are being worked on right now, after completion of which tasks 1 (b) and 3 will be initiated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402,1,['validat'],['validation']
Security,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:135,validat,validation,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430,3,['validat'],['validation']
Security,"@glwagner True, we should just make use of the existing infrastructure. We don't have to call it a monitor but seems like this diagnostic would be closer in spirit to `NaNChecker` than `HorizontalAverage`. We might want to have some way of accessing the `TimeStepWizard` from the diagnostic though. Although this could probably be done with an anonymous function. @asinghvi17 Thanks for the tip! Had no idea you could pass a `progress` kwarg to logging macros. Will have to check it out along with #71",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-537053103:240,access,accessing,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-537053103,1,['access'],['accessing']
Security,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:196,access,accessing,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124,3,"['access', 'validat']","['access', 'accessing', 'validation']"
Security,"@glwagner and @simone-silvestri, thank you for the clarification. Indeed, this does not happen with `--check-bounds=yes`, as shown below:; ```julia; julia> my_field[-2, :, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [-2, OffsetArrays.IdOffsetRange(values=-1:5, indices=-1:5), OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Int64, ::Function, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[23]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> my_field[:, -2, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [OffsetArrays.IdOffsetRange(values=-1:4, indices=-1:4), -2, OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _ge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:207,access,access,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['access'],['access']
Security,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:214,validat,validation,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158,1,['validat'],['validation']
Security,@glwagner our lab at Northeastern and @christophernhill both have access to a set of MI50 and MI100 AMD GPUs. We're using them for now for our development code. I don't know the plan after we get the tests working.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783:66,access,access,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783,1,['access'],['access']
Security,"@glwagner, do you think a bit more elaborate validation test is in order?; I'll approve at this point and let this to your judgment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627253:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627253,1,['validat'],['validation']
Security,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:136,validat,validation,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827,1,['validat'],['validation']
Security,"@hdrake, the scripts in `validation/immersed_boundary` are meant to be run on the master branch using the existing immersed boundary implementation (not the implementation on `vw/arbitrary_immersedboundary`). However, the script has gone stale (see #1634) and needs to be updated to match the current API. Once the syntax is updated (eg changing `RegularCartesianGrid` to `RegularRectilinearGrid`) we expect the script to run.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-839935427:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-839935427,1,['validat'],['validation']
Security,"@hengdiliang could be nice if you post results from a little validation test just to document that this not only runs, but runs correctly",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2385651669:61,validat,validation,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2385651669,1,['validat'],['validation']
Security,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:291,validat,validation,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547,2,['validat'],['validation']
Security,@iuryt do you want to help set up a validation case for this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825,1,['validat'],['validation']
Security,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:170,access,access,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,2,['access'],['access']
Security,"@johncmarshall54 suggested that a good validation test for an immersed boundary implementation is a topographic Rossby wave, a la:. https://journals.ametsoc.org/mwr/article/125/9/2293/104481/Representation-of-Topography-by-Shaved-Cells-in-a. which has an analytical solution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['validat'],['validation']
Security,"@liuchihl and I are trying to implement forcing functions that depend the tracer diffusivity. It is clear how to do this for a `ScalarDiffusivity` but not for a flow-dependent closure such as `SmagorinskyLilly`. The root of the problem seems to be that forcing functions only have access to the model `grid` and a limited tuple of `model_fields`. Since [diffusivities are also treated as `Fields` internally](https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/diffusivity_fields.jl), it is not clear to me why these are not included in the `model_fields` tuple that is passed to the Forcing function:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L203-L204. Maybe what I am asking for is the same thing as suggested by this comment:; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/Models/Models.jl#L124-L126",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582:281,access,access,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582,1,['access'],['access']
Security,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260,1,['validat'],['validation']
Security,@maeckha do you have access to Oceananigas.jl? i.e. can you merge this PR yourself?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872335304:21,access,access,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872335304,1,['access'],['access']
Security,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:273,validat,validation,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,2,['validat'],['validation']
Security,"@michel2323 @vchuravy this looks like an error in KA indexing, which I recall you guys resolved previously? [and @glwagner there was that weird offset issue before iirc]. ```julia. Enzyme on advection and diffusion: Error During Test at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/test/test_enzyme.jl:93; --;   | Got exception outside of a @test;   | BoundsError: attempt to access 16×16×1 Array{Tuple{Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}}, 3} at index [1, 1, 2];   | Stacktrace:;   | [1] setindex!;   | @ ./array.jl:971 [inlined];   | [2] setindex!;   | @ ./multidimensional.jl:670 [inlined];   | [3] aug_fwd;   | @ /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:20 [inlined];   | [4] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(4, 4, 8)}, KernelAbstractions.NDIte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:393,access,access,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['access'],['access']
Security,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ CenteredFourthOrder │ 1.779 s │ 1.789 s │ 1.794 s │ 1.814 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.066 s │ 1.061 s │ 1.090 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.467 s │ 2.505 s │ 2.505 s │ 2.544 s │ 1.05 MiB │ 1685 │ 2 │; │ CPU │ UpwindBiasedThirdOrder │ 1.808 s │ 1.877 s │ 1.862 s │ 1.903 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.775 s │ 6.775 s │ 6.775 s │ 6.775 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.879 ms │ 20.970 ms │ 21.078 ms │ 21.874 ms │ 2.17 MiB │ 20610 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.402 ms │ 15.533 ms │ 15.138 ms │ 15.680 ms │ 2.05 MiB │ 13147 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.356 ms │ 23.498 ms │ 24.055 ms │ 29.246 ms │ 2.21 MiB │ 23281 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.863 ms │ 19.027 ms │ 19.298 ms │ 21.745 ms │ 2.12 MiB │ 17945 │ 10 │; │ GPU │ WENO5 │ 23.234 ms │ 28.467 ms │ 27.982 ms │ 28.684 ms │ 2.30 MiB │ 29259 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; This PR same file, (WENO5 on uniform grids); ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:168,validat,validation,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,3,['validat'],"['validate', 'validation']"
Security,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:294,access,access,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495,1,['access'],['access']
Security,"@navidcy, based on your comment [here](https://github.com/CliMA/Oceananigans.jl/pull/3087/commits/43723b6661ffeba0f7caf9320c8e3fb32c943f98), I have put the spaces between the hashes to restore the literation style of the examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1572565458:175,hash,hashes,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1572565458,1,['hash'],['hashes']
Security,@pnavaro I believe we have been able to run Oceananigans in this scenario. I can't remember exactly what was done (@ali-ramadhan may have more insight). . Have you tried running `Pkg.instantiate()` in an environment that contains Oceananigans on the login node? I believe this should download the software that you need (despite that precompilation will fail if the login node does not have a GPU). If you can get access to the GPU node interactively at the same time that you have access to the login node I think that might help a lot with debugging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707414042:414,access,access,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707414042,2,['access'],['access']
Security,"@siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl. if I run this on this branch I get:. ```Julia; julia> include(""multi_region_cubed_sphere.jl""); [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 2: 1.4784702873954643e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 3: 1.353035964424265e-7; [ Info: φᶠᶠᵃ_difference",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2012222484:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2012222484,1,['validat'],['validation']
Security,"@siddharthabishnu can you post perhaps a shorter MWE-type code snippet that showcases this issue, e.g., for a `CenterField` and `XFaceField`?. After some investigation, I noticed that in the [script](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:287,validat,validation,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856,3,['validat'],['validation']
Security,"@siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414,2,['validat'],['validation']
Security,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924:181,validat,validation,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924,1,['validat'],['validation']
Security,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299,4,['validat'],['validation']
Security,"@simone-silvestri I think another error has now come up with the original MWE in issue #3681. I tried the `main` branch and this branch on two different systems and I'm getting a different CUDA illegal memory access error. Since it's probably not related to this PR I'll open a new issue about it. I'm guessing something is out of bounds in an `@inbounds`. I'll try catching it with `--check-bounds=yes`. MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); ```. Error:. ```julia; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_stru",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:209,access,access,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['access'],['access']
Security,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814,1,['validat'],['validation']
Security,@simone-silvestri you can run the GPU profiler on the `validation/elliptic_solvers/doubly_bounded_poisson.jl` on this branch. You can set `arch = GPU()` and it should work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636:55,validat,validation,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636,1,['validat'],['validation']
Security,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:831,access,accessed,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,1,['access'],['accessed']
Security,"@tomchor , thanks for the suggestion, but didn't have any access. @ali-ramadhan , thanks for merging!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872727739:58,access,access,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872727739,1,['access'],['access']
Security,@tomchor Ah are you okay with committing my suggestion before merging? . I think docs did get built and deployed:; https://buildkite.com/clima/oceananigans/builds/2048#0d49a5b8-1dec-4f7b-b82a-cf6f8809e234/40-574; https://clima.github.io/OceananigansDocumentation/previews/PR1543/simulation_tips/. Working on getting you guys access to Buildkite so you can control it as well. I'm not a Buildkite admin so I have to ask one to invite other people...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412:325,access,access,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412,1,['access'],['access']
Security,"@tomchor, let's do these in this PR:. > * Remove the Lid-drive cavity and Couette flow from the docs; > * Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu). and open issue/other PR for `validation` directory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873257930:227,validat,validation,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873257930,1,['validat'],['validation']
Security,"@whitleyv, if I want to start playing around with your immersed boundary implementations, where is a good place to start? Should I go back to https://github.com/CliMA/Oceananigans.jl/commit/28a9de91bbeb673cccce92e0e4c4c524c0a162e7 or start using your more arbitrary implementation in this branch https://github.com/CliMA/Oceananigans.jl/tree/vw/arbitrary_immersedboundary. (Anecdotally, I had trouble running any of the immersed boundary validation experiments on that branch on my CPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-839176808:438,validat,validation,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-839176808,1,['validat'],['validation']
Security,@xiaozhour @navidcy @sandreza are we ok to merge this PR without examples (since it has a lot of fixes) and continue working on 1) eddying channel example and 2) eddying channel validation test on new branches?. I'll work on getting tests to pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890346316:178,validat,validation,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890346316,1,['validat'],['validation']
Security,"@xiaozhour and I looked into some direct comparisons with MITgcm and found a few differences that we are continuing to investigate. One thing worth noting is that in the MITgcm computation the xz and yz components of the diffusivity tensor that act on vertical gradients are directly set to zero, whereas the zz component is treated implicitly. In the simulation below I increase the initial horizontal gradient by a factor of two and set the initial tracer to be constant. A numerical instability develops eventually leading to NaNs in the tracer field. By setting the Redi-component to zero the solution remains stable. The file is located here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/modified_baroclinic_adjustment.jl. https://user-images.githubusercontent.com/22668662/165390858-211bce67-fb10-4ae4-8e60-3516b49e5031.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312:724,validat,validation,724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312,1,['validat'],['validation']
Security,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:152,validat,validates,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['validat'],['validates']
Security,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:675,access,access,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363,1,['access'],['access']
Security,"A git merge/rebase master might help with review, but only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292,1,['validat'],['validation']
Security,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:246,validat,validating,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,1,['validat'],['validating']
Security,"A more minimal example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, PartialCellBottom. arch = CPU(). underlying_grid = RectilinearGrid(arch,; size=(128, 64), halo=(3, 3), ; y = (-1, 1),; z = (-1, 0),; topology=(Flat, Periodic, Bounded)). @inline seamount(x, y) = - 1 + 0.5 * exp(- y^2 / 0.25^2). minimum_fractional_Δz = 0.2. grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(seamount; minimum_fractional_Δz)). tracer_advection = CenteredSecondOrder(); momentum_advection = CenteredSecondOrder(). model = HydrostaticFreeSurfaceModel(; grid,; tracer_advection,; momentum_advection,; coriolis = FPlane(f=0.1),; tracers = :b,; buoyancy = BuoyancyTracer()); ```. ```julia; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×134 OffsetArray(::Matrix{Float64}, 1:1, -2:131) with eltype Float64 with indices 1:1×-2:131 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [6] overdub; @ ~/Research/OC2.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; [7] immersed_cell(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826:840,access,access,840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826,1,['access'],['access']
Security,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['validat'],['validation']
Security,"A quick fix is to change. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/validation/immersed_boundaries/flow_over_hills.jl#L30. to . ```julia; underlying_grid = RectilinearGrid(architecture, size = (Nx, Nz), halo = (4, 4), ; ```. ie increase the number of halo points by 1. It does beg the question whether we should increase the number of default halo points to 4 from 3. Both #2989 and #2827 should increase the problem with cryptic errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282:113,validat,validation,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282,1,['validat'],['validation']
Security,About Stratified Couette Flow validation case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:30,validat,validation,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,1,['validat'],['validation']
Security,"Abstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9770,hash,hashing,9770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hashing']
Security,Accidental double hashed comments in two_dimensional_turbulence.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1167:18,hash,hashed,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1167,1,['hash'],['hashed']
Security,"Actually they're validation experiments, not verification experiments",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,1,['validat'],['validation']
Security,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:131,access,access,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,1,['access'],['access']
Security,Add a validation script and/or tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204:6,validat,validation,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204,1,['validat'],['validation']
Security,Add direct access to auxiliary fields for forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2733:11,access,access,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733,1,['access'],['access']
Security,Add validation for array-based coordinates,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:4,validat,validation,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,1,['validat'],['validation']
Security,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2059:858,validat,validation,858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059,1,['validat'],['validation']
Security,Adding `length` as kwarg with code to validate is fine too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204403:38,validat,validate,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-544204403,1,['validat'],['validate']
Security,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,2,['validat'],['validation']
Security,Adds a tilted bottom boundary layer validation example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498,1,['validat'],['validation']
Security,Adds benchmark for free surface solvers on lat-lon immersed boundary + triply-bounded Poisson bench/validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2784:100,validat,validation,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2784,1,['validat'],['validation']
Security,Adds flow_over_hills validation case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402,1,['validat'],['validation']
Security,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:79,validat,validaton,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,2,"['access', 'validat']","['access', 'validaton']"
Security,"Agree that SI default makes sense for a code called ""Oceananigans"". Note that some of the examples are non-dimensional, so an SI default will indeed add code to those examples --- which are likely some of the most-read scripts in the Oceananigans-verse. I also think for accessibility it could make sense to prioritize ease-of-use in a classroom context, where non-dimensional runs are the norm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889:271,access,accessibility,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889,1,['access'],['accessibility']
Security,"Agreed! I went back and see that things are much better on my cpu. There are a few warnings but then it gets down to business. I am estimating that it might take 14 hours, and now I believe that it is progressing (unlike before). On a future world, when one sees that things are taking a while, it would be nice to run things in parallel using distrubed version of the model. I see there are distributed models for IncompressibleModel and ShallowWater, but not HydrostaticModel, yet. . Maybe I'll create an issue since this is something that I presume we would like to have going forward. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Second_Oceananigans/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:106; ┌ Warning: Cannot save Function property into grid/immersed_boundary/mask; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:21; ┌ Warning: Could not initialize ./internal_tide.jld2: data may already be initialized.; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:193; [ Info: [0.06%], iteration: 100, time: 0.055, max|w|: 9.46e-06; [ Info: [0.11%], iteration: 200, time: 0.110, max|w|: 2.67e-05; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305:703,validat,validate,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305,1,['validat'],['validate']
Security,"Ah I see, the GPU compiler would just see `Fu(grid, velocities, tracers, i, j, k)` and not know what to call at compile time. Would `struct ForcingFunctions{FFu, ...}` be the best approach to inject arbitrary functions (maybe with a specific signature) into a GPU kernel at run time? Can't think of many options myself.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467044774:192,inject,inject,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467044774,1,['inject'],['inject']
Security,Ah I thought we could do something with abstract types for that but couldn't get it to work before. I'll try this on a GPU now if I can get one. And that makes sense for the validation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305857142:174,validat,validation,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305857142,1,['validat'],['validation']
Security,"Ah I wouldn't say your GPU lacks any architecture, it's just different from the one we test on. And we don't have access to many different GPUs. Might be good to leave this issue open until we increase the ≈ tolerance to account for different GPU microarchitectures (at which points tests should pass on your system).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726995346:114,access,access,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726995346,1,['access'],['access']
Security,"Ah ok, thanks for that info! I guess that means this internal tide validation experiment wouldn't benefit from GPU parallelization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868667638:67,validat,validation,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868667638,1,['validat'],['validation']
Security,Ah that could be a neat validation experiment for tilted gravity and Oceananigans in general!. Just linking to Ruan et al. (2019): https://doi.org/10.1175/JPO-D-18-0079.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739513986:24,validat,validation,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739513986,1,['validat'],['validation']
Security,"Ah we can figure out the best names in the future PR then?. > I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?. Maybe the fastest thing to do for now would be to use `JLD2OutputWriter`? It should work with the grids no problem until we sort out `NetCDFOutputWriter`. I've been able to open JLD2 files in Python with h5py in the past if that's helpful, but yeah no xarray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492:140,validat,validate,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492,1,['validat'],['validate']
Security,Ah we can ignore the validation experiments pipeline failure. It's failing because `.buidlkite/validation-pipeline.yml` is not on this branch. I've since disabled GitHub triggers for the validation pipeline. Now it's triggered every night at 3 am EST and can be triggered manually but needs more work at PR #1223.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736701709:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736701709,3,['validat'],"['validation', 'validation-pipeline']"
Security,"Ah yeah no that's a good question. Initially it's just because the CPUs on Buildkite (running on our machine) are more powerful than the ones on Travis so we can reduce documentation build times from 30~40 minutes down to ~20 minutes. But we also want to run higher-resolution examples and more of them, which is where more powerful CPUs is helpful, and since we have many cores available we can hopefully run/test/build many examples in parallel (#1053). And yeah maybe at some point we'll also have MPI (+ GPU?) examples which would have to run on more powerful machines that we can probably access through Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1051#issuecomment-708042089:594,access,access,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1051#issuecomment-708042089,1,['access'],['access']
Security,"Ah, I foolishly assumed it was running in CPUs but do see it's running on GPUs. I gather it's slow because the GPU I have on my desktop is poor. Maybe I'll kill it and run it on a CPU as that maybe faster on my local machine. One thing that should be changed, sometime, is the only output I see is a warning message. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735:431,validat,validate,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735,2,['validat'],['validate']
Security,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:28,validat,validated,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,3,['validat'],"['validated', 'validation']"
Security,"Ah, these experiments are the immersed Bickley jet but they use a one layer HydrostaticFreeSurfaceModel. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/bickley_jet/immersed_bickley_jet.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475449166:156,validat,validation,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475449166,1,['validat'],['validation']
Security,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:192,validat,validation,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['validat'],['validation']
Security,All tests should pass (see https://buildkite.com/clima/oceananigans-validation-experiments/builds/96) but Tartarus went down so a lot of builds died leading to failing tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769149023:68,validat,validation-experiments,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769149023,1,['validat'],['validation-experiments']
Security,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:554,validat,validation,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141,1,['validat'],['validation']
Security,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:1314,validat,validation,1314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194,1,['validat'],['validation']
Security,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:414,validat,validation,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882,2,['validat'],['validation']
Security,"Also with `SumOfFields` we can put in proper support for other things. It can be an `AbstractField` and be used in operations (perhaps the biggest advantages because users will want to do diagnostics on the sum probably), we can give it a location and expose its grid, and we can support `fill_halo_regions` and `mask_immersed_field`. It's a decent idea provided that the normal way of summing fields that produces a `BinaryOperation` or `MultiaryOperation` won't work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265995885:252,expose,expose,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265995885,1,['expose'],['expose']
Security,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:221,validat,validate,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,1,['validat'],['validate']
Security,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:441,secur,security,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['secur'],['security']
Security,"Apparently the figures in the [Convergence tests](; https://clima.github.io/OceananigansDocumentation/latest/validation/convergence_tests/) and Stratified Couette flow sections of the documentation aren't showing. I suspect it's a broken link or something (probably very easy to fix). Sorry if you guys are aware of this already, but I couldn't find any issue about it. Cheer!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1212:109,validat,validation,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212,1,['validat'],['validation']
Security,Are you running the pasted example or the code in `validation`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867911238:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867911238,1,['validat'],['validation']
Security,"As a convenience, we can provide constructors for different use cases. For example, we can have an `OceanModel`, which has `ConstantAnisotropicDiffusivity` as default and exposes the anisotropic coefficients directly to the user. This deals with @johncmarshall54's concern about the `ConstantIsotropicDiffusivity` default. This will also help us move some of the body of the `Model` constructor into re-useable functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/258:171,expose,exposes,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/258,1,['expose'],['exposes']
Security,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:198,access,access,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,1,['access'],['access']
Security,"As far as I can tell, I think this is related to the issue @jagoosw mentioned too, where the indices that the output is trying to access does not match the size of the sliced fields, similar to what we are seeing here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281:130,access,access,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281,1,['access'],['access']
Security,"As for issues with other topologies, we could possibly use the ""forced flow, fixed-slip"" convergence test with 2D slices oriented in various directions to uncover issues:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/convergence_tests/src/ForcedFlowFixedSlip.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638:225,validat,validation,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638,1,['validat'],['validation']
Security,"At high enough ~~vertical~~ vertical + horizontal resolution, it seems that the `zonally_averaged_baroclinic_adjustment.jl` validation test blows up with `IsopycnalSkewSymmetricDiffusivity`; specifically:. ```julia; gerdes_koberle_willebrand_tapering = FluxTapering(1e-2); gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = 1000,; κ_symmetric = 900,; slope_limiter = gerdes_koberle_willebrand_tapering); ```. For example, with 50m vertical resolution (Nz=20, Lz=1000m, 20km horizontal resolution) we find. https://user-images.githubusercontent.com/15271942/164360760-ef03fc9d-e07a-4b50-9e80-bd79997cfa1d.mp4. while at 25m resolution (same extent, horizontal resolution, time-step) we find. https://user-images.githubusercontent.com/15271942/164360772-e39a08e4-eb5e-48e4-bfc4-cde1e241ec0f.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2453:124,validat,validation,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2453,1,['validat'],['validation']
Security,"At last, I found an algebra mistake in my definition of the forced fixed-slip problem. The forced fixed-slip convergence validation test now passes! This means that the Oceananigans pressure solver produces correct results when the pressure gradient is non-zero on the boundary. ![image](https://user-images.githubusercontent.com/15271942/85010687-6d626b80-b12e-11ea-9169-6dc0bfc11d59.png). @ali-ramadhan I think we should run these in CI eventually. Should we do that in this PR or save for a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-645935643:121,validat,validation,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-645935643,1,['validat'],['validation']
Security,"At least, this is not the current syntax for discrete diffusion function:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/validation/near_global_lat_lon/near_global_quarter_degree.jl#L131. There are also some formatting irregularities here:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/src/TurbulenceClosures/discrete_diffusion_function.jl#L57-L67",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690:162,validat,validation,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690,1,['validat'],['validation']
Security,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201:158,validat,validation,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201,1,['validat'],['validation']
Security,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1001:1745,validat,validation,1745,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001,1,['validat'],['validation']
Security,"Awesome! The two solvers do pretty different things at this point because; CuFFT doesn't do DCTs or r2r transforms but I've also baked in some; performance optimizations to reduce memory access and operation count. We; should be able to hide some of it away with dispatch but some of the; optimizations are baked into the time stepping so not completely... Might be easier to talk in person when we meet later today?. On Tue, Mar 5, 2019, 9:00 AM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm going to work on this. I would also like to improve the solver; > implementation. Why are there different spectral solvers; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L4>; > for different devices; > <https://github.com/climate-machine/Oceananigans.jl/blob/3cd4ae32cb4d716bc6470a6e7ba484ed98d60de7/src/spectral_solvers.jl#L215>?; > Can we combine them into one type with the Device as a type parameter?; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/102#issuecomment-469689574>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBV5TY3u4FjjnraBoJT3fw5L4JqWNks5vTnhggaJpZM4bahv3>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219:187,access,access,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/102#issuecomment-469691219,1,['access'],['access']
Security,"Awesome, I'll change the behavior in #1229 so it only opens the file as needed to write output. Not sure what will happen if you open a file while the simulation is running (but not writing output) then try to access data while Oceananigans is writing output, but hopefully it'll all be well-behaved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735433046:210,access,access,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735433046,1,['access'],['access']
Security,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777:311,validat,validation,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777,1,['validat'],['validation']
Security,Barotropic turbulence validation tests on RegularLatitudeLongitudeGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['validat'],['validation']
Security,Better validation for `LatitudeLongitudeGrid` + add test for `sum(Azᶜᶜᵃ) ≈ 4πr²`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3240:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240,1,['validat'],['validation']
Security,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1310:319,validat,validate,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310,1,['validat'],['validate']
Security,Bugfixes for HydrostaticSphericalCoriolis and solid body rotation validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,1,['validat'],['validation']
Security,"But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2261913274:220,validat,validation,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2261913274,1,['validat'],['validation']
Security,"But it's the same solver in the validations script also, right? The FFT solver...; Is there any other difference?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486161704:32,validat,validations,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486161704,1,['validat'],['validations']
Security,"CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS) when using Lagrangian particles under large CFL number",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:30,access,access,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['access'],['access']
Security,CUDA illegal memory access during `HydrostaticFreeSurfaceModel` construction with `Float32` and CATKE,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:20,access,access,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['access'],['access']
Security,CUDA illegal memory access when constructing a `Float32` `HydrostaticFreeSurfaceModel` + `CATKEVerticalDiffusivity` on the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:20,access,access,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['access'],['access']
Security,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:115,validat,validation,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856,2,['validat'],['validation']
Security,Can you do a validation case that has implicit vertical diffusion? Does it work in that case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965110912:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965110912,1,['validat'],['validation']
Security,"Change. https://github.com/CliMA/Oceananigans.jl/blob/d4a462b259073b5c698f2cf9a8f419304f74262b/validation/mesoscale_turbulence/baroclinic_adjustment.jl#L51. to. ```julia; diffusive_closure = VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), ν = νz, κ = κz) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996:95,validat,validation,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996,1,['validat'],['validation']
Security,"Click the link titled ""Details"". This will take you to build kite and, if you have authorization, you will see an button that says ""Rebuild"". You may have to navigate around the build kite site a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843336320:83,authoriz,authorization,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843336320,1,['authoriz'],['authorization']
Security,"Closes #3534. After this PR:. ```Julia; julia> using Oceananigans. julia> model = NonhydrostaticModel(grid = RectilinearGrid(size=(2, 3, 4), extent=(1, 1, 1))); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: Centered reconstruction order 2; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> model = ShallowWaterModel(grid = RectilinearGrid(size = (4, 4), extent = (1, 1), topology=(Periodic, Bounded, Flat)), gravitational_acceleration = 1); ┌ Warning: The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation.; └ @ Oceananigans.Models.ShallowWaterModels ~/Research/OC8.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0) ; ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo; ├── timestepper: RungeKutta3TimeStepper; ├── advection scheme: ; │ ├── momentum: Upwind Biased reconstruction order 5; │ └── mass: WENO reconstruction order 5; ├── tracers: (); └── coriolis: Nothing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3542:821,validat,validation,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3542,1,['validat'],['validation']
Security,Convergence test and validation experiment Buildkite pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['validat'],['validation']
Security,Correct accessing velocities from the background field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862:8,access,accessing,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862,1,['access'],['accessing']
Security,Could you comment on what version of Oceananigans you are using?. Perhaps we need to add a validation that spits out a meaningful warning to the user when this happens.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596:91,validat,validation,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596,1,['validat'],['validation']
Security,"CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45980,hash,hashing,45980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,Cubed sphere validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['validat'],['validation']
Security,"Currently a work in progress, but it has one validation experiment (Rossby-Haurwitz) and one ""for fun"" dynamics test (Bickley Jet)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570,1,['validat'],['validation']
Security,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,1,['validat'],['validation']
Security,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:267,access,access,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,1,['access'],['access']
Security,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/985:297,access,accessed,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985,2,['access'],['accessed']
Security,Curvilinear diffusion validation experiments,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1423:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423,1,['validat'],['validation']
Security,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:104,access,access,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,1,['access'],['access']
Security,"Dear Oceananigans team,. We are trying to use Oceananigans to create reference LES solutions for multiple canonical flows. We use a cubical domain and random perturbations to trigger the flow. During our validation tests, we noticed that we could not reproduce the results, i.e., running the same .jl script (same initial flow conditions) leads to different averaged solutions (see attached picture). We ran more than 16 simulations and never obtained the same solution. We tried to set the seed of the random perturbations constant, but this did not solve the problem. Do you observe this problem, and could you help us run reproducible simulations so other users can obtain the same solutions? We attached the .jl file we are using to define the simulations. Best regards,; Filipe Pereira; Luke van Roekel ; Amrapalli Garanaik; Brodie Pearson . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193599386-11eccb58-2a3f-4a1c-83d6-cde2ea429d00.png). [c16_128_128m(1).jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9698212/c16_128_128m.1.jl.zip)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766:204,validat,validation,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766,1,['validat'],['validation']
Security,"Dedalus currently has a binary configuration option to cache the evaluation of every intermediate operation within a single timestep / sub-stage. The recursive evaluation of an operator tree accepts and propagates a cache-key argument, which could be related to e.g. the simulation iteration and sub-stage. If caching is enabled, each operator checks it's own size-1 cache for the cache-key, and returns the result if present. Otherwise it evaluates itself, and stores the result under the cache-key. . This eliminates the repeated evaluation of individual operators, but at the cost of storing the result of every intermediate operation. We're currently working on an upgrade that first traverses the tree, counts the number of references to a given operator, and deallocates the cached result after the cache has been accessed the corresponding number of times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991:820,access,accessed,820,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694332991,1,['access'],['accessed']
Security,"Definitely in favor of an MPI example!. I think the point is that the script is not an example now, so it could make sense to put the script in `validation/` until it's ready / someone has time to write the example in Literate style and built into the documentation, and perhaps implement the suggested updates to the physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842408398:145,validat,validation,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842408398,1,['validat'],['validation']
Security,"Definitely looks good! I guess it belongs more in `validation/`?. We can eventually run it as part of the validation pipeline to generate the plot every night and make sure everything still converges. Also noticed that `examples/Inertial_Instability_2D_old.mp4` was somehow included in this PR (I thought `*.mp4` was in `.gitignore`). I think we'll want to remove it then make sure to ""squash and merge"" this PR so the mp4 file doesn't enter git history (and increase the repo size).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839116955:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839116955,2,['validat'],['validation']
Security,Delete validation-pipeline.yml,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3176:7,validat,validation-pipeline,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3176,1,['validat'],['validation-pipeline']
Security,Delete validation/near_global_lat_lon directory,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3012:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3012,1,['validat'],['validation']
Security,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:63,validat,validation,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['validat'],['validation']
Security,"Do we want to have a goal of 100% reproducibility for the validation cases? I think their main purpose is expository, ie to show advanced usage of the code. Exact reproducibility isn't the highest priority for that purpose --- is it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1895904765:58,validat,validation,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1895904765,1,['validat'],['validation']
Security,Document and test numerical convergence validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,1,['validat'],['validation']
Security,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36385,validat,validate,36385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['validat'],['validate']
Security,Does anyone know if there is a way when we activate a project in Julia to preclude access to all packages in the general Julia `(v1.6)` environment? That would make this procedure smoother...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869100541:83,access,access,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869100541,1,['access'],['access']
Security,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:597,validat,validated,597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['validat'],['validated']
Security,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:107,validat,validation,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,1,['validat'],['validation']
Security,Error in `visualize_barotropic_gyre.jl` in validation exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:43,validat,validation,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['validat'],['validation']
Security,"Even if the length is 1, you are missing these lines:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L60-L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637:142,validat,validation,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637,1,['validat'],['validation']
Security,"Exciting; On Mon, Dec 3, 2018 at 6:03 PM Ali Ramadhan <notifications@github.com> wrote:; >; > @christophernhill Thanks for posting this! @mg547 and I were able to get it working with our Laplacian operator. Going to try and inject it into the pressure solver now, fingers crossed!; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub, or mute the thread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443920196:224,inject,inject,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443920196,1,['inject'],['inject']
Security,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:14,validat,validation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,2,['validat'],['validation']
Security,"First results from the ""stratified ocean remains at rest"" validation:. <img width=""394"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/162029258-21ef073b-62a1-47ae-8515-9fb7e2a7f377.png"">. Short answer --- with partial cells, a resting ocean does not remain at rest! So, we need to implement either the ""MITgcm method"" for hydrostatic pressure, or Lin 1997 (or both).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309:58,validat,validation,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309,1,['validat'],['validation']
Security,Fix bug for horizontal diffusivity with Flat horizontal dimension + updates baroclinic adjustment validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['validat'],['validation']
Security,Fix bug when throwing exception during grid validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,1,['validat'],['validation']
Security,Fix erroneous double hashes in two_dimensional_turbulence.jl example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1168:21,hash,hashes,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1168,1,['hash'],['hashes']
Security,Fix fatal interaction between FieldTimeSeries construction and input validation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2589:69,validat,validation,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589,1,['validat'],['validation']
Security,"Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/validation.jl:141; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:418 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Fields.gpu__regrid!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:4545,validat,validate,4545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['validat'],['validate']
Security,Flux boundary conditions for HydrostaticFreeSurfaceModel and barotropic gyre validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1433:77,validat,validation,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433,1,['validat'],['validation']
Security,"For a more complicated case on the cubed sphere, see https://github.com/CliMA/Oceananigans.jl/blob/main/validation/cubed_sphere_tracer_advection/cubed_sphere_tracer_advection.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826:104,validat,validation,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826,1,['validat'],['validation']
Security,"For a thesis project about the migration and dispersal of fish larvae in the sea I am looking for CFD tools that allow a newcomer in this field (like myself) the simulation of agent based models (each agent represents a fish) in laminar flows and later in more realistic turbulences. I chose the following steps as milestones:. - First, as a means for validation, I will show a lid driven cavity flow (Oceananigans already does this in an example).; - After this I will combine this with an agent based model where an agent will represent a larvae. At that state the agent should follow simple rules, like drift in the direction of a laminar flow.; - If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef.; - Next, putting n agents into the water and see, if the individuals are behaving differently when put into a swarm. . I am planning to keep this in 2D since doing it in 3D would probably be to difficult given the limited time (3 months). I will not try to simulate the exact ocean currents or the bottom of the ocean. Are you capable of assessing the suitability of Oceananigans for those steps? Is it possible to deliver those steps? . For the Agent based modelling I will be working with the [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/) package probably, since it seems well documented.; Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and [WaterLily.jl](https://github.com/weymouth/WaterLily.jl)? Given my description of the project above, would you tend to use either of them?; Thank you!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438:352,validat,validation,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438,1,['validat'],['validation']
Security,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:507,access,access,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['access'],['access']
Security,"For future reference, I believe that updating the ssh deploy keys requires two things:. 1. Access to tartarus; 2. Admin privileges on the documentation repo, https://github.com/CliMA/OceananigansDocumentation. The [`Documenter.jl` documentation for generating deploy keys](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh) reads confusingly because we don't use Travis CI, but I do think we need to do something like what's outlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147:91,Access,Access,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147,1,['Access'],['Access']
Security,"For large complex domains, we can obtain an excellent speedup. In the case of the quarter-degree ocean (where the roughly 42% of the domain is immersed), the speedup is about 1.47X!. To document the speedup, here is the profile for the `validation/near_global_lat_lon/near_global_quarter_degree.jl` . On main:; <img width=""1512"" alt=""Screen Shot 2022-11-16 at 10 14 53 AM"" src=""https://user-images.githubusercontent.com/33547697/202219607-aa98d26d-6f6c-4c04-9692-cf9907ad14d6.png"">. On this branch:; <img width=""1512"" alt=""Screen Shot 2022-11-16 at 10 14 48 AM"" src=""https://user-images.githubusercontent.com/33547697/202219640-3476d0a0-e70d-4af8-aa95-f131c86d5379.png"">. The tendency calculations (the four large kernels in the profile) speedup of more than a factor 2!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317183274:237,validat,validation,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317183274,1,['validat'],['validation']
Security,"For reference, here are some quick and dirty surface buoyancy plots from the Oceananigans setup at 4 and 10 days. Kind of close to Haine & Marshall (1998) figure 8 but probably not enough for a validation test as it's just eyeballing. ![image (1)](https://user-images.githubusercontent.com/20099589/85021841-70feee00-b140-11ea-9e4b-fe8d9560d39a.png). ![image (2)](https://user-images.githubusercontent.com/20099589/85021848-73614800-b140-11ea-9415-22d9330fc461.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-645995878:194,validat,validation,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-645995878,1,['validat'],['validation']
Security,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:105,validat,validation,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['validat'],['validation']
Security,For w is; 1. `k = Nz` now the surface implying that `k=0` is the bottom and a halo cell?; 2. or is `k = 1` the bottom implying that `k = Nz+1` is the surface and a halo cell?. Seems that we're actually implementing the second. Might be nice to have direct access to the surface via `k = Nz` but this would break the pattern that `i = 1` for u and `j = 1` for v coincide with the boundary whereas `i = Nx` and `j = Ny` do not.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542219856:256,access,access,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542219856,1,['access'],['access']
Security,"Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4183,validat,validation,4183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validation']
Security,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:618,access,accessed,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,1,['access'],['accessed']
Security,GPU illegal memory access,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:19,access,access,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['access'],['access']
Security,"Good idea to do a partial cell Immersed boundary!. weird, from what I see here the `mask_immersed_field!` should work properly. have you tried to do ; ```; struct PartialCellBottom{B, E} <: AbstractGridFittedBoundary; bottom_height :: B; minimum_fractional_partial_Δz :: E; end; ```. Like that it seems to be working for me... ```; julia> grid = RectilinearGrid(size=(1, 1, 10), extent=(1, 1, 1)); 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> ibg = ImmersedBoundaryGrid(grid, PartialCellBottom((x, y)-> -0.5, 1)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; with immersed: PartialCellBottom{var""#1#2"", Int64}. julia> c = CenterField(ibg); 1×1×10 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×10 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 3×3×12 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:11) with eltype Float64 with indices 0:2×0:2×0:11; └── max=0.0, min=0.0, mean=0.0. julia> fill!(c, 1); 3×3×12 Array{Float64, 3}:; [:, :, 1] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. ;;; … . [:, :, 10] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276:831,validat,validate,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276,1,['validat'],['validate']
Security,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:632,validat,validation,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['validat'],['validation']
Security,Good idea. I will move it to validation in a new PR today then @ali-ramadhan and I can talk about turning this into a real example.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842413805:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842413805,1,['validat'],['validation']
Security,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1195,Inject,Injection,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Inject'],['Injection']
Security,Good thing to test as it exposed a typo. Resolves #539,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/549:25,expose,exposed,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549,1,['expose'],['exposed']
Security,Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590505343:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590505343,1,['validat'],['validation']
Security,Great. I'll have a look after the docs are build (and I have access to the preview). :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290:61,access,access,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290,1,['access'],['access']
Security,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:1299,validat,validation,1299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['validat'],['validation']
Security,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:522,access,access,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['access'],['access']
Security,Haine & Marshall (1998) channel validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:32,validat,validation,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,1,['validat'],['validation']
Security,Happy to approve this if there's unanimous consent. I guess we should tag v0.50.0 with this PR and get the pain of breaking changes out of the way?. Out of paranoia I'm also running the convergence tests for this PR manually: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149:267,validat,validation-experiments,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149,1,['validat'],['validation-experiments']
Security,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:545,validat,validation,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,3,['validat'],['validation']
Security,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;   | [2021/07/29 16:10:57.288] INFO ∂T∂z * g̃[2] = 0.0001065658790393914, mean(∂y_T) = 0.0001065658790360618, Δ = 3.32959842423014e-15 at t = 1 hour with θ=1°;   | [2021/07/29 16:10:57.288] INFO ∂T∂z * g̃[3] = 0.006105155121314884, mean(∂z_T) = 0.006105155121314366, Δ = 5.178149575790769e-16 at t = 1 hour with θ=1°;   | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;   | Expression: all(∂T∂z * g̃[2] .≈ interior(∂y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1622,validat,validation,1622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453,1,['validat'],['validation']
Security,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,2,['validat'],['validation']
Security,"Here are some plots of longitudes at locations cca, fca and cfa with colorbars. They can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/623b6f5d4c230441871ac61ba55e27d379898ead/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [623b6f5](https://github.com/CliMA/Oceananigans.jl/commit/623b6f5d4c230441871ac61ba55e27d379898ead) of the Oceananigans branch [sb-ncc-ss/cubed-sphere-tracer-advection](https://github.com/CliMA/Oceananigans.jl/tree/sb-ncc-ss/cubed-sphere-tracer-advection) with the specification test_multi_region_cubed_sphere_plots = true. Since these plots look fine to me, I guess the unusual nature of the previous plots can be attributed to a plotting artifact. So, I may be back to square one. . Using set! at location cca; ![longitude_panel_wise_visualization_c_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/3733da53-dde3-4ce2-9960-c0530d322ba3); Using λnodes at location cca; ![longitude_panel_wise_visualization_u_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/dbd1c4e3-506c-4a2e-b0af-b6a626205784). Using set! at location fca; ![longitude_panel_wise_visualization_u_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/66c57a6a-81e7-44af-a662-f0c4cc986783); Using λnodes at location fca; ![longitude_panel_wise_visualization_v_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/c6066339-af84-4ca7-a547-e98de9627ffc). Using set! at location cfa; ![longitude_panel_wise_visualization_v_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/e86ec39d-799a-4891-ad65-b436037e0c4c); Using λnodes at location cfa; ![longitude_panel_wise_visualization_c_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/7920da3c-96b9-41fc-bbab-14daa5665d90)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400:241,validat,validation,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400,1,['validat'],['validation']
Security,"Here's a few idea:. 1. Write more constructors for `BoundaryCondition`. The simplest constructor is what we often use, when the boundary condition is a constant or array. But we should add more constructors that support specifying boundary condition parameters. We should assume that by default the user wants to use `BoundaryFunction`, rather than the current default assumption that the function being specified is low-level. We can have a public constructor for `BoundaryCondition` that takes the argument parameters, which is designed to work with what we currently call ""`BoundaryFunction`"". 2. Add support for a lower-level, non-default boundary condition function signature (the current default) that gives the user access to more of the model state, should they need it. 3. Never ask the user to tell `BoundaryCondition` what field / boundary is being used. Instead, add interpretation to `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc that rebuilds the boundary conditions objects as needed. Use defaults in the `BoundaryCondition` constructor as temporary placeholders, and rewrap as needed in `TracerBoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660:723,access,access,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660,1,['access'],['access']
Security,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172,1,['validat'],['validation']
Security,"Here's a twin partial cell case (dx = 1 km as in the `GridFittedBottom` case above). The pattern in the differences is almost identical, although their magnitude is slightly smaller with partial cells:. ![numerical-EMVR08_pbc](https://github.com/user-attachments/assets/c99cdb8b-83bf-49b7-8946-b22d099edf0c). Resolution seems to have a negligible effect (dx = 200 m shown below, tried a few others):. ![hires_gfb](https://github.com/user-attachments/assets/bc29bbe3-5e8f-49d5-8f0b-8a2973df742d). The fact that partial cells actually reduce the magnitude of the difference seems encouraging, though. This could become a good validation case to illustrate the advantages of partial and cut cells for representing the BBL over a slope.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2272813809:624,validat,validation,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2272813809,1,['validat'],['validation']
Security,Here's a video from the `sediment_entrainment.jl` validation case:. https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167:50,validat,validation,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167,1,['validat'],['validation']
Security,"Here's a visualization from the new ""bumpy baroclinic adjustment"" validation case:. https://user-images.githubusercontent.com/15271942/162013972-d020b628-3f7b-4ce8-ac56-84c77a96bd42.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580,1,['validat'],['validation']
Security,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:537,access,access,537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,1,['access'],['access']
Security,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:953,validat,validation,953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550,1,['validat'],['validation']
Security,"Here's some validation. The animation below is from a triply-periodic 3D simulation with an initial reasonably-resolved initial condition without any forcings. Note that the IC looks a bit weird right now (a couple of straight lines in strain) because I'm taking a shortcut in defining a well-resolved random IC, but I can easily change it later if necessary. Left panel shows the strain rate squared for the `SmagorinskyLilly` closure, while the one on the right shows results for the `ScaleInvarianteSmagorinsky` closure, implemented in this PR. The bottom panel shows the evolution of the dynamically-calculated Smagorinsky coefficient for the latter, in comparison with the constant value of 0.16 imposed on the former. Important here is that the value of 0.16 was analytically derived by Lilly by assuming an isotropic 3D turbulence, a Kolmogorovian energy cascade, and further assuming that the cut-off filter is in the inertial range. I think all these assumptions are valid in this simulation, so we expect the dynamically-calculated value of the Smagorinsky coefficient (the black line) to approach the value 0.16 as time goes on. https://github.com/CliMA/Oceananigans.jl/assets/13205162/4049e7cf-452e-4883-a709-a675cf12277c. Although the match is not exact (the value it approaches is ~0.17), I think this is close enough. That said, I'm planning on also implementing a boundary layer validation along similar lines, which we can use to validate the model in the same fashion as [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152). One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. ```julia; ┌ Info: Runnin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170,1,['validat'],['validation']
Security,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:381,validat,validating,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685,1,['validat'],['validating']
Security,"Hi @ali-ramadhan! I'm working on Lagrangian analysis tools for ocean model output. Our original code was written in Matlab (https://doi.org/10.1109/escience.2016.7870923), but since I've recently been learning more about Julia I would like to switch. Our goal is to provide easy community access to large data volume numerical ocean simulations, with ready-made and easy-to-use tools. For Eulerian analysis we've used Python (https://doi.org/10.21105/joss.01506); that package is up and running. I want to add Lagrangian analysis tools to this framework. I'd love to learn more about what you guys are up to!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382:289,access,access,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382,1,['access'],['access']
Security,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:414,validat,validated,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554,1,['validat'],['validated']
Security,Hi @maeckha sorry for the out-of-date scripts. I've been meaning to add the validation experiments to CI so this doesn't happen. I can open a PR later today with an updated lid-driven cavity script if that would be helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083:76,validat,validation,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083,1,['validat'],['validation']
Security,"Hi @pnavaro thanks for opening this issue. Yeah this is an issue on some clusters so it might be worth adding a note in the documentation. In my case I think the login node had a GPU so I was able to build on the login node then just precompile and run on the compute node without internet access. But this was also before CUDA.jl which very nicely downloads CUDA artifacts for you so it just relied on the local CUDA toolkit. Do you have access to the CUDA toolkit on the login node via something like `module load cuda`? Might allow you to build on the login node without a GPU but might be weird to have CUDA but no GPU. Your compute node must have a CUDA installation. Looks like the CUDA.jl documentation has a section on how to make use of a local CUDA installation: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#CUDA-toolkit. If you can find where the CUDA toolkit is installed on your compute node, then maybe all you have to do is set one of the `CUDA_HOME`, `CUDA_ROOT` or `CUDA_PATH` environment variables?. Looks like creating a container with CUDA.jl is an option but it still requires a CUDA toolkit at runtime: https://juliagpu.gitlab.io/CUDA.jl/installation/overview/#Containers. Let us know if this helps or if you're able to get up and running on your compute node. Would be good to figure this out and add to the documentation. The #gpu channel on Julia's Slack or the GPU section of the Julia Discourse might also be good places to ask if we can't figure it out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840:290,access,access,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035#issuecomment-707637840,2,['access'],['access']
Security,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:155,access,access,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328,1,['access'],['access']
Security,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770:525,validat,validation,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770,1,['validat'],['validation']
Security,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:599,access,access,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618,1,['access'],['access']
Security,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:685,access,access,685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,1,['access'],['access']
Security,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1669:1180,validat,validation,1180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669,2,['validat'],['validation']
Security,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594,2,['validat'],['validation']
Security,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:1209,validat,validation,1209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,1,['validat'],['validation']
Security,"Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose. I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415:28,validat,validation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415,2,['validat'],['validation']
Security,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,inject,injected,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768,1,['inject'],['injected']
Security,"Hmmm, right so if a boundary condition uses the `discrete_form=true` then it might require access to `state(model)` to fill halos, and if it `depends_on` other fields, then it needs access to them. I agree that we don't want to make invasive changes where fields depend on other fields and fields have extra properties that link to other big objects... It would make the code less modular I think. I think the current field abstraction is pretty lean so it might be nice to avoid bloating it. Would it make sense to add these dependencies in the boundary condition or `BoundaryFunction`? Then filling halos just calls the boundary condition which has immediate access to the state/fields it needs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698403877:91,access,access,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971#issuecomment-698403877,3,['access'],['access']
Security,"Hmmm, yeah I'll close it for now as we haven't discussed it in forever. The way the `Field` abstraction seems to have evolved is that we expose `Field`s to users, but behind the scenes we have to get a little messy and use either the `OffsetArray` or the underlying `Array/CuArray` as needed. Which is fine, as long as the user interface is clean.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676:137,expose,expose,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-525545676,1,['expose'],['expose']
Security,"Hmmm, yeah so the GitLab CI GPU tests always get stuck testing the pressure solvers (which is where we start creating FFT plans) with Julia 1.3+. Was never able to reproduce this on any machine I have access to. Example build logs:; Julia 1.3: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/444576929; Julia 1.5: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/444576930. @maleadt Was wondering if you have any ideas about what's going on? Maybe someone else had similiar issues. I'll isolate exactly which test/line it always gets stuck on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589135055:201,access,access,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589135055,1,['access'],['access']
Security,"However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2482,access,access,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security,"HydrostaticFreeSurfaceModel does (after #3504). ```Julia; julia> model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (4, 4, 4), extent = (1, 1, 1))); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection(); ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; ├── advection scheme:; │ ├── momentum: Centered reconstruction order 2; │ ├── T: Centered reconstruction order 2; │ └── S: Centered reconstruction order 2; └── coriolis: Nothing; ```. but not the shallow-water model. ```Julia; julia> model = ShallowWaterModel(grid = RectilinearGrid(size = (4, 4), extent = (1, 1), topology=(Periodic, Bounded, Flat)), gravitational_acceleration = 1); ┌ Warning: The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation.; └ @ Oceananigans.Models.ShallowWaterModels ~/Research/OC11.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0); ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo; ├── tracers: (); └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3534#issuecomment-2041019715:1250,validat,validation,1250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3534#issuecomment-2041019715,1,['validat'],['validation']
Security,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:575,validat,validate,575,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,1,['validat'],['validate']
Security,"I added a script for looking at coarse, 3D baroclinic adjustment with GM starting with either a gradient in `y` or in `x`: https://github.com/CliMA/Oceananigans.jl/blob/0d04d4014c9ecc06deb158c42a2b3e3cd7699b31/validation/mesoscale_turbulence/coarse_baroclinic_adjustment.jl. It was tricky to get this to work in the first place; it seems we need diffusion to stabilize GM right now. I settled on adding biharmonic diffusivity with a time scale of 10 days. The script computes a mean in the direction perpendicular to the initial gradient. When the gradient is initially in `y`:. https://user-images.githubusercontent.com/15271942/164878441-a0660d6e-3241-4ec4-a473-cf0c65c70fa6.mp4. When the gradient is in `x`:. https://user-images.githubusercontent.com/15271942/164878658-18604606-9374-4008-894e-29ee7e49782a.mp4. From this it seems that the diffusivity is at least doing the right thing (but the stencil may still be non-optimal). We also need to test on a lat-lon grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713:210,validat,validation,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713,1,['validat'],['validation']
Security,"I agree that creating the file when the simulation starts to run is better than the current behavior (I think right now it creates the file as soon as you create the netCDF writer, right?). That still wouldn't allow one to access the file while the simulation is running though, right? I think that's important since we need to check the simulations, etc. Do you have any workarounds for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735428916:223,access,access,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735428916,1,['access'],['access']
Security,I agree with docs changes. But it would disrupt a lot of important ongoing work to remove the `validation` directory from the repo without providing an alternative place / way to collaborate on new features. So I think we should leave the `validation` scripts in the repo and discuss what to do next before removing them.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873160439:95,validat,validation,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873160439,2,['validat'],['validation']
Security,"I agree with these!. I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`. For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673:188,validat,validate,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673,1,['validat'],['validate']
Security,"I also couldn't play the movies in the first comment. I suspect because they were created with `gif(anim, ""movie.mp4"", ...)`. I re-run the validation script and replaced them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410:139,validat,validation,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410,1,['validat'],['validation']
Security,I also improved the validation according to the discussion in #3241.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369,1,['validat'],['validation']
Security,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:112,validat,validation,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,3,['validat'],['validation']
Security,"I am able to run the validatoin example. Unfortunately, it produces `NaNs` after just over an hour. Sigh. Even if I reduce the time step from 20 seconds to 1 second, it still goes unstable at about the same time. I need to look more closely as to why this might be happening. I would share an animation but one hour doesn't seem to be enough time for much to happen so I don't see any changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835:21,validat,validatoin,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835,1,['validat'],['validatoin']
Security,I am happy to say that the `VectorInvariant` formulation yields similar growth rates `0.144` and `0.123`. Given the numerical methods are different I'm not bothered by this difference. They should converge with increased resolution. Any more questions/concerns on this simple validation problem before I return to the global one?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533:276,validat,validation,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533,1,['validat'],['validation']
Security,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:1013,access,access,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,1,['access'],['access']
Security,"I am still learning how to parse the output but this is what I get. ```julia> typeof(results[CenteredSecondOrder]); Array{NamedTuple{(:cx, :grid),Tuple{NamedTuple{(:simulation, :analytical, :L₁, :L∞),Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}},Oceananigans.Grids.RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},0}; ```. Also, I found that I can use map in the following way. ```; julia> c_ana = map(r -> r.cx.analytical[:], results[CenteredSecondOrder]); 0-dimensional Array{Array{Float64,1},0}:; [8.339763449228298e-167, 9.289942488656767e-154, 3.0530062298945994e-141, 2.960041007581741e-129, 8.466874781928682e-118, 7.14502772471784e-107, 1.7788530458865225e-96, 1.3065667360543323e-86, 2.831251796148466e-77, 1.8100091259558352e-68 … 6.525187676003588e-221, 1.7125465800091643e-236, 1.3260110721966124e-252, 3.0290558443461884e-269, 2.0413749536348825e-286, 4.058762655833247e-304, 2.2e-322, 0.0, 0.0, 0.0]; ```. Then I can access the array using `c_ana[1]'. This seems strange to me but I guess this is what I need to be doing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185:1126,access,access,1126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185,1,['access'],['access']
Security,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,2,"['access', 'validat']","['accessing', 'validation']"
Security,"I believe this smells like validation rather than an example. Examples are nice if they are simple yet interesting. This is complicated, but boring (but super useful for validation, obviously!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945,2,['validat'],['validation']
Security,"I believe we also observed bigger speed ups for WENO when it was first implemented. This is plausible because WENO invokes the same memory access pattern as the UpwindBiasedFifthOrder scheme, but has much more compute, which gives the GPU more of an edge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-862808760:139,access,access,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-862808760,1,['access'],['access']
Security,"I can take a stab at literate-ing a version of this validation experiment, although I suggest using scalings appropriate for the deep ocean. I think it would be nice to rework the experiment into something like this [example script](https://github.com/hdrake/internal-tide-mixing/blob/main/internal_tide_replicate-NL2010.jl), in which I essentially reproduce the MITgcm setup used in [Nikurashin and Legg (2011)](https://journals.ametsoc.org/view/journals/phoc/41/2/2010jpo4522.1.xml) and [Yi et al (2017)](https://www.mdpi.com/2311-5521/2/4/55). Here's a video showing the solution for ~20 M2 tidal cycles or so. https://user-images.githubusercontent.com/12971166/210029541-c3ffe93f-b972-491c-90b6-ab4955d99583.mov. Another idea is to do the simulation in the linear limit (very small topography) and validate some of the results with analytical solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694#issuecomment-1367695388:52,validat,validation,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694#issuecomment-1367695388,2,['validat'],"['validate', 'validation']"
Security,I can't re-run the tests but if someone with access can I think this PR should be done?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1511478135:45,access,access,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1511478135,1,['access'],['access']
Security,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902,2,"['access', 'validat']","['access', 'validation']"
Security,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:289,access,access,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,3,['access'],['access']
Security,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:96,validat,validation,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,1,['validat'],['validation']
Security,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468:56,validat,validation,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468,1,['validat'],['validation']
Security,"I copied the output of pgk.status as per your request. The second part comes out when I am running lid_driven_cavity.jl. I run it in VS Codium. ```; julia> simulate_lid_driven_cavity(Re=100, N=128, end_time=15); ERROR: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at REPL[2]:1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183:1336,validat,validation,1336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183,1,['validat'],['validation']
Security,I did not notice this problem. `ShallowWaterModel` (`Flat` in z) works with an `ImmersedBoundaryGrid`. An example can be found in `validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl` . this video is the output. https://user-images.githubusercontent.com/33547697/200380534-7a4832d6-bdb4-4044-a019-d8d57e553e8a.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970:131,validat,validation,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970,1,['validat'],['validation']
Security,I don't think I have access to Sverdrup. Could I get access? I wanted to try to run the test there to see what's happening...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1544978864:21,access,access,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1544978864,2,['access'],['access']
Security,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:357,validat,validation,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,1,['validat'],['validation']
Security,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:199,validat,validation,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,8,['validat'],"['validate', 'validated', 'validation']"
Security,"I don't think we should add a new example for this feature though. Perhaps we can include a script as a reference in `validation`? Another possibility is to include an example in the docstring that sets up the Stokes drift profile described here, which will preserve it for future generations as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507:118,validat,validation,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507,1,['validat'],['validation']
Security,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:704,validat,validations,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444,1,['validat'],['validations']
Security,"I found this in the validation script:; ```Julia; grid = LatitudeLongitudeGrid(size = (12, 14),; longitude = (-180, 180),; latitude = (-30, 30),; z = (0, 0),; halo = (4, 4),; topology = (Periodic, Bounded, Flat)); ```. Hm.... `z = (0, 0)` seems to be crucial! Removing it gives the error I posted above. But with `z`-dimension Flat then `z = (0, 0)` shouldn't be needed. We should fix the `LatitudeLongitudeGrid` constructor accordingly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355,1,['validat'],['validation']
Security,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:406,access,access,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['access'],['access']
Security,"I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!. But you're right that you don't know which input is the problem (only I know that only the grid matters). So yeah, I think some input validation for `grid` would help in the `NonhydrostaticModel` constructor. We only support `RegRectilinearGrid` and `HRegRectilinearGrid`. All other grid types are invalid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778:274,validat,validation,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778,1,['validat'],['validation']
Security,"I guess my opinion is that from an organizational and psychological point of view it makes the most sense to have ""real"" validation experiments and a validation pipeline _when / if_ somebody can take responsibility for maintaining it. At that time, I think that person will be showered with praise, making the job less thankless! I think this is the best strategy in the long run for eventually having legitimate validation experiments. Having them sitting around in a half-baked state could produce the false impression in a future collaborator that such a task does not remain to be done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872406505:121,validat,validation,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872406505,3,['validat'],['validation']
Security,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1108:156,validat,validation,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108,3,['validat'],['validation']
Security,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:1285,access,access,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['access'],['access']
Security,"I have created a branch and started to make changes to use Plots.jl. Attached are some not so excting plots that are the first of many to come. . ![test1](https://user-images.githubusercontent.com/8239041/102254504-ae1d2080-3ed6-11eb-855d-b79131a5a267.png). ![test2](https://user-images.githubusercontent.com/8239041/102254484-a52c4f00-3ed6-11eb-8354-1e0cdb835a30.png). I do have a question on how to do something. If you look in the code [here](https://github.com/CliMA/Oceananigans.jl/blob/1456cc68b0dd559f91d5ca3770bd123ff2f5eb3a/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L65) you will see that I need to put in the advection scheme for this to work. . My next step is to try looking over a couple of schemes, but can't do that using the current syntax. Any advice on what I need to change? The old code just had results, which I would like to have as well, but not sure why it's not working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217:533,validat,validation,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217,1,['validat'],['validation']
Security,"I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. . Some preliminary results are shown below. First, this is the case with a flat bottom and it does produce the same results as what we have in the example. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/3f8cc034-6764-4d3e-a7c1-510d7b55073d). Second, this is an example of prograde topography with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/d262c028-1ea3-41b8-8573-8ab4419ed891). Third, this is an example of retrograde topopgraphy with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/064ebf34-b8bf-4cca-9000-a9edb1bdfd94). The growth rates differ but I want to update my linear stability code to compute the growth rates so that we can validate that the results are quantitatively close. But for this case here the prograde case is slightly more unstable with the rettrograde case, which is qualitatively correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400,2,['validat'],"['validate', 'validation']"
Security,"I have incurred a problem with our `ScalarDiffusivity`, which is exposed in enzyme tests. . The `N` parameter of `ScalarDiffusivity` and `ScalarBiharmonicDiffusivity`, which tells us how large the halo size has to be, was in the wrong position. I tried to fix this problem by switching a couple of parameters around (I need to add a unit test for that before this PR is merged), but this exposed a problem with the constructor that is not type-stable. We can pass any `required_halo_size,` and the resulting type will differ (which is quite fine code-wise but not for auto diff). I have changed the constructor to accept `Val(halo_size_required)` instead of an integer, and this fixes the tests, but I am not completely convinced with this solution (Why would we need to pass `Val(Int)` instead of an integer?). What would the options be here? Completely change where we store the buffer size (quite annoying because it is nice to abstract it away in the parameters of the type)? Is there a way to stabilize the constructor type without doing this hacky change to the UI?. I should probably open an issue so we can discuss this topic. We should not merge this PR until this is solved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2327763947:65,expose,exposed,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2327763947,2,['expose'],['exposed']
Security,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:49,access,access,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991,1,['access'],['access']
Security,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,1,['validat'],['validation']
Security,"I have tried it on by completely removing lateral dissipation but unfortunately it crashes after 165 days of simulation with a time step of 6 minutes. This is the last snapshot I have of vertical vorticity compared to a run that starts at the same initial condition but with lateral dissipation and vector invariant scheme. Indeed the structures are much smaller (probably because of the fact that I completely removed horizontal dissipation, both laplacian and biharmonic for both tracers and velocity). On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. . The positive is that actually, for some weird reason, this scheme is a bit faster! (Maybe it has to do with how it interacts with the implicit solver?). I see a lot of wave propagation when I start the solution, maybe coming from adjustment to a zero-dissipation solution or maybe just because the numerical dissipation is not enough. I am trying to rerun it with a smaller timestep now to allow an adjustment period, maybe it helps? (or maybe the dream of running without explicit lateral dissipation is not attainable :sweat_smile:) . Also, I am _still_ not sure about this formulation on the sphere so trying it like this is kind of a hail Mary (@francispoulin I hope we can make it work on the`ShallowWaterModel` to validate it would be great). In particular I am not sure what to do with `Coriolis`, which we treat separately but I suspect has to be lumped in into the advection formulation. Also, I am not sure I am treating the immersed boundary conditions correctly. ![global](https://user-images.githubusercontent.com/33547697/157757996-da2a42c4-d822-4ab3-a721-82c8e8721ddb.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603:1348,validat,validate,1348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603,1,['validat'],['validate']
Security,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:917,validat,validation,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029,1,['validat'],['validation']
Security,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,2,['validat'],['validation']
Security,"I just thought I'd drop by with my point of view as user and (for now) not a developer. Talking with other people who have tried Oceananigans, the most important thing from our point of view may be the MPI parallelism. I know there is some debate to be had in this topic (I've had a couple discussions with @glwagner myself), but for now my understanding is that it's much easier to have access to CPUs then GPUs. Also if I understand correctly that would allow the model to be run on multiple GPUs, which will allow for some really big simulations resolving a huge array of scales. I bet there's new physics to be found there among the nonlinear interactions between all these scales!. From my point of view (now without talking to other users) #1241 seems like a pretty big issue. It's hard to use Oceananigans if you're not sure you're going to be able to calculate the statistics you need to do your science straightforwardly. For what I want right now it seems like I can use `LESbrary.jl`, but that might not always be the case. I'd definitely put that in the list of issues to be resolved asap. From a user perspective I think #890 is also important. I've suffered the consequences of lack of attention to BCs already and it'd be nice to have the model check those for me. I also think #471 would be nice to have. I agree with @navidcy that it's not a deal breaker, but it would save computation and (if I understand correctly) all the hard work for that has been done already, no?. Anyway, I'm still learning about Oceananigans and might be kind of naive in relation to some of the model's particularities. So please that fact into consideration when assessing my suggestions! . Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452:388,access,access,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452,1,['access'],['access']
Security,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,3,['validat'],['validation']
Security,I like this idea. Although I've never had to access an output writer after pushing it to `model.output_writers` it would be way better to refer to them as `model.output_writers[:profile_writer]` instead of `model.output_writers[2]`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-523430159:45,access,access,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-523430159,1,['access'],['access']
Security,I ll try to produce a profile of `validation/elliptic_solvers/doubly_bounded_poisson.jl` with nsys and post it here,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553:34,validat,validation,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553,1,['validat'],['validation']
Security,"I propose that we develop a type that corresponds to a boundary conditions. I think the following user code will be nice:. ```Julia; ...; surface_flux(x, y, z, t) = F_b * exp(-x^2 / 2L^2) * cos(σ*t); bottom_flux = N^2. top_bc = DirichletBoundaryCondition(:T, :z; :right, surface_flux); bottom_bc = DirichletBoundaryCondition(:T, :z, :left, bottom_flux). model = Model(... bcs=[top_bc, bottom_bc]); ```. (The names of the types are certainly up for debate: we might also have `ConstantDirichletBoundaryCondition` and `VariableDirichletBoundaryCondition`, and either expose it to the user or hide this layer from from the user and use multiple dispatch to parse between user-inputs.). We can propose default boundary conditions that are deployed whenever a boundary condition is not specified.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468249677:565,expose,expose,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468249677,1,['expose'],['expose']
Security,I pushed some minor edits to the validation script.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722:33,validat,validation,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722,1,['validat'],['validation']
Security,"I ran a few tests using the [Bickley Jet](https://github.com/CliMA/Oceananigans.jl/blob/glw-vw/grid-fitted-incompressible-model/validation/immersed_boundaries/immersed_bickley_jet.jl) with an immersed top wall from the validation script. . ### Surface Normal Velocity; We can easily look at the surface normal velocity of the immersed wall (which should be zero) with increased resolution and see that it is converging nicely, as this method should be exact except for the pressure correction, which will scale. ![Bickley_normal](https://user-images.githubusercontent.com/67593861/122986244-2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:128,validat,validation,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,2,['validat'],['validation']
Security,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:708,validat,validation,708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,1,['validat'],['validation']
Security,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:120,validat,validation,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['validat'],['validation']
Security,"I removed that because in master the length of results is just 1, so there is nothing to look over. . In `one_dimensional_gaussian_advection_diffusion.jl` at this [line](https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/one_dimensional_gaussian_advection_diffusion.jl#L46) it forms all_results by combining different results and I don't believe that I do that in this code. I just have their version of advection_results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196:257,validat,validation,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196,1,['validat'],['validation']
Security,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:693,access,access,693,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,1,['access'],['access']
Security,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:90,access,access,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875,1,['access'],['access']
Security,I sent a flurry of updates once I had the validation case coded up! It should work now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314,1,['validat'],['validation']
Security,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:877,access,access,877,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,1,['access'],['access']
Security,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:614,access,access,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,1,['access'],['access']
Security,"I think 100% coverage is noble and worthy. Probably there's some functions we can delete (rather than adding tests for everything). For physics I suppose we review validation tests + literature. I think we want to be ""well-validated"", rather than putting a number like 100% on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1100#issuecomment-716550484:164,validat,validation,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1100#issuecomment-716550484,2,['validat'],"['validated', 'validation']"
Security,"I think I actually never posted the result. It is wrong (the ocean is not barotropic) but it is sure mesmerizing. https://user-images.githubusercontent.com/33547697/226215545-c6f34133-6ce4-456c-8430-4f2ced3587eb.mp4. > > There is one that does a one-level near global ocean on a latitude-longitude grid. (in the near_global validation folder); > > I haven't tried this particular script before; > ; > but that's not shallow water... sorry, wrong folder:; https://github.com/CliMA/Oceananigans.jl/blob/main/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475429283:324,validat,validation,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475429283,2,['validat'],['validation']
Security,"I think a new type would reduce confusion. Right now `ConstantIsotropicDiffusivity` is fine as it's both constant in time and space, but could be confusing if it's just constant in time. `SpatiallyVaryingIsotropicDiffusivity` is a bit of a mouthful, but being verbose is probably better than having the user guess or have them continuously checking the documentation. > Also, I am realizing that we want to do this with functions rather than arrays. Arrays can always be implemented via a function that accesses a `const` array anyways, but would be good to benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531226496:503,access,accesses,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531226496,1,['access'],['accesses']
Security,"I think a single `advection` kwarg would make for a cleaner UI, since there are already lots of model kwargs. I agree it's a bit messier to parse and validate but the parsing and validation can be done by small functions in a separate file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031:150,validat,validate,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031,2,['validat'],"['validate', 'validation']"
Security,"I think a slow down for small models, speed up for large models makes sense given that this PR splits one relatively large kernel into three smaller ones (two times). Seems like an acceptable trade off to me (and also nearly unnoticeable). Why are the validation experiments failing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736700405:252,validat,validation,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736700405,1,['validat'],['validation']
Security,"I think its correct that `Periodic` boundary conditions have `condition=nothing`. . Shouldn't we fill halos in all 3 directions? That way everything is neat and simple and there's no special directions. It will also allow us to easily implement `Periodic` in the z direction at some point in the future, which may be useful for both science and validating the model against established results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066:345,validat,validating,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066,1,['validat'],['validating']
Security,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305,4,['validat'],['validation']
Security,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:218,validat,validation,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603,1,['validat'],['validation']
Security,I think the disadvantage of using artifacts is that we are a bit more exposed to bugs and I think that's the cause of at least some of our pain here. The advantage is that it's less work to maintain our local CUDA software and our test environment might be more realistic / relevant since users typically use artifacts (I think).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872395555:70,expose,exposed,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872395555,1,['expose'],['exposed']
Security,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:557,access,access,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,1,['access'],['access']
Security,I think the latitude range validation should occur regardless of topology... right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358,1,['validat'],['validation']
Security,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:615,validat,validation,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['validat'],['validation']
Security,I think these are the only two instances. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/validation/immersed_boundaries/cylinder_flow_with_tracer.jl#L243-L250. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/validation/near_global_lat_lon/cyclic_interpolate_utils.jl#L18-L30,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1372326567:129,validat,validation,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1372326567,2,['validat'],['validation']
Security,"I think these lines should be using `ξnode`, `ηnode`, and `rnode`:. https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L136-L142. I'll open a PR with a fix tomorrow. Should probably also add a test for particle advection on a lat-lon grid. ---. Some debug printing inside `advect_particle` with 1 particle:. ```; [ Info: Iteration 1...; [ Info: X=(1.0, -1.5, -10.0), I=(47, 109, 53); [ Info: (before) X⁺=(1.0, -1.5, -10.0); (iᴿ, jᴿ, kᴿ) = (101, 201, 61); (xᴸ, yᴸ, zᴸ) = (87813.63270401207, -217942.05622333512, -100.0); (xᴿ, yᴿ, zᴿ) = (136722.49142523398, -124538.3178419058, 0.0); (x⁺, y⁺, z⁺) = (175626.26540802413, -249075.1356838116, -10.0); [ Info: (after) X⁺=(175626.26540802413, -249075.1356838116, -10.0); [ Info: Iteration 2...; [ Info: X=(175626.26540802413, -249075.1356838116, -10.0), I=(39914880, -59303137, 53); ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528:975,access,access,975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528,1,['access'],['access']
Security,"I think this is a better MWE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid);. julia> view(model.free_surface.η, :, :, 2:2); ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [1:9, 1:9, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:734; [2] checkbounds; @ ./abstractarray.jl:699 [inlined]; [3] view; @ ./subarray.jl:179 [inlined]; [4] offset_windowed_data(data::OffsetArray{Float64, 3, Array{…}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{…}, OffsetVector{…}, OffsetVector{…}, CPU}, indices::Tuple{Colon, Colon, UnitRange{…}}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::Function, j::Function, k::UnitRange{Int64}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:316; [6] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. We should be able to call `view(model.free_surface.η, :, :, 2:2)` since the free surface is a windowed field with vertical indices `2:2` (the index slice corresponding to the top surface of the model...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852:276,access,access,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852,1,['access'],['access']
Security,I think this is resolved. You just define a const array and the forcing function accesses it. See https://github.com/climate-machine/Oceananigans.jl/issues/110#issuecomment-470556414. Although might make sense to benchmark this. X-Ref: #370,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-525551621:81,access,accesses,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-525551621,1,['access'],['accesses']
Security,I think this might make a nice validation test!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-642048709:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-642048709,1,['validat'],['validation']
Security,"I think we can hide GPU 0. I suspect the tartarus CPU is much faster. This problem only arose because I exposed GPU 0 to the docs build. . The slurm stuff is just maintained by us, so if we are all professionals, we are professionals...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356625573:104,expose,exposed,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356625573,1,['expose'],['exposed']
Security,I think we can merge now. Maybe it'd be nice to have the realistic case in a similar file as `one_degree_setups/idealized_near_global_one_degree.jl` (if it isn't there already)?. https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/near_global_lat_lon/one_degree_setups/idealized_near_global_one_degree.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105:255,validat,validation,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105,1,['validat'],['validation']
Security,I think we can't move forward with this until we have a working validation script that uses it. So let's wait until #3306 is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850,1,['validat'],['validation']
Security,"I think we should delete the regression test and put a warning in the model constructor ""The ShallowWaterModel has not been validated"". It's a shame we've put so much time into the regression test as it is. I think the model likely has a few bugs to be ironed out. I'm also not convinced that we have all the numerical methods (ie vanishing layers, positive preserving advection) that would be needed to advertise the model as ""production-ready""). One could argue that the regression test is misleading in that it gives the false impression that the model is in a state that shouldn't change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100:124,validat,validated,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100,1,['validat'],['validated']
Security,I think we should just remove these validation experiments since we have ClimaOcean now...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689,1,['validat'],['validation']
Security,"I tried to create a lat-lon grid that is flat in `z` but got this... ```Julia; julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; Stacktrace:; [1] getindex(A::Vector{Any}, i1::Int64); @ Base ./array.jl:805; [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```. @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094:246,access,access,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094,1,['access'],['access']
Security,"I tried to use CUDA's [`compute-sanitizer`](https://cuda.juliagpu.org/stable/development/debugging/#compute-sanitizer) to debug the memory issue, but couldn't get anything useful out of it so I went back to debug print statements lol. I printed out the value of `maximum(CuArray(randn(100)))` which should error after the illegal memory access occurs. So I peppered these statements around to try and find where the error happens. The issue happens somewhere here:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L246-L252. Adding. ```julia; κu★ = convert(eltype(grid), κu★); κc★ = convert(eltype(grid), κc★); κe★ = convert(eltype(grid), κe★); ```. causes the MWE to work, which is weird because `@show` on the CPU tells me that they are `Float32` anyways. And I'm not sure on the GPU because `@cushow` can't show strings. Commenting out. ```julia; # κu★ = mask_diffusivity(i, j, k, grid, κu★); # κc★ = mask_diffusivity(i, j, k, grid, κc★); # κe★ = mask_diffusivity(i, j, k, grid, κe★); ```. also causes the MWE to work. I haven't been able to isolate the problematic line/operation yet. And as far as I can tell, the code used to compute `κuᶜᶜᶠ`, `κcᶜᶜᶠ`, and `κeᶜᶜᶠ` is all type-safe. Will continue later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361:32,sanitiz,sanitizer,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361,3,"['access', 'sanitiz']","['access', 'sanitizer']"
Security,"I used `validation/mesoscale_turbulence/baroclinic_adjustment.jl` but I reduced the grid size. The big problem of main is the implicit solver, so if you don't use it you see only the difference given by the tracer tendencies, which is smaller. The results above, however, are obtained using exactly the same code you posted (on a mac M1 with one thread though, you use 6, so maybe that is the root cause of the difference)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133,1,['validat'],['validation']
Security,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:289,validat,validation,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857,1,['validat'],['validation']
Security,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/ep/pcg-with-multigrid/validation/elliptic_solvers/testing_preconditioner.jl)). When the initial guess is all 0s the precondition! method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here ](https://www.netlib.org/templates/templates.pdf)so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2655:270,validat,validation,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655,1,['validat'],['validation']
Security,I was trying to run `validation/immersed_boundaries/flow_over_hills.jl` and all simulations except the ref one are NaNing pretty quickly. On `main` it works!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528946599:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528946599,1,['validat'],['validation']
Security,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355:506,validat,validation,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355,1,['validat'],['validation']
Security,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:109,access,access,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,1,['access'],['access']
Security,"I went back to check your script and you should not expect NaNs in this simulation.; The model is initiated only with a u-velocity which is constant in x, there are no x-gradients, the grid is periodic in x and there are no boundary conditions nor viscosity that could affect the velocity field, thus the flow field is steady, and would not change also with much higher CFL numbers.; There are no tracers, so no possible NaNs there as well. Particles are lagrangian, they cannot NaN because they do not undergo numerical instability, the only thing that can happen is that they are shot in the x direction way beyond the periodic x-domain which will understandably produce out-of-bounds results when trying to interpolate the location in the grid. I believe that If you find NaNs there is a bug because that simulation should not produce any. You can set debugging level 2 in the Julia invocation (`julia -g2 --check-bounds=yes`) to have access to a more detailed stack trace on the GPU. ; https://cuda.juliagpu.org/stable/development/debugging/; Note that you need CUDA version 11.5 or higher to have access to a detailed stack trace",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998:938,access,access,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998,2,['access'],['access']
Security,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:314,validat,validation,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['validat'],['validation']
Security,"I wrote some validation scripts and I think the model is working, but I'd appreciate some feedback. First, this animation shows two 3D decaying turbulence simulations, one with `SmagorinskyLilly` and another with the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us her",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,2,['validat'],['validation']
Security,"I""m going to shift this fork to a personal account so that I can enable push access. This will require me to close this PR in favor of that one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936996887:77,access,access,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936996887,1,['access'],['access']
Security,"I'd be in favor of always emitting a warning for `ImmersedBoundaryCondition` that it's experimental (no published papers, few validation tests)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377,1,['validat'],['validation']
Security,"I'd like to resurrect this issue. We've implemented 5, but we don't have callbacks. I think we should just add a callback layer to `Simulation` to replace `simulation.progress` and address whether diagnostics should become callbacks later. The key change is that `iteration_interval` would no longer be an argument to `Simulation`. Instead we would refactor all the examples and validation tests to implement logging and adaptive time stepping via callbacks. Because of that this ends up being a big API change. A barebones callback feature might be. ```julia; struct Callback{F, S}; func :: F; schedule :: S; end; ```. Usage would be something like. ```julia; progress(sim) = println(""Iteration $(sim.model.clock.iteration)""); progress_printer = Callback(progress, schedule = IterationInterval(100)). wizard = TimeStepWizard(cfl=0.1, initial_dt = 2minutes, schedule = IterationInterval(10)). simulation = Simulation(model, stop_time=2hours, callbacks = [progress_printer, wizard]); ```. In other words, the `TimeStepWizard` becomes a callback with a schedule, and we can print progress and adapt the time step on different schedules. What do people think about this API?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721:379,validat,validation,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-881904721,1,['validat'],['validation']
Security,"I'm a bit confused, I managed to solve the issue by changing manually the grid passed to `output_indices` at:; https://github.com/CliMA/Oceananigans.jl/blob/e243e5b44ea0c4570ae427bdce1d68dc29594f24/src/OutputWriters/output_construction.jl#L32-L42; For example, in the example provided by @navidcy:; ```; julia> size(grid); (5, 5, 4); ```; That is passed to the `output_indices` function that outputs the indices `(1:5, 1:5, 1:5)` or `(4:8, 4:8, 4:8)` once the halos are taken into account. ; The way I managed to save $\eta$ in a hacky way was by changing the `size(grid)` to (5, 5, -1), so it outputs the surface index in `z`, since the `size(eta)` is `(5, 5, 1)`; My two ideas on how to fixing this are:; - Rather than using the `size(grid)`, use `size(output)`, however using `size(eta)` still crashes, since it try to access the indexes `(4:8, 4:8, 4:5)` rather than `(4:8, 4:8, 1:0)`; - Check if there is a `Face` in the `z` direction of the `location(output)`, and then force the last index to be `-1`. . Before I do any of this changes, I don't understand how are the halos (applied in all directions) implemented in a surface such as $\eta$? I guess the same will apply to any flux at the surface right? . Do you have any other way to fix this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651:822,access,access,822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651,1,['access'],['access']
Security,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:801,access,access,801,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['access'],['access']
Security,I'm fine with that too... so something like. ```julia; if q == 0; return zero(FT); else; ...; end; ```. We were lead to believe that `ifelse` is faster on the GPU --- any concerns about that here? Presumably GPU cycles are cheap (but memory accesses are not as long as we aren't using shared memory...),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/335#issuecomment-519085204:241,access,accesses,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/335#issuecomment-519085204,1,['access'],['accesses']
Security,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:145,access,access,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['access'],['access']
Security,I'm going to clean up the validation experiments for the new syntax and then this is ready.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879853229:26,validat,validation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879853229,1,['validat'],['validation']
Security,"I'm going to try and put some some into this, but I'm a bit unsure of what to do. First, to summarize what the current state on `main` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:507,access,accesses,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,2,['access'],['accesses']
Security,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2450:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450,1,['validat'],['validation']
Security,"I'm trying to add some particles to a hydrostatic model on a lat-lon grid, but ran into some CUDA memory issues. After reducing down to a MWE I noticed that it also segfaults on the CPU. The MWE seems to be sensitive to the exact grid. Some lat-lon ranges lead to illegal memory accesses and others do not. I could not find a pattern though. On the CPU the segfault seems to occur after ~2 iterations. On the GPU after ~29 iterations. The particles are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:279,access,accesses,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['access'],"['access', 'accesses']"
Security,"I'm trying to run the near global shallow water model and having difficulties with the latitude longitude grid. The line that calls it is here. https://github.com/CliMA/Oceananigans.jl/blob/5ba82e5786d1b7725d6bfa3e45072d2f6fad487a/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl#L95. And the error that I get is the following,. ```; julia> include(""near_global_shallow_water_quarter_degree.jl""); ┌ Warning: Over-writing registration of the datadep; │ name = ""quarter_degree_near_global_lat_lon""; └ @ DataDeps ~/.julia/packages/DataDeps/Y2lje/src/registration.jl:15; ERROR: LoadError: UndefVarError: `Nλ` not defined; Stacktrace:; [1] validate_lat_lon_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, latitude::Tuple{…}, longitude::Tuple{…}, z::Nothing, precompute_metrics::Bool); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:257; [2] LatitudeLongitudeGrid(architecture::GPU, FT::DataType; size::Tuple{…}, longitude::Tuple{…}, latitude::Tuple{…}, z::Nothing, radius::Float64, topology::Tuple{…}, precompute_metrics::Bool, halo::Tuple{…}); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:189; [3] macro expansion; @ show.jl:1181 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; [5] include(fname::String); @ Base.MainInclude ./client.jl:489; [6] top-level scope; @ REPL[70]:1; [7] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; Some type information was truncated. Use `show(err)` to see complete types.; ```. Should the lat-lon grid be able to handle flat in the vertical? @simone-silvestri, maybe this is something you tried to fix the last time we chatted?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275:231,validat,validation,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275,3,['validat'],['validation']
Security,I'm trying to run the script `validation/elliptic_solvers/doubly_bounded_poisson.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139068720:30,validat,validation,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1139068720,1,['validat'],['validation']
Security,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:14,validat,validate,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['validat'],['validate']
Security,"I've been looking at a coastal upwelling model with an analytical solution ([Estrade *et al.*, 2008](https://elischolar.library.yale.edu/journal_of_marine_research/207/)'s Equation 15, plotted below) that could be a good candidate for an immersed boundary validation test. It is an extension of Ekman's classical 1D solution to a simple 2D planar slope ($x-z$) geometry:. ![EMVR08_analytical](https://github.com/CliMA/Oceananigans.jl/assets/4955404/5a8775df-3887-4503-af87-0bbca795e6f7). Estrade *et al.* test this with a 2D ROMS implementation (their Figure 10) that I've tried to replicate in Oceananigans:. ![compare_EMVR08-analytical-numerical](https://github.com/CliMA/Oceananigans.jl/assets/4955404/c17b41e9-cb0c-463a-9bae-d418ab30e007). The discrepancy is mostly in the BBL, so I'm wondering if cut cells (#3146) would improve it. But I'm also not sure if I'm prescribing bottom friction correctly at the immersed boundary (see code below run in Oceananigans v0.91.0). Any thoughts?. ```julia; using Oceananigans; using Oceananigans.Units; using Printf. Lx = 200kilometers; dx = 100meters #200meters#500meters; hmin = 4meters; slope = 1e-3. D = 50meters; f = 3.8145e-05 # At ~15N. dz = 2meters #4meters. Ti = 2π/f; Av = f*(D/π)^2/2; @info @sprintf(""Ti: %.1f h"", Ti/3600); @info @sprintf(""Av: %1.3e m2/s for D = %d m"", Av, D) # Av = 4.831e-3 m2/s, D = 50 m, lat = 15N in Estrade et al. (2008). te = 4Ti #10Ti; outdt = Ti/10; fout = ""upwelling2Dhomog.nc"". logdt = outdt#Ti/100; maxcfl = 0.7. H = hmin + slope*Lx; Nx = Int(ceil(Lx/dx)); Nz = Int(ceil(H/dz)). underlying_grid = RectilinearGrid(CPU(),; size=(Nx, Nz), halo=(3, 3),; x = (-Lx, 0),; z = (-H, 0),; topology=(Bounded, Flat, Bounded)). h(x) = hmin + slope*x; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(h)). τx₀ = 0 # [Pa]; τy₀ = -0.1 # [Pa]; ρ₀ = 1025 # [kg/m3]; r = 5e-3. Twind = Ti/2 # Wind ramp-up timescale. τx₀ = τx₀/ρ₀; τy₀ = τy₀/ρ₀. # Boundary conditions (wind stress and bottom friction).; @inline wind_stress_u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906:256,validat,validation,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906,1,['validat'],['validation']
Security,I've been meaning to raise this issue for a while. I think we export too many names. We should figure out which names truly need to be dumped into users namespaces' when `using Oceananigans` is written. . Users can easily access non-exported names via `Oceananigans.name` or `using Oceananigans: name`. This does not affect functionality; it's mainly a good-scripting-practice issue.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/364:222,access,access,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/364,1,['access'],['access']
Security,"I've been playing around with the `immersed_couette_flow.jl` validation experiment and think I discovered a bug in the immersed boundaries implementation which causes non-immersed boundary conditions to be ignored. The BCs specified are here:; https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/validation/immersed_boundaries/immersed_couette_flow.jl#L16-L23. It is clear from the movie produced by the script that the flow adjusts to the immersed value BCs of u(0.1)=1 and c(0.1)=1 but does not adjust to meet the top BCs of u(1)=-1 and c(1)=-1. https://github.com/CliMA/Oceananigans.jl/assets/12971166/fb6ac2a8-7081-4edf-b363-87850b47fc6a. I ran into the same problem when adding an immersed boundary to the `horizontal_convection.jl` experiment. Adding an immersed boundary invalidated the surface buoyancy forcing, even when no `immersed` boundary condition was explicitly specified. Has anyone run into this issue or know what might be going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208:61,validat,validation,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208,2,['validat'],['validation']
Security,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144:880,access,access,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144,1,['access'],['access']
Security,"I've changed things a bit in response to your suggestions. Mainly, the structs and fieldsets to checkpoint can be specified through the `Checkpointer` constructor. If an incompatible struct is provided, e.g. `:forcing`, an exception is raised. Validation only occurs in the constructor so no need for if-statements and warnings anywhere else. @glwagner Lemme know if this looks okay to merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524075400:244,Validat,Validation,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-524075400,1,['Validat'],['Validation']
Security,"I've now added some validation scripts that seem appropriate for realistic use cases. First, as a classic CFD example we have flow around a cylinder with prescribed flow on one side and no gradient in the wall-normal flow on the other, this works quite well:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/e3c13b81-b5d9-4fda-81b5-900013d566fa. Adding to this, as a case where we know what the flow is doing ""outside"" the domain, the flow now oscillates sinusoidally. We could do the same as above and prescribe this on both the boundaries:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/116344f5-699a-4af1-a47c-3d4fd9b65975. but when the flow is out of the domain this causes oscillations as interior perturbations hit the boundary. To reduce the oscillations we can instead say that there should be no wall-normal velocity gradient and relax to the prescribed flow (so the boundary point is some mix of information from the prescribed and interior flows):. https://github.com/CliMA/Oceananigans.jl/assets/26657828/09668bb2-adf5-4529-bad6-6c8c484ac3e9. For all the plots isolines of vorticity are shown in the whole domain. CC: @tomchor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2197735344:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2197735344,1,['validat'],['validation']
Security,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:186,access,access,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296,1,['access'],['access']
Security,"Ideally the user would just define an element-wise function `closure(..., i, j, k)` that gets passed to the model and is added to the velocity or tracer source terms, acting as a forcing term in the momentum and tracer advection equations. Defining an element-wise function will allow the function to be injected into CPU and GPU kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73:304,inject,injected,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73,1,['inject'],['injected']
Security,"If I want to test out multi-region nonhydrostatic simulations on a GPU cluster with immersed boundaries, is my best bet to start from [validation/multi_region/multi_region_les.jl](https://github.com/CliMA/Oceananigans.jl/blob/ss/multi-region-nonhydrostatic/validation/multi_region/multi_region_les.jl) in this PR and just add something like ; ```julia; grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBottom(bump)); mrg_with_bump = MultiRegionGrid(grid_with_bump, partition=XPartition(2), devices=(0, 1)); ```; from the hydrostatic multi-region internal tide validation to include immersed boundaries?. Like @mmr0, this is pretty much what I've been waiting for to go all in on Oceananigans 💯",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1366766961:135,validat,validation,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1366766961,3,['validat'],['validation']
Security,"If we are going to update this example, it's probably better to use `ImmersedBoundaryGrid` like in the other immersed boundary validation experiments...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871637524:127,validat,validation,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871637524,1,['validat'],['validation']
Security,Illegal memory access on CPU and GPU with `LagrangianParticles` + `HydrostaticFreeSurfaceModel` + `LatitudeLongitudeGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:15,access,access,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,"Implements callbacks between sub-steps as described in #2772 . I chose to add them to the model since that is the only part of the simulation they have access to when they run, and went with using the same `Callback` constructor so that parameters can still be passed to the functions despite the fact that whatever the specified schedule they have to run at every sub-step.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773:152,access,access,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773,1,['access'],['access']
Security,"In #1648 we introduced a script to show the convergence rates for the difference advection schemes. I just tried it and sadly it now gives bad results. I will workon fixing this. Also, it is probably a good idea to mention this in the docs in `Validation experiments`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1739:244,Validat,Validation,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1739,1,['Validat'],['Validation']
Security,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:198,validat,validation,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,3,['validat'],['validation']
Security,"In for `MultiRegionField`s, we often forced to do, e.g.,. ```julia; for region in 1:number_of_regions(grid); u[region] .= - ∂y(ψ[region]); v[region] .= + ∂x(ψ[region]); end; ```. We'd like to be able to simply do:. ```Julia; u .= - ∂y(ψ); v .= + ∂x(ψ); ```. See, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/validation/multi_region/cubed_sphere_tracer_advection.jl#L59-L69. cc @siddharthabishnu, @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577:357,validat,validation,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577,1,['validat'],['validation']
Security,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039,3,['validat'],['validation']
Security,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:71,access,access,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,3,['access'],['access']
Security,"Incorrect behavior results if, for example, a `NormalFlow` boundary condition is applied to a tracer or non-wall-normal velocity component. Conversely, only the `NormalFlow` boundary condition type is correct for a wall-normal velocity component. We may want to validate the boundary condition types in the constructors for `XFaceField`, `YFaceField`, `ZFaceField`, and `CellField`. I think this might save some users a bit of pain.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/890:262,validat,validate,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/890,1,['validat'],['validate']
Security,"Indeed, I think the fact you do not have an out-of-bounds access error is connected to the @inbounds flag. ; With regards to the second problem, I think it might be more consistent to have the correct ""displaced"" indices in `interior` refer to the valid data chunk instead of the index starting from 1. We need a PR to address this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2152732303:58,access,access,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2152732303,1,['access'],['access']
Security,"Indeed, the lines referenced in the error attempt to access `model.auxiliary_fields`, which, as the error states, is not a property of `ShallowWaterModel`:. ```julia; masking_events = Tuple(mask_immersed_field!(field) ; for field in merge(model.auxiliary_fields, merge(model.solution, model.tracers))); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843550186:53,access,access,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843550186,1,['access'],['access']
Security,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:1088,access,access,1088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['access'],['access']
Security,Input validation for stretched grid dimensions breaks `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2588:6,validat,validation,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2588,1,['validat'],['validation']
Security,"Inspired by #1477 , I think it's worthwhile to add `norm` to supported functions, which will allow users to access it more easily on CPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1479:108,access,access,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1479,1,['access'],['access']
Security,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:826,access,accessible,826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,1,['access'],['accessible']
Security,"Is it so hard to update the validation scripts too? Hopefully that should be easy and it doesn't really matter what you do first. We use the validation scripts to test the user interface. You'll be changing them no matter what, in either case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357:28,validat,validation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357,2,['validat'],['validation']
Security,"Is there any syntax change need to be made in . https://github.com/CliMA/Oceananigans.jl/blob/jsw/different-velocities/validation/lagrangian_particles/particles_in_convection.jl. I'm actually thinking now that if the name of the module didn't change, moving the module from `LagrangianParticleTracking` to `Models.LagrangianParticleTracking` might not imply any syntax change _given_ that the module name is exported. @glwagner?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533796569:119,validat,validation,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533796569,1,['validat'],['validation']
Security,Issue with out-of-bounds access and windowed field indexing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:25,access,access,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['access'],['access']
Security,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:748,validat,validated,748,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['validat'],['validated']
Security,"It might be good to add divergence and tracer budget calculations to either a validation or a test, no? What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2892#issuecomment-1414117039:78,validat,validation,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2892#issuecomment-1414117039,1,['validat'],['validation']
Security,"It might be possible to use one of the more complex validation tests like the forced flow, fixed slip convergence test on a vertically stretched grid for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1806#issuecomment-872633972:52,validat,validation,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1806#issuecomment-872633972,1,['validat'],['validation']
Security,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:634,access,access,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,2,['access'],['access']
Security,"It was indeed designed just to provide convenient access to all `FieldTimeSeries` from one JLD2 file. This assumption could of course be relaxed as `FieldDataset` doesn't rely on `grid` or `times`, but this is how I've been using it. Same with JLD2 files for me. Surface fields get one file, 3D fields another, zonal slices another, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3859#issuecomment-2436176256:50,access,access,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3859#issuecomment-2436176256,1,['access'],['access']
Security,It would be really cool to put some viz in the docs. Could add a validation test just for the grid to `validation` perhaps with viz in it too (perhaps as a stop gap if there isn't time to whip up nice docs).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174:65,validat,validation,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-788891174,2,['validat'],['validation']
Security,"It would probably make sense to have a structure called `ImmersedBoundaryFlux`. If so, we will not have to expose `ImmersedBoundaryCondition`. What matters to me is that the integral of the flux over the ocean bottom (or any surface) should be easy to calculate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1589814346:107,expose,expose,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1589814346,1,['expose'],['expose']
Security,"It's a bit hard to tell what's gone wrong here at this point. I'd do something like; * Create a local branch with `git branch logging_orig $some_hash_or_branch_name` or something to keep this safe. If you've lost the original branch or hash name, don't panic (and don't delete your .git directory)! You can use `git reflog` to find it again.; * Create and check out another local branch as a work in progress `git checkout -b logging_wip logging_orig`; * Squash your changes with `git rebase -i` on `logging_wip` branch into a single commit.; * Reset your master (this PR) to the new rewritten upstream master `git checkout master; git reset --hard origin/master` (presuming origin is `git@github.com:climate-machine/Oceananigans.jl.git`); * Cherry pick the single commit from `logging_wip` onto this new master with `git cherry-pick logging_wip`.; * Force push your new master up to this pull request. (By the way, this would probably be clearer for you if you'd made the original pull request off a branch rather than your master branch. Generally that's a good idea, especially if you want to do multiple PRs)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496:236,hash,hash,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496,1,['hash'],['hash']
Security,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:170,access,access,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277,1,['access'],['access']
Security,It's actually a bit different than the example code in the first post. There are some oddities in there that might deserve tweaking. It also has `architecture=GPU()`. If you improve the validation definitely open a PR!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867916110:186,validat,validation,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867916110,1,['validat'],['validation']
Security,"It's just a small detail... if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`. . This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately). So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611:677,access,access,677,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084711611,1,['access'],['access']
Security,"It's not trivial for us to use the same kind of biharmonic diffusion as MITgcm (because MITgcm scales with grid factors and time-step somehow) -- are we sure that's the same too? It looks like it might not be:. https://github.com/CliMA/Oceananigans.jl/blob/990df6a9165413468475aa37035416e8044a9937/validation/mesoscale_turbulence/modified_baroclinic_adjustment.jl#L44. @simone-silvestri knows some of these finer details. I think we can pull the ""MITgcm-like"" biharmonic implementation from the 1 deg setup and use it here. Maybe we should actually formalize that to make these comparisons easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1111148813:298,validat,validation,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1111148813,1,['validat'],['validation']
Security,"It's ready @navidcy . @francispoulin right, that's why it's so hard to understand the problem. It only fails intermittently. We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor. Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498070654:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498070654,2,['validat'],['validation']
Security,"I’m fine with using arrays. However, we probably don’t want to write code that assumes anything about grid spacing at the boundaries. In other words, i think we should write our algorithm so that the spacing of halo cells is accessed explicitly, rather than assumes to be equal to the spacing of cells just inside the boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/531#issuecomment-553984173:225,access,accessed,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/531#issuecomment-553984173,1,['access'],['accessed']
Security,"JuliaGeo also hosts. https://github.com/JuliaGeo/NetCDF.jl. ( but not https://github.com/Alexander-Barth/NCDatasets.jl ). On Fri, Mar 22, 2019 at 11:07 AM Ali Ramadhan <notifications@github.com>; wrote:. > Zarr looks interesting! Sounds like we'd need a good internet connection; > (e.g. on Google Cloud) but might be cool for accessing datasets over; > OpeNDAP (can it do that?) or saving tons of data to a cloud storage bucket.; > We could easily play around with a Zarr output writer on a branch (could; > try ZarrNative.jl or the python implementation with PyCall).; >; > And no, we haven't talked with JuliaGeo. Seems like it's a more GIS; > oriented organization, but could be helpful to get in touch with @yeesian; > <https://github.com/yeesian>.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/145#issuecomment-475656904>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ADXx4PcRnv_wD0UOkskOPbrlShGP5Npjks5vZPGugaJpZM4cBlZJ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475665141:327,access,accessing,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475665141,1,['access'],['accessing']
Security,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44:36,access,accessing,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44,2,['access'],"['accessed', 'accessing']"
Security,"Just a few final details regarding the tests. Also the name ""update_lagrangian_particles!"" keeps confusing me, its hard to remember the difference between ""updating particles"" and ""updating particle properties"". Maybe `step_lagrangian_particles!` is a better name for that function (which is defined by `TimeSteppers`). There's also some stray stuff in the tests and validating that I'd rather get cleaned up before mergin, since it'll have to be cleaned up by ""someone"" sooner or later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1568530147:367,validat,validating,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1568530147,1,['validat'],['validating']
Security,"Just a note on this PR: It's kind of hacky but to avoid images and videos taking up space in git history (they take up a lot!) I'd advocate for uploading images into an issue (effectively hosting them on GitHub's servers) and then linking/embedding them. In an ideal world the validation experiment CI pipeline would run and produce figures for all validation experiments which would then be automatically embedded into the docs with every version release. But setting up this infrastructure would take time and effort which I suspect no one can spare right now. Unfortunately it's a thankless job haha. > We try to fix this issue and keep the validation experiments and benchmarks up-to-date. I've always wanted to do this and wish I had the time to do it... This was the original motivitation for setting up the validation experiment CI pipeline: https://buildkite.com/clima/oceananigans-validation-experiments. It only runs the convergence tests right now and it still runs every night but it's been neglected so stuff is failing. I personally think we should be reviving the validation experiments one-by-one starting with the most important ones by running them as part of that CI pipeline and fixing it when it fails. But without the ability to dedicate the time I can see why reducing our maintenance burden would be desirable. I've also always wanted to set up a benchmarking CI pipeline, but I don't think we have the proper computational resources to set it up right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226:277,validat,validation,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226,6,['validat'],"['validation', 'validation-experiments']"
Security,Just bumping version to 0.30.0 now that you need to use SeawaterPolynomials.jl to access `TEOS10` (a breaking change).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/750:82,access,access,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/750,1,['access'],['access']
Security,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:212,access,access,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['access'],['access']
Security,"Just found this issue while setting up a `ShallowWaterModel` experiment with nonzero `bathymetry`. Implementing this involves modifying `src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl` to include the terms associated with bathymetric gradients in `x_pressure_gradient` and `y_pressure_gradient`, correct? What else would be needed? I would be happy to help write a validation test case and/or an example for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114340276:382,validat,validation,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114340276,1,['validat'],['validation']
Security,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2506:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506,1,['validat'],['validation']
Security,"Just some restructuring of the `fill_halo_regions!` to allow the application of `apply_regionally!` to the directional fill_halo.; The `fill_halo_regions!` looks like this; ```; halo_tuple = permute_boundary_conditions(boundary_conditions); ; for task = 1:3; barrier = device_event(arch); fill_halo_event!(task, halo_tuple, c, loc, arch, barrier, grid, args...; kwargs...); end; ```; this should actually not change the performance... but I guess it will change completely since we will not want a loop over halo events anymore, neither to permute BCs.; There are differences in the `HydrostaticFreeSurfaceModel` where I lumped all the `fill_halo_regions` together and exposed a little bit of parallelism, and in the `QuasiAdamsBashforthTimeStepper` which might affect the `NonhydrostaticModel` benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545:669,expose,exposed,669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545,1,['expose'],['exposed']
Security,"Just take a step back. We had a working system until we exposed the GPU. I did that as an experiment and added the quick start example. Now, if the experiment isn't working, let's revisit it. Moving the docs to caltech is a nuclear option. If it gives us speed up --- great. That's a good reason. But if it's just for the GPU issue, it makes no sense. It's like we tried to experiment with a new vegetable in our pasta sauce, didn't like the vegetable, and decided to stop eating dinner altogether as as result. It's not logical.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356634967:56,expose,exposed,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356634967,1,['expose'],['exposed']
Security,Keeping validation script up-to-date,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,1,['validat'],['validation']
Security,"LLVM might have decided to do it anyway, but since GPUs tend to prefer straightline code it is a useful tool to have access to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481489668:117,access,access,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481489668,1,['access'],['access']
Security,"Last validation for now I think... two tracers that react (a - > b), one sinking, one rising:. https://user-images.githubusercontent.com/15271942/161640083-9df98a3c-c6cb-4ccf-bf04-d396b4e4ddc5.mp4. (validates putting forcings in a tuple)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1088061129,2,['validat'],"['validates', 'validation']"
Security,"Len{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:7380,validat,validate,7380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['validat'],['validate']
Security,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:741,access,access,741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178,1,['access'],['access']
Security,"Let's see what @ali-ramadhan has to say.; If we are to nuke the validation experiments section, then there is no point of bringing the pngs back adding this way burden to the git history :) We may as well nuke in the PR and rename the PR :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871895268:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871895268,1,['validat'],['validation']
Security,"Link shortener are commercial entities which can either go under any time, can maliciously tamper with the link or make money by tracking people who click the link. When You Interact With a Bitly Link. Bitly automatically collects personal information about the interaction (such as clicks or views) with every Bitly Link created through the Services (either our bit.ly links or one of our branded domains) on a third-party website. This information includes, but is not limited to: . (i) the IP address and location derived from the IP address; . (ii) the referring websites or services; . (iii) the time and date of each access; . (iv) device settings, such as browser type, operating system, and language; . (v) cookies, as described below, and mobile advertising identifiers and (v) information about sharing of the Bitly Link on Third Party Services such as Twitter and Facebook (collectively, “Bitly Link Metrics”). . As described in this policy, we use Bitly Link Metrics to provide the Services, to understand and analyze how our Services are used and to identify trends, and to detect, deter and prevent malicious, fraudulent or unlawful activity. Please see the “Information We May Share” section of this Privacy Policy for a description of how we may share information we collect when you create, view or interact with Bitly Links.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/773#issuecomment-645895985:623,access,access,623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/773#issuecomment-645895985,1,['access'],['access']
Security,Literate internal tide validation experiment?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694,1,['validat'],['validation']
Security,"Longitude values are not defined correctly at locations fca and cfa of (some particular orientations of) the orthogonal spherical shell grid (OSSG). Recall that the OSSGs constitute the individual panels of the conformal cubed sphere. The attached plots can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [60dde17](https://github.com/CliMA/Oceananigans.jl/commit/60dde179a1851bcc47a55987478d825709e3e7c6) of the Oceananigans branch [jmc-ss/cubed-sphere](https://github.com/CliMA/Oceananigans.jl/tree/jmc-ss/cubed_sphere) with the specification test_multi_region_cubed_sphere_plots = true. ![longitude_heatsphere_c](https://github.com/CliMA/Oceananigans.jl/assets/12926768/250e2ad9-530b-4e00-94da-ebfff9c8d0c6); ![longitude_panel_wise_visualization_c_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/6a3aec42-476d-4575-906b-f04ecd88ea82). ![longitude_heatsphere_u](https://github.com/CliMA/Oceananigans.jl/assets/12926768/fabf2caf-dfaf-4342-a713-1799e592e307); ![longitude_panel_wise_visualization_u_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2a83e72e-8527-45bd-bb0d-0bd120544848). ![longitude_heatsphere_v](https://github.com/CliMA/Oceananigans.jl/assets/12926768/79f91dec-0f48-4a11-9f6f-2e7f16bce000); ![longitude_panel_wise_visualization_v_k_2](https://github.com/CliMA/Oceananigans.jl/assets/12926768/68605b8c-34be-4d7c-9d9e-d5a84efefb56). The first, second and third pair of plots depict the longitude at locations cca, fca, and cfa respectively. The first pair of plots appear to be reasonable. That is not the case with the second and third pairs of plots, where the longitudes appear to be oriented along the latitudes (while ignoring the plotting issue resulting in a small gap).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217:410,validat,validation,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217,1,['validat'],['validation']
Security,Looks good to me! It all seems appropriate and can't think of anything it's missing but we can always access everything else with `Oceananigans.non_exported_name` anyways.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/364#issuecomment-526918570:102,access,access,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/364#issuecomment-526918570,1,['access'],['access']
Security,"Looks great! I think we still don't want images like `validation/convergence_tests/convergence_rates.png` getting into the repo but we can ""squash and merge"" this PR to avoid this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522:54,validat,validation,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522,1,['validat'],['validation']
Security,"Looks like `OrderedDict` is part of [DataStructures.jl](https://github.com/JuliaCollections/DataStructures.jl) so we'd be adding a new dependency, although in this case it seems like a good idea (and it's a solid package as it used to be part of `Base`). Order is definitely important so it would be nice to have the option of iterating over diagnostics and accessing them by name if needed. It would be good to have two ways of adding diagnostics or output writers:; 1. `model.diagnostics[:havg_u] = diag` if you want to give it a name.; 2. `push!(model.diagnostics, diag)` when you don't care about giving it a name. Or when you want to `append!` a bunch of diagnostics without worrying about names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529619838:358,access,accessing,358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529619838,1,['access'],['accessing']
Security,"MA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.actions.githubusercontent.com wss://*.actions.githubusercontent.com productionresultssa0.blob.core.windows.net/ productionresultssa1.blob.core.windows.net/ productionresultssa2.blob.core.windows.net/ productionresultssa3.b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:1190,Secur,Security,1190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,3,"['Secur', 'XSS']","['Security', 'Security-Policy', 'XSS-Protection']"
Security,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2312,validat,validate,2312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['validat'],['validate']
Security,Make the 3D stokes drift validation case even better,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3578:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3578,1,['validat'],['validation']
Security,Make validation/barotropic/barotropic.jl run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['validat'],['validation']
Security,"Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298982981:62,hash,hash,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298982981,1,['hash'],['hash']
Security,Momentum dynamics validation on the CubedSphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306:18,validat,validation,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306,1,['validat'],['validation']
Security,More distributed validation scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,1,['validat'],['validation']
Security,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:167,access,access,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722,1,['access'],['access']
Security,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:138,validat,validation-experiments,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,1,['validat'],['validation-experiments']
Security,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:925,validat,validation,925,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['validat'],['validation']
Security,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713:135,access,access,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713,1,['access'],['access']
Security,"My plan:. * When the user specifies a single diffusivity, this diffusivity is applied to all tracer fields; * Otherwise, diffusivities are specified by a named tuple, where names correspond to diffusivity names, eg. ```julia; tracers = (:T, :S). closure = ConstantIsotropicDiffusivity(ν=1e-6, κ=(T=1e-6, S=1e-7)); ```. and. ```julia; tracers = (:T, :S). closure = ConstantIsotropicDiffusivity(ν=1e-6, κ=1e-6, tracers=tracers); ```. would be possible use patterns. The `tracers` keyword is only required when the diffusivity is not itself a named tuple. Or, possibly we can require that `tracers` is supplied, eg. ```julia; closure = ConstantIsotropicDiffusivity(tracers, ν=1e-6, κ=(T=1e-6, S=1e-7)); ```. This last pattern would be useful if, for example, we want to do input validation on the diffusivity tuple. We may also want to think about designs / syntactic sugar for making the handling of large numbers of passive tracers easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/430#issuecomment-536523208:776,validat,validation,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/430#issuecomment-536523208,1,['validat'],['validation']
Security,Near global quarter degree validation experiment is broken,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690,1,['validat'],['validation']
Security,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:149,access,access,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720,1,['access'],['access']
Security,None of the examples or validation tests changed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1706577311:24,validat,validation,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1706577311,1,['validat'],['validation']
Security,Not sure if this is fully correct but qualitatively the Gaussian blob remains coherent due to geostrophic balance and we get Kelvin waves on the boundary. Was hoping we could merge this PR as it gets the cubed sphere face grid working (and it seems to be working okay pending more rigorous validation tests). Not sure if we'll keep the surface gravity waves validation experiment but might be good to use it for the full cubed sphere as well. https://user-images.githubusercontent.com/20099589/112829246-d6342800-905e-11eb-89fc-4f77a3eb8521.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564:290,validat,validation,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480#issuecomment-809299564,2,['validat'],['validation']
Security,"Not sure what the best solution is but I think if just have a few users (<10-ish) then maybe we can just use the [question label](https://github.com/climate-machine/Oceananigans.jl/labels/question) and questions are asked through this GitHub repo. In reality, all the users right now are on the 15th and 16th floors of our building so nothing online will get used I think. A Slack channel (or some open-source equivalent) might be the way to go? We can create an #Oceananigans channel on the CliMA Slack but not sure if random users will be able to use it. Gitter might be a better (if you can get into the channel without an account/invite). Discourse might be a little overkill: you need a decent server(>2 GB RAM), a mail delivery service, SSL certificate, etc. so might not be worth it for a project like this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/114#issuecomment-470673624:747,certificate,certificate,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/114#issuecomment-470673624,1,['certificate'],['certificate']
Security,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:630,access,access,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,1,['access'],['access']
Security,"Note that there is a validation test for couette flow here:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/immersed_couette_flow.jl. So apparently this is only a problem with the API for specifying fluxes on individual boundary facets. Ie this works:. ```julia; u_immersed_bc = ValueBoundaryCondition(-1); u_top_bc = ValueBoundaryCondition(1); u_bcs = FieldBoundaryConditions(immersed=u_immersed_bc, top=u_top_bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582837617,2,['validat'],['validation']
Security,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:62,access,access,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791,1,['access'],['access']
Security,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:366,Expose,Expose,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,1,['Expose'],['Expose']
Security,"OK, I feel this is ready to be merged. What you all think?. @sandreza, there is a slope limiter now. The Gerdes et al 1991. But others can be implemented. I'm running the validation exp with GM for 60 years to see how it looks...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-930892328:171,validat,validation,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-930892328,1,['validat'],['validation']
Security,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231:42,validat,validations,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231,3,['validat'],['validations']
Security,"OK, with [9916af8](https://github.com/CliMA/Oceananigans.jl/pull/3475/commits/9916af841ae2b4069eef50b216a5ac5ac90ff1d2) I think I moved (almost) all the AMDGPU-related methods into an extension. @fluidnumerics-joe now when you do . ```Julia; julia> using Oceananigans; ```. you don't have access to the AMDGPU methods you added. But if you do. ```Julia; julia> using Oceananigans, AMDGPU; ```. then the extension loads and everything is available!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1944305273:289,access,access,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1944305273,1,['access'],['access']
Security,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2534:267,validat,validation,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534,1,['validat'],['validation']
Security,"Off to some kind of start. <img width=""607"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/118571256-1c863900-b72a-11eb-89fa-aa52506b6929.png"">. (Validation using free convection in a single column context.) Diffusivity is a bit small for some reason so the code and parameters should be proofread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-842725359:167,Validat,Validation,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-842725359,1,['Validat'],['Validation']
Security,"Ok I think I figured it out. The `Float64` values are coming in from functions like `depthᶜᶜᶠ` and `height_above_bottomᶜᶜᶠ`. The main issue is actually the grid coordinates not being fully `Float32`. In particular, when coordinates like `grid.zᵃᵃᶜ` are ranges the reference and step size are `Float64`:. ```julia; julia> r = range(0.0f0, 1.0f0, 16); 0.0f0:0.06666667f0:1.0f0. julia> typeof(r); StepRangeLen{Float32, Float64, Float64, Int64}; ```. You can force it to be `Float32` via:. ```julia; julia> rr = StepRangeLen{Float32, Float32, Float32, Int}(r); 0.0f0:0.06666667f0:1.0f0. julia> typeof(rr); StepRangeLen{Float32, Float32, Float32, Int64}; ```. Doing this in `grid_coordinates.jl` fixes the MWE. Curiously this behavior of `range` is not mentioned in the docs for `range` or `StepRangeLen` but is discussed on the [Julia Discourse](https://discourse.julialang.org/t/the-type-of-a-range-step-defined-as-float32-changes-to-float64/27411). Well looks like it was briefly mentioned in the `StepRangeLen` docstring in 2019. The step size being twice the precision is supposed to help with rounding errors. But maybe on the GPU it can do more harm than good?. I can see how this leads to type promotion to `Float64` but I'm not totally sure how having a `Float64` reference and step size leads to illegal memory accesses. I'm also surprised that this issue never cropped up before. On another note, I wonder if this had any impact on performance. I'm curious to do some benchmarking before and after this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445532635:1316,access,accesses,1316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445532635,1,['access'],['accesses']
Security,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:79,validat,validation,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940,2,['validat'],['validation']
Security,"Ok, looking at the code more I see we don't need to update `inactive_node` or peripheral_node for `Flat`. The reason is they don't do any array access on their own (except potentially through `immersed_cell`). So the right fix here is to modify `immersed_cell`. I took the liberties to scope creep and also added unrelated comments and did some clean up in `inactive_node`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027:144,access,access,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027,1,['access'],['access']
Security,"Okay finally tests passed!. @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run. So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543:422,access,access,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543,1,['access'],['access']
Security,"Okay, I took a second look at the other validation tests and I do think they should be kept. Sure, they're not super thorough, but I think they add to the docs. It's especially nice to see animations of the lid-cavity flow. So my vote goes to keeping them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872276522:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872276522,1,['validat'],['validation']
Security,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1174,expose,exposes,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416,1,['expose'],['exposes']
Security,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:478,validat,validate,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464,1,['validat'],['validate']
Security,"On master there is an object called `all_results`, which is looped over:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L56-L58. It looks like you've omitted the loop over the contents of `all_results`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745477192:161,validat,validation,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745477192,1,['validat'],['validation']
Security,One of the errors is for the Stratified Couette flow validation.; But `max_change = 1.1` in ; https://github.com/iuryt/Oceananigans.jl/blob/22e2e06b4f1451c18cfd4489a8862e28faab0759/validation/stratified_couette_flow/stratified_couette_flow.jl#L245. I suggest to add in the error output which value was given by the user.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394:53,validat,validation,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1705747394,2,['validat'],['validation']
Security,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:601,access,accessible,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,1,['access'],['accessible']
Security,"One way to come up with a test is to ""propose"" an incompressible solution, diagnose the advection term associated with this solution, and then add that term as a forcing function to the RHS to generate a stationary problem. The resulting problem could have zero pressure gradient by construction --- I think. This is the strategy used in. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFreeSlip.jl. (free-slip) and. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFixedSlip.jl. (fixed-slip).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076:390,validat,validation,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076,2,['validat'],['validation']
Security,"Oof, ok I understand. I thought the filtering would allow us to remove the warnings from the docstring. But it doesn't. Instead we have to include the warning in the docstring (including a random path to someone's Oceananigans version, eg `Research/OC11.jl`:. ```; help?> MultiRegionGrid; search: MultiRegionGrid multi_region_grid MultiRegionField MultiRegionObject. MultiRegionGrid(global_grid; partition = XPartition(2),; devices = nothing,; validate = true). Split a global_grid into different regions handled by devices. Positional Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • global_grid: the grid to be divided into regions. Keyword Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • partition: the partitioning required. The implemented partitioning are XPartition (division along the x direction) and; YPartition (division along the y direction). • devices: the devices to allocate memory on. If nothing is provided (default) then memorey is allocated on the the CPU.; For GPU computation it is possible to specify the total number of GPUs or the specific GPUs to allocate memory on. The; number of devices does not need to match the number of regions. • validate :: Boolean: Whether to validate devices; defautl: true. Example; ≡≡≡≡≡≡≡. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat)); 12×12×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.0833333; ├── Bounded y ∈ [0.0, 1.0] regularly spaced with Δy=0.0833333; └── Flat z. julia> multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4)); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/Research/OC11.jl/src/MultiRegion/multi_region_grid.jl:108; MultiRegionGrid{Float64, Bounded, Bounded, Flat} partitioned on CPU():; ├── grids: 3×12×1 RectilinearGrid{Float64, RightConnected, Bounded, Flat} on ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336:444,validat,validate,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336,1,['validat'],['validate']
Security,"Out of curiousity, is the plan for this PR to add an example as an eddying baroclinic double gyre on the GPU with `IncompressibleModel` while #1433 adds a viscous barotropic double gyre with `HydrostaticFreeSurfaceModel` as a validation experiment?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-799462155:226,validat,validation,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-799462155,1,['validat'],['validation']
Security,"Output of the `benchmark_advection_schemes.jl` script ran on Tartarus with the following specs:; ```julia; Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); Environment:; JULIA_CUDA_MEMORY_POOL = none; LD_LIBRARY_PATH = /storage4/simone/lib:; GPU: NVIDIA TITAN V; ```; Note that ; - the `Centered` scheme is unaffected by this PR ; - `UpwindBiased` should have a similar execution time between this branch and main given that the operations are the same but they just happen at different levels; - `WENO(; order = 1)` defaults to `UpwindBiased(; order = 1)`. # On Main; <img width=""1160"" alt=""Screenshot 2024-07-24 at 11 37 44 AM"" src=""https://github.com/user-attachments/assets/1530b2b6-7c79-4d77-b379-854c65bfa940"">. # On this PR; <img width=""1192"" alt=""Screenshot 2024-07-24 at 11 02 35 AM"" src=""https://github.com/user-attachments/assets/d776af2b-3c6a-4997-a7ae-2763ed49bc6c"">. There are a couple of things to note here when it comes to the WENO scheme:; - on CPU we gain roughly a factor of 1.8 given that computations have been reduced by 2X; - on the GPU the gain is less, because, in this case, the uncoalesced memory access (which has to happen for both the branches) costs much more than on the CPU; - (I suspect that) if using WENO only for horizontal reconstructions (like in the global ocean shown above) the penalty of uncoalesced memory access is reduced significantly and the kernel speeds up by a factor of 2 also on the GPU by virtue of the lower (2X) arithmetic intensity of the kernel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2248327750:1436,access,access,1436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2248327750,2,['access'],['access']
Security,"Overturning, eddying channel validation test following Abernathey et al. 2011",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,1,['validat'],['validation']
Security,Patch security loophole,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1225:6,secur,security,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1225,1,['secur'],['security']
Security,Perhaps split out a PR with just CATKE update + a validation script that runs in 3D? Might make things quicker?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2864#issuecomment-1378195828:50,validat,validation,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2864#issuecomment-1378195828,1,['validat'],['validation']
Security,"Plus some cleanup of input validation, and a test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/508:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/508,1,['validat'],['validation']
Security,"Possibly a solution could be that as part of the validation of the grid we check whether; ```Julia; min(Δy) - max(Δy) < abstol; ```; and if the above is true then recreate the grid with `y = (min(grid.y), max(grid.y))`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022641499:49,validat,validation,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022641499,1,['validat'],['validation']
Security,"Posting this here for my own reference later. With the current code, when I run this example:. ```; using Oceananigans; using Oceananigans.OutputWriters: construct_output. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities. op = u^2+v^2. indices1 = (:, :, :); indices2 = (1, 2:3, :). u_sliced1 = Field(u, indices=indices1); u_sliced2 = Field(u, indices=indices2). construct_output(u_sliced2, model.grid, indices1, false); ```. I get this error:. ```; ERROR: BoundsError: attempt to access 1×2×10 view(::Array{Float64, 3}, 4:4, 5:6, :) with eltype Float64 at index [4:4, 5:6, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:225; [5] view(f::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314:608,access,access,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314,1,['access'],['access']
Security,"Previously, I believe I was defining fields on immersed grids. When I try now I get an error. Am I doing something silly or has something changed?. ```; julia> using Oceananigans. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> h0, L = 0.5, 0.25; (0.5, 0.25). julia> grid = RectilinearGrid(size=(16, 8), y=(-1, 1), z=(-1, 0),; topology=(Flat, Periodic, Bounded), halo=(3,3)); 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Arra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2250:908,validat,validate,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250,1,['validat'],['validate']
Security,Probably best if we can access this release through the registry right? Why wait?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401:24,access,access,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401,1,['access'],['access']
Security,Proposal for sustainable `validation` scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:26,validat,validation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,1,['validat'],['validation']
Security,Rehabilitating validation/cubed_sphere_eddying_aquaplanet,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['validat'],['validation']
Security,"Related to this, I wanted to point something out:. ```julia. julia> struct Test; a::Array{Float64, 1}; end. julia> import Base: getindex. julia> getindex(t::Test, inds...) = getindex(t.a, inds...); getindex (generic function with 196 methods). julia> t = Test(rand(4)); Test([0.502462, 0.632246, 0.585965, 0.845577]). julia> @code_lowered t.a[2]; CodeInfo(; 731 1 ─ %1 = (Base.arrayref)($(Expr(:boundscheck)), A, i1) │; └── return %1 │; ). julia> @code_lowered t[2]; CodeInfo(; 1 1 ─ %1 = (Base.getproperty)(t, :a) │; │ %2 = (Core.tuple)(%1) │; │ %3 = (Core._apply)(Main.getindex, %2, inds) │; └── return %3 │; ). julia> @code_lowered @inbounds t.a[2]; CodeInfo(; 538 1 ─ nothing │; │ %2 = (Base.Expr)(:inbounds, true) │; │ %3 = (Base.esc)(blk) │; │ %4 = (Base.Expr)(:(=), :val, %3) │; │ %5 = (Base.Expr)(:local, %4) │; │ %6 = (Base.Expr)(:inbounds, :pop) │; │ %7 = (Base.Expr)(:block, %2, %5, %6, :val) │; └── return %7 │; ). julia> @code_lowered @inbounds t[2]; \CodeInfo(; 538 1 ─ nothing │; │ %2 = (Base.Expr)(:inbounds, true) │; │ %3 = (Base.esc)(blk) │; │ %4 = (Base.Expr)(:(=), :val, %3) │; │ %5 = (Base.Expr)(:local, %4) │; │ %6 = (Base.Expr)(:inbounds, :pop) │; │ %7 = (Base.Expr)(:block, %2, %5, %6, :val) │; └── return %7 │; ); ```. Note that the lowered code for an *inbounds* `getindex` call is exactly the same for `Test` as it is for it's field, `Test.a`. There is a difference when the array access is not inbounds. So we probably shouldn't see slow down for using `getindex` on `Field` directly if its inbounds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-479825567:1408,access,access,1408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163#issuecomment-479825567,1,['access'],['access']
Security,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2684:207,access,access,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684,1,['access'],['access']
Security,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3748:535,access,access,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748,1,['access'],['access']
Security,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:282,access,access,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['access'],['access']
Security,Run on GPU without network access,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:27,access,access,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,1,['access'],['access']
Security,"Running on julia debug level 2: the error seems to be an out-of-bounds array access coming from `_mask_immersed_field!` triggered at `mask_immersed_velocities!` (which is called in `set!(model; kwargs...)`. . Indeed, if you `set!(b, b₀)` the error disappears, but it is still there whenever you will call `mask_immersed_field!` (i.e., when updating the model). The output is a little difficult to interpret but the error seems to be located here. ```; peripheral_node(::Center, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Flat, ; Bounded, RectilinearGrid{Float64, Bounded, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, ; Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, ; GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuDeviceMatrix{Float64, 1}}}, Nothing}) at ; /home/ssilvest/Oceananigans.jl/src/Grids/inactive_node.jl:104; ```. So it seems like it is trying to do a `peripheral_node` of the v velocity, which in this case is flattened since the direction is `Flat`. In this case it will try to do; ```; @inline peripheral_node(LX, ::Face, LZ, i, j, k, grid) = inactive_cell(i, j, k, grid) | inactive_cell(i, j-1, k, grid); ```; hitting `inactive_cell(i, 0, k, grid)`. That is not a problem for a normal grid bit for an immersed grid it is because it evaluates `immersed_cell` at a zero location.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634:77,access,access,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634,1,['access'],['access']
Security,"Running with `--check-bounds=yes` on the CPU provides a strong hint:. ```; at index [39914881, -59303136, 54]; ```. Yeah that'll do it lol. ---. ```; [ Info: Iteration 1...; [ Info: Iteration 2...; ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:401 [inlined]; [5] _interpolate; @ ~/atdepth/Oceananigans.jl/src/Fields/interpolate.jl:295 [inlined]; [6] interpolate; @ ~/atdepth/Oceananigans.jl/src/Fields/interpolate.jl:245 [inlined]; [7] advect_particle; @ ~/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:113 [inlined]; [8] macro expansion; @ ~/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; [9] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [10] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructArrays.StructVector{…}, restitution::Float64, grid::LatitudeLongitudeGrid{…}, Δt::Float64, velocities::@NamedTuple{…}); @ Oceananigans.Models.LagrangianParticleTracking ./none:0; [11] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [12] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstracti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2427969795:240,access,access,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2427969795,1,['access'],['access']
Security,Same typo fix as #1333 but done securely for Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1335:32,secur,securely,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1335,1,['secur'],['securely']
Security,"See, e.g., the Stratified Couette flow validation section in Docs: . <img width=""750"" alt=""Screen Shot 2021-03-13 at 4 44 11 pm"" src=""https://user-images.githubusercontent.com/7112768/111020624-6e090380-841b-11eb-8658-1130d560d86b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459,1,['validat'],['validation']
Security,"Seems I don't have the option ""Allow edits and access to secrets by maintainers"" ; likely because this is coming from an organization account.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936987782:47,access,access,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936987782,1,['access'],['access']
Security,Seems like it has to do with the `Flat` direction: https://github.com/CliMA/Oceananigans.jl/blob/fbfc35348371981feabec10be96820029d4d5c91/validation/immersed_boundaries/flow_over_hills.jl#L32. Perhaps changing that to `Periodic` (plus other appropriate changes to the constructor) will fix it,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1367095694:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1367095694,1,['validat'],['validation']
Security,"Should be a perfect example of a inner constructor (which I really only recommend for input sanitization and invariants checking). ```; struct BoundaryConditions; x_bc::Symbol; y_bc::Symbol; top_bc::Symbol; bottom_bc::Symbol. function BoundaryConditions(x_bc, y_bc, top_bc, bottom_bc); @assert x_bc == :periodic && y_bc == :periodic ""Only periodic horizontal boundary conditions are currently supported.""; @assert top_bc == :rigid_lid ""Only rigid lid is currently supported at the top.""; @assert bottom_bc in [:no_slip, :free_slip] ""Bottom boundary condition must be :no_slip or :free_slip.""; new(x_bc, y_bc, top_bc, bottom_bc); end; end; ```. Instead of Symbols you can also use `@enum`, but that is a stylistic choice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/84#issuecomment-467876426:92,sanitiz,sanitization,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/84#issuecomment-467876426,1,['sanitiz'],['sanitization']
Security,Should we add a test for this? Or at least make all directions testable on the validation script?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2429960900:79,validat,validation,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2429960900,1,['validat'],['validation']
Security,Should we promote the [internal tide validation experiment](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/internal_tide.jl) to a literate one that goes into the docs?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694:37,validat,validation,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694,2,['validat'],['validation']
Security,Simplify way users have access to grid metrics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:24,access,access,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['access'],['access']
Security,"Since this script computes the rates of convergence acurately, I wonder if we might want to include this as a test, or validation maybe? Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1759#issuecomment-866473521:119,validat,validation,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1759#issuecomment-866473521,1,['validat'],['validation']
Security,"So MkDocs can be used with Documenter.jl if you specify `format = DocumenterMarkdown()` in `makedocs()` which will be run on the .md files output by Documenter.jl but then the final HTML gets built and placed in gh-pages, so readthedocs won't have access to the .md files it needs to run MkDocs on. Also couldn't figure out how to use the material theme with mkdocs, so I just switched back to vanilla Documenter.jl. Resolved by https://github.com/ali-ramadhan/Oceananigans.jl/commit/19ba9bab38a18796ee4f32e1a5bdb640ba382e64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/48#issuecomment-466689692:248,access,access,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/48#issuecomment-466689692,1,['access'],['access']
Security,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:207,access,access,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808,1,['access'],['access']
Security,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:328,validat,validation,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,1,['validat'],['validation']
Security,"Some benches. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. (The above are results with `@btime`... It's pretty obvious than PCG brings allocations to the roof...). ![doubly_bounded_poisson](https://user-images.githubusercontent.com/7112768/188521946-143e1b9a-935d-4703-8582-ff5d826b9f3a.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237533405:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237533405,1,['validat'],['validation']
Security,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:12,validat,validations,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777,1,['validat'],['validations']
Security,"Some results from the ""closure comparison"" validation test (rotating wind-driven mixing in a stratified fluid):. # dz = 1 meter, dx = dy = 2 meter. ![smag_comparison_10](https://github.com/user-attachments/assets/5c6a3bf2-42c8-46ad-968d-91210cc37fb5); ![closure_comparison_10](https://github.com/user-attachments/assets/71de45d3-c3aa-476d-8e31-bbba4bf70546). # dz = 2 meter, dx = dy = 4 meter. ![smag_comparison_20](https://github.com/user-attachments/assets/a223e274-1efa-400f-8a71-1c82e0e98bde); ![closure_comparison_20](https://github.com/user-attachments/assets/74d44106-3ebb-489c-b93a-b5329b8d62a5). Seems like dynamic smag is doing what it should which is great. I'm surprised to see that the Lilly coefficient doesn't do much at coarse resolution at least. On cost: it is a bit interesting. I think as kernel saturate, WENO(order=9) will start to win. For small kernels however, AMD seems ideal. We'll have to do a proper benchmark. This PR also contains an experimental implementation of Lagrangian-averaged (scale-invariant) dynamic Smagorinsky.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2443333362:43,validat,validation,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2443333362,1,['validat'],['validation']
Security,Some updates in validation scripts: `AveragedField()` -> `Field(Average())`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2630:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2630,1,['validat'],['validation']
Security,"Something I don't understand about the vertical integrals: for performance, would we not want to launch `Nx` by `Ny` blocks, each with `Nz` threads? That way an entire column ends up in the shared memory of a block. Maybe I am missing something. Similarly, it would seem that for 3D computations we want to launch a 3D array of threads within each block to maximize the usage of within-block shared memory as we loop over stencils. To minimize memory access across blocks, we need the 3D thread block to be as large and as isotropic as possible. Again, maybe I am missing something... Might be to discuss with @vchuravy, since this is his bread-and-butter, as they say.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496565439:451,access,access,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496565439,1,['access'],['access']
Security,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749:215,validat,validation,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749,1,['validat'],['validation']
Security,Sorry @glwagner ; Maybe I didn't express very well.; I don't see any problem in split files and understand the importance in having that.; What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896434796:169,access,access,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896434796,1,['access'],['access']
Security,Sorry @navidcy I think unit tests were failing due to me removing StaticArrays but `weno_reconstruction.jl` and (`test_weno_reconstruction.jl`) still needed it. Tests should pass now 🤞 . Moving nth order WENO into a draft PR makes sense to me so I've nuked it in this PR so we can get rid of the explicit dependency on StaticArrays. @navidcy Don't think you can restart Buildkite builds right now since @glwagner and I had to be added as Buildkite users (and it's all under some CliMA account). @jakebolewski might know whether it's possible for GitHub collaborators to have some access to Buildkite?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736950477:580,access,access,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736950477,1,['access'],['access']
Security,"Sorry for taking that long to come back here.; We should also add a validation for multi-GPU simulations, right?; If so, what should change? We still use MPI as the communicator?; Do you have an example I could use to understand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085333291:68,validat,validation,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085333291,1,['validat'],['validation']
Security,Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121:6,validat,validation,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769909121,1,['validat'],['validation']
Security,"Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing). @navidcy would be happy not to use `ς`!. `\Upsilon` is disturbingly similar to ""Y"":. ```julia; julia> Υ = 1; 1; ```. maybe there's a better choice? We could also change the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094:108,validat,validation,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094,1,['validat'],['validation']
Security,"Sounds like a good idea. I think `setbc!` and `getbc` aren't fully tested so also worth adding some simple tests there. Hmmm, so right now aliases like `top` and `bottom` are defined on coordinate boundary conditions but maybe we want to define them on `FieldBoundaryConditions`?. ```julia; getbc(fbc::FieldBoundaryConditions, ::Val{:south}) = getfield(fbc.y, :left); getbc(fbc::FieldBoundaryConditions, ::Val{:top}) = getfield(fbc.z, :right); ```. So accessing boundary conditions of a field `u` would look like; ```julia; u.boundary_conditions.south # Instead of u.boundary_conditions.y.south; u.boundary_conditions.top # Instead of u.boundary_conditions.z.top; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/637#issuecomment-589875183:452,access,accessing,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/637#issuecomment-589875183,1,['access'],['accessing']
Security,"Sponge layers can be added with the existing API. A 1 line implementation (by defining the forcing function to implement a sponge layer, using the currently provided arguments) is currently possible. What is meant by “arbitrary”?. Strictly speaking, the information available to some forcing function cannot be greater than the union of (arguments to rhs kernel, global variables accessible to the forcing function at model instantiation). . In practice this includes all variables — and this can be implemented with the current API. So perhaps we need a narrow design spec?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504415220:380,access,accessible,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294#issuecomment-504415220,1,['access'],['accessible']
Security,"Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?. ```Julia; julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64). Closest candidates are:; get_face_node(::Function, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; get_face_node(::AbstractVector, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; get_face_node(::Nothing, ::Any); @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11. Stacktrace:; [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; [3] top-level scope; @ REPL[4]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392:81,validat,validation,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762168392,1,['validat'],['validation']
Security,"Suggestions are definitely welcome for streamlining everything!. Note: in dedalus, this problem is handled by allowing users to accumulate parameters into something like `model.parameters` (in dedalus, this is essentially a dict whose keys are accessible by their names to any function/equation defined with a string expression). Having a ""global-like"" variable (like `model.parameters`) is pretty convenient, but also leads to more complicated code. The more democratic callable object strategy is a bit simpler and more modular, but may involve a slightly more complicated API (though I'm not 100% sure about that --- users must decide!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214:244,access,accessible,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214,1,['access'],['accessible']
Security,Supercedes #1717 . The validation NaN's right now with the implemented immersed boundary. @christophernhill take over from here?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1723:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1723,1,['validat'],['validation']
Security,"Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. ### Local topologies. The local grid topology may need",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:1093,inject,injection,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injection']
Security,"Tagging @weymouth for his expertise on IB methods. My (basic) understanding of the options for getting both incompressibility and accurate boundary conditions is that you can either modify the RHS of the pressure Poisson equation, or use an iterative approach (which I think is what @glwagner suggests above). . Either way I agree with the suggestion to merge this PR and focus on validation and improvement (also probably good to have @whitleyv add a cylinder validation case since there's lots of prior results to compare this to).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855287092:381,validat,validation,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855287092,2,['validat'],['validation']
Security,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1405:1077,access,access,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405,2,['access'],['access']
Security,Temporarily sanitized the BibTeX file while some Bibliography.jl issues are sorted out. X-Ref: https://github.com/Azzaare/Bibliography.jl/issues/4; X-Ref: https://github.com/Azzaare/Bibliography.jl/issues/6; X-Ref: https://github.com/Azzaare/Bibliography.jl/issues/7,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657685107:12,sanitiz,sanitized,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657685107,1,['sanitiz'],['sanitized']
Security,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['validat'],['validation']
Security,Thank you @jmbeckers for sharing these papers. I noticed that some of these links you shared have restricted access so I'm copying direct links to the PDFs below. . Since I started this issue I have done some reading and read that two major approaches are what some call the POM and ROMS approaches for sigma coordinates. Can you briefly comment on how your approach compares with those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:109,access,access,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,1,['access'],['access']
Security,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:209,authenticat,authentication,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,1,['authenticat'],['authentication']
Security,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:697,access,access,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,1,['access'],['access']
Security,"Thanks @ali-ramadhan and I agree completely. When I was working on the validation schemes I did test these schemes outside of Oceananigans and they did produce the correct slopes of -1 and -6. Sixth order accuracy could actually be attractive for some applications. Getting first order from upwinding may not sound llike much but it does ensure positivity, which might also be helpful for some cases where you want to ensure tracer concentrations are non-negative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599:71,validat,validation,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1320#issuecomment-768404599,1,['validat'],['validation']
Security,"Thanks @glwagner . . Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed. I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344:306,access,access,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344,1,['access'],['access']
Security,"Thanks @glwagner! Indeed. ```julia; if !(κu★ isa FT); @show i j k κu★; end; ```. does print quite a few lines. So I think all the values are coming back as `Float64`. ---. Very nice find @simone-silvestri! I still get the CUDA illegal memory access error after the change, but this seems like a good change to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2444956478:242,access,access,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2444956478,1,['access'],['access']
Security,"Thanks @simone-silvestri , I agree. I looked and did not see it in the list. Is there someplace else I can access this data? . This is also a problem with ClimaOcean.jl, and I posted an issue [there](https://github.com/CliMA/ClimaOcean.jl/issues/87).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181143084:107,access,access,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181143084,1,['access'],['access']
Security,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:292,validat,validation,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301,1,['validat'],['validation']
Security,"Thanks @tomchor!. I think the issue was that the GPU was not able to access the `grid` inside `bottom_mask_func`, but obviously the error did not give any hints at all. In general, for functions that are to be embedded within GPU kernel (like your `bottom_mask_func`) I would not use anything but the input arguments and `const` values in the function. So with this change I was able to run your script on the GPU:. ```julia; # Set-up sponge layer; heaviside(x) = ifelse(x < 0, zero(x), one(x)). const H = grid.Lz. sponge_one = minimum(oc.Grids.znodes(Face, grid)); sponge_zero = sponge_one + grid.Lz/10. function bottom_mask_func(x, y, z); sponge_one = -H/2; sponge_zero = sponge_one + H/10; return heaviside(-(z-sponge_zero)) * (z - sponge_zero)^2 / (sponge_one - sponge_zero)^2; end; #bottom_mask = GaussianMask{:z}(center=-grid.Lz/2, width=grid.Lz/40); mom_sponge = Relaxation(rate=1/20, mask=bottom_mask_func, target=0); ```. You could also declare `sponge_one` and `sponge_zero` as `const` values outside `bottom_mask_func` if they won't change, and to save a few measly FLOPS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733850482:69,access,access,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733850482,1,['access'],['access']
Security,"Thanks @weymouth ! I was thinking a good approach might be to first implement a continuous forcing method (since its easy), along with a validation test or two; perhaps some with moving boundaries... ? Then we can assess error + accuracy, and use the validation tests to assess improvements in potential future discrete forcing implementations with modified Poisson solvers... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-646309242:137,validat,validation,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-646309242,2,['validat'],['validation']
Security,"Thanks everyone for the feedback. I did some debugging and I'm happy to say that bathymetry is now specified as we expected, no negative sign, and it gives results that are consistent with previous findings: prograde is more unstable and retrograde is more stable. . You can see the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl). . Any other thoughts on this before I move on to the global model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794:370,validat,validation,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794,1,['validat'],['validation']
Security,"Thanks for opening this!. I don't have a lot of server/internet access right now so I can't properly test this, but using `.*┌ Warning.*\n` and `.*└ @ Oceananigans.*\n` seems to work. You can test things out here: https://regexr.com/. Also, it seems like there's an extra quote in your regex line?. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")""]` . maybe should be. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")]`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506:64,access,access,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506,1,['access'],['access']
Security,"Thanks for reporting this @truedichotomy! Looks like it's GPUArrays that is failing to precompile but we do run CI tests on Mac OS that have seemed fine so hopefully it's just an environment/version issue... Which Julia version are you using? For Oceananigans v0.34.1 you need Julia 1.4+. Can you also post your Julia environment, the output of typing `] status` at the Julia REPL?. I don't have access to a Mac to test unfortunately (@glwagner does I think).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854#issuecomment-673427153:396,access,access,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854#issuecomment-673427153,1,['access'],['access']
Security,"Thanks for the explaination @glwagner and I agree, saving this question for future validation and/or convergence tests is a good idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838848318:83,validat,validation,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838848318,1,['validat'],['validation']
Security,"Thanks for the feedback. . First, I used the formatting to get nicer output,; ```; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2 ; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3 ; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4 ; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5 ; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5 ; ```. Second, sorry about the extra files. I will probably close this and create a new one rather than having a bunch of commits, as that will be cleaner. I presume that's the preferred option?. Third, can you point me to another validation experiment that uses a library not in the library?. Fourth, I won't do any other advection schemes for this PR. Fifth, I will move this into the validation folder and chane the name of the files appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393:679,validat,validation,679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393,2,['validat'],['validation']
Security,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:403,access,accessing,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,1,['access'],['accessing']
Security,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386:550,access,access,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386,1,['access'],['access']
Security,"That is a huge leap forward @hennyg888 and great to see! Before we were at 50% and now we are at 75%. An increase of 50%, which is pretty huge all things considered. I like @christophernhill 's suggest of adding the version info. Yesterday when we talked the consensus was that one major problem was how we do buffering. As a silly experiment, what if we redo this without updating any halos, ever. Physically, it's going to be wrong but do we get another huge increase in the efficiency? If the efficiency gets close to 100% then in my mind that validate the hypothesis. If not, then that would signify there is another bottleneck that we need to hunt down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593:547,validat,validate,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593,1,['validat'],['validate']
Security,"That would be awesome! Wasn't sure if it was open to packages outside of Julia main framework. Just signed up on GitLab and requested access. Looks like @navidcy is already a member, does FourierFlows.jl use this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/53#issuecomment-464735083:134,access,access,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/53#issuecomment-464735083,1,['access'],['access']
Security,"That would be nice, especially #746, but on the topic of defining `lastindex`: is it possible that someone might want a forcing function to access halo information? Using `grid.H{x,y,z}` would be better than `end` but it would be weird if `end < grid.Nx + 2grid.Hx` when working with halos. I can't think of a possible use case but might still be good to add a recommendation against using `end` to preserve flexibility.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691066453:140,access,access,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/838#issuecomment-691066453,1,['access'],['access']
Security,"That's a good point you bring up, sounds like this will be easier once #59 is resolved. Instead of dispatching, I was actually thinking of using a macro here, e.g. `@insert_forcing` that inserts a zero if the forcing is `nothing`, a function call if the forcing is a function, and grabs a numbers from an array if it's an array. Some pseudocode:; ```julia; # Insert forcing for u-momentum equation.; macro insert_forcing_u(Fu); if Fu == nothing; return 0; else if typeof(Fu) == Function; return Meta.parse(""Fu(grid, velocities, tracers, i, j, k)""); else if typeof(Fu) <: AbstractArray; return Meta.parse(""Fu[i, j, k]""); end; end; ```; Then the time-stepping might look like; ```julia; Gu[i, j, k] = (-u∇u(...) + ... + @insert_forcing_u); ```; All the different macros can be defined in an `@eval` loop or maybe with a single `@insert_forcing` definition is it knows which forcing is being inserted so it can inject the correct `Fu"", ""Fv"", etc. in the expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470506051:908,inject,inject,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470506051,1,['inject'],['inject']
Security,That's a good point! We can test / validate `OrlanskiBoundaryCondition` using `ShallowWaterModel` (or `HydrostaticFreeSurfaceModel`) with confidence knowing that there's no pressure solver to mess things up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934704012:35,validat,validate,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934704012,1,['validat'],['validate']
Security,"That's a good point. Maybe oceananigans will fail when trying to write; output to a file that is already being accessed by another, which is a; problem. Maybe some testing/discussion is needed before implementing this?. On Sun, Nov 29, 2020, 10:08 Ali Ramadhan <notifications@github.com> wrote:. > Awesome, I'll change the behavior in #1229; > <https://github.com/CliMA/Oceananigans.jl/pull/1229> so it only opens the; > file as needed to write output.; >; > Not sure what will happen if you open a file while the simulation is; > running (but not writing output) then try to access data while Oceananigans; > is writing output, but hopefully it'll all be well-behaved.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735433046>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSH6LTSOJGZEQIVAYLSSKEYVANCNFSM4UGAS57A>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735433543:111,access,accessed,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227#issuecomment-735433543,2,['access'],"['access', 'accessed']"
Security,"That's very nice @apaloczy, thank you! I have to think about it more but I think the hypothesis is rational: there is an unavoidable error associated with step topography, but the error can be reduced by using partial cells vs full cells. If that holds this would be an excellent case to use to motivate/develop cut cells. Note there are a few articles that suggest the same:. - [How slippery are piecewise-constant coastlines in numerical ocean models?](https://www.tandfonline.com/doi/abs/10.3402/tellusa.v50i1.14514); - [Sliding or Stumbling on the Staircase: Numerics of Ocean Circulation Along Piecewise-Constant Coastlines](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2022MS003594). This could be a good bona fide example I think. We only have an internal tide example now, right? But definitely a validation test otherwise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015:817,validat,validation,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2273594015,1,['validat'],['validation']
Security,The Convergence tests and Couette flow pages (in validation) had missing figures that somehow got lost at some point. I was able to find the figures by going back to older versions of Oceananigans and reintroduced them. Resolves #1459. Resolves #1696.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797:49,validat,validation,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797,1,['validat'],['validation']
Security,The GPU validation should be identical. You just need to ; 1. Make sure you have enough gpus and the MPI installation is cuda-aware (MPI.has_cuda() == true); 2. Switch CPU to GPU in the script. The rest of the script does not change,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2087613955:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2087613955,1,['validat'],['validation']
Security,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1696:4,Validat,Validation,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696,1,['Validat'],['Validation']
Security,"The [Simulation tips](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594:299,access,access,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594,1,['access'],['access']
Security,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,4,['validat'],['validation']
Security,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:201,access,accesses,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,2,['access'],['accesses']
Security,"The convention we use for the other variables stored on faces is that our ""interior"" data spans from `i=1` to `i=N`. Thus we call the `i=N+1` a ""halo point"" for fields on faces, even though it really is not (its on the boundary, see #455). . In addition, we use a convention that face indices are ""left"" of cell indices. Thus `iFace=1` corresponds to the ""left"" boundary of the domain. `iCell=N` is the rightmost cell in the domain; and `iFace=N+1` corresponds to the rightmost boundary. Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this? This is confusing to me and I don't see why we would want to have an odd and surprising convention for the vertical coordinate. The fact is simply that the face at `i=N` is a very concrete and real place. It lies in the interior of the domain, to the left of the cell point `i=N`. This is a fact of our grid and must be internalized by anyone who wants to work with the discrete data and index fields directly by raw index. If/when we use named axis conventions for `fields` (see #457), we would be able to access the surface via `u[Z(At(0))]` (or some syntax like that. We can also create an alias `Surface() = Z(At(0))`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106:513,access,access,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106,2,['access'],['access']
Security,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3099:126,access,access,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099,2,['access'],['access']
Security,"The docstring example for three-dimensional Stokes drift can be improved:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/StokesDrifts.jl#L219-L226. The `v`-component (for example) is associated with a Stokes drift `vS` of the form:. ```julia; vS = p.Uˢ * exp(z / p.h) * cos(p.k * x) * sin(t); ```. For this to represent a real surface wave field, then it would have to be sinusoidally oscillating in time (hard to imagine). Also, the envelope of the surface drift is modulated in space by `cos(k * x)`. Unfortunately, this is quite confusing because `k` is typically used to represent the wavelength of the _surface wave field_ (not the envelope of the surface waves). For example, for a monochromatic wave field, `h = 2k` is the vertical scale of the Stokes drift. So in this example, `k` has a different meaning (governing the wave field envelope) then it normally does (the wavenumber of the underlying wave field). A better docstring example might represent a wavepacket that is translating at the group velocity, as done in a validation case:. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/surface_wave_quasi_geostrophic_flow.jl#L5-L51",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3422:1076,validat,validation,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3422,2,['validat'],['validation']
Security,"The dynamics test exhibits some ""breathing"":. https://user-images.githubusercontent.com/15271942/109686870-acb3d980-7b50-11eb-86c5-437fb7257d6b.mp4. https://user-images.githubusercontent.com/15271942/109686850-a887bc00-7b50-11eb-8939-803a1de29261.mp4. this could be because the initial condition doesn't satisfy discrete geostrophic balance, or a continuing issue with the coriolis implementation. However, I suggest we merge this PR now (since it has some bug fixes) and continue working on the validation tests in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613:496,validat,validation,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-789067613,1,['validat'],['validation']
Security,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:14,validat,validation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,3,"['access', 'validat']","['access', 'validation']"
Security,The following PR adds a new script with immersed boundaries on a lat-lon grid as a validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1880:83,validat,validation,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1880,1,['validat'],['validation']
Security,"The function `interpolate` is currently mostly used for Lagrangian particle advection:. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L186-L198. However, it's also potentially useful for many other things. Right now though it doesn't work (or make sense) for fields with `Nothing` locations:. ```julia; source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); s = Field{Center, Center, Nothing}(source_grid); set!(s, (x, y) -> x + y); loc = Tuple(L() for L in location(s)); x = y = 0.67; z = 0; interpolate(s, loc..., source_grid, x, y, z); ```. gives. ```julia; julia> interpolate(s, loc..., source_grid, x, y, z); ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] fractional_z_index; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:110 [inlined]; [3] fractional_indices; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:133 [inlined]; [4] interpolate(field::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356:758,access,access,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356,1,['access'],['access']
Security,"The issue here seems to be with `parent_index_range`. ; This should return the parent indices which are then used to `view(parent(data), parent_indices...)`. ; This will not work with sliced fields because in sliced fields the `data` has windowed indices (returned by `parent_index_range`), but the parent has indices that always start from 1. for example for a 10x10x10 grid: ; ```; julia> η.data; 16×16×1 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, 11:11) with eltype Float64 with indices -2:13×-2:13×11:11:; .; .; .; ```; ```; julia> η.data.parent; 16×16×1 Array{Float64, 3}:; .; .; .; ```; So if I try to do `view(, :, : grid.Nz+1)` it returns ; ```; julia> view(η, :, :, grid.Nz+1); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```; because ; ```; julia> parent_indices = parent_index_range.(indices(η), location(η), topology(η.grid), halo_size(η.grid)); (Colon(), Colon(), 14:14). julia> windowed_parent = view(parent(data), parent_indices...); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```. In my opinion `parent_index_range` should return here `(Colon(), Colon(), 1:1)`, but I would like to be sure before breaking everything",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541:722,access,access,722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541,2,['access'],['access']
Security,"The issue is coming from a boundserror:. ```julia; ERROR: BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; --;   | Stacktrace:;   | [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{});   | @ Base ./abstractarray.jl:651;   | [2] checkbounds;   | @ ./abstractarray.jl:616 [inlined];   | [3] _setindex!;   | @ ./abstractarray.jl:1289 [inlined];   | [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::String);   | @ Base ./abstractarray.jl:1267;   | [5] find_local_cuda();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:156;   | [6] macro expansion;   | @ ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:51 [inlined];   | [7] macro expansion;   | @ lock.jl:209 [inlined];   | [8] toolkit();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:14;   | [9] toolkit_version();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:209;   | [10] versioninfo(io::Base.TTY) (repeats 2 times);   | @ CUDA ~/.julia-3060/packages/CUDA/mVgLI/src/utilities.jl:35;   | [11] top-level scope;   | @ none:1; ```. On CUDA@3.3.0 this comes from a line that looks like. ```julia; __temp_libcusolver[] = ...; ```. I don't this this construct is valid in julia 1.6:. ```; julia> __temp_libcusolver = Ref{Union{Nothing,String}}[]; Ref{Union{Nothing, String}}[]. julia> __temp_libcusolver[] = nothing; ERROR: BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; Stacktrace:; [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] _setindex!; @ ./abstractarray.jl:1289 [inlined]; [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::Nothing); @ Base ./abstractarray.jl:1267; [5] top-level scope; @ REPL[4]:1; ```. But on CUDA#master the bug may have been fixed:. https://github.com/JuliaGPU/CUDA.jl/blob/3c251c1c210ff3fc75cef8dad688d170caadc275/deps/bindeps.jl#L180. ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612:82,access,access,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612,1,['access'],['access']
Security,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:84,validat,validation,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363,1,['validat'],['validation']
Security,"The main rationale for not having an immersed boundary conditions example was because we regarded it as an experimental feature, and didn't want to trip new users up (which is the opposite of the motivation #3). We could change our philosophy though. @tomchor you may not realize it, but you probably have the most experience with immersed boundary conditions. I think it's reasonable that nobody has added an example for these yet. I don't think there are any validation tests at all, or papers that use them, in constrast to much of the rest of the code. The fact that a major bug like the one found in #3142 still exists is a testament to the fact that these are unvalidated, and I think also validates our justification for not having an example yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028:461,validat,validation,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599993028,2,['validat'],"['validates', 'validation']"
Security,"The new validation experiment `validation/implicit_vertical_diffusion/nonhydrostatic_one_dimensional_diffusion.jl` produces. <img width=""600"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117710734-eae7fd80-b17e-11eb-9069-90690515f479.png"">. showing that implicit vertical diffusion now works for `IsotropicDiffusivity` in `IncompressibleModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-837155940:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-837155940,2,['validat'],['validation']
Security,"The problem is these lines . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Fields/field.jl#L243-L244. ```; julia> parent_indices = parent_index_range.(indices(a_field), location(a_field), topology(grid), halo_size(grid)); (Colon(), Colon(), 4:4). julia> windowed_parent = view(parent(a_field.data), parent_indices...); ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [1:26, 1:26, 4:4]; ```; ; `parent(a_field.data)` has a z-index that never reahes 4. The actual offset data has indices 4:4 in the z-direction, but the parent only 1:1. We can view `a_field.data` at 4:4 not `parent(a_field.data)` (or in your case even worst 4:23). ; I think the parent index of a sliced field should be ; ```; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```; (if we assume `index::UnitRange` means it is a sliced field so it does not have halos). This is not the whole story though, since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. So once we have fixed this we have to deal with the output writers which rely on `view(field, indices...)`. I guess the error here will be somewhere in this function . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/OutputWriters/output_construction.jl#L50-L60. Here we have to interpolate the `indices` which result from line 56 with `indices(output)` that contain the indices of the (maybe) sliced field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594:395,access,access,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594,1,['access'],['access']
Security,The syntax is. https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/validation/curvilinear_diffusion/spot_tracer_diffusion.jl#L24-L29. The infrastructure that supports this is in . https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617381:102,validat,validation,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617381,1,['validat'],['validation']
Security,"There are a few more `0.0` in the code. Question:. If there is. ```Julia; fill!(var, 0.0); ```. where `var::Array` and if we don't have access to grid, then is . ```Julia; fill!(var, 0); ```; safe to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416:136,access,access,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416,1,['access'],['access']
Security,"There are some merge conflicts after #2576. For the shallow_water_bickley_jet.jl example the merge should be. ```julia; gravitational_acceleration = 1; coriolis = FPlane(f=1). model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO5()); ```. But for the validation script I'm not sure...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140402565:326,validat,validation,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140402565,1,['validat'],['validation']
Security,"There is a script at https://github.com/CliMA/Oceananigans.jl/blob/ncc-glw/cubed-sphere-dynamics/validation/multi_region/cubed_sphere_vorticity.jl. ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/7112768/fcf66cf7-c257-4fd0-bc5a-39cb79a6bc92). So computing the vorticity there are 6 holes on the 2 corners that do not correspond to an interior point. These are the. `i = 1, j = Ny+1` points for odd panels and `i = Nx+1, j = 1` for even panels. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. One idea is to have each panel of the cubed sphere span until, e.g., `Nx+1` or `Ny+1`. We will have redundancy in the computations but will sort the other issue. Otherwise we just want to call the vorticity kernel on those 3 points; do we do it in a different kernel? Before calling the kernel we need to ensure that the horizontal velocities have their halo regions filled right as the circulation around those points involves some velocities in the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341,1,['validat'],['validation']
Security,"There is definitely a wrong assumption somewhere in this pipeline. Maybe we can focus on this:. > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886:114,access,access,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2013010886,1,['access'],['access']
Security,There is one that does a one-level near global ocean on a latitude-longitude grid. (in the near_global validation folder); I haven't tried this particular script before,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475427126:103,validat,validation,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475427126,1,['validat'],['validation']
Security,"There's a growing number of users of Oceananigans, and we want share knowledge, share ideas, chat, science together, and maybe even work together. Currently the only way for users to ask questions is by posting an issue to github like this one. . But the issue tracker is _supposedly_ supposed to be used for issues related to the source code and code development. Other questions like:. * Why is my code slow?; * How do I implement my science idea?; * What does Oceananigans _mean_?; * Why is @navidcy so passionate about documentation?. don't have a place to be asked except for, perhaps, emailing developers and other normal humans directly. But unfortunately private emails are not accessible to all, and thus knowledge is lost or not disseminated. We do now have a channel on the julia slack:. https://julialang.slack.com/archives/C01D24C0CAH. which may, or may not, suffice for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1098:686,access,accessible,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1098,1,['access'],['accessible']
Security,There's a preliminary implementation here:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/bickley_jet/disk_time_series.jl. It's used for plotting the Bickley jet here:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L142-L159. The principal change that's needed for `JLD2OutputWriter` is to serialize a bit more information. This is done manually for the Bickley jet:. https://github.com/CliMA/Oceananigans.jl/blob/62c8abb1f39fb2f4fd24e274165ee2765e130933/validation/bickley_jet/bickley_jet.jl#L101-L107. but it would be easy to implement saving this kind of metadata as a default.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801617027,3,['validat'],['validation']
Security,"There's a progress writer:. https://github.com/CliMA/Oceananigans.jl/blob/8c60dba84334ddd1c731e1b5a3cc0414f9066cbd/validation/immersed_boundaries/internal_tide.jl#L28-L31. so the reason you didn't see output might be because it was still compiling??? Or, running very very very very slow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867963213:115,validat,validation,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867963213,1,['validat'],['validation']
Security,"There's no real validation of this feature, so it wasn't added to the docs. Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939,2,['validat'],['validation']
Security,"These are notes showing the equations for `ShallowWaterModel` in vector invariant form on the first page. I believe that @simone-silvestri and @glwagner have access to this document. On the second page I started derving the weak form using finite volume including both divergent and rotational viscosity. It needs more work. I believe that the divergent form is included in this PR and I would suggest saving the rotational form can be saved for a future PR. I need to better understand how the nonlinear terms are dealt with. Maybe @simone-silvestri can help me with this?. Some of this could make it's way into the docs, if there is interest. [ShallowWaterModel.pdf](https://github.com/CliMA/Oceananigans.jl/files/8716623/ShallowWaterModel.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130027776:158,access,access,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130027776,1,['access'],['access']
Security,These explorations are great but if in the end we figure out that it was the bathymetry fiddling that was the issue perhaps we should think of ClimaOcean as the place to hold this validation script? It includes tools to manipulate bathymetry…,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2009590429:180,validat,validation,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2009590429,1,['validat'],['validation']
Security,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:908,Validat,Validation,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['Validat'],['Validation']
Security,This PR adds a few barotropic turbulence validation tests on `RegularLatitudeLongitudeGrid`. It also includes some miscellaneous improvements needed for these simulations:. * Bugfixes for `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (missing functions + closure shenanigans to solve type inference issues); * Allows `TimeStepWizard` to accept user-defined `cell_advection_timescale` functions; * Implements `auxiliary_fields` computed during `update_state!` for `HydrostaticFreeSurfaceModel`. Here's where we are at:. https://user-images.githubusercontent.com/15271942/116346519-4ab5d000-a79f-11eb-8c7f-91281db0ff56.mp4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1626:41,validat,validation,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626,1,['validat'],['validation']
Security,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463:48,validat,validation,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463,2,['validat'],['validation']
Security,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2110:571,validat,validate,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110,1,['validat'],['validate']
Security,This PR adds a set of changes so that needed dispatch paths for CubedSphereGrid are followed when CubedSphereFaceGrid tuple is wrapped in an ImmersedBoundary type. . With these changes the https://github.com/CliMA/Oceananigans.jl/blob/cnh-glw/immersed-cubed-sphere/validation/immersed_boundaries/immersed_cubed_sphere_rossby_haurwitz.jl code works identically for non-immersed and immersed cube sphere.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1737:265,validat,validation,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1737,1,['validat'],['validation']
Security,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:58,validat,validates,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['validat'],['validates']
Security,This PR adds a tilted bottom boundary layer validation based on one of the simulations in [this paper](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml). This is only a draft for now! (So not ready for review.) In particular I still need to. - [x] Add a sponge layer to the top.; - [x] Confirm that the result is still qualitatively correct; - [x] Add a tilted coriolis acceleration (implemented in #1892). This example renders here: https://clima.github.io/OceananigansDocumentation/previews/PR1498/generated/tilted_bottom_boundary_layer/. CC: @wenegrat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498,1,['validat'],['validation']
Security,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,2,['validat'],['validation']
Security,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602:35,validat,validation,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602,1,['validat'],['validation']
Security,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2348:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348,1,['validat'],['validation']
Security,This PR adds biharmonic diffusion appropriate for curvilinear grids as described by the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. Looking for suggestions on more comprehensive tests / validation experiments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1531:245,validat,validation,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1531,1,['validat'],['validation']
Security,This PR adds tests for Face-Face halo filling and ensures that the `fill_halo_regions!` for Face-Face fields are done correctly. After this PR a `fill_halo_regions!` works on a Face-Face field on a `ConformalCubedSphereGrid` **with the exception** of the 2 corner points that belong in the halo regions and _do not_ correspond to any interior point!. If those corner points are filled manually. https://github.com/CliMA/Oceananigans.jl/blob/b0ff6c4874355ec69208f437be4f46fc8935f3d7/validation/multi_region/cubed_sphere_tracer_advection.jl#L32-L53. Then everything seems fine. (This is of course not a final solution but I wanted to make a note here.). (work done with @siddharthabishnu),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3324:482,validat,validation,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3324,1,['validat'],['validation']
Security,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/936:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936,1,['validat'],['validation']
Security,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389:1678,Validat,Validation,1678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389,1,['Validat'],['Validation']
Security,"This PR allows simulations to hold parameters, useful if you need to access stuff from the `progress` function (e.g. see https://github.com/thabbott/JULES.jl/pull/63) going with the idea that we'll probably get rid of `model.parameters` in favor of more local parameters. It also cleans up show functions for models and simulations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/639:69,access,access,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/639,1,['access'],['access']
Security,"This PR also provides _experimental_ (untested) supported for Bounded domains: @johnryantaylor @raphaelouillon. Future work / PRs can add tests for these cases, and perhaps some validation experiments. I also think we've unlocked the requirements for FFT + tridiagonal solve, but that is yet again for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368:178,validat,validation,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368,1,['validat'],['validation']
Security,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444:546,validat,validating,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444,1,['validat'],['validating']
Security,"This PR creates a new script that computes the convergence rates for all of the advection schemes and plots them together in one figure, which is doing what #1276 tried to do. The output is a figure and the following:; ```; Results are for the L1-norm:. Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5; ``` . ![convergence_rates](https://user-images.githubusercontent.com/8239041/117871837-dcc3db00-b26b-11eb-9307-0156e84714ee.png). The rates are very, very close to the theory. Questions:. - Can someone help me align the output so that Rate of Convergence appears in the same location?; - Any suggestions on how to improve the plot?; - I needed to add Polynomials to do this. Any problems with adding this to the Manifest?. Next Steps:. @ali-ramadhan suggested using this to validate new advection schemes, and I think it's a good idea. Things we could do next include,. - [ ] First order upwinding; - [ ] Sixth order center differencing; - [ ] Nth-order WENO",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648:1090,validat,validate,1090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648,1,['validat'],['validate']
Security,"This PR fills the metrics for the halo regions for a `OrthogonalSphericalShellGrid`. Also adds a validation example for a splash on an `OrthogonalSphericalShellGrid`, i.e., a `HydrostaticFreeSurface` model starting from rest + its free surface lifted up in the form of a Gaussian. Partially resolves #3198.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3239:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3239,1,['validat'],['validation']
Security,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:67,validat,validation,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['validat'],['validation']
Security,This PR fixes `set!` for `CubedSphereReducedField` for now which is used in the Rossby-Haurwitz validation experiment (and adds tests).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1622:96,validat,validation,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622,1,['validat'],['validation']
Security,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935:406,validat,validation,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935,3,['validat'],['validation']
Security,"This PR implements `PrescribedVelocityFields` for `HydrostaticFreeSurfaceModel` (or more precisely, moves the implementation from `validation/` to `src/`). `PrescribedVelocityFields` acts similar to the `velocities` tuple, except that `velocities.u, velocities.v, velocities.w` are prescribed functions of `x, y, z, t` and optional `parameters`. Using the kwarg `velocities=PrescribedVelocityFields(...)` in the constructor for `HydrostaticFreeSurfaceModel` causes the free surface to be set to `nothing` and elides memory allocations for velocity and free surface tendency fields. The model then amounts to tracer advection by the prescribed fields. This feature was discussed on #958, where it was envisioned this feature would be implemented in `IncompressibleModel`. Right now the implementation is specific to `HydrostaticFreeSurfaceModel`. However, I think the tracer advection-diffusion physics permitted by `IncompressibleModel` and `HydrostaticFreeSurfaceModel` are identical right now. So perhaps this PR closes #958?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1426:131,validat,validation,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1426,1,['validat'],['validation']
Security,"This PR implements a `VectorInvariant` formulation for momentum advection in `HydrostaticFreeSurfaceModel`, and also adds a `validation/bickley_jet/bickley_jet.jl` script. . `validation/bickley_jet/` also contains a preliminary implementation of `DiskTimeSeries` which might be useful to merge into the source code eventually to help users post-process their output. With `WENO5` for both `momentum_advection` and `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108126995-913ccf00-7078-11eb-8ced-ac4d51fe3bd2.mp4. This is more or less what we ""expect"" (though it'd be nice to be more quantitative at some point). With `CenteredSecondOrder` for `momentum_advection`, but `WENO5` for `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108127592-7454cb80-7079-11eb-9091-45cd93464c6e.mp4. while with `VectorInvariant` we get. https://user-images.githubusercontent.com/15271942/108127600-77e85280-7079-11eb-9f55-2fc5f8ea1a06.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366:125,validat,validation,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366,2,['validat'],['validation']
Security,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738:527,validat,validation,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738,1,['validat'],['validation']
Security,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2023:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023,1,['validat'],['validation']
Security,This PR implements the triad discretization for the Gent-McWilliams skew flux following [Griffies et al 1998](https://journals.ametsoc.org/view/journals/phoc/28/5/1520-0485_1998_028_0805_idiazc_2.0.co_2.xml?tab_body=fulltext-display). @jm-c . Running `/validation/isopycnal_skew_symmetric_diffusivity/coarse_baroclinic_adjustment.jl` produces . https://github.com/user-attachments/assets/124baffe-037c-4acd-bf97-d2b7cde36015. I think its working?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3901:253,validat,validation,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3901,1,['validat'],['validation']
Security,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1423:19,validat,validation,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423,8,['validat'],['validation']
Security,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888:1776,Validat,Validation,1776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888,1,['Validat'],['Validation']
Security,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:1279,validat,validation,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['validat'],['validation']
Security,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771,2,['validat'],['validation']
Security,"This PR just updates and cleans up the lid-driven cavity script. At some point I'd like to add all the validation experiments into CI and into the docs as advanced examples, but this will have to wait for now. The issue is that the script was using `Flat` back when it did nothing but now when using `Flat` you need to pass a 2-tuple for the grid size. I switched the script from `Flat` to `Bounded` until `Flat` is fully working. cc @maeckha. Resolves #1507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1516:103,validat,validation,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516,1,['validat'],['validation']
Security,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/411:348,access,accessed,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411,2,['access'],"['accessed', 'accessing']"
Security,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,1,['validat'],['validation']
Security,"This PR makes a few major contributions:. * Fixes a bug in Anisotropic Minimum Dissipation (AMD) type closures that led to (very) wrong subgrid-scale diffusivities.; * Adds a new flavor of AMD proposed by [Verstappen (2018)](https://www.sciencedirect.com/science/article/abs/pii/S0045793016304005) and described in detail by [Vreugdenhil and Taylor (2018)](https://aip.scitation.org/doi/abs/10.1063/1.5037039). This new flavor of AMD, dubbed the ""Verstappen"" AMD, is now the default name bound to `AnisotropicMinimumDissipation`; * The closure formerly known as `AnisotropicMinimumDissipation` is now called `RozemaAnisotropicMinimumDissipation` (it was first described by [Rozema et al. (2015)](https://aip.scitation.org/doi/abs/10.1063/1.4928700)). It is not exported, but can be accessed via `Oceananigans.RozemaAnisotropicMinimumDissipation`.; * There is new Smagorinsky closure variant called `BlasiusSmagorinsky` which is untested and unexported. It can be accessed via `Oceananigans.BlasiusSmagorinsky`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383:782,access,accessed,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383,2,['access'],['accessed']
Security,"This PR makes a number of bug fixes needed to time step `HydrostaticFreeSurfaceModel` with a `RegularLatitudeLongitudeGrid`, and adds an experimental ""spherical splash"" example that uses Makie to visualize the solution on the surface of a the sphere:. https://user-images.githubusercontent.com/15271942/109041650-4553e080-769d-11eb-8c05-b169cba87153.mp4. Everything is still experimental, but we need these tools (and bug fixes) to set about validating our curvilinear finite volume numerics implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1399:442,validat,validating,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1399,1,['validat'],['validating']
Security,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:621,validat,validation,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,2,['validat'],['validation']
Security,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090:24,validat,validations,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090,1,['validat'],['validations']
Security,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:301,validat,validation,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,1,['validat'],['validation']
Security,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:1404,validat,validation,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,1,['validat'],['validation']
Security,"This PR partially generalizes the implementation of flux boundary conditions to work on curvilinear grids. The design implemented in this PR required a number of changes:. - Preservation of field locations in GPU kernels through a generalization of `adapt_structure(to, field::Field)`; - Creation of generic area and volume operators that dispatch on location like `Ax(i, j, k, grid, X, Y, Z)` (others are `Ay`, `Az`, and `volume`); - Generalization of `apply_top_z_flux!`, etc. The similar functions for `x` and `y` could also be generalized in this PR, though we don't have regression tests to ensure that they still work as before...; - Activation of `calculate_boundary_tendencies!` for `HydrostaticFreeSurfaceModel`. The new `validation/barotropic_gyre.jl` experiment is definitely a work in progress but will eventually produce a movie like. https://user-images.githubusercontent.com/15271942/110257064-a747fc00-7f61-11eb-83aa-18665f01efb4.mp4. We may want to add side and bottom drag, tweak the surface stress, and tweak the viscosity.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1433:731,validat,validation,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433,1,['validat'],['validation']
Security,"This PR puts some code into the `IncompressibleModel` constructor that adjusts the halos in `grid` so that they're valid for the specified `advection` scheme and turbulence `closure`. The changes went a little deep because of the fact that we allow fields to be passed directly to `IncompressibleModel`. We now check whether such fields have the correct grid and throw an error if they don't. I decided not to validate the `pressure_solver` input. This isn't commonly provided by users (and wasn't previously checked). There's a new function in `Solvers` that could be modified if such a check becomes desirable. Here's what happens if you use a high-order advection scheme now:. ```julia; using Oceananigans, Oceanaingans.Advection. grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)). # output --- note that halos are (1, 1, 1); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. but,. ```julia; model = IncompressibleModel(advection=WENO5(), grid=grid). model.grid. # output --- halos are (3, 3, 3); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. This PR relies on #1003 . Resolves #941",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1012:410,validat,validate,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1012,1,['validat'],['validate']
Security,"This PR splits `validation/bickley_jet.jl` into two scripts (one for the ""immersed bickley jet"" and one for the ""ordinary"" bickley jet) and somewhat improves the script for the ordinary bickley jet. @simone-silvestri I left the ""immersed bickley jet"" unchanged so you can continue to use it as is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2420:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2420,1,['validat'],['validation']
Security,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:948,inject,injecting,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['inject'],['injecting']
Security,This PR updates the baroclinic adjustment validations scripts. Closes #2291,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:42,validat,validations,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['validat'],['validations']
Security,This PR was supposed to be small but tests will probably take a while to run (my fault they're backed up) so feel free to add onto it. It would be very nice to access diagnostics and output writers by name.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525936330:160,access,access,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525936330,1,['access'],['access']
Security,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:602,expose,exposed,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['expose'],['exposed']
Security,"This captures a few changes, such as updates to `show`, `Callback` `parameters`, new field types, and boundary condition validation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2172:121,validat,validation,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2172,1,['validat'],['validation']
Security,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['validat'],['validation']
Security,"This input validation:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/Grids/input_validation.jl#L108. breaks the ""naive"" construction of grid domain that's used in `FieldTimeSeries`:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/OutputReaders/field_time_series.jl#L143. There, an `OffsetArray` with correct indexing (but incorrect size, according to the new restrictions on grid construction) is used to build a grid for `FieldTimeSeries` (when deserialization fails; typically this is because data was created with an old version of Oceananigans or a different Julia version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2588:11,validat,validation,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2588,1,['validat'],['validation']
Security,"This is a great PR, thanks @simone-silvestri for putting it together!. There is a script [here ](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/advection/plot_rates_convergence_advection.jl)that computes the convergence rates fro the different advection schemes. Given your results I'm sure that replacing `WENO5` by your new new version, would give the same results. . But this script uses a uniform grid. Would it be of interest trying this with a streteched grid to see what order of convergence we get with the different schemes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968980153:148,validat,validation,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968980153,1,['validat'],['validation']
Security,"This is a great validation test! The PR has gone stale so I'm going to close, but it'd be great if someone wants to revive this validation test in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-1104640370:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-1104640370,2,['validat'],['validation']
Security,"This is a link to the PDF, in case someone does not have easy access to JPO. https://www.researchgate.net/publication/341332653_Centrifugal_and_Symmetric_Instability_during_Ekman_Adjustment_of_the_Bottom_Boundary_Layer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802879976:62,access,access,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-802879976,1,['access'],['access']
Security,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:165,validat,validation,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,3,['validat'],['validation']
Security,This is the output of the 1D advection test in `validation/advection/simple_one_dimensional_advection.jl`. ![Screenshot 2024-02-13 at 12 41 25 PM](https://github.com/CliMA/Oceananigans.jl/assets/33547697/05a4651d-9106-4d81-b127-0ac0f9f9f42e),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942086368:48,validat,validation,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942086368,1,['validat'],['validation']
Security,"This is tough because there are an infinity of possible dumb mistakes. For many purposes, restricting the types of the keyword arguments may be simplest:. ```julia; julia> f(x; y::AbstractFloat=2.0) = x + y; f (generic function with 1 method). julia> f(1; y=2); ERROR: TypeError: in keyword argument y, expected AbstractFloat, got Int64; Stacktrace:; [1] (::getfield(Main, Symbol(""#kw##f"")))(::NamedTuple{(:y,),Tuple{Int64}}, ::typeof(f), ::Int64) at ./none:0; [2] top-level scope at REPL[6]:1; ```. I think this is a reasonable restriction for *outermost* constructors where we would otherwise use input validation that has exactly the same functional impact. Note that keyword arguments cannot be used for dispatch. Or, you can write a function:. ```julia; function validate_instance(argname, a); typeof(a) <: Type && throw(ArgumentError(""Argument $argname = $a is a `Type` rather than an instance of the type $a. Perhaps you meant to write $argname = $a()?"")); return nothing; end; ```. Then you can write. ```julia; validate_instance(""buoyancy"", buoyancy); ```. Or write a loop. ```julia; [validate_instance(arg, eval(arg)) for arg in (:buoyancy, :closure, :architecture)]; ```. Seems like a black hole to me, but maybe people will benefit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-541374330:605,validat,validation,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-541374330,1,['validat'],['validation']
Security,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394:430,validat,validation,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394,2,"['Validat', 'validat']","['Validate', 'validation']"
Security,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:226,expose,expose,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,1,['expose'],['expose']
Security,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['validat'],['validation']
Security,"This occurs because the work layout `:xyz` is used for `Computation`:. https://github.com/CliMA/Oceananigans.jl/blob/8d808881c5a277b44abff83f39dd470fe2f16324/src/AbstractOperations/computations.jl#L45. to fix this issue, we need three-dimensional layouts that increase their length by 1 on bounded dimensions. Since `work_layout` has access to `grid` already, this might be implemented with a keyword argument in `work_layout`, perhaps something like `include_boundaries` which is `false` by default. When `include_boundaries=true` the `worksize` should be increased by 1 on bounded dimensions:. https://github.com/CliMA/Oceananigans.jl/blob/8d808881c5a277b44abff83f39dd470fe2f16324/src/Utils/kernel_launching.jl#L40-L43",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/908#issuecomment-686610504:334,access,access,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/908#issuecomment-686610504,1,['access'],['access']
Security,This script has `using GLMakie` at the top:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lat_lon_barotropic_turbulence/visualize.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839176931:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839176931,1,['validat'],['validation']
Security,"This script:. ```julia; using Oceananigans, Plots. grid = RegularRectilinearGrid(size=(128, 128), x=(-5, 5), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump; bump(x, y, z) = z < exp(-x^2). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-2 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = UpwindBiasedThirdOrder(),; closure = IsotropicDiffusivity(ν = 1e-6, κ = 1e-6),; tracers = :b, ; buoyancy = BuoyancyTracer(),; immersed_boundary = bump,; forcing = (u = tidal_forcing,)); ; # Linear stratification with N² = 1; set!(model, b = (x, y, z) -> z); ; simulation = Simulation(model, Δt = 2e-3, stop_iteration=10000); run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]; u_plot = heatmap(xu, zu, u', title=""u velocity""). xb, yb, zb = nodes(model.tracers.b); b = interior(model.tracers.b)[:, 1, :]; b_plot = heatmap(xb, zb, b', title=""buoyancy""). ub_plot = plot(u_plot, b_plot, layout=(2, 1)) ; display(ub_plot); ```. produces. <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117941274-68faf000-b2b6-11eb-8eeb-e82abae50b82.png"">. The script is at `validation/immersed_boundary/internal_tide.jl`. Seems unfortunate that the time-step needs to be so short but perhaps that's right?. More work needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839561830:1174,validat,validation,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839561830,1,['validat'],['validation']
Security,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:546,validat,validation,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,1,['validat'],['validation']
Security,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733:521,validat,validation,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733,3,['validat'],['validation']
Security,"This then leads to an `Undef` error; ```julia; Got exception outside of a @test; UndefRefError: access to undefined reference; Stacktrace:; [1] #28164; @ ~/.julia/packages/Enzyme/aEyGD/src/rules/typeunstablerules.jl:793 [inlined]; [2] macro expansion; @ ./ntuple.jl:72 [inlined]; [3] ntuple(f::Enzyme.Compiler.var""...; @ Base ./ntuple.jl:69; [4] idx_jl_getfield_rev(::...; @ Enzyme.Compiler ~/.julia/packages/Enzyme/aEyGD/src/rules/typeunstablerules.jl:791; [5] iterate; @ ./namedtuple.jl:165 [inlined]; [6] iterate; @ ./generator.jl:44 [inlined]; [7] collect_to!; @ ./array.jl:892; [8] collect_to_with_first!; @ ./array.jl:870 [inlined]; [9] collect; @ ./array.jl:844 [inlined]; [10] _totuple; @ ./tuple.jl:425 [inlined]; [11] Tuple; @ ./tuple.jl:391 [inlined]; [12] update_boundary_condition!; @ ~/Documents/Projects/Oceananigans.jl/src/BoundaryConditions/update_boundary_conditions.jl:15 [inlined]; [13] #apply_regionally!#56; @ ~/Documents/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; [14] apply_regionally!; @ ~/Documents/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; [15] macro expansion; @ ~/Documents/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; [16] #update_state!#49; @ ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:38; [17] update_state!; @ ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2254591947:96,access,access,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2254591947,1,['access'],['access']
Security,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1273:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273,4,['validat'],['validation']
Security,This validation test essentially implements the tracer advection test:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/tracer_advection_over_bump.jl. but we should take care to make sure the boundary conditions are correct.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1574116905:5,validat,validation,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1574116905,2,['validat'],['validation']
Security,"Thoughts on your questions:. - I can imagine some people would prefer to type `FPlane` instead fo `GeneralFPlane`. Maybe we could keep the name of the former but get it to call the latter? Bascially keep the name but none of the code, as having fewer functions seems like a good idea.; - We could look at a propagating internal wave and measure it's phase speed. That would be one way to validate the Corioilis parameter, but maybe more complicated than other examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887460578:388,validat,validate,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887460578,1,['validat'],['validate']
Security,"To my mind there are three main ways to approach this:. 1. design simulations such that the output can be directly compared with analytical solutions;; 2. design simulations such that the statistics of the output can be compared with theory; or; 3. design simulations to mimic published results. Option 1 restricts us to systems with tractable analytical solutions, but still contains a wealth of feasible problems, such as:; 1. Munk gyre; 2. Spin down of a flow-field under the influence of friction; 3. Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; 4. Rayleigh–Bénard convection (as mentioned previously); 5. Onset of baroclinic instability: compare growth rates with analytical predictions. Option 2 lets us explore dynamics in the presence of turbulence. Potential test cases here include:; 1. 2D QG turbulence: explore energy and enstrophy cascades; 2. lee wave generation and breaking (will require large-scale flow field and bathymetry). Option 3 lets you do whatever you want - you just need to find a published result and try to reproduce it. It's unlikely that you'll get the exact same answer, so this option is more difficult to implement in a testing framework that doesn't require eyeballs to validate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237:1271,validat,validate,1271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467159237,1,['validat'],['validate']
Security,"To verify that the momentum equation is correctly implemented, we need a few validation tests. These can use `ExplicitFreeSurface`; getting `SplitExplicitFreeSurface` to work will be tackled separately. We should set the gravitational acceleration so that the barotropic wave speed is roughly 10x faster than the dynamics velocity (eg low Mach number). We propose 3 tests:. 1. Solid body rotation test. This can be implemented by attempting a free running simulation using the velocity field from the tracer advection test.; 2. Rossby-Haurwitz test, following https://github.com/CliMA/Oceananigans.jl/blob/main/validation/solid_body_rotation/rossby_haurwitz.jl; 3. Freely-decaying barotropic turbulence on the sphere (eg following https://github.com/CliMA/Oceananigans.jl/blob/v0.70.0/validation/near_global_lat_lon/freely_decaying_barotropic_turbulence.jl).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3265:77,validat,validation,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3265,3,['validat'],['validation']
Security,Try deleting `show_axis=false` from:; https://github.com/CliMA/Oceananigans.jl/blob/d4a462b259073b5c698f2cf9a8f419304f74262b/validation/barotropic_gyre/visualize_barotropic_gyre.jl#L64. ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122842967:125,validat,validation,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122842967,1,['validat'],['validation']
Security,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1619:107,access,access,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619,1,['access'],['access']
Security,"Two small notes:. - It could be nice (more Julian) to use `isapprox` with the `rtol` keyword for some of the validations, rather than `minimum`. - It save work in the future to write doc strings above the function definition rather than comment sections (typically enclosed between triple quotes, ie. ```; """"""; f(x). Returns `x^2`.; """"""; f(x) = x^2; ```; Doc strings are automatically detected and compiled to documentation by Julia's `Documenter.jl` package. Next, I'm having a little trouble with the logic of these functions:. What is happening under the flag `wavenumbers=:second_order`? If derivatives are calculated with second-order finite differences, then we have no need for Fourier wavenumbers --- correct? What does this flag mean?. Why are the square wavenumbers equal to `k² = @. (4 / Δx^2) * sin(π*n / N)^2`? These are not equispaced and not equal to the Fourier wavenumbers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440808299:109,validat,validations,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440808299,1,['validat'],['validations']
Security,"Type#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9884,hash,hash,9884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hash']
Security,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:90,checksum,checksum,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['checksum'],['checksum']
Security,"Unlike the `NonhydrostaticModel`, which has these lines:. https://github.com/CliMA/Oceananigans.jl/blob/1c96350d03e1ee066d5c9060089e043e15f711d6/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L120-L122. It's nice to validate the halos, because sometimes there are non-intuitive constraints (eg on #1994 we may have discovered that isopycnal closures need halos of size 2). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2041:225,validat,validate,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2041,1,['validat'],['validate']
Security,Update SWE immersed boundaries validation scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985,1,['validat'],['validation']
Security,Update `baroclinic_adjustment.jl` in validations exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545:37,validat,validations,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545,1,['validat'],['validations']
Security,Update cubed sphere 32 grid file sha256 checksum,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:40,checksum,checksum,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['checksum'],['checksum']
Security,Update lid-driven cavity validation experiment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1516:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516,1,['validat'],['validation']
Security,Update validation for distributed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3428:7,validat,validation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3428,1,['validat'],['validation']
Security,Updates `validation/periodic_advection.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1811:9,validat,validation,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1811,1,['validat'],['validation']
Security,Updates the `near_global_quarter_degree.jl` validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2743:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2743,1,['validat'],['validation']
Security,Updates to validation and docs for distributed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429:11,validat,validation,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429,1,['validat'],['validation']
Security,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:914,access,access,914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['access'],['access']
Security,Uses ValueBoundaryCondition in stratified couette flow validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1982:55,validat,validation,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1982,1,['validat'],['validation']
Security,"Using the `FFTBasedPoissonSolver` in complex domains on the `ImmersedBoundaryGrid` leads to resulting solution that either. 1. Does not conserve tracers in the flow; or; 2. Leads to divergent flow along the immersed boundary. On the other hand, using the `PreconditionedConjugateGradientSolver` on complex domains leads to exact solution at a much slower speed on the GPU. This PR implements an `ImmersedPressureSolver` that uses the `FFTBasedPoissonSolver` as a preconditioner, then iterates `PreconditionedConjugateGradientSolver` to arrive at the correct solution. This approach is much faster than using a vanilla `PreconditionedConjugateGradientSolver` as the number of iterations scale much more slowly with grid size on the GPU. This PR will include the `ImmersedPressureSolver`, a few validation examples for benchmarking purposes and a number of example use cases where this solver would be useful. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188:793,validat,validation,793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188,1,['validat'],['validation']
Security,Validate Implementation of Orthogonal Spherical Shell Grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3222:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222,1,['Validat'],['Validate']
Security,Validate `boundary_conditions` argument to model constructors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3788:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3788,1,['Validat'],['Validate']
Security,Validate boundary conditions on Fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['Validat'],['Validate']
Security,Validate field boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['Validat'],['Validate']
Security,Validate the convergence rates for advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650:0,Validat,Validate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650,1,['Validat'],['Validate']
Security,Validation + Convergence tests: images not showing up,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459,1,['Validat'],['Validation']
Security,Validation Experiments in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1696:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696,1,['Validat'],['Validation']
Security,Validation and performance benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['Validat'],['Validation']
Security,Validation script for flow over immersed hills fails in `bottom_drag` case,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Validat'],['Validation']
Security,Validation test: Abernathey et al 2011,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/774:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774,1,['Validat'],['Validation']
Security,Validation tests for immersed boundary implementations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775,1,['Validat'],['Validation']
Security,Validation tests of numerical convergence,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767:0,Validat,Validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767,1,['Validat'],['Validation']
Security,"VectorInvariant momentum advection ""scheme"" and Bickley jet validation example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366:60,validat,validation,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366,1,['validat'],['validation']
Security,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:910,access,access,910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937,1,['access'],['access']
Security,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:316,validat,validation,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['validat'],['validation']
Security,"WE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface = ExplicitFreeSurface(; gravitational_acceleration = 10),; closure = nothing,; tracers = nothing,; buoyancy = nothing); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572:949,access,access,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572,1,['access'],['access']
Security,We also had this problem on `Thermodynamics` and it was fixed by re-opening the PR from the repo rather than a fork. There is a security issue because you may not want to run buildkite jobs from random people (despite that we definitely do want to run buildkite for PRs from @josuemtzmo <3).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1997659329:128,secur,security,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3506#issuecomment-1997659329,1,['secur'],['security']
Security,We are almost there... for what concerns advection (and Coriolis term) it seems like we're ok. I am not equally sure about bathymetry and closures. If you want to take a look at it go ahead! I think we can wait till the end of this week to merge so that we can finish validating all the terms a bit better,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1137236644:268,validat,validating,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1137236644,1,['validat'],['validating']
Security,"We can add some validation to the inner constructor for `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Fields/field.jl#L13-L16. I think three lines along the lines. ```julia; validate_boundary_conditions(X, topology(grid, 1), bcs.x); validate_boundary_conditions(Y, topology(grid, 2), bcs.y); validate_boundary_conditions(Z, topology(grid, 3), bcs.z); ```. might work. Then we can write a couple methods for `validate_boundary_conditions. ```julia; function validate_boundary_conditions(loc, topo, bcs, dir); validate_boundary_condition(loc, topo, bcs.left, dir, :left); validate_boundary_condition(loc, topo, bcs.right, dir, :right); return nothing; end. function validate_boundary_condition(loc, ::Periodic, bc::BoundaryCondition{C}, dir, side) where C; C === BoundaryConditions.Periodic ||; error(""$side boundary condition type $C in $dir at location $loc is invalid; must be Periodic""); return nothing; end. function validate_boundary_condition(::Face, ::Bounded, bc::BoundaryCondition{C}, dir, side) where C; C === NormalFlow || error(""$side boundary condition type $C in $dir at location Face is invalid; must be NormalFlow""); return nothing; end. function validate_boundary_condition(::Cell, ::Bounded, bc::BoundaryCondition{<:NormalFlow}, dir, side) =; error(""$side boundary condition in $dir at location Cell cannot be NormalFlow.""); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/890#issuecomment-699575845:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/890#issuecomment-699575845,1,['validat'],['validation']
Security,We can delete this validation test too after this: https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/internal_tide.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575780453:19,validat,validation,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575780453,2,['validat'],['validation']
Security,We could to suggest wrapping the `Reduction` in a `Field`. I'm not 100% sure the best way to inject that kind of hint; we don't own operations like `/` so I think to do that we would have to define them (and then throw an error). Hmm.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891:93,inject,inject,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891,1,['inject'],['inject']
Security,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682:709,access,accessible,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682,1,['access'],['accessible']
Security,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:352,access,access,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['access'],['access']
Security,"We need to overhaul the way we specify advection schemes, whose current limitations were exposed when ""WENO vector invariant"" was implemented. I propose that we implement a hierarchical specification system using a new object called `AdvectionScheme` that specifies. 1. The ""form"" of the advection operator for momentum and tracers (either `VectorInvariant` or `FluxForm` for momentum, always `FluxForm` for tracers); 2. For `FluxForm`, the reconstruction scheme for the advected component ; 3. For `VectorInvariant`, the stencil for _computing_ vorticity, as well as the method for _reconstructing_ vorticity at the momentum locations; 4. For `VectorInvariant` with WENO reconstruction, the type of the smoothness stencil (vorticity or velocity); 5. The method for reconstruction velocities in mass conservation (continuity) as well as tracer advection. We also may want to specify how we reconstruction _advecting_ velocities for flux form momentum advection (right now we use centered advection with an accuracy one order lower than the accuracy of the advected component reconstruction --- ie with `UpwindBiasedFifthOrder()` we reconstruct advecting components with a centered fourth order scheme). Finally, we need to allow different schemes for every tracer. This modular design will allow more detailed specification of an advection scheme and also us to remove the option for WENO reconstruction for vector invariant more easily, which @simone-silvestri pointed out is experimental. We also would like to explore alternative discretization for the continuity equation. For this we need a ""mass"" reconstruction scheme, and the advecting scheme for tracers needs to reconstruct `advected_velocity` in a way that's consistent with the mass reconstruction. Here's a sketch of what these new types might look like:. ```julia; """""" Specifies a reconstruction scheme for fluxes of the form u * c,; where u is the `advecting_velocity` and c is the `advected_quantity` """"""; struct FluxFormAdvection; adv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454:89,expose,exposed,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454,1,['expose'],['exposed']
Security,We should figure out an interface to help users access grid metrics. We shouldn't have to write things like `grid.Δxᵃᵃᶜ` in the examples. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/2050#issuecomment-967266791_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058:48,access,access,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058,1,['access'],['access']
Security,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/136:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136,1,['validat'],['validation']
Security,We validate boundary conditions now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-1100254368:3,validat,validate,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-1100254368,1,['validat'],['validate']
Security,"We've discussed moving `validation` to another repo in the past. Certainly that would decrease our maintenance burden during development, while tracking the Oceananigans version that the validation scripts are ""guaranteed"" to work with. The main downside I think is that the validation repo goes stale by design. By putting `validation` in `Oceananigans` and requiring the scripts to run during CI we ""enforce"" that the scripts are up to date with the API implemented in `master`. This helps the validation scripts better serve their purpose... One solution might be to split up the scripts in `validation/`. A growing number of the `validation` cases really just use an ""eyeball"" norm and more serve to demonstrate functionality than to ""validate"" it in a scientific sense. (This includes the immersed boundary case.) Perhaps we can create a new repo for these cases which achieve most of their value as ""advanced examples"", while keeping quantitatively valuable validation cases in the main repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832055527:24,validat,validation,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832055527,9,['validat'],"['validate', 'validation']"
Security,"Well!. It looks like the ""compute capability"" of an NVIDIA device determines the kind of computations it can do:. https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capabilities. Your device, which is an ""NVS 310"", has a compute capability of 2.1:. https://developer.nvidia.com/cuda-gpus. Apparently this compute capability is not supported by the julia CUDA tools. So I'm not sure you can resolve this issue, other than finding a different GPU. The issue you pasted briefly explains why this might be the case; it has something to do with the compiler used by `CUDAdrv`?. We typically use the Tesla V100 or P100, which apparently have compute capabilities of 7.0 or 6.0. I'm not 100% sure the NVS 310 would accelerate computations relative to your CPU anyways. It only has 48 cores (compared to 5,120 for a Tesla V100), and 512 MB of memory?. https://www.nvidia.com/en-us/design-visualization/nvs-graphics-cards/. Do you have access to a cluster with GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539791534:949,access,access,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539791534,1,['access'],['access']
Security,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514:821,validat,validation,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514,1,['validat'],['validation']
Security,What about `validation/elliptic_solvers`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3052#issuecomment-1498341815:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3052#issuecomment-1498341815,1,['validat'],['validation']
Security,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:717,validat,validate,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['validat'],['validate']
Security,What are the criteria of the validation test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-641387654:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771#issuecomment-641387654,1,['validat'],['validation']
Security,"What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. > and the number of times it accesses this condition changes based on what's on the output list. Is this expected?. I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733:133,access,accesses,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873151733,2,['access'],"['access', 'accesses']"
Security,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280:305,access,access,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280,1,['access'],['access']
Security,Where could we find a function for the free surface equation linear operator? I would like to replace `compute_∇²!` in the following line https://github.com/CliMA/Oceananigans.jl/blob/aea5494a763eb3949b234b5302ddb0a2e9764678/validation/elliptic_solvers/doubly_bounded_poisson.jl#L94,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1161302426:225,validat,validation,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1161302426,1,['validat'],['validation']
Security,"While bathymetry is not a priority at the moment, there may be simple, non-invasive methods (from an algorithms standpoint) like the one described in the slack message pasted by @ali-ramadhan for modeling non-rectangular domains. . Probably the main challenge is not implementing the method (which could take a few days), but verifying and validating the implementation (more likely a few weeks of work at minimum). A collaboration with others who are knowledgeable in Julia and can participate in debugging and validation is probably the best chance for having this feature implemented any time soon, given the time constraints of the main developers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644:340,validat,validating,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644,2,['validat'],"['validating', 'validation']"
Security,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:698,access,access,698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['access'],['access']
Security,"Who can edit? I guess those with repo write access, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2470#issuecomment-1112673782:44,access,access,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470#issuecomment-1112673782,1,['access'],['access']
Security,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,1,['validat'],['validation']
Security,"Working with @arnscheidt to output vorticity to NetCDF the code below is what we came up with but it feels quite cumbersome and required us to define some boilerplate `get_vorticity` function so it can all be accessed on demand by the `NetCDFOutputWriter`. I wonder if we can improve the interface to allow users to easily pipe the output of abstract operations to disk. One approach might be to add explicit support for abstract operations to output writers. `NetCDFOutputWriter` already knows what to do if you give it a field or a function. We can tell it to do all this in the background if given an abstract operation like `vorticity_operation = ∂x(v) - ∂y(u)`. ```julia; u, v, w = model.velocities; vorticity_operation = ∂x(v) - ∂y(u); ω = Field(Face, Face, Cell, model.architecture, model.grid, TracerBoundaryConditions(grid)); vorticity_computation = Computation(vorticity_operation, ω). function get_vorticity(model); compute!(vorticity_computation); return Array(interior(ω)); end. fields = Dict(..., ""vorticity"" => get_vorticity); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/653:209,access,accessed,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653,1,['access'],['accessed']
Security,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728:354,validat,validation,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728,1,['validat'],['validation']
Security,"Would a diagonal advection problem expose the difference between dimension-by-dimension WENO and ""true"" 2D WENO?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172615024:35,expose,expose,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172615024,1,['expose'],['expose']
Security,"X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:2736,validat,validation,2736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['validat'],['validation']
Security,"Yeah I agree with no code being better than broken code. So I guess that means nuke non-working scripts and they can always be revived later with the intention of maintaining them long-term. Also agree that sandbox is bad. We can discourage further short-term additions to `validation` and encourage people to use branches or other short-term repositories for them?. As for repo size yeah the biggest files are images and regression files which we could aim to get rid of in the long-term, maybe in one fell swoop with BFG repo cleaner. We've done in the past but it takes some preparation and is rewriting git history which is bad.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473:274,validat,validation,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473,1,['validat'],['validation']
Security,"Yeah I think some of those one-off experiments in `validation` should probably be nuked. Maybe we should put them in a `sandbox` directory in the future. Ideally they would serve both as actual validation against existing results (e.g. convergence test, lid-driven cavity, viscous flow around a cylinder) and as advanced examples, so maybe they should become Literate examples (or Pluto examples/notebooks...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143,2,['validat'],['validation']
Security,"Yeah not sure what's happening at the equator. Maybe we need even more gravity?. The corner blow up is probably due to #1584 though, so we should be able to fix it soon and re-run with momentum advection. @sandreza Is it okay if we turn the Rossby-Haurwitz and spherical Bickley jet into validation experiments or would you rather keep them as examples?. I think in the end, validation experiments will serve as ""advanced examples"" once we have some time to clean them up and put them in the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-819649881:288,validat,validation,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-819649881,2,['validat'],['validation']
Security,"Yeah, sorry! That's what I meant. I think that would keep the validations up-to-date, and we'd only have to cater to it when we bump the Oceananigans version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832265842:62,validat,validations,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832265842,1,['validat'],['validations']
Security,"Yeah, the lat-lon grid does not `validate` Flat directions, we can change that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143584189:33,validat,validate,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143584189,1,['validat'],['validate']
Security,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:929,validat,validation,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,1,['validat'],['validation']
Security,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:529,validat,validation,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924,2,['validat'],['validation']
Security,"Yes, from what I could test so far the CPU performance seems roughly; equivalent between versions. Although it would be good if someone else; tried to validate that as well. On Fri, Jun 25, 2021, 09:16 Gregory L. Wagner ***@***.***>; wrote:. > I'm sorry, I misinterpreted the results @ali-ramadhan; > <https://github.com/ali-ramadhan> posted. I thought that; > CenteredSecondOrder was 1.0x slower with julia 1.6 than with 1.5 (and; > that small slowdowns were observed for the other schemes, which is why I; > recommended testing the biharmonic scheme.) Now I understand that these; > results are all for julia 1.6; we are comparing the results with previously; > obtained benchmarks (not posted) for julia 1.5.; >; > Looking at @tomchor <https://github.com/tomchor> and @ali-ramadhan; > <https://github.com/ali-ramadhan>'s results then it looks like; > simulations with WENO5 are running approximately 6-8 times slower on julia; > 1.6 than it was on julia 1.5, while other advection schemes (and closures); > are unchanged --- correct?; >; > Is the *CPU* performance of WENO5 roughly equivalent between julia 1.5; > and julia 1.6?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868677634>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KV46VENYCZPAGUMK4LTUSTVVANCNFSM47I24R7Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868684330:151,validat,validate,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868684330,1,['validat'],['validate']
Security,"Yestereday, @simone-silvestri and I had a chat and discussed the current state of the shallow water model. We found that if we ignore this PR and run the validation script on main, then it runs for 20 days before it blows up. This is different from what we saw a year or two ago, but that is the current state of affairs. We observed that there were very strong zonal velocities, `+25 m/s`, that occured in the arctic and the antarctic. This is presumably what gives rise to `NaN`'s that appear. Maybe there is a problem with the immersed boundary method, we are not sure. We took a side step and decided to study an acquaplanet case on main. We removed the continents and made the bathymetry flat. Below are the plots of `u,v,h` after 59 days. Note that you can still see the continents but I think that's because there is no forcing over land. Some good news is that we do see the ACC and it's moving in the right direction! @navidcy . We also see that the velocites are much more reasonable, around `.1 m/s`. . One odd bit is the height field seems to be `0` at the top and bottom. I am including an animation of `u,h` in case that is of interest. Thoughts?. ![u_20days](https://github.com/CliMA/Oceananigans.jl/assets/8239041/dcd79861-6368-45d2-b7ee-8c2431168446). ![v_20days](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b736f43c-a601-4f6e-99ae-7658b2c4381a). ![h_20days](https://github.com/CliMA/Oceananigans.jl/assets/8239041/ef743f9e-3894-42d3-be97-401e6e3fe0d7). https://github.com/CliMA/Oceananigans.jl/assets/8239041/035bb9ed-ce4b-42f1-ac7c-c17235d2aad9",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2061191965:154,validat,validation,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2061191965,1,['validat'],['validation']
Security,"You are right, I did something wrong with the output writers, I hadn't realized it is a problem of halos, I ll try to give a better look. The only thing that I had to change for output writers is to validate BC when non trivial indices are given as an argument. . That `view(field, indices...)` confused me though. I guess by changing that I had fields saved with halos?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257887145:199,validat,validate,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257887145,1,['validat'],['validate']
Security,"You could use two AnisotropicDiffusivity closures (or 3?) that individually set the diffusivities in each direction. Then you can test that a model which uses a single closure with all three diffusivities returns the same result as a model with a 3-tuple of different closures. That actually might be good enough for a bona fide test, not just a validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947:346,validat,validation,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947,1,['validat'],['validation']
Security,"Your are correct @apaloczy that we need to be careful. One thing I should point out is that we are solving the equations in conservation form, so it is a bit differente than the link you cited. If you look at equations 7 to 9 in this [paper](https://journals.ametsoc.org/view/journals/phoc/35/5/jpo2719.1.xml) then you will see how this is written in conservation form. Note that the syntax is `h` is the total depth and `h_B` is the height of the topography. . Also, this paper simulates the instabilty of a geostrophically balanced Bickley jet over sloping topogrpahy. We could take the `ShallowWaterModel` example and modify the parameters slightly to reproduce the results in this paper, if we wanted some validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156510:710,validat,validation,710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156510,1,['validat'],['validation']
Security,"Zarr looks interesting! Sounds like we'd need a good internet connection (e.g. on Google Cloud) but might be cool for accessing datasets over OpeNDAP (can it do that?) or saving tons of data to a cloud storage bucket. We could easily play around with a Zarr output writer on a branch (could try ZarrNative.jl or the python implementation with PyCall). And no, we haven't talked with JuliaGeo. Seems like it's a more GIS oriented organization, but could be helpful to get in touch with @yeesian.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475656904:118,access,accessing,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475656904,1,['access'],['accessing']
Security,"[3] _permute_index at /home/alir/Oceananigans.jl/src/Solvers/index_permutations.jl:11; [4] permute_index at /home/alir/Oceananigans.jl/src/Solvers/index_permutations.jl:24; [5] macro expansion at /home/alir/Oceananigans.jl/src/Solvers/solve_for_pressure.jl:39; [6] gpu_calculate_pressure_right_hand_side! at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/macros.jl:80; [7] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:4082,validat,validate,4082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['validat'],['validate']
Security,"] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; in expression starting at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:91; ```. So basically there are six errors starting with the lid_driven_cavity at the top level going all the way down to input_validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:1985,validat,validation,1985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,3,['validat'],['validation']
Security,"` is to provide a way for users to define a function of `x, y, z, t`. However, there are other cases, perhaps less common but still important, where one might want `x, y, z, t, parameters`. . In the case that parameters are `nothing` (the default), the `SimpleForcing` function assumes that `func` is a function of `x, y, z, t`. If parameters are specified in the construction of the `SimpleForcing` object, eg. ```julia; forcing = SimpleForcing((x, y, z, t, p) -> p.a * x^2, parameters = (a=2,)); ```; then `func` must have the signature `x, y, z, t, parameters`, where `parameters` corresponds to the parameters object passed by the user to `SimpleForcing`. We could delete the `parameters` field in `SimpleForcing` and replace it with a boolean type parameter, say `with_parameters`, which indicates that `func` is a function of `x, y, z, t, p` and that `p` corresponds to `model.parameters`. Do you think this is better? . At the time this code was written I considered this possibility, but I felt the ""non-locality"" of that usage made it a bit trickier (ie, one builds `SimpleForcing` but adds `parameters` to `Model`, rather than building `SimpleForcing` and specifying parameters in `SimpleForcing`). . It seems local straightforward things like that are preferred over seemingly more elaborate interlocking systems --- but maybe I'm wrong? The advantage of local usage realizes itself when you might consider many alternative `SimpleForcing` functions. Then, rather than having to change two lines when you want to change the forcing function (since you'd have to both change the definition of your forcing function *and* change `model.parameters`), you can just change the definition of a single `SimpleForcing` object. This seems better to me. But maybe its not. Note that we have common names for subfields in many other places. For example, each field has a subfield called `data`, and we know through context that `u.data` is not the same as `v.data`. Doesn't the same logic apply here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564733831:1364,interlock,interlocking,1364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565#issuecomment-564733831,1,['interlock'],['interlocking']
Security,"`@sprintf` / `@printf` formatters allow right-padding with the syntax `% 123s`, where `123` is the number of spaces. for example:. ```julia; julia> a = ""hi""; ""hi"". julia> b = ""bye""; ""bye"". julia> c = ""yeah sure""; ""yeah sure"". julia> @printf(""a: % 12s\nb: % 12s\nc: % 12s"", a, b, c); a: hi; b: bye; c: yeah sure; ```. Other points:. * The plot looks great!; * I would suggest just merging this plot and working on new advection schemes in another PR.; * You can let a validation script depend on `Polynomials` without adding `Polynomials` to the Oceananigans `Project.toml`. There's a few other validation scripts that depend on random packages that are not a part of Oceananigans.; * This PR also adds a bunch of new examples that are variants on the Bickley jet. Probably not intended?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343:467,validat,validation,467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343,2,['validat'],['validation']
Security,`LatitudeLongitudeGrid` validation seems to be leaky,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:24,validat,validation,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,1,['validat'],['validation']
Security,"`NetCDFOutputWriter` constructor says that ""`outputs` (which can be a; `Dict` or `NamedTuple`)"" but this line does not work on named tuples. https://github.com/climate-machine/Oceananigans.jl/blob/a511fdd2fedc9aae49a76905be24fdc60c2d60b0/src/OutputWriters/netcdf_output_writer.jl#L162. ```julia; julia> nt = (a=2, b=4, c=8); (a = 2, b = 4, c = 8). julia> for (i, j) in nt; @show i, j; end; ERROR: BoundsError: attempt to access Int64; at index [2]; Stacktrace:; [1] indexed_iterate(::Int64, ::Int64, ::Nothing) at ./tuple.jl:72; [2] top-level scope at ./REPL[4]:1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/553:421,access,access,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553,1,['access'],['access']
Security,`Nz=1` is probably broken for `DistributedFFTPoissonSolver` right now:. https://github.com/CliMA/Oceananigans.jl/blob/a94d27afcd5c2c26f2a6cbd65a54acc4394f592f/src/Distributed/distributed_fft_based_poisson_solver.jl#L49-L50. We want to support this case to make implementing a distributed FFT-based implicit free surface solver straightforward. We're hashing it out on https://github.com/jipolanco/PencilFFTs.jl/issues/43.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2533:350,hash,hashing,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2533,1,['hash'],['hashing']
Security,"```julia; function Stokes_drift(τ, z); kᵖ = peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); return uˢ₀ * (T₁(kᵖ, z) + T₂(kᵖ, z)); end; ```; I think it should be `T₁(kᵖ, z) - T₂(kᵖ, z)` in the above code? It might explain why the maximum Stokes drift in the figure is below the surface rather than at the surface. >It'd be nice to have a way of validating this. . One way is to use the observation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:347,validat,validating,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704,1,['validat'],['validating']
Security,"`dynamics` is just a function called with this signature:. https://github.com/CliMA/Oceananigans.jl/blob/9b67d4d106c905918866e0edb527def0edcc367f/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl#L140. I found that just by reading the source code. It's all contained in three files here:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/Models/LagrangianParticleTracking. For buoyant particles I think you want to add a velocity increment to the particle position. But it'd be nice if users didn't have to do this manually, ie if we could add additional advecting velocities. I think there's a PR about that floating around... Unfortunately since docs are pretty spare I think you're going to have to be reading the source code. Documentation PRs definitely welcome!. Another thought about the error in this issue: I think it would make sense to validate the `tracked_fields`. For example each property should be `AbstractField` with a proper `location(field)`, otherwise the error in the post is received (the location was evaluated to `nothing, nothing, nothing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136324615:871,validat,validate,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136324615,1,['validat'],['validate']
Security,"`julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2715,validat,validation,2715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,1,['validat'],['validation']
Security,"`xnodes, ynodes, znodes` are exported so users should have access to them after saying `using Oceananigans`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2986#issuecomment-1475117843:59,access,access,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2986#issuecomment-1475117843,1,['access'],['access']
Security,`∇²ᶜᶜᶜ` gives the right solution for the pressure solver (correct as in no flow divergence at the boundary) that we are developing for the `ImmersedPoissonSolver` here:; https://github.com/xkykai/Oceananigans.jl/blob/df579ed61935378273f2f0e3df0706554be22c30/validation/immersed_boundaries/immersed_pressure_solver.jl#L114,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2915#issuecomment-1426277751:258,validat,validation,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2915#issuecomment-1426277751,1,['validat'],['validation']
Security,a 20-year integration of the quarter degree simulation (in `validation/near_global_lat_lon/near_global_quarter_degree.jl`) using the following as a free surface:. ```; Δt = 10minutes # probably we can go to 10min or 15min?; CFL = 0.7. wave_speed = sqrt(g_Earth * grid.Lz); Δg = 1 / sqrt(1 / min_Δx(grid)^2 + 1 / min_Δy(grid)^2). @show substeps = Int(ceil(2 * Δt / (CFL / wave_speed * Δg))). free_surface = SplitExplicitFreeSurface(; substeps); ```. https://user-images.githubusercontent.com/33547697/217328677-9c737e8d-140b-4a9f-92b9-d42f5d364a3d.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576:60,validat,validation,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576,1,['validat'],['validation']
Security,"acer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_dudy_diff](https://user-images.githubusercontent.com/67593861/122987679-dc405900-d36e-11eb-895a-0f66daf9a473.png). Any thought on these results would be greatly appreciated, or if there is something else that might be good to look at with this particular test case. Further refinements to the grid are taking quite a long time to run on my PC, but they can be done. These were run with a viscosity of 0 for the isotropic closure. I want to look at the viscous cases of these to see if the results change at all with added viscosity. I'm also working on some cylinder validation metrics for this IBM, but we can move forward without those for now if we like what we're seeing here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:2568,validat,validation,2568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,1,['validat'],['validation']
Security,"ackages/KernelAbstractions/jAutM/src/macros.jl:80; [4] overdub at /home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] macro expansion at /home/glwagner/.julia/packages/Oceananigans/cLFd3/src/Fields/computed_field.jl:86; [2] gpu__compute! at /home/glwagner/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:80; [3] overdub at /home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/glwagner/.julia/packages/TimerOutputs/ZmKD7/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:39; [6] compile at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:35 [inlined]; [7] cufunction_compile(::GPUCompiler.FunctionSpec; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/glwagner/.julia/packages/CUDA/YeS8q/src/compiler/execution.jl:310; [8] check_cache(::Dict{UInt64,Any}, ::Any, ::Any, ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053:10916,validat,validate,10916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053,1,['validat'],['validate']
Security,"all to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5448,validat,validate,5448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validate']
Security,"ally we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a draft PR for now because there are some things that need doing:. - [x] Generalize the filter for stretched grids. For now it assumes a regular grid for simplicity, but it's trivial to generalize.; - [x] Optimize the calculation of the coefficient. At the moment I'm creating four extra fields in order to calculate the Smag coefficient: `LM`, `MM` are 3D fields; and `LM_avg` and `MM_avg` are 1D or 2D. What I'm doing is to first calculate $L_{ij} M_{ij}$ and $M_{ij} M_{ij}$ pointwise, and then `LM_avg` and `MM_avg` receive their averages. We should be able to calculate everything without needing `LM`, `MM` are 3D fields, I just couldn't figure out how yet :); - [ ] Write docs; - [x] Write tests; - [x] Validate that model is working as intended. CC @glwagner @simone-silvestri @xkykai @whitleyv . Feel free to add more things to the to-do list that I may have forgotten.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:2708,Validat,Validate,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['Validat'],['Validate']
Security,"an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of proces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5097,authenticat,authentication,5097,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['authenticat'],['authentication']
Security,"as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, wor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36684,validat,validate,36684,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['validat'],['validate']
Security,"ast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:3098,validat,validate,3098,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['validat'],['validate']
Security,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:605,access,access,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533,2,['access'],['access']
Security,"ate_pressure_right_hand_side! at /home/alir/.julia/packages/KernelAbstractions/xslEz/src/macros.jl:80; [7] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/GKp4B/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323:4357,validat,validate,4357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828#issuecomment-700320323,1,['validat'],['validate']
Security,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2046,attack,attack,2046,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,2,['attack'],['attack']
Security,"ays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Function, ::Function, ::Int64); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> interior(my_windowed_field, :, :, 5:6); ERROR: BoundsError: attempt to access 2×3×2 view(::Array{Float64, 3}, 3:4, 3:5, :) with eltype Float64 at index [1:2, 1:3, 5:6]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, ::Function, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:184; [4] interior(::Field{…}, ::Function, ::Function, ::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:395; [5] top-level scope; @ REPL[10]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; I will create a PR to address the second issue, as suggested by @simone-silvestri.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:3890,access,access,3890,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['access'],['access']
Security,"buted grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:2590,validat,validation,2590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['validat'],['validation']
Security,can we put `validation/implicit_free_surface/implicit_surface_solvers_benchmark.jl` in the benchmark folder?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690,1,['validat'],['validation']
Security,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:2111,access,access,2111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['access'],['access']
Security,closes #3681. We can probably use this PR to add also a validation for the `PartialCellBottom` and the bug-fixes in the implementation.; What do people think?. cc @jm-c,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682:56,validat,validation,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682,1,['validat'],['validation']
Security,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606:1449,access,access,1449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606,1,['access'],['access']
Security,"cs, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordinates other than `z`. We can either call the new field `model.stokes_drift` or `model.surface_waves`. We can validate our implementation by reproducing results in [McWilliams et al (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), [Polton and Belcher (2007)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2007JC004205), and [Skyllingstad and Denbo (1995)](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94JC03202?casa_token=EqggenV30loAAAAA:Qu8czM4PvMqLP486Ma1BUZen0CPIuGZgyVDXrIoYnopbmOUDzbwwmH1BiftvEvIpzuV1_l9J6LgXkGE). cc @johncmarshall54",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/443:2269,validat,validate,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443,1,['validat'],['validate']
Security,"cts/Oceananigans.jl/sandbox/simple_forcing.jl:22; [3] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [4] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] FS at /archive1/glwagner/Projects/Oceananigans.jl/sandbox/simple_forcing.jl:22; [2] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [3] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); Stacktrace:; [1] calculate_interior_source_terms! at /archive1/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:178; [2] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Stacktrace:; [1] check_ir(::CUDAnative.CompilerJob, ::LLVM.Module) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/validation.jl:114; [2] macro expansion at /data5/glwagner/.julia/packages/TimerOutputs/7zSea/src/TimerOutput.jl:216 [inlined]; [3] #codegen#119(::Bool, ::Bool, ::Bool, ::Bool, ::Bool, ::Function, ::Symbol, ::CUDAnative.CompilerJob) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/driver.jl:186; [4] #codegen at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/driver.jl:0 [inlined]; [5] #compile#118(::Bool, ::Bool, ::Bool, ::Bool, ::Bool, ::Function, ::Symbol, ::CUDAnative.CompilerJob) at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/driver.jl:47; [6] #compile#117 at ./none:0 [inlined]; [7] compile at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/compiler/driver.jl:28 [inlined] (repeats 2 times); [8] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/9rZcJ/src/execution.jl:378 [inlined]; [9] #cufunction#159(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468:4011,validat,validation,4011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496489468,1,['validat'],['validation']
Security,"d, apparently, `Σ² = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2069,validat,validation,2069,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,1,['validat'],['validation']
Security,"ddle of the domain; > 2. sets u and v zero everywhere except for a couple of points **inside the bump**?; > 3. the island isn't fully centered; > 4. it solves something for a potential inside the island; > 5. the velocities inside the island are adjusted?; > ; > does the setup make sense to you two?. Here is some output with print added for 5 x 5 version (and with g=1000 ). The solvers don't iterate I think - because Ax == 0? . Also the island is not quite centered? . ```; (base) chriss-MacBook-Pro:onan-2021-12-29 chrishill$ /Applications/Julia-1.7.app/Contents/Resources/julia/bin/julia --project=. test/runtests.jl ; [2021/12/29 11:49:20.908] INFO Testing immersed boundaries divergent flow solve; bottom; 5×5 Matrix{Float64}:; -1.0 -1.0 -1.0 -1.0 -1.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; -1.0 0.0 0.0 0.0 0.0; [2021/12/29 11:49:27.354] WARN ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues. -@-> /Users/chrishill/projects/onan-2021-12-29/src/ImmersedBoundaries/ImmersedBoundaries.jl:102; [2021/12/29 11:49:27.400] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /Users/chrishill/projects/onan-2021-12-29/src/Advection/weno_fifth_order.jl:145; model.free_surface.gravitational_acceleration = 10000.0; ∫ᶻQ.u; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; η; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 1:1) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 -1.0 4.0 -1.0 0.0; 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; u before; 5×5×1 view(::Array{Float64, 3}, 4:8, 4:8, 4:4) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167:1153,validat,validate,1153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131#issuecomment-1002686167,1,['validat'],['validate']
Security,"dic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.Com",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:4780,validat,validation,4780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validation']
Security,"dition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}:; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:9406,access,access,9406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,1,['access'],['access']
Security,"e a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1454,access,accessible,1454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['access'],['accessible']
Security,"e docstring (including a random path to someone's Oceananigans version, eg `Research/OC11.jl`:. ```; help?> MultiRegionGrid; search: MultiRegionGrid multi_region_grid MultiRegionField MultiRegionObject. MultiRegionGrid(global_grid; partition = XPartition(2),; devices = nothing,; validate = true). Split a global_grid into different regions handled by devices. Positional Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • global_grid: the grid to be divided into regions. Keyword Arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • partition: the partitioning required. The implemented partitioning are XPartition (division along the x direction) and; YPartition (division along the y direction). • devices: the devices to allocate memory on. If nothing is provided (default) then memorey is allocated on the the CPU.; For GPU computation it is possible to specify the total number of GPUs or the specific GPUs to allocate memory on. The; number of devices does not need to match the number of regions. • validate :: Boolean: Whether to validate devices; defautl: true. Example; ≡≡≡≡≡≡≡. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(12, 12), extent=(1, 1), topology=(Bounded, Bounded, Flat)); 12×12×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on CPU with 3×3×0 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.0833333; ├── Bounded y ∈ [0.0, 1.0] regularly spaced with Δy=0.0833333; └── Flat z. julia> multi_region_grid = MultiRegionGrid(grid, partition = XPartition(4)); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/Research/OC11.jl/src/MultiRegion/multi_region_grid.jl:108; MultiRegionGrid{Float64, Bounded, Bounded, Flat} partitioned on CPU():; ├── grids: 3×12×1 RectilinearGrid{Float64, RightConnected, Bounded, Flat} on CPU with 3×3×0 halo; ├── partitioning: Equal partitioning in X with (4 regions); ├── connectivity: MultiRegionObject{Tuple{@NamedTuple{west::Nothing, east::Oceanani",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336:1134,validat,validate,1134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287773336,2,['validat'],['validate']
Security,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:1922,validat,validation,1922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,5,['validat'],['validation']
Security,"eArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/utils.jl:68; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.Multiplicati",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:7215,validat,validate,7215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['validat'],['validate']
Security,"eldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl/blob/063680d4650787f028a301054559a816f5450ac3/src/Fields/set!.jl#L60. As far as I can tell the difference between this and the main branch is that `copyto!(u_parent, v_parent)` throws the following bounds error on this branch, but not on main, causing it to head into the catch section with the `interior` call instead. I'm not sure why, though.; ```; ERROR: BoundsError: attempt to access 13×13×13 CuArray{Float64, 3, CUDA.Mem.DeviceBuffer} at index [3375]; Stacktrace:; [1] throw_boundserror(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] copyto!; @ ~/.julia/packages/CUDA/fAEDi/src/array.jl:343 [inlined]; [4] copyto!(dest::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, src::Array{Float64, 3}); @ CUDA ~/.julia/packages/CUDA/fAEDi/src/array.jl:350; [5] top-level scope; @ REPL[32]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. ```. MWE below that I get it from. ```; using CUDA; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, mask_immersed_field!. underlying_grid = RectilinearGrid(GPU(); size = (5, 5, 5), extent = (20, 20, 20)); @inline is_immersed(x, y, z) = z < -2.0; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(is_immersed)); model = NonhydrostaticModel(g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:2385,access,access,2385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547,1,['access'],['access']
Security,"enceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, CPU, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, Nothing, Nothing, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64. ... @ Oceananigans.Simulations ~/LocalDocs/code/Oceananigans.jl/src/Simulations/run.jl:86; [10] top-level scope; @ ~/LocalDocs/code/Oceananigans.jl/validation/immersed_boundaries/flow_over_hills_test.jl:146; ```. Any pointers would be helpful! I'm happy to contribute to an updated example once I sort this out. The relevant code was included in https://github.com/CliMA/Oceananigans.jl/commit/737ee905167ed44d61940098c32b108befbf1a26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:24118,validat,validation,24118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['validat'],['validation']
Security,"eredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:7915,hash,hashing,7915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,"eviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/validation.jl:141; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:418 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Fields.gpu__reg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:4132,validat,validation,4132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['validat'],['validation']
Security,"experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit decision and stick to it (for now), no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:1154,validat,validation,1154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,5,"['access', 'validat']","['access', 'validation']"
Security,"fsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}}}, NamedTuple{(:T, :S), Tuple{OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}}}, Nothing, NamedTuple{(:u, :v, :w, :T, :S), NTuple{5, typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float32, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:16936,validat,validate,16936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['validat'],['validate']
Security,getindex and setindex! much slower than just accessing array contents directly.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/13:45,access,accessing,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13,1,['access'],['accessing']
Security,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:78,validat,validation,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201,1,['validat'],['validation']
Security,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:1862,validat,validate,1862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,1,['validat'],['validate']
Security,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:103,Checksum,Checksum,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289,1,['Checksum'],['Checksum']
Security,https://github.com/CliMA/Oceananigans.jl/blob/bb35dcbefad63c038cd311c5eed43ac5326bb824/validation/mesoscale_turbulence/eddying_channel.jl#L96-L97,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974:87,validat,validation,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974,1,['validat'],['validation']
Security,"huh, do you think there is a bug in interpolation that causes an out of bounds memory access?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751595363:86,access,access,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751595363,1,['access'],['access']
Security,"iRegionObject{…}, z::Tuple{…}, panel::Oceananigans.Utils.Iterate{…}, topology::Tuple{…}, halo::Tuple{…}, radius::Float64}); @ Oceananigans.Utils /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Utils/multi_region_transformation.jl:161; [5] construct_regionally(::Function, ::String, ::Vararg{Any}; kwargs::@Kwargs{Nz::MultiRegionObject{…}, z::Tuple{…}, panel::Oceananigans.Utils.Iterate{…}, topology::Tuple{…}, halo::Tuple{…}, radius::Float64}); @ Oceananigans.Utils /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Utils/multi_region_transformation.jl:139; [6] (ConformalCubedSphereGrid)(filepath::String, arch::CPU, FT::Type; Nz::Int64, z::Tuple{…}, panel_halo::Tuple{…}, panel_topology::Tuple{…}, radius::Float64, devices::Nothing); @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/MultiRegion/multi_region_cubed_sphere_grid.jl:428; [7] MultiRegionGrid; @ /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/MultiRegion/multi_region_cubed_sphere_grid.jl:411 [inlined]; [8] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; If the new `cubed_sphere_32_grid_with_4_halos.jld2` file is available locally, executing:; ```; using JLD2; cs32_4_halos = jldopen(""cubed_sphere_32_grid_with_4_halos.jld2""); keys(cs32_4_halos); ```; will print out ; ```; 6-element Vector{String}:; ""panel1""; ""panel2""; ""panel3""; ""panel4""; ""panel5""; ""panel6""; ```; However, if the new `cubed_sphere_32_grid_with_4_halos.jld2` file is accessed online, the bug arises, due to a failure in identifying the keys panel1, ..., panel6. This issue must be associated with defining the Oceananigans grid using the coordinates and metrics from the `cubed_sphere_32_grid_with_4_halos.jld2` file obtained online.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:3749,access,accessed,3749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['access'],['accessed']
Security,"id 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5166,secur,secure,5166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['secur'],['secure']
Security,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:1083,access,access,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,1,['access'],['access']
Security,"ion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37024,validat,validate,37024,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['validat'],['validate']
Security,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:1754,expose,expose,1754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['expose'],['expose']
Security,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:2018,access,accessing,2018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['access'],['accessing']
Security,it looks like `validation/near_global_lat_lon/near_global_quarter_degree.jl` was updated elsewhere so we need to resolve merge conflicts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119057526,1,['validat'],['validation']
Security,"ivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:7962,hash,hashing,7962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,"julia; julia> grid = RectilinearGrid(size=(1, 2, 3), x=(0, 1), y=(0, 1), z=(0, 1)); 1×2×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×2×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.5; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.333333. julia> windowed = CenterField(grid, indices=(:, :, 2:2)); 1×2×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×2×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×2×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 2:2); └── data: 3×6×1 OffsetArray(::Array{Float64, 3}, 0:2, -1:4, 2:2) with eltype Float64 with indices 0:2×-1:4×2:2; └── max=0.0, min=0.0, mean=0.0. julia> view(windowed, :, :, 2:2); ERROR: BoundsError: attempt to access 3×6×1 Array{Float64, 3} at index [1:3, 1:6, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:734; [2] checkbounds; @ ./abstractarray.jl:699 [inlined]; [3] view; @ ./subarray.jl:179 [inlined]; [4] offset_windowed_data(data::OffsetArray{Float64, 3, Array{…}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{…}, OffsetVector{…}, OffsetVector{…}, CPU}, indices::Tuple{Colon, Colon, UnitRange{…}}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::Function, j::Function, k::UnitRange{Int64}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:316; [6] top-level scope",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088761876:1057,access,access,1057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088761876,1,['access'],['access']
Security,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:154,validat,validation,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684,1,['validat'],['validation']
Security,"lways have them together. At some point we have to get the external value, and if it's in the condition slot in `BoundaryCondition` we can get it like this:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L9. which can be e.g.; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L124-L133; which is called because of there being a `ContinuousBoundaryFunction` in the `BoundaryCondition` type:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L119; which was automatically set-up and then `regularize`-d. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/boundary_condition.jl#L53-L67. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L74-L75. But if we have this as part of the condition we get something like:; ```julia; BoundaryCondition{<:Open, <:OpenConditions{ES, MS}}; ```. then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. In the existing code the condition and classification are never directly accessed (except from inside `getbc`) and all of the other bits are based on the types:. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L15. so we can just write methods like:. ```julia; @inline function _fill_west_halo!(j, k, grid, c, bc::BoundaryCondition{Open{<:SomeMatchingScheme}}, loc, args...); ```. I don't really understand how it makes the code any harder to understand if we then get the condition as above v.s. writing new things so we can do `external_state = some_function(bc)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344:1544,access,accessed,1544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344,1,['access'],['accessed']
Security,"m the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3282,validat,validation,3282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['validat'],['validation']
Security,"ma.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/) ,. to study the dynamics of constant flow over a linearly slowing bottom. Note that I tried to pick the parameters as close to one of the cases in WT2020, however I did make some modifications. 1. I changed the direction of the constant horizontal flow (along bathymetry) to avoid inertial instability. This produces simpler dynamics.; 2. The code uses free-slip boundary conditons by default, but I believe I have no slip working as well.; 3. Currently diffusion and viscosity is larger by a factor of `100` as it's easier to resolve the boundary layer that develops. The examples were very easy to modify, which shows that people have done a great job in making them friendly, as promised. Thanks everyone for that! You can find my examples on branch `fjp/Test_ImmersedBoundaryMethod`. . The first code, what I call [take1](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl), uses the immersed boundary method. . Thet second code, what I call [take2](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take2.jl) used the tilted geometry approach. . Below I will share some results that people might find interest, maybe @tomchor in particular?. The first plot shows at heatmap of the velocity profile and a contour plot of the isopycnals for the case of an immersed boundary (take1). We see the isopycnals incrop (reach the bathymetry) at a 90 degree angle, which is consistent with what is said in the paper. It seems odd that slip boundary conditions yields a flow that gets faster over the topography, but that is not a problem. ![v_b_final_slip_take1](https://github.com/CliMA/Oceananigans.jl/assets/8239041/b1c88bdf-cdcd-4286-967c-b56e8aab5e07). The second plot shows at heatmap of the velocity profile and a contour plot of the isopycna",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526:1350,validat,validation,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526,1,['validat'],['validation']
Security,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2569,validat,validation,2569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932,1,['validat'],['validation']
Security,"medTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/LHjFw/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/utils.jl:83; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:355; [7] #228; @ ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:348 [inlined]; [8] JuliaContext(f::CUDA.var""#228#229""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIterat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:5568,validat,validation,5568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['validat'],['validation']
Security,"most tests fail now...... :( . Also I get; ```Julia; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = grid.Nz); ERROR: BoundsError: attempt to access Tuple{Int64} at index [2]; Stacktrace:; [1] indexed_iterate; @ ./tuple.jl:86 [inlined]; [2] new_data(FT::DataType, grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, loc::Tuple{DataType, DataType, DataType}, indices::Int64); @ Oceananigans.Grids ~/Research/OC2.jl/src/Grids/new_data.jl:59; [3] (Field{Face, Center, Nothing, O, G, I, D, T, B, S, F} where {O, G, I, D, T, B, S, F})(grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, T::DataType; kw::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:indices,), Tuple{Int64}}}); @ Oceananigans.Fields ~/Research/OC2.jl/src/Fields/field.jl:158; [4] top-level scope; @ REPL[24]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012:179,access,access,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012,1,['access'],['access']
Security,moving mpi example to validation folder,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1661:22,validat,validation,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1661,1,['validat'],['validation']
Security,"n as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:382 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/NRdsv/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:381 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:108; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:106 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:34; [13] JuliaContext(f::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:25; [14] compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:249; [15] actual_compilation(cache::Dict{Any, CuFunction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:6558,validat,validate,6558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['validat'],['validate']
Security,"nanigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12960,hash,hash,12960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hash']
Security,"nc), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method. If I set-up exactly the same code but using a `NonhydrostaticModel` things work as expected. Things also work if I set the `OpenBoundaryCondition` using a constant, such as:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)); u₀ = 1; u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u₀), west = OpenBoundaryCondition(u₀)); model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. Am I missing something obvious here, or is something wrong? Also I couldn't find any scripts in the repo that exemplify `OpenBoundaryConditions`, so I'm happy to set-up a validation script or something once this is figured out if you guys think it's a good addition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:2713,validat,validation,2713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,1,['validat'],['validation']
Security,net/ productionresultssa8.blob.core.windows.net/ productionresultssa9.blob.core.windows.net/ productionresultssa10.blob.core.windows.net/ productionresultssa11.blob.core.windows.net/ productionresultssa12.blob.core.windows.net/ productionresultssa13.blob.core.windows.net/ productionresultssa14.blob.core.windows.net/ productionresultssa15.blob.core.windows.net/ productionresultssa16.blob.core.windows.net/ productionresultssa17.blob.core.windows.net/ productionresultssa18.blob.core.windows.net/ productionresultssa19.blob.core.windows.net/ github-production-repository-image-32fea6.s3.amazonaws.com github-production-release-asset-2e65be.s3.amazonaws.com insights.github.com wss://alive.github.com; font-src github.githubassets.com; form-action 'self' github.com gist.github.com copilot-workspace.githubnext.com objects-origin.githubusercontent.com; frame-ancestors 'none'; frame-src viewscreen.githubusercontent.com notebooks.githubusercontent.com; img-src 'self' data: github.githubassets.com media.githubusercontent.com camo.githubusercontent.com identicons.github.com avatars.githubusercontent.com github-cloud.s3.amazonaws.com objects.githubusercontent.com secured-user-images.githubusercontent.com/ user-images.githubusercontent.com/ private-user-images.githubusercontent.com opengraph.githubassets.com github-production-user-asset-6210df.s3.amazonaws.com customer-stories-feed.github.com spotlights-feed.github.com objects-origin.githubusercontent.com *.githubusercontent.com; manifest-src 'self'; media-src github.com user-images.githubusercontent.com/ secured-user-images.githubusercontent.com/ private-user-images.githubusercontent.com github-production-user-asset-6210df.s3.amazonaws.com gist.github.com; script-src github.githubassets.com; style-src 'unsafe-inline' github.githubassets.com; upgrade-insecure-requests; worker-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; Transfer-Encoding: chunked; X-GitHub-Request-Id: 85AA:37E5AB:1E9255C:2BAFBE6:6674307A; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:3580,secur,secured-user-images,3580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,2,['secur'],['secured-user-images']
Security,"ng),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTradi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12893,hash,hashing,12893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hashing']
Security,"nhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:1969,access,access,1969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['access'],['access']
Security,"ns currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:931,access,accesses,931,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['access'],['accesses']
Security,"nsBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:6367,validat,validation,6367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['validat'],['validation']
Security,"nsion at /home/glwagner/.julia/packages/Oceananigans/cLFd3/src/Fields/computed_field.jl:86; [2] gpu__compute! at /home/glwagner/.julia/packages/KernelAbstractions/jAutM/src/macros.jl:80; [3] overdub at /home/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/glwagner/.julia/packages/TimerOutputs/ZmKD7/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:39; [6] compile at /home/glwagner/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:35 [inlined]; [7] cufunction_compile(::GPUCompiler.FunctionSpec; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/glwagner/.julia/packages/CUDA/YeS8q/src/compiler/execution.jl:310; [8] check_cache(::Dict{UInt64,Any}, ::Any, ::Any, ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Fields.gp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053:11140,validat,validate,11140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738834053,1,['validat'],['validate']
Security,"oat64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:45933,hash,hashing,45933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hashing']
Security,"oat64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5173,validat,validate,5173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['validat'],['validate']
Security,"odel::HydrostaticFreeSurfaceModel{…}, grid::RectilinearGrid{…}, callbacks::Tuple{}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:72; [8] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/single_column_model_mode.jl:64 [inlined]; [9] update_state!; @ ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:29 [inlined]; [10] time_step!(model::HydrostaticFreeSurfaceModel{…}, Δt::Float64; callbacks::Tuple{}, euler::Bool); @ Oceananigans.TimeSteppers ~/Projects/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:123; [11] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:122; [12] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}; pickup::Bool); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:97; [13] run!(sim::Simulation{HydrostaticFreeSurfaceModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/Projects/Oceananigans.jl/src/Simulations/run.jl:85; [14] top-level scope; @ ~/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; [15] include(fname::String); @ Base.MainInclude ./client.jl:489; [16] top-level scope; @ REPL[1]:1; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/validation/vertical_mixing_closures/tupled_vertical_diffusion.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:3565,validat,validation,3565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,2,['validat'],['validation']
Security,"olver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditione",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:1402,validat,validation,1402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['validat'],['validation']
Security,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:2209,expose,exposes,2209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,1,['expose'],['exposes']
Security,"on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = Rectilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1191,interlock,interlocked,1191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['interlock'],['interlocked']
Security,"onhydrostatic_tendency_kernel_functions.jl:92; [4] macro expansion; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:148; [5] gpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [6] gpu_compute_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:382 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/NRdsv/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:381 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:108; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:106 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUComp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:6252,validat,validate,6252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['validat'],['validate']
Security,"oposed / described by [Breivik et al., 2016](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500316X00042/1-s2.0-S1463500316000159/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAoaCXVzLWVhc3QtMSJGMEQCIEuzyjjMiYKjWncqy3fB9gow3kA5926WXv4VBHU9V0HoAiBgSB%2BFi9CNjS0smrtpCWSh2fziUgRWzaTpBid40ar%2FnSr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMRVnsHhFNYBpkm%2B7%2BKtcDEI3fj7WLlfM53vSXM70Jkta7qu8fr%2BZ4CiPp4EQEEdZO6gUvY4SodH4tbdylMZ16%2B6i0LOoNoyjZ%2FVjIVIr%2BzT90aJhP4POuZeDrpUxWfNYUqCXOyJ%2Bl4Uz3BCrk0e4ciQXjvEtJzlNbQDfq48BbAPBlW6B4SZ8q5Tui7pe1OvlCCs299aJ8749qPcCrKO5zN5QGE0iDQ2PAN0c2L53i%2BjjNPA0EOYaa0HdQWwO0tF14tTe79EjPEgl%2BMv%2BtlDH3XbTE595%2FdFEfPieVxLQJxNVWwvBZn2docHqGUXgcMsjOQVus7E%2FLZymGWm5cdHIJeB1d5VhK27LB4laC%2FhKCYsRVY59KDzsKVDR0jp6Rz6Ot6MjCwTVKuDTt6Gz0lsC02z3Q52EEIwxsWwpFJytxblTwDDGU5vu0nC%2BXSaZAA4rt8uytZSBR%2BO5ePkeRpOR04IF45ZmZw6w8TTlQXDewatkd64cUrRc6FQw0krDJ4eP%2FCDJKSd1h02HjU7C7GH6Q26NhNyFNw6Arxd173SQ43s7JMYW%2BOqY5%2BPj791sOnT7e5unKOSlnygc9ByJ5nr1mjt8aEaX9kxW5ZcaWnRZ%2Fue3NGi3ZQZvmkfZXITWkG1JzW%2BQUXxBUMObG1JAGOqYBlOoU8BHgt%2FoqN5rPBE1L0boNzjsSZWd3Mvv%2FJL1puzzfMbVoxGXMWcCRTcGyUDKA5eKG261EWk8WXCHK77FpXfb67tIFjOPUqtQRYpPDw10p39jA2oX168yKgrQZe1OVbIrw4uM%2FzGI57WdgefB3HgcwUgAacmIOndn5YvNpMZIRU4ExzrHGrCb1%2BwKJjRNm4WjEnfczrQPDhzPx6kTK9RnxkpCWvA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T190618Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYUWF4GJ7K%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=23dc65f5c0ed27e40381ce3eafb4d99c62faa368fa7ca21d3b635b3b05731127&hash=c2a51e264c7e095492ef97c3cb63571bfba4a5379b4090b7ad3b20ff588c2db6&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500316000159&tid=spdf-69dccd42-cfb6-4987-9af5-8ccdc6d81ccf&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=5306520250050e5302&rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290:344,Secur,Security-Token,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:5086,validat,validation,5086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807,3,['validat'],"['validate', 'validation']"
Security,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2523,validat,validation,2523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326,1,['validat'],['validation']
Security,"othing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}} at index [1, 1, 1]; Stacktrace:; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:1351,access,access,1351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638,1,['access'],['access']
Security,"othing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12846,hash,hashing,12846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['hash'],['hashing']
Security,"periments. > ; > > We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:; > > http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf; > ; > Unless I'm missing something this seems trivial (some good news!). I believe we'll need to insert a mass correction step into our algorithm (perhaps after fill halo regions in update state?) and how to decide when we need it. I think we'll need it both for non-zero inflow conditions (so `Open` boundaries with conditions other than `nothing` / 0`) and outflow conditions like Orlanski. > ; > > For this to work properly, we need to modify the pressure solver to work for time-dependent inflows; > ; > This seems far from trivial. But I'm assuming this was implemented when you guys implemented cubed sphere capabilities, no?. We only support hydrostatic cubed sphere simulations, so we did not implement an algorithm for accurate non-hydrostatic pressure solves with time-dependent boundary conditions when implementing the cubed sphere. The algorithm is known (I have a sketch, though some effort should be devoted to writing it up in the documentation); we only need to design a useful software abstraction. The main issue is that the right hand side of the pressure Poisson equation depends on the _time-derivative_ of the wall-normal velocity. This means that we need to store the wall-normal velocity at a prior time-step. We can probably redesign the implementation of the `Open` boundary condition for this purpose, and add code to `solve_for_pressure!` that adds these contributions when necessary: ; https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L23-L39. > ; > CC @zhazorken. One possible route forward is to first implement the Orlanski boundary condition and setup a few validation experiments before deciding whether the pressure solver modifications are needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920:2356,validat,validation,2356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934615920,1,['validat'],['validation']
Security,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:2246,expose,expose,2246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510,1,['expose'],['expose']
Security,"quent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` for averaging `AbstractOperations`. We also might be able to apply `mapreduce` directly to `AbstractOperati",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:2042,access,accesses,2042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['access'],['accesses']
Security,"ray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/LHjFw/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/utils.jl:83; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:355; [7] #228; @ ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:348 [inlined]; [8] JuliaContext(f::CUDA.var""#228#229""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:5930,validat,validate,5930,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['validat'],['validate']
Security,"resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to jl_f_getfield); Stacktrace:; [1] getproperty; @ ./Base.jl:37; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92; [4] macro expansion; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:148; [5] gpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [6] gpu_compute_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:382 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/NRdsv/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:381 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:108; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:106 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:5855,validat,validation,5855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['validat'],['validation']
Security,rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAsaCXVzLWVhc3QtMSJGMEQCIBRKxiRGfmCqFI08tnCQqlwbVGk%2Bm8YOAG57p4smh3cHAiAC%2B9pA%2FCQMsYbtGWN4kUfk%2FIAKtiQzgv56vUWJpK03NCr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMtkIfmex2gMV%2FyYy6KtcD496P%2F695JO%2BGnHHg3hAcKNGkmiiEA8fjZyLcowzIG1pT5TS%2Ft%2BElYms%2FLx0gMtbZFbl3ks8ifVzTgoC0pM3zCN2TCTyxCPFUUB2j0PmnsyNtq9v5ljKcSf2eolUGpQlINrUrJ170CMAGYA7XjRWzC8YJCZBRF7iThfHpYOvqkjO5BJyW8p52vOlmz%2FRfy%2FSMbW0kVlgEef5PcIWTff3BSKQ5BA%2BdekJjdRrZDVaSwNIcQjE4l%2Ff38F%2Bp%2BlY75UZft0%2Fd1I18PyELQS5rWPmCIPNkmsePvN1rgPnhqldC5ozV0OO2Anr8oBoxmnmwNwnrfk5yUwJWc%2Fhsk4zmTD96nmzDgS3IOgCjh8b1TIhBEvYlZlCVkXouGc8M0%2BN7tCEZqvdjxKVkulq2BqwXW9bbYoPmp9ufV9A96mGmBWzqbJpRBLg%2FZHX5%2BDFDPoFc1vZ4gPCz9JSS8xyyayG1JtaZ6etf%2F%2FbmN2IcTbPh0lqf9B5O7DqisxWMCKadJvgsr5oVghbvkEd%2FjjFL7KrspUdfonTXuY5C5U2TiLkOIVlg2bFaEP9QemD8FVljVjKLrUr8K99rJnaPC1uQncZXj%2FL%2FF%2BKfi9k9bIQe0uhDrmwNpigQzgOdZy1GMJDS1JAGOqYB3PXXbyBFFFdkUJqOFawxA9rk4s0ZqMS4J8%2BpTJxrUG%2F3KL8SAYJh9PmjeekbuM1lz8q1TlsQNM50q4UiPr0Ld7Wt5PrqC01LwdIFgbhr1l1GltNfCH9vWLEasPpjc2O6MGHwNpmrCNVstzsTQ%2FbiELElpjrhNjLZUaIOPWHKUTVTcIBmQf%2B5AVSebzQWwEX2aaFc8HYk5XfmfFwJoKdlO%2F3oR%2FOsnQ%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T191639Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY34KZ3BVM%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290:2167,Secur,Security-Token,2167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,"s an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execut",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1082,access,access,1082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['access'],['access']
Security,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1758,access,accesses,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['access'],['accesses']
Security,see #3141 ; closes #3141 . The results from `validation/immersed_boundaries/immersed_couette_flow.jl` from this branch. https://github.com/CliMA/Oceananigans.jl/assets/33547697/e50beac1-4d22-4581-9715-5f541e8dcf01,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142,1,['validat'],['validation']
Security,"setup-julia/issues/226"">#226</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/4190528a8ca9962739fbfd1529f9b38939baa442""><code>4190528</code></a> Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/9acd04fccc6b5b219d40b75c902c8f1654d88a9a""><code>9acd04f</code></a> Bump nock from 13.5.1 to 13.5.4 (<a href=""https://redirect.github.com/julia-actions/setup-julia/issues/224"">#224</a>)</li>; <li>See full diff in <a href=""https://github.com/julia-actions/setup-julia/compare/v1...v2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:8651,secur,security-vulnerabilities,8651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['secur'],"['security-updates', 'security-vulnerabilities']"
Security,"skyLilly` closure, while the one on the right shows results for the `ScaleInvarianteSmagorinsky` closure, implemented in this PR. The bottom panel shows the evolution of the dynamically-calculated Smagorinsky coefficient for the latter, in comparison with the constant value of 0.16 imposed on the former. Important here is that the value of 0.16 was analytically derived by Lilly by assuming an isotropic 3D turbulence, a Kolmogorovian energy cascade, and further assuming that the cut-off filter is in the inertial range. I think all these assumptions are valid in this simulation, so we expect the dynamically-calculated value of the Smagorinsky coefficient (the black line) to approach the value 0.16 as time goes on. https://github.com/CliMA/Oceananigans.jl/assets/13205162/4049e7cf-452e-4883-a709-a675cf12277c. Although the match is not exact (the value it approaches is ~0.17), I think this is close enough. That said, I'm planning on also implementing a boundary layer validation along similar lines, which we can use to validate the model in the same fashion as [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152). One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. ```julia; ┌ Info: Running; └ closure = SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.738 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.852 seconds).; [ Info: Simulation is stopping after running for 11.657 seconds.; [ Info: Simulation time 1.333 minutes equals or exceeds stop time 1.333 minutes.; ┌ Info: Running;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170:1395,validat,validation,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170,2,['validat'],"['validate', 'validation']"
Security,"src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType})(ctx::LLVM.Context); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9921; [14] JuliaContext(f::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType}); @ GPUC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:2358,validat,validate,2358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['validat'],['validate']
Security,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:6148,validat,validation,6148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['validat'],['validation']
Security,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1123,inject,injected,1123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,1,['inject'],['injected']
Security,"t the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSpheres.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-20a2fde3ffb57dacaf2440040602aa34df63d347b81a5f18153845e523173d85>; > (16); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/animate_on_map_projection.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-3e851a92e09dfbd624c25fc1b1788c34f3dcd632f708d910b8c4825d3d77fc37>; > (98); > - *A*; > validation/cubed_sphere_eddying_aquaplanet/cubed_sphere_eddying_aquaplanet.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1602/files#diff-35c0493950749d6d09943668f3782338fd14b59fe00034c962bd05543f81771d>; > (232); >; > Patch Links:; >; > - https://github.com/CliMA/Oceananigans.jl/pull/1602.patch; > - https://github.com/CliMA/Oceananigans.jl/pull/1602.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1602>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQURPBSSLXOB4N53WXDTJ4FLJANCNFSM43K2CYSQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:2158,validat,validation,2158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,2,['validat'],['validation']
Security,"t we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:1364,access,accessing,1364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['accessing']
Security,"t64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:46047,hash,hash,46047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hash']
Security,"t_call(::Any, ::Array{Any,1}, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:567; [13] abstract_eval_call(::Array{Any,1}, ::Array{Any,1}, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:805; [14] abstract_eval(::Any, ::Array{Any,1}, ::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:890; [15] typeinf_local(::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:1135; [16] typeinf_nocycle(::Core.Compiler.InferenceState) at ./compiler/abstractinterpretation.jl:1191; [17] typeinf(::Core.Compiler.InferenceState) at ./compiler/typeinfer.jl:14; [18] typeinf at ./compiler/typeinfer.jl:10 [inlined]; [19] typeinf_type(::Method, ::Any, ::Core.SimpleVector, ::Core.Compiler.Params) at ./compiler/typeinfer.jl:604; [20] return_types(::Any, ::Any) at ./reflection.jl:980; [21] check_method(::CUDAnative.CompilerContext) at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/validation.jl:12; [22] compile(::CUDAnative.CompilerContext) at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/driver.jl:67; [23] #compile#109(::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::VersionNumber, ::Any, ::Any) at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/driver.jl:45; [24] compile at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/driver.jl:43 [inlined]; [25] #compile#108(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::Function, ::CUDAdrv.CuDevice, ::Function, ::Any) at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/driver.jl:18; [26] compile at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/compiler/driver.jl:16 [inlined]; [27] macro expansion at /home/alir_mit_edu/.julia/packages/CUDAnative/PFgO3/src/execution.jl:269 [inlined]; [28] #cufunction#123(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477727916:2562,validat,validation,2562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153#issuecomment-477727916,1,['validat'],['validation']
Security,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:10343,access,access,10343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['access'],['access']
Security,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:1732,validat,validation,1732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,1,['validat'],['validation']
Security,"the internal_tide.jl code in validation. It seemed like the best place to start, even though I know it's just's going to produce the nice animation that you posted in this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867912605:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867912605,1,['validat'],['validation']
Security,"the stacktrace is. ```Julia; Biogeochemistry: Error During Test at /Users/navid/Research/OC5.jl/test/test_biogeochemistry.jl:126; Got exception outside of a @test; BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ./range.jl:940 [inlined]; [4] Azᶜᶜᵃ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:209 [inlined]; [5] Azᶜᶜᶠ; @ ~/Research/OC5.jl/src/Operators/spacings_and_areas_and_volumes.jl:192 [inlined]; [6] macro expansion; @ ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl:135 [inlined]; [7] cpu__compute_coefficients!; @ ~/.julia/packages/KernelAbstractions/lhhMo/src/macros.jl:276 [inlined]; [8] cpu__compute_coefficients!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(5, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{2}, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(5, 1)}, Nothing, Nothing}}, diag::Array{Float64, 3}, Ax::Array{Float64, 3}, Ay::Array{Float64, 3}, ∫Ax::Field{Face, Center, Nothing, Nothing, LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:188,access,access,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635,1,['access'],['access']
Security,"tic_free_surface_Gu!; @ ./none:0; Reason: unsupported use of double value; Stacktrace:; [1] Float32; @ ./float.jl:258; [2] convert; @ ./number.jl:7; [3] setindex!; @ ~/.julia/packages/Metal/lnkVP/src/device/array.jl:105; [4] setindex!; @ ~/.julia/packages/Metal/lnkVP/src/device/array.jl:118; [5] setindex!; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:443; [6] macro expansion; @ ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:35970,validat,validation,35970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['validat'],['validation']
Security,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:2122,access,access,2122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['access'],['access']
Security,"tself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1343,access,accessed,1343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['access'],['accessed']
Security,"umulative mean.) . ![u_evolution](https://user-images.githubusercontent.com/13205162/124214589-537c9800-daa7-11eb-99cd-ef90fcc5b8cd.png). However, if I swap the line `outputs = (tke_c=tke_c, u=u,)` for ; ```julia; outputs = (tke_k=tke_k, u=u,); ```; (so basically I'm just changing the **TKE** calculation from being done with a `ComputedField` to being done with a `KernelComputedField`) then the output for **`u`** is correct!. ![u_evolution](https://user-images.githubusercontent.com/13205162/124214510-2c25cb00-daa7-11eb-9b48-c2c9c3bd5b4a.png). So just to be clear: the nature of the other diagnostics being calculated in the list of outputs changes the average result for `u`! Below is a list of what works and doesn't work (for `u`) when setting the list of outputs:. ```julia; outputs = (tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u,) # Works; outputs = (tke_k=tke_k, tke_c=tke_c, u=u,) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v, w=w) # Doesn't work; outputs = (tke_k=tke_k, u=u, v=v,) # Doesn't work; outputs = (u=u, v=v,) # Doesn't work; outputs = (u=u, w=w,) # Doesn't work; outputs = (u=u,) # Works; ```. Notes: . - I haven't checked the calculation of the other stuff yet; - I created [a branch](https://github.com/CliMA/Oceananigans.jl/tree/tc/fix-time-average) that lets me keep track of when each condition [here](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L146) gets accessed and the number of times it accesses [this condition](https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L190) changes based on what's on the output list. Is this expected?; - I've reproduced this in two different machines but I still haven't got confirmation that anyone else reproduced this independently. Could someone please run this? Here's the [Python script to generate this plot](https://pastebin.com/1dSE1hGj)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633:3140,access,accessed,3140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872684633,2,['access'],"['accessed', 'accesses']"
Security,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:1376,validat,validation,1376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,3,['validat'],['validation']
Security,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:1663,validat,validation,1663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,2,['validat'],['validation']
Security,validation scripts are not maintained so oftentimes with breaking changes one need to tweak them a bit...; the scripts in the `examples` directory are maintained... we should include an example with immersed boundaries there,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1370324971:0,validat,validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1370324971,1,['validat'],['validation']
Security,"validation/barotropic/barotropic.jl currently errors when you try and run it. 1. The Flux() type is not imported; 2. The explicit stepper and timestep aren't in sync and code NaNs. The timestep is set for implicit free surface. . These two tweaks make it run and produce something ""reasonable"". ; It could be good to have it set so it runs as cloned?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:0,validat,validation,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['validat'],['validation']
Security,"w_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Function, ::Int64, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[24]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> my_field[:, :, -2]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [OffsetArrays.IdOffsetRange(values=-1:4, indices=-1:4), OffsetArrays.IdOffsetRange(values=-1:5, indices=-1:5), -2]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Function, ::Function, ::Int64); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:2649,access,access,2649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['access'],['access']
Security,"w_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Int64, ::Function, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[23]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> my_field[:, -2, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [OffsetArrays.IdOffsetRange(values=-1:4, indices=-1:4), -2, OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Function, ::Int64, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:1428,access,access,1428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['access'],['access']
Security,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3795,access,access,3795,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security,"yConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 14×14×106 OffsetArray(::Array{Float64, 3}, -2:11, -2:11, -2:103) with eltype Float64 with indices -2:11×-2:11×-2:103; └── max=0.0, min=0.0, mean=0.0. julia> set!(c_src, (λ, φ, z) -> rand()); 8×8×100 Field{Center, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 8×8×100 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 14×14×106 OffsetArray(::Array{Float64, 3}, -2:11, -2:11, -2:103) with eltype Float64 with indices -2:11×-2:11×-2:103; └── max=0.999998, min=1.2255e-5, mean=0.497663. julia> c_dst = CenterField(flat_grid); 1×1×100 Field{Center, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 1×1×100 LatitudeLongitudeGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo and without precomputed metrics; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 1×1×106 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:103) with eltype Float64 with indices 1:1×1:1×-2:103; └── max=0.0, min=0.0, mean=0.0. julia> Oceananigans.Fields.interpolate!(c_dst, c_src); ERROR: BoundsError: attempt to access Tuple{Float64} at index [2]; Stacktrace:; [1] indexed_iterate; @ ./tuple.jl:92 [inlined]; [2] _fractional_indices; @ ~/Projects/Oceananigans.jl/src/Fields/interpolate.jl:163 [inlined]; [3] fractional_indices; @ ~/Projects/Oceananigans.jl/src/Fields/interpolate.jl:152 [inlined]; [4] interpolate; @ ~/Projects/Oceananigans.jl/src/Fields/interpolate.jl:222 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Fields/interpolate.jl:302 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1967799919:2859,access,access,2859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1967799919,1,['access'],['access']
Security,"ymbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4862,validat,validate,4862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['validat'],['validate']
Security,"ys.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, SmallSlopeIsopycnalTensor{Int64}}, VerticalScalarDiffusivity{ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}}}, BoundaryCondition{Flux, Nothing}, Buoyancy{SeawaterBuoyancy{Float64, SeawaterPolynomials.BoussinesqEquationOfState{TEOS10SeawaterPolynomial{Float64}, Int64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:T, :S), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Tuple{NamedTuple{(:νₑ,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Nothing}, typeof(Oceananigans.Forcings.zeroforcing), NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/XyxTy/src/validation.jl:139. ```. Note that the equivalent code works fine on CPU. Any ideas? Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:8164,validat,validation,8164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['validat'],['validation']
Security,"ze=3, z=(0, 1), topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Regular, with spacing 0.3333333333333333; ```. so `grid in x:` isn't aligned with the rest of the ""data table"". Here's what we get when `z` is stretched:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Stretched, with spacing min=0.2, max=0.5; ```. So here's a few ideas:. #### Include ""spacing"" information under the `domain` row?. One idea would be to show something like. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], Δz: 0.33; ```. instead of `domain:` (for the regularly-spaced case), and. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], extrema(Δz): (0.2, 0.5); ```. for the stretched case. We could also increase the length of the table and put the spacings on their own lines, eg. ```julia; x: Flat; y: Flat; z: [0.0, 1.0]; extrema(Δz): (0.2, 0.5); ```. We might also just hide flattened directions (we already express that the directions are `Flat` so why print this again?). #### Eliminate `topology` row because this information is already printed in the type signature. #### Compactify how we show the size + halo. I've always found the way we write `(Nx, Ny, Nz)` to negatively impact readability. . I think it's ok to just write `size`, because we want to move towards providing a function-based API rather than expecting users to access struct properties directly. Eg we could have just. ```julia; size: (1, 1, 1); halo: (0, 0, 1); ```. What do others think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064:1971,access,access,1971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064,1,['access'],['access']
Security,"{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/utils.jl:68; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:6853,validat,validation,6853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['validat'],['validation']
Security,"}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}}}, NamedTuple{(:T, :S), Tuple{OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}}}, Nothing, NamedTuple{(:u, :v, :w, :T, :S), NTuple{5, typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float32, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:16523,validat,validation,16523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['validat'],['validation']
Security,"},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:8029,hash,hash,8029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['hash'],['hash']
Security,"},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:9817,hash,hashing,9817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['hash'],['hashing']
Security,"~~Actually it appears that I was wrong. It's not the complexity that's causing the error, it's happening due to the indexing. Here's what I'm getting on the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:1000,access,access,1000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['access'],['access']
Security,"⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4380,validat,validated,4380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['validat'],['validated']
Testability," "">GPU</td>; <td style = ""text-align: right; "">CenteredSecondOrder</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">UpwindBiasedFifthOrder</td>; <td style = ""text-align: right; "">2.05742</td>; <td style = ""text-align: right; "">1.02812</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td>; <td style = ""text-align: right; "">1.47568</td>; <td style = ""text-align: right; "">1.02677</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">WENO5</td>; <td style = ""text-align: right; "">3.04361</td>; <td style = ""text-align: right; "">1.02812</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. ## Arbitrary tracers benchmarks. <table>; <caption style = ""text-align: center; "">Arbitrary tracers relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Ns</th>; <th style = ""text-align: right; "">tracers</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">(0, 0)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">128</td>; <td style = ""text-align: right; "">(0, 1)</td>; <td style = ""text-align: right; "">1.19815</td>; <td style = ""text-align: right; "">1.18011</td>; <td style = ""text-align: righ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:3418,benchmark,benchmarks,3418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['benchmark'],['benchmarks']
Testability," # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110909,benchmark,benchmark,110909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability," (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5126,test,test,5126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability," +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = HydrostaticFreeSurfaceModel(grid = grid,; + architecture = arch,; + #free_surface = ExplicitFreeSurface(),; + #free_surface = ImplicitFreeSurface(maximum_iterations=10),; + free_surface = ImplicitFreeSurface(),; + momentum_advection = nothing,; + tracer_advection = WENO5(),; + coriolis = nothing,; + buoyancy = nothing,; + tracers = nothing,; + closure = nothing); +; + x_ref = [0.0 0.0 0.0 0.0 0.0 0.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 2.0 0.0; + 0.0 3.0 2.0 1.0 1.0 2.0 0.0; + 0.0 3.0 2.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4780,test,testset,4780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406,2,"['Test', 'test']","['Testing', 'testset']"
Testability, - Coverage 72.16% 69.21% -2.96% ; ==========================================; Files 189 131 -58 ; Lines 5536 2790 -2746 ; ==========================================; - Hits 3995 1931 -2064 ; + Misses 1541 859 -682 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `82.60% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/9,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822:1669,test,test,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822,2,['test'],['test']
Testability, -726 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:1913,test,test,1913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,2,['test'],['test']
Testability," /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: Linux (x86_64-redhat-linux); CPU: Intel(R) Xeon(R) Platinum 8268 CPU @ 2.90GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_DEPOT_PATH = /g/data/v45/nc3020/.julia:/share/julia/site/; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_LOAD_PATH = @:@v#.#:@stdlib:@site; JULIA_NUM_THREADS = 48. shell> nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Tue Feb 21 07:30:33 2023; Driver Version : 525.60.13; CUDA Version : 12.0. Attached GPUs : 1; GPU 00000000:3D:00.0; Product Name : Tesla V100-SXM2-32GB; Product Brand : Tesla; Product Architecture : Volta; Display Mode : Enabled; Display Active : Disabled; Persistence Mode : Enabled; MIG Mode; Current : N/A; Pending : N/A; Accounting Mode : Disabled; Accounting Mode Buffer Size :",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:18447,Log,Logging,18447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Log'],['Logging']
Testability, 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 9379,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3437,test,test,3437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability, 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 9379,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867:3056,test,test,3056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867,1,['test'],['test']
Testability," 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat, rows::Vector{Int64}, cols::Vector{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64, ncols::Int64); @ Base ./arrayshow.jl:68; [11] _print_matrix(io::IOContext{Base.TTY}, X::AbstractVecOrMat, pre::String, sep::String, post::String, hdots::String, vdots::String, ddots::Strin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1749,assert,assertscalar,1749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['assert'],['assertscalar']
Testability," 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12137,test,test,12137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:11587,benchmark,benchmark,11587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmark']
Testability," 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111914,benchmark,benchmark,111914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1649,Benchmark,Benchmarking,1649,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605,5,"['Benchmark', 'benchmark']","['Benchmarking', 'benchmark']"
Testability," 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106943,Test,Test,106943,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability, 71.80% +0.12% ; ==========================================; Files 184 124 -60 ; Lines 4781 2476 -2305 ; ==========================================; - Hits 3427 1778 -1649 ; + Misses 1354 698 -656 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [...ts/one\_dimensional\_gaussian\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9nYXVzc2lhbl9hZHZlY3Rpb25fZGlmZnVzaW9uLmps) | | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | | |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854:1718,test,test,1718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854,2,['test'],['test']
Testability, 72.17% 69.08% -3.09% ; ==========================================; Files 205 143 -62 ; Lines 5994 3047 -2947 ; ==========================================; - Hits 4326 2105 -2221 ; + Misses 1668 942 -726 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://co,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:1750,benchmark,benchmark,1750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,2,['benchmark'],['benchmark']
Testability," 755.937 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 1 │ 61.083 ms │ 63.464 ms │ 63.969 ms │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4124,benchmark,benchmark,4124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmark']
Testability," 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | ERROR: ERROR: ERROR: ERROR: Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] pkgerrorPackage Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] (pkgerror; &nbsp; | [1] (pkgerror::(; &nbsp; | [1] ::pkgerrorString) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Oper",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:2109,test,test,2109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['test'],['test']
Testability," ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1657,log,log,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['log'],['log']
Testability," <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 232.677 μs … 19.414 ms ┊ GC (min … max): 0.00% … 98.38%; Time (median): 257.090 μs ┊ GC (median): 0.00%; Time (mean ± σ): 283.748 μs ± 477.843 μs ┊ GC (mean ± σ): 5.51% ± 3.23%. ▁▂ ▄█▁ ; ▂██▆▅▃▂▁▁▁▁▃███▇▆▄▃▂▂▂▂▂▂▂▂▂▃▄▄▄▄▃▂▂▂▂▂▂▃▃▄▄▄▄▃▃▃▃▂▂▂▂▂▂▂▁▁▁▁ ▂; 233 μs Histogram: frequency by time 325 μs <. Memory estimate: 100.95 KiB, allocs estimate: 714. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 56.666 μs … 8.788 ms ┊ GC (min … max): 0.00% … 90.04%; Time (median): 60.193 μs ┊ GC (median): 0.00%; Time (mean ± σ): 65.835 μs ± 166.794 μs ┊ GC (mean ± σ): 4.88% ± 1.93%. ▄▆██▆▃▁ ; ▁▁▁▃▅████████▆▅▃▂▂▁▁▁▁▁▂▂▂▂▂▂▂▃▂▂▂▃▃▃▂▃▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂; 56.7 μs Histogram: frequency by time 77.1 μs <. Memory estimate: 41.09 KiB, allocs estimate: 103. julia> . ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:1990,benchmark,benchmark,1990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065,4,"['Benchmark', 'benchmark']","['BenchmarkTools', 'benchmark']"
Testability," = ""1.7.2"". [[TOML]]; deps = [""Dates""]; git-tree-sha1 = ""44aaac2d2aec4a850302f9aa69127c74f0c3787e""; uuid = ""fa267f1f-6049-4f14-aa54-33bafae1ed76""; version = ""1.0.3"". [[TableTraits]]; deps = [""IteratorInterfaceExtensions""]; git-tree-sha1 = ""c06b2f539df1c6efa794486abfb6ed2022561a39""; uuid = ""3783bdb8-4a98-5b6b-af9a-565f29a5fe9c""; version = ""1.0.1"". [[Tables]]; deps = [""DataAPI"", ""DataValueInterfaces"", ""IteratorInterfaceExtensions"", ""LinearAlgebra"", ""TableTraits"", ""Test""]; git-tree-sha1 = ""c9d2d262e9a327be1f35844df25fe4561d258dc9""; uuid = ""bd369af6-aec1-5ad0-b16a-f7cc5008161c""; version = ""1.4.2"". [[TaylorSeries]]; deps = [""InteractiveUtils"", ""LinearAlgebra"", ""Markdown"", ""Requires"", ""SparseArrays""]; git-tree-sha1 = ""66f4d1993bae49eeba21a1634b5f65782585a42c""; uuid = ""6aa5eb33-94cf-58f4-a9d0-e4b2c4fc25ea""; version = ""0.10.13"". [[Test]]; deps = [""Distributed"", ""InteractiveUtils"", ""Logging"", ""Random""]; uuid = ""8dfed614-e22c-5e08-85e1-65c5234f0b40"". [[TimerOutputs]]; deps = [""Printf""]; git-tree-sha1 = ""32cdbe6cd2d214c25a0b88f985c9e0092877c236""; uuid = ""a759f4b9-e2f1-59dc-863e-4aeb61b1ea8f""; version = ""0.5.8"". [[TranscodingStreams]]; deps = [""Random"", ""Test""]; git-tree-sha1 = ""7c53c35547de1c5b9d46a4797cf6d8253807108c""; uuid = ""3bb67fe8-82b1-5028-8e26-92a6c54297fa""; version = ""0.9.5"". [[Tullio]]; deps = [""DiffRules"", ""LinearAlgebra"", ""Requires""]; git-tree-sha1 = ""7201bbb4c138c18bf14511c4cc8daeac6a52c148""; uuid = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; version = ""0.2.14"". [[UUIDs]]; deps = [""Random"", ""SHA""]; uuid = ""cf7118a7-6976-5b1a-9a39-7adc72f591a4"". [[Unicode]]; uuid = ""4ec0a83e-493e-50e2-b9ac-8f72acf5a8f5"". [[Zlib_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""320228915c8debb12cb434c59057290f0834dbf6""; uuid = ""83775a58-1f1d-513f-b197-d71354ab007a""; version = ""1.2.11+18"". [[nghttp2_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""8e2c44ab4d49ad9518f359ed8b62f83ba8beede4""; uuid = ""8e850ede-7688-5339-a07c-302acd2aaf8d""; version = ""1.40.0+2""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:17441,Test,Test,17441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability," = grid.Δz; @inline Δzᵃᵃᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; ; +@inline Δzᶠᶜᶜ(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; +@inline Δzᶜᶠᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = Hydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4374,test,test,4374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406,1,['test'],['test']
Testability," > (448); > - *M* test/regression_tests/rayleigh_benard_regression_test.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-88>; > (2); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-89>; > (87); > - *M* test/test_abstract_operations.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-90>; > (34); > - *M* test/test_boundary_conditions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-91>; > (4); > - *M* test/test_buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-92>; > (10); > - *M* test/test_diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-93>; > (22); > - *M* test/test_dynamics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-94>; > (6); > - *M* test/test_examples.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-95>; > (2); > - *M* test/test_models.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-96>; > (2); > - *M* test/test_solvers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-97>; > (3); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-98>; > (14); > - *M* test/test_turbulence_closures.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-99>; > (12); > - *M* verification/stratified_couette_flow/stratified_couette_flow.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-100>; > (5); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/591.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/591.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/59",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:14539,test,test,14539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['test'],['test']
Testability, > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1017 +/- ##; ==========================================; - Coverage 70.70% 69.81% -0.90% ; ==========================================; Files 223 155 -68 ; Lines 6554 3412 -3142 ; ==========================================; - Hits 4634 2382 -2252 ; + Misses 1920 1030 -890 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tr,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991:1361,test,test,1361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991,2,['test'],['test']
Testability," @ Oceananigans.Fields ~/builds/tartarus-7/clima/oceananigans/src/Fields/field.jl:657; [13] minimum_spacing(dir::Symbol, grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:408; [14] minimum_xspacing(grid::ImmersedBoundaryGrid{Float32, Periodic, Periodic, Bounded, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float32, Float32, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64, Int64}}, CPU}, GridFittedBottom{OffsetMatrix{Float32, Matrix{Float32}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.Grids ~/builds/tartarus-7/clima/oceananigans/src/Grids/grid_utils.jl:429; [15] macro expansion; @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [16] test_regular_rectilinear_xnode_ynode_znode_and_spacings(arch::CPU, FT::Type{Float32}); @ Main ~/builds/tartarus-7/clima/oceananigans/test/test_grids.jl:203. <br class=""Apple-interchange-newline"" style=""caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-style: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration: none;"">; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091:10297,Test,Test,10297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1592864091,3,"['Test', 'test']","['Test', 'test']"
Testability," Appveyor, and GitLab CI (both CPU and GPU). So it's kind of OS-specific but seems pretty robust across different hardware. But looking at the test log, the errors look fine: `Δv` and `Δw` are no larger than `~1e-13`. I'm wondering if there's a zero entry in `v` and `w` resulting in an expression like `1e-15 ≈ 1e-25`. Both `1e-15` and `1e-25` are close enough to zero for this test, but `≈` would return false. This entry could be closer or further from zero depending on OS and architecture. ```; julia> 1 ≈ 1 + 1e-10; true; julia> 1e-15 ≈ 1e-25; false; ```. Looking at how the regression data was generated, seems like it might have been good to initialize `v` with some noise. But `w=u₀` and it still fails... Rather than regenerating the regression data maybe it'll be good to change the test to check for absolute error by using the `isapprox` function and passing a non-zero `atol`. I can give this a try later this afternoon. ---. ```; Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; [ Info: Δu: min=-1.14728e-13, max=1.62294e-13, mean=-1.09883e-20, absmean=2.12163e-14, std=2.76021e-14; [ Info: Δv: min=-1.5609e-13, max=1.08464e-13, mean=-2.75418e-20, absmean=2.0988e-14, std=2.72286e-14; [ Info: Δw: min=-1.80785e-13, max=1.97494e-13, mean=-1.62683e-19, absmean=3.17569e-14, std=4.27591e-14; [ Info: ΔT: min=-2.73559e-13, max=2.06057e-13, mean=-5.36897e-16, absmean=2.77339e-14, std=3.88347e-14; [ Info: ΔS: min=-1.13687e-13, max=7.81597e-14, mean=1.56125e-17, absmean=1.51424e-14, std=1.96383e-14; Ocean large eddy simulation [CPU]: Test Failed at /Users/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:69; Expression: all(Array(data((checkpointed_model.velocities).v)) .≈ Array(data((test_model.velocities).v))); ```. ```; Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; [ Info: Δu: min=-7.75408e-14, max=5.89303e-14, mean=-3.3749e-21, absmean=1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712:1137,Test,Testing,1137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712,1,['Test'],['Testing']
Testability," FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14667,test,test,14667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability, GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.0; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.46; [1019f520] JLFzf v0.1.7; [692b3bcd] JLLWrappers v1.5.0; [682c06a0] JSON v0.21.4; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.18; [929cbde3] LLVM v6.6.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [23fbe1c1] Latexify v0.16.2; [2ab3a3ac] LogExpFunctions v0.3.27; [e6f89c97] LoggingExtras v1.0.3; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [1914dd2f] MacroTools v0.5.13; [739be429] MbedTLS v1.1.9; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.7; [85f8d34a] NCDatasets v0.14.3; [5da4648a] NVTX v0.3.4; [77ba4419] NaNMath v1.0.2; [d8793406] ObjectFile v0.4.1; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [4d8831e6] OpenSSL v1.4.2; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [b98c9c47] Pipe v1.3.0; [eebad327] PkgVersion v0.3.3; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.4.1; [91a5bcdd] Plots v1.40.2; [2dfb63ee] PooledArrays v1.4.3; ⌃ [aea7be01] PrecompileTools v1.2.0; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.1; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [01d81517] RecipesPipeline v0.6.12; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.1; [ae029012] Requires v1.3.0; [,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:4404,Mock,Mocking,4404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Mock'],['Mocking']
Testability, I might wait until we truly need to regenerate regression data as regenerating regression data adds to the size of the git repo that can only be recovered by rewriting git history. We did this once but probably don't want to do again as it pollutes git history and we may need to run tests on old versions(?). I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDi,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867:1059,test,test,1059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867,1,['test'],['test']
Testability," I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_strat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:1075,test,test,1075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:1343,log,logical,1343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['log'],['logical']
Testability," LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 FieldTimeSeries{Chunked} located at (Face, Center, Center) on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── indices: (Colon(), Colon(), Colon()); └── data: 23×22×16×4 OffsetArray(::Array{Float64, 4}, -2:20, -2:19, -2:13, 1:4) with eltype Float64 with indices -2:20×-2:19×-2:13×1:4; └── max=8.0, min=0.0, mean=1.67984; ```. This is not final and all open to suggestions/changes/improvement. maybe interesting for @yuchenma23",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:1983,test,testfile,1983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['test'],['testfile']
Testability," Nothing}}}, _tupled_implicit_linear_coefficients::@NamedTuple{b::ZeroField{Int64, 3}, e::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, @NamedTuple{}}}, ::Active{Float64}); @ Enzyme ~/.julia/packages/Enzyme/8GSlk/src/Enzyme.jl:504; [63] macro expansion; @ ~/Projects/Oceananigans.jl/test/test_enzyme.jl:285 [inlined]; [64] macro expansion; @ ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:1577 [inlined]; [65] top-level scope; @ ~/Projects/Oceananigans.jl/test/test_enzyme.jl:265; [66] include(fname::String); @ Base.MainInclude ./client.jl:489; [67] top-level scope; @ REPL[6]:1; [68] eval; @ ./boot.jl:385 [inlined]; [69] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; [70] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; [71] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; [72] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/RE",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:151539,Test,Test,151539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,2,['Test'],['Test']
Testability," Pkg. julia> Pkg.activate("".""); Activating environment at `~/new_directory/Project.toml`. julia> print(read(""Manifest.toml"", String)); # This file is machine-generated - editing it directly is not advised. [[AbstractFFTs]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""485ee0867925449198280d4af84bdb46a2a404d0""; uuid = ""621f4979-c628-5d54-868e-fcf4e3e8185c""; version = ""1.0.1"". [[Adapt]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""f1b523983a58802c4695851926203b36e28f09db""; uuid = ""79e6a3ab-5dfb-504d-930d-738a2a938a0e""; version = ""3.3.0"". [[ArrayInterface]]; deps = [""IfElse"", ""LinearAlgebra"", ""Requires"", ""SparseArrays"", ""Static""]; git-tree-sha1 = ""2fbfa5f372352f92191b63976d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-546",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:1001,Test,Test,1001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability," Receiving objects: 100% (103248/103248), 119.80 MiB | 1.54 MiB/s, done.; Resolving deltas: 100% (78348/78348), done.; (base) $ du -sh Oceananigans-6.jl; 131M	Oceananigans-6.jl; ```. I run [a script](https://dev.to/jakecarpenter/shrinking-your-git-repository-with-bfg-repo-cleaner-145e) to find the big files. There are some `.jld2` files in the GitHub repo... and also some `report-....nsys-rep` files.... (@simone-silvestri?). ```; All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.; size pack SHA location; 48992 16829 1dd3f4706ebc79549624bee40f78b5aa2c0d644d report-last.sqlite; 48916 16814 839a363a9dd693e35abb48f4822be360ac313a4c report-shared-memory.sqlite; 20694 12212 950954a5d3ef4fac9d6d0480886b95e66d7ec510 report-shufflin.nsys-rep; 20664 12149 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:1459,test,test,1459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability," ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] top-level scope; @ REPL[10]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) . [2022/06/01 18:14:12.544] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:14:12.545] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; Test Passed; Thrown: AssertionError; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:2130,Assert,AssertionError,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500,3,"['Assert', 'Test']","['AssertionError', 'Test']"
Testability," The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @ben",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352:1514,benchmark,benchmark,1514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352,1,['benchmark'],['benchmark']
Testability," This is done by using the `Val` type to pass the tracer index into the kernel functions that compute `∇_κ_∇c`, rather than using the raw, unwrapped, integer `tracer_index`, eg. https://github.com/climate-machine/Oceananigans.jl/blob/606d40444038d058e32be71655a7239986114a56/src/time_steppers.jl#L172. The flux divergence for constant isotropic diffusivity, for example, is now. https://github.com/climate-machine/Oceananigans.jl/blob/606d40444038d058e32be71655a7239986114a56/src/TurbulenceClosures/constant_isotropic_diffusivity.jl#L42. Benchmarks on cyclops are now. ## Master. ```julia; Oceananigans package status:; Status `~/.julia/environments/v1.1/Project.toml`; [9e8cae18] Oceananigans v0.11.1 #master (https://github.com/climate-machine/Oceananigans.jl.git). ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/fLiQ1/src/indexing.jl:16; Running static ocean benchmark: 32× 32× 32 (GPU, Float64)...; Running static ocean benchmark: 64× 64× 64 (GPU, Float64)...; Running static ocean benchmark: 128×128×128 (GPU, Float64)...; Running static ocean benchmark: 256×256×256 (GPU, Float64)...; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 82.9s / 0.58% 8.26GiB / 0.37% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 287ms 59.8% 28.7ms 7.73MiB 24.5% 791KiB; 32× 32× 32 (GPU, Float64) 10 75.9ms 15.8% 7.59ms 8.28MiB 26.3% 848KiB; 128×128×128 (GPU, Float64) 10 66.7ms 13.9% 6.67ms 7.79MiB 24.7% 798KiB; 64× 64× 64 (GPU, Float64) 10 50.6ms 10.5% 5.06ms 7.73MiB 24.5% 791KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-outer-loops`. ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852:1052,benchmark,benchmark,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852,1,['benchmark'],['benchmark']
Testability," WARNING: Method definition discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23169,test,test,23169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _concrete_ locations such that a difference needs to be resolved. In other cases (such as a binary operation between fields at common locations, or a binary operation between a field and a number), the location of the members of the operation is preserved. In this way, `BinaryOperations` are ""stubborn"". . We thus have results like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:2974,stub,stubborn,2974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['stub'],['stubborn']
Testability, [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.1; [842dd82b] InlineStrings v1.4.2; [41ab1584] InvertedIndices v1.3.0; [92d709cd] IrrationalConstants v0.2.2; [42fd0dbc] IterativeSolvers v0.9.4; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.50; [692b3bcd] JLLWrappers v1.5.0; [0f8b85d8] JSON3 v1.14.0; [63c18a36] KernelAbstractions v0.9.22; [929cbde3] LLVM v8.0.0; [8b046642] LLVMLoopInfo v1.0.0; [8ac3fa9e] LRUCache v1.6.1; [b964fa9f] LaTeXStrings v1.3.1; [2ab3a3ac] LogExpFunctions v0.3.28; ⌃ [da04e1cc] MPI v0.20.16; [3da0fdf6] MPIPreferences v0.1.11; [1914dd2f] MacroTools v0.5.13; [e1d29d7a] Missings v1.2.0; [85f8d34a] NCDatasets v0.14.4; [5da4648a] NVTX v0.3.4; [9e8cae18] Oceananigans v0.91.4; [6fe1bfb0] OffsetArrays v1.14.1; [bac558e1] OrderedCollections v1.6.3; [65ce6f38] PackageExtensionCompat v1.0.2; [69de0a69] Parsers v2.8.1; [0e08944d] PencilArrays v0.19.5; [4a48f351] PencilFFTs v0.15.1; [eebad327] PkgVersion v0.3.3; [2dfb63ee] PooledArrays v1.4.3; [aea7be01] PrecompileTools v1.2.1; [21216c6a] Preferences v1.4.3; [08abe8d2] PrettyTables v2.3.2; [49802e3a] ProgressBars v1.5.1; [94ee1d12] Quaternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [189a3867] Reexport v1.2.2; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.1; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.5; [a2af1166] SortingAlgorithms v1.2.1; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:17571,Log,LogExpFunctions,17571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Log'],['LogExpFunctions']
Testability," `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 Fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:1052,test,testfile,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['test'],['testfile']
Testability," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:1360,test,testcode,1360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,1,['test'],['testcode']
Testability, ```diff; @@ Coverage Diff @@; ## master #823 +/- ##; ==========================================; + Coverage 70.72% 71.38% +0.66% ; ==========================================; Files 188 189 +1 ; Lines 5113 5270 +157 ; ==========================================; + Hits 3616 3762 +146 ; - Misses 1497 1508 +11 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <50.00%> (-8.19%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `89.36% <54.54%> (-10.64%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZv,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956:1572,benchmark,benchmark,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956,2,['benchmark'],['benchmark']
Testability, `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:13094,Log,LogExpFunctions,13094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Log'],['LogExpFunctions']
Testability," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7301,benchmark,benchmarks,7301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['benchmark'],['benchmarks']
Testability," absmean=+2.775558e-17, std=+2.219887e-16 (4096/4096 matching grid points); ΔS: min=+0.000000e+00, max=+0.000000e+00, mean=+0.000000e+00, absmean=+0.000000e+00, std=+0.000000e+00 (4096/4096 matching grid points). Testing Rayleigh–Bénard tracer regression [CPU]; Δu: min=-1.930400e-14, max=+1.984524e-14, mean=+3.909719e-18, absmean=+1.930621e-15, std=+2.841226e-15 (4096/4096 matching grid points); Δv: min=-2.386980e-14, max=+2.642331e-14, mean=-6.492243e-19, absmean=+1.871573e-15, std=+2.799057e-15 (4096/4096 matching grid points); Δw: min=-2.242651e-14, max=+2.160425e-14, mean=+3.640442e-18, absmean=+1.618786e-15, std=+2.583244e-15 (4096/4096 matching grid points); Δb: min=-1.665335e-14, max=+2.053913e-14, mean=+9.239435e-18, absmean=+1.249038e-15, std=+1.938872e-15 (4096/4096 matching grid points); Δc: min=-6.022960e-15, max=+7.648396e-15, mean=-4.893137e-19, absmean=+5.861175e-16, std=+9.281398e-16 (4096/4096 matching grid points). Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; Δu: min=-2.772501e-07, max=+1.865995e-07, mean=-1.633351e-20, absmean=+6.868489e-10, std=+6.155992e-09 (2959/4096 matching grid points); Δv: min=-1.600098e-07, max=+1.647848e-07, mean=+1.619951e-20, absmean=+6.257578e-10, std=+5.220796e-09 (3396/4096 matching grid points); Δw: min=-9.857415e-08, max=+1.515074e-07, mean=+7.983410e-20, absmean=+4.958399e-10, std=+3.887294e-09 (2458/4096 matching grid points); ΔT: min=-3.295630e-07, max=+5.110846e-07, mean=-2.005688e-10, absmean=+2.047434e-09, std=+1.735861e-08 (4092/4096 matching grid points); ΔS: min=-3.296776e-10, max=+5.103402e-10, mean=-8.673617e-17, absmean=+2.002898e-12, std=+1.753659e-11 (4096/4096 matching grid points). Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; Δu: min=-2.139048e-08, max=+1.303954e-08, mean=-1.313232e-20, absmean=+5.768485e-11, std=+5.320877e-10 (3793/4096 matching grid points); Δv: min=-2.835820e-08, max=+2.339656e-08, mean=+1.094790e-19,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-690400562:2043,Test,Testing,2043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-690400562,1,['Test'],['Testing']
Testability," amplitude of the `truth` is significantly larger and noisier. I wonder whether the noise that was added before was of larger amplitude than what we have here?. ![vdiff](https://user-images.githubusercontent.com/8239041/221380109-96ff99c1-d6cf-4ce5-9b40-52c38eaaca11.png); ![vtruth](https://user-images.githubusercontent.com/8239041/221380111-3ee2224e-3ba3-4169-90e2-3f03cd00e78b.png); ![vnew](https://user-images.githubusercontent.com/8239041/221380112-8a34bccf-4485-406b-92e6-74f6a13f479e.png). ```; julia> include(""test_shallow_water_regression.jl""); [2023/02/25 15:42:20.222] WARN Over-writing registration of the datadep -@-> /home/fpoulin/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/25 15:42:20.223] WARN Over-writing registration of the datadep -@-> /home/fpoulin/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/25 15:42:20.355] INFO Running shallow water regression tests...; [2023/02/25 15:42:20.355] INFO Testing shallow water Bickley jet simulation regression [CPU, ConservativeFormulation]; [2023/02/25 15:42:21.128] INFO Initializing simulation...; [2023/02/25 15:42:21.129] INFO ... simulation initialization complete (685.283 μs); [2023/02/25 15:42:21.129] INFO Executing initial time step...; [2023/02/25 15:42:23.148] INFO ... initial time step complete (2.019 seconds).; [2023/02/25 15:42:23.672] INFO Simulation is stopping after running for 2.521 seconds.; [2023/02/25 15:42:23.672] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/25 15:42:23.814] INFO Δu: min=-1.673332e-04, max=+1.094476e-04, mean=+2.507827e-07, absmean=+5.538768e-06, std=+1.574960e-05 (16384/16384 matching grid points); [2023/02/25 15:42:23.814] INFO Δv: min=-2.878156e-04, max=+1.230686e-04, mean=+1.406671e-07, absmean=+2.141572e-05, std=+4.550342e-05 (256/16512 matching grid points); [2023/02/25 15:42:23.814] INFO Δh: min=-1.126421e-03, max=+1.182485e-03, mean=+9.255018e-09, absmean=+7.901569e-05, std=+2.067916e-04 (16384/16384 matching grid p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1445209446:1799,Test,Testing,1799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1445209446,1,['Test'],['Testing']
Testability," and it still fails... Rather than regenerating the regression data maybe it'll be good to change the test to check for absolute error by using the `isapprox` function and passing a non-zero `atol`. I can give this a try later this afternoon. ---. ```; Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; [ Info: Δu: min=-1.14728e-13, max=1.62294e-13, mean=-1.09883e-20, absmean=2.12163e-14, std=2.76021e-14; [ Info: Δv: min=-1.5609e-13, max=1.08464e-13, mean=-2.75418e-20, absmean=2.0988e-14, std=2.72286e-14; [ Info: Δw: min=-1.80785e-13, max=1.97494e-13, mean=-1.62683e-19, absmean=3.17569e-14, std=4.27591e-14; [ Info: ΔT: min=-2.73559e-13, max=2.06057e-13, mean=-5.36897e-16, absmean=2.77339e-14, std=3.88347e-14; [ Info: ΔS: min=-1.13687e-13, max=7.81597e-14, mean=1.56125e-17, absmean=1.51424e-14, std=1.96383e-14; Ocean large eddy simulation [CPU]: Test Failed at /Users/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:69; Expression: all(Array(data((checkpointed_model.velocities).v)) .≈ Array(data((test_model.velocities).v))); ```. ```; Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; [ Info: Δu: min=-7.75408e-14, max=5.89303e-14, mean=-3.3749e-21, absmean=1.12211e-14, std=1.46851e-14; [ Info: Δv: min=-8.65072e-14, max=4.9561e-14, mean=1.44939e-20, absmean=1.1453e-14, std=1.46633e-14; [ Info: Δw: min=-9.09516e-14, max=1.64272e-13, mean=7.36786e-20, absmean=1.85036e-14, std=2.48686e-14; [ Info: ΔT: min=-1.74083e-13, max=2.06057e-13, mean=-2.37657e-16, absmean=1.79422e-14, std=2.66236e-14; [ Info: ΔS: min=-1.20792e-13, max=7.81597e-14, mean=-3.19189e-16, absmean=1.17857e-14, std=1.57889e-14; Ocean large eddy simulation [CPU]: Test Failed at /Users/travis/build/climate-machine/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:70; Expression: all(Array(data((checkpointed_model.velocities).w)) .≈ Array(data((",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712:1853,test,test,1853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479#issuecomment-542798712,1,['test'],['test']
Testability," benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110025,test,test,110025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability," benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110343,Test,Test,110343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability," benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32.9KiB; 64x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:1153,benchmark,benchmarks,1153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['benchmark'],['benchmarks']
Testability," bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1228:1084,Test,Test,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228,1,['Test'],['Test']
Testability," but @jm-c and @christophernhill have a pretty good idea of what changes were made to accommodate channels. Some notes:. A new Poisson solver has been added that solves Poisson's equation with periodic boundary conditions in the x and staggered Neumann BCs in the y and z. This involves computing a 2D DCT on the GPU, which has no native DCT, so I implemented the fast 2D cosine transform from Makhoul (1980). Unfortunately the 2D FCT does not generalize from the 1D version, and extra steps are involved. In particular, as Fourier coefficients need to be indexed in multiple ways in some statements, we need a second buffer/storage array until I can figure out whether this is necessary. A couple of 1D masks are also needed. Anyways, so this PNN Poisson solver is a little involved, but is still decently fast. We have more tests and more GPU tests in general, but this also means that the test suite takes even longer to run especially with GPUs. I've moved each test set to it's respective file so we can use the regression tests as a stand-alone . In particular, this PR heavily refactors `poisson_solvers.jl`. It's more modular, concrete, and better documented I still need to describe the algorithms in the docs, especially important as it's not easy to figure this out and the only references are sparse papers (no code or implementations as far as I can tell). `time_steppers.jl` has also been cleaned up. Several kernels were converted to broadcasts. I also removed several bits of code that aren't used anymore. I considered making separate PRs to clean things up but I had to refactor and clean up to implement stuff so I ended up doing it all in this PR. The front-end has not changed at all but this PR ended up changing/cleaning a lot of the backend so I'd like to merge it ASAP before it starts to go out of date. Currently it's twice as slow as running a doubly periodic model. Will have to profile to figure out where it's spending that extra time. For reference, a P100 is roughly 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950:1048,test,test,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290#issuecomment-506884950,2,['test'],"['test', 'tests']"
Testability," c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1); simulation = Simulation(model, Δt=Δt, stop_time=stop_time). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Field(Average(model.tracers.c2, dims=(1, 2))); ; nc_outputs = Dict(""c1"" => ∫c1_dxdy, ""c2"" => ∫c2_dxdy); nc_dimensions = Dict(""c1"" => (""zC"",), ""c2"" => (""zC"",)). single_time_average_nc_filepath = ""single_decay_windowed_time_average_test.nc""; ; window = window_nΔt*Δt; interval = interval_nΔt*Δt. single_nc_output = Dict(""c1"" => ∫c1_dxdy); single_nc_dimension = Dict(""c1"" => (""zC"",)). simulation.output_writers[:single_output_time_average] =; NetCDFOutputWriter(model, single_nc_output,; array_type = Array{Float64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = overwrite); checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation. end; ; Δt = .01 #1/64 # Nice floating-point number; T1 = 6Δt # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); window_nΔt = 2; interval_nΔt = 2; stride = 1; # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, window_nΔt, interval_nΔt, stride, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, window_nΔt, interval_nΔt, stride, false); run!(simulation, pickup=checkpoint). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 /",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:3359,test,test,3359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['test'],['test']
Testability," code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1244,test,test,1244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,1,['test'],['test']
Testability," const Δz = Lz / 2 # elevation difference at the top. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; # return Lz - Δz * sin(π/2 * y/Ly) - Δz * 0.2; return Lz - Δz; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; topology = (Periodic, Bounded, Bounded),; halo = (4, 4, 4),; ). @inline function is_ib(x::R, y::R, z::R) where {R<:Real}; return z > z_top(y); # return false; end. ImmersedBoundaryGrid(; underlying_grid,; GridFittedBoundary(is_ib); ); end. # pressure solver; pressure_solver = ImmersedPoissonSolver(; ib_grid,; preconditioner = :FFT,; solver_method = :PreconditionedConjugateGradient,; reltol = 0,; abstol = 0,; maxiter = 20,; ). # ---------------------------------------------------------------------- #; # test the solver. rhs = Field((Center, Center, Center), ib_grid); output = Field((Center, Center, Center), ib_grid). set!(output, 0.0). output[1, 1, 1] = 1.0 # use a random field as the solution. pressure_solver.pcg_solver.linear_operation!(rhs, output). rhs ./= norm(rhs). set!(output, 0.0). solve!(output, pressure_solver.pcg_solver, rhs). # ---------------------------------------------------------------------- #; # calculate the eigenvalues. const c0 = 0.1; const do_gauge_fixing = true; const active_cells = active_cells_map(ib_grid, ib_grid.immersed_boundary). const n_active_cells = length(active_cells). if do_gauge_fixing; @assert c0 > 0; end. function apply_linear_operation!(w, v, solver); solver.pcg_solver.linear_operation!(w, v); if do_gauge_fixing; w .-= c0 * mean(v); end; end. function apply_preconditioner!(w, v, solver); precondition!(w, solver.pcg_solver.preconditioner, v); mask_immersed_field!(w); if do_gauge_fixing; w .-= inv(c0) * mean(v); end;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611:2508,test,test,2508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611,1,['test'],['test']
Testability," data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:3623,Log,Logging,3623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['Log'],['Logging']
Testability," definition discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:177 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23394,test,test,23394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:1508,test,tests,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['test'],['tests']
Testability," discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:17577,test,test,17577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," e::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, @NamedTuple{}}}, ::Active{Float64}); @ Enzyme ~/.julia/packages/Enzyme/8GSlk/src/Enzyme.jl:504; [63] macro expansion; @ ~/Projects/Oceananigans.jl/test/test_enzyme.jl:285 [inlined]; [64] macro expansion; @ ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:1577 [inlined]; [65] top-level scope; @ ~/Projects/Oceananigans.jl/test/test_enzyme.jl:265; [66] include(fname::String); @ Base.MainInclude ./client.jl:489; [67] top-level scope; @ REPL[6]:1; [68] eval; @ ./boot.jl:385 [inlined]; [69] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; [70] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; [71] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; [72] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; [73] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/.julia/jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:151623,test,test,151623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['test'],['test']
Testability," errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | ERROR: ERROR: ERROR: ERROR: Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] pkgerrorPackage Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] (pkgerror; &nbsp; | [1] (pkgerror::(; &nbsp; | [1] ::pkgerrorString) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; &nbsp; | [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:2409,test,testing,2409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,4,['test'],['testing']
Testability," errors are present even in the initial velocities and the diagnosed initial vorticity. The vorticity error is significantly pronounced near the cubed sphere corners due to the deviation from orthogonality. For instance, in the domain's interior, the vorticity error norm is three orders of magnitude less than the vorticity norm, whereas at the corners, it is nearly the same order of magnitude.; - As the simulation progresses, the amplified error from the corners propagates into the interior as expected. After 500 time steps, the vorticity error in the interior increases from three orders of magnitude less to one order of magnitude less than the vorticity norm. I have attached panel-wise plots of the exact vorticity and the error of its numerical counterpart on the cubed sphere for the initial condition and after 500 time steps for reference. Given these circumstances, @navidcy and I are contemplating whether we should continue using the exact solution for verification in the test script or consider alternative verification methods, such as ensuring that the norm of the numerical solution of the Rossby-Haurwitz wave remains bounded within a specified range (as mentioned in the introduction to this PR). @glwagner, @simone-silvestri and @jm-c, let us know your thoughts. **Exact initial vorticity**. ![cubed_sphere_rossby_haurwitz_wave_ζ₀_exact](https://github.com/CliMA/Oceananigans.jl/assets/12926768/ec936d28-49e5-4da2-9f49-783e517b6f0c). **Error in initial vorticity**. ![cubed_sphere_rossby_haurwitz_wave_ζ₀_error](https://github.com/CliMA/Oceananigans.jl/assets/12926768/59374933-eeab-417b-adfe-56eb1e2e5673). **Exact vorticity after 500 time steps**. ![cubed_sphere_rossby_haurwitz_wave_ζ_exact](https://github.com/CliMA/Oceananigans.jl/assets/12926768/15c81d0c-239e-42ad-a740-8505bd3a4a35). **Error in vorticity after 500 time steps**. ![cubed_sphere_rossby_haurwitz_wave_ζ_error](https://github.com/CliMA/Oceananigans.jl/assets/12926768/9209cb44-860b-4a88-8d4a-946d1143da7c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684:1739,test,test,1739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684,1,['test'],['test']
Testability," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2041,stub,stubborn,2041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['stub'],['stubborn']
Testability," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2878,test,test,2878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,1,['test'],['test']
Testability," few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centrali",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1813,log,logic,1813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,1,['log'],['logic']
Testability," forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002 ms │ 881.88 KiB │ 1514 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 7.747 ms │ 7.970 ms │ 8.234 ms │ 10.968 ms │ 1.28 MiB │ 2103 │ 10 │; │ CPU │ RectilinearGrid │ ImplicitFreeSurface │ 151.499 ms │ 165.772 ms │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:3525,Benchmark,Benchmarks,3525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['Benchmark'],['Benchmarks']
Testability," from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:1258,log,log,1258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['log'],['log']
Testability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1911,log,logic,1911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,"['log', 'test']","['logic', 'testing']"
Testability," graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #856 +/- ##; ==========================================; + Coverage 70.84% 70.99% +0.14% ; ==========================================; Files 187 188 +1 ; Lines 5180 5230 +50 ; ==========================================; + Hits 3670 3713 +43 ; - Misses 1510 1517 +7 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.05% <0.00%> (-3.95%)` | :arrow_down: |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/Diagnostics/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL3dpbmRvd2VkX3RpbWVfYXZlcmFnZS5qbA==) | `84.37% <84.37%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `93.33% <100.00%> (+1.02%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856?src=pr&el=footer). Last update [b2c5393...d7188c2](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/856?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/856#issuecomment-674243275:1625,test,test,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/856#issuecomment-674243275,2,['test'],['test']
Testability," grid points);   | [2023/05/22 15:07:12.175] INFO Δw: min=-4.886854e-13, max=+5.149812e-13, mean=+2.845466e-16, absmean=+5.854449e-14, std=+8.803219e-14 (4318/4352 matching grid points);   | [2023/05/22 15:07:12.176] INFO ΔT: min=-1.303846e-12, max=+1.495692e-12, mean=-4.293441e-17, absmean=+1.875657e-13, std=+2.728047e-13 (4096/4096 matching grid points);   | [2023/05/22 15:07:12.177] INFO ΔS: min=-4.632739e-12, max=+5.300649e-12, mean=-1.405126e-16, absmean=+6.662951e-13, std=+9.690186e-13 (4096/4096 matching grid points);   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Expression: all(test_fields.u .≈ correct_fields.u);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Expression: all(test_fields.v .≈ correct_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:78;   | Expression: all(test_fields.w .≈ correct_fields.w); ```. You can see that u, v, and w fail, but the errors are really small an",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586:1746,test,test,1746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586,1,['test'],['test']
Testability," if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7274,test,testing,7274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['testing']
Testability," improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with Regular",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:1011,Benchmark,Benchmarking,1011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['Benchmark'],['Benchmarking']
Testability," in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:179 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:180 overwritten on the same line (check for duplicate calls to `include`).; [2024/03/15 16:21:27.055] INFO Testing Coriolis...; FPlane{Float32}(f=0.000103126); ConstantCartesianCoriolis{Float32}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float32}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float32}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); FPlane{Float64}(f=0.000103126); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 0.00e+00, fz = 1.00e-04; BetaPlane{Float64}(f₀=0.000103126, β=1.61868e-11); NonTraditionalBetaPlane{Float64}(fz = 1.03e-04, fy = 1.03e-04, β = 1.62e-11, γ = -3.24e-11, R = 6.37e+06); Test Summary: | Pass Total Time; Oceananigans | 90 90 1.8s; Testing Oceananigans tests passed ; ```. Closes #3507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:23859,test,test,23859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,5,"['Test', 'test']","['Test', 'Testing', 'test', 'tests']"
Testability," interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ1(x, y, z) = x + (1 - y)^2 + tanh(z); λ2(x, y, z) = x + (1 - y)^2 + tanh(4z). Fc1(x, y, z, t, c1) = - λ1(x, y, z) * c1; Fc2(x, y, z, t, c2) = - λ2(x, y, z) * c2; ; c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2=c2_forcing)). set!(model, c1=1, c2=1); simulation = Simulation(model, Δt=Δt, stop_time=stop_time). ∫c1_dxdy = Field(Average(model.tracers.c1, dims=(1, 2))); ∫c2_dxdy = Fi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:1590,Test,Test,1590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['Test'],['Test']
Testability," it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a lo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2187,Test,Test,2187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['Test'],['Test']
Testability," j+1, k) - δy_c2f(g, f, i, j, k); end; end. @inline function δz²_c2f2c(g::RegularCartesianGrid, f, i, j, k); if k == g.Nz; return δz_c2f(g, f, i, j, k); else; return δz_c2f(g, f, i, j, k) - δz_c2f(g, f, i, j, k+1); end; end. @inline function ∇²_pnn(g::RegularCartesianGrid, f, i, j, k); 	(δx²_c2f2c(g, f, i, j, k) / g.Δx^2) + (δy²_c2f2c(g, f, i, j, k) / g.Δy^2) + (δz²_c2f2c(g, f, i, j, k) / g.Δz^2); end. function ∇²_pnn!(grid::RegularCartesianGrid, f, ∇²f); @loop for k in (1:grid.Nz; blockIdx().z); @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); @inbounds ∇²f[i, j, k] = ∇²_pnn(grid, f, i, j, k); end; end; end. @synchronize; end. function solve_poisson_3d_pnn!(g::RegularCartesianGrid, f::CellField, ϕ::CellField); kx² = zeros(g.Nx, 1); ky² = zeros(g.Ny, 1); kz² = zeros(g.Nz, 1). for i in 1:g.Nx; kx²[i] = (2sin((i-1)*π/g.Nx) / (g.Lx/g.Nx))^2; end; for j in 1:g.Ny; ky²[j] = (2sin((j-1)*π/(2g.Ny)) / (g.Ly/g.Ny))^2; end; for k in 1:g.Nz; kz²[k] = (2sin((k-1)*π/(2g.Nz)) / (g.Lz/g.Nz))^2; end. FFTW.r2r!(f.data, FFTW.REDFT10, [2, 3]); FFTW.fft!(f.data, 1). for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds ϕ.data[i, j, k] = -f.data[i, j, k] / (kx²[i] + ky²[j] + kz²[k]); end; ϕ.data[1, 1, 1] = 0. FFTW.ifft!(ϕ.data, 1). @. ϕ.data = real(ϕ.data) / (2g.Ny*2g.Nz). FFTW.r2r!(ϕ.data, FFTW.REDFT01, [2, 3]). nothing; end. function poisson_pnn_planned_div_free_cpu(ft, Nx, Ny, Nz, planner_flag); g = RegularCartesianGrid(ft, (Nx, Ny, Nz), (100, 100, 100)). RHS = CellField(Complex{ft}, CPU(), g); RHS_orig = CellField(Complex{ft}, CPU(), g); ϕ = CellField(Complex{ft}, CPU(), g); ∇²ϕ = CellField(Complex{ft}, CPU(), g). RHS.data .= rand(Nx, Ny, Nz); RHS.data .= RHS.data .- mean(RHS.data). RHS_orig.data .= copy(RHS.data). solve_poisson_3d_pnn!(g, RHS, ϕ); ∇²_pnn!(g, ϕ, ∇²ϕ). ∇²ϕ.data ≈ RHS_orig.data; end. @test poisson_pnn_planned_div_free_cpu(Float64, 16, 16, 16, FFTW.ESTIMATE); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344:3195,test,test,3195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-483896344,1,['test'],['test']
Testability," libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwrit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:14022,test,test,14022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:21006,test,test,21006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [6] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:448; &nbsp; | Halo communication: Test Failed at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:366; &nbsp; | Expression: all(south_halo(field, include_corners = false) .== arch.connectivity.south); &nbsp; | Stacktrace:; &nbsp; | [1] test_triply_periodic_halo_communication_with_411_ranks(::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:366; &nbsp; | [2] macro expansion at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:477 [inlined]; &nbsp; | [3] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [4] macro expansion at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:475 [inlined]; &nbsp; | [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [6] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:448; &nbsp; | Halo communication: Halo communication: Test Failed at Test Failed at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:365; &nbsp; | /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:365; &nbsp; | Halo communication: Test Failed at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:365; &nbsp; | Expression: Expression: all(north_halo(field, include_corners = all(north_halo(fiel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843439802:2030,Test,Test,2030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843439802,2,['Test'],['Test']
Testability," manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); CubedSphereField{Center, Center, Center}; ├── grid: 3×3×1 ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo; ├── boundary conditions: FieldBoundaryConditions; └── data: Mul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:1217,test,test,1217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511,1,['test'],['test']
Testability," nothing). g = model.free_surface.gravitational_acceleration; R = grid.radius; Ω = model.coriolis.rotation_rate. uᵢ(λ, φ, z) = 0.1 * cosd(φ) * sind(λ); ηᵢ(λ, φ, z) = (0.1 * Ω * R + 0.1^2 / 2) * sind(φ)^2 / g * sind(λ); cᵢ(λ, φ, z) = Gaussian(λ - 1, φ - 5, 10). set!(model, u=uᵢ, η=ηᵢ, c=cᵢ). Δt = 0.1 * Δ_min(grid) / sqrt(g * grid.Lz) . for _ in 1:20; time_step!(model, Δt); end. return merge(model.velocities, model.tracers, (; η = model.free_surface.η)); end. Nx = 32; Ny = 32. grid = LatitudeLongitudeGrid(CPU(), size = (Nx, Ny, 1),; halo = (3, 3, 3),; latitude = (-80, 80),; longitude = (-160, 160),; z = (-1, 0),; radius = 1,; topology=(Bounded, Bounded, Bounded)). us, vs, ws, cs, ηs = solid_body_rotation_test(grid). regions = 2; P = XPartition. @info "" Testing $regions $(P)s on $(typeof(grid).name.wrapper) on the $arch""; u, v, w, c, η = solid_body_rotation_test(grid; P=P, regions=regions). u = reconstruct_global_field(u); v = reconstruct_global_field(v); w = reconstruct_global_field(w); c = reconstruct_global_field(c); η = reconstruct_global_field(η). using GLMakie. function plot_to_compare(field1, field2). λ, φ, z = nodes(field1). fig = Figure(fontsize=30); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); ax3 = Axis(fig[1, 3]). heatmap!(ax1, λ, φ, interior(field1, :, :, 1)); heatmap!(ax2, λ, φ, interior(field2, :, :, 1)); heatmap!(ax3, λ, φ, interior(field1, :, :, 1) .- interior(field2, :, :, 1)). return fig; end. @show @test all(isapprox(u, us, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(v, vs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(w, ws, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(c, cs, atol=1e-20, rtol = 1e-15)); @show @test all(isapprox(η, ηs, atol=1e-20, rtol = 1e-15)); ```. The test for `c` fails. When you then plot. ```Julia; fig = plot_to_compare(cs, c); fig; ```. <img width=""1290"" alt=""Screenshot 2023-04-13 at 2 26 11 pm"" src=""https://user-images.githubusercontent.com/7112768/231653433-fd089614-26ca-4306-9069-0b2194f7dd2d.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737:2530,test,test,2530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1506325737,6,['test'],['test']
Testability," ocean (GPU, Float32) 10 5.68ms 0.01% 568μs 1.35MiB 11.0% 139KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```. Now:; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Intermediate output Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 116s / 69.4% 115GiB / 81.4% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 64x 64x 64 static ocean (CPU, Float32) 10 70.3s 87.0% 7.03s 83.5GiB 88.9% 8.35GiB; 32x 32x 32 static ocean (CPU, Float32) 10 10.5s 13.0% 1.05s 10.4GiB 11.1% 1.04GiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 63.8s / 1.31% 13.6GiB / 0.09% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (GPU, Float64) 10 366ms 43.9% 36.6ms 1.79MiB 13.6% 183KiB; 256x256x256 static ocean (GPU, Float32) 10 344ms 41.2% 34.4ms 1.51MiB 11.4% 155KiB; 128x128x128 static ocean (GPU, Float64) 10 49.8ms 5.96% 4.98ms 1.79MiB 13.6% 183KiB; 128x128x128 static ocean (GPU, Float32) 10 48.6ms 5.82% 4.86ms 1.51MiB 11.4% 155KiB; 64x 64x 64 static ocean (GPU, Float64) 10 7.78ms 0.93% 778μs 1.79MiB 13.6% 183KiB; 64x 64x 64 static ocean (GPU, Float32) 10 7.66ms 0.92% 766μs 1.51MiB 11.4% 155KiB; 32x 32x 32 static ocean (GPU, Float32) 10 5.35ms 0.64% 535μs 1.51MiB 11.4% 154KiB; 32x 32x 32 static ocean (GPU, Float64) 10 4.57ms 0.55% 457μs 1.79MiB 13.6% 183KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496475610:2775,benchmark,benchmarks,2775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496475610,1,['benchmark'],['benchmarks']
Testability," on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_funct",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20792,test,test,20792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition simple_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:174 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_function_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:175 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:176 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_function_bc(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:20583,test,test,20583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> 0)); test_dynamics.jl: grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); test_dynamics.jl: # Immersed grid cases; test_dynamics.jl: immersed_vertical_grid = ImmersedBoundaryGrid(RectilinearGrid(arch,; test_dynamics.jl: ImmersedBoundaryGrid(RectilinearGrid(arch,; test_hydrostatic_free_surface_immersed_boundaries_implicit_solve.jl:using ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:1426,test,test,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199,1,['test'],['test']
Testability," problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:2874,benchmark,benchmarks,2874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability," rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1657,Test,Test,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['Test'],['Test']
Testability," schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 14.2 ms Histogram: frequency by time 14.4 ms <. Memory estimate: 47.78 KiB, allocs estimate: 320. ```. The counterpart using the new ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:1499,Benchmark,BenchmarkTools,1499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['Benchmark'],['BenchmarkTools']
Testability," simulation initialization complete (79.862 ms); > [2023/02/15 08:09:30.137] INFO Executing initial time step...; > [2023/02/15 08:09:49.128] INFO ... initial time step complete (18.991 seconds).; > [2023/02/15 08:09:49.218] INFO Simulation is stopping after running for 19.159 seconds.; > [2023/02/15 08:09:49.218] INFO Model iteration 20 equals or exceeds stop iteration 20.; > [2023/02/15 08:09:49.338] INFO Δu: min=-2.979433e-08, max=+2.978377e-08, mean=-1.025389e-10, absmean=+1.911258e-09, std=+5.570608e-09 (16384/16384 matching grid points); > [2023/02/15 08:09:49.338] INFO Δv: min=-2.709283e-11, max=+2.834728e-11, mean=-2.606411e-14, absmean=+1.007855e-12, std=+2.676083e-12 (16512/16512 matching grid points); > [2023/02/15 08:09:49.339] INFO Δh: min=-4.765317e-07, max=+4.756881e-07, mean=+1.373701e-08, absmean=+2.044855e-07, std=+2.513230e-07 (16384/16384 matching grid points); > Test Passed; > ; > julia> run_shallow_water_regression(arch, formulation; regenerate_data = false)VectorInvariantFormulation()^C; > ; > julia> run_shallow_water_regression(arch, VectorInvariantFormulation(); regenerate_data = false); > [2023/02/15 08:10:46.432] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /g/data/v45/nc3020/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; > [2023/02/15 08:10:46.449] INFO Initializing simulation...; > [2023/02/15 08:10:46.450] INFO ... simulation initialization complete (580.963 μs); > [2023/02/15 08:10:46.450] INFO Executing initial time step...; > [2023/02/15 08:10:46.453] INFO ... initial time step complete (3.038 ms).; > [2023/02/15 08:10:46.490] INFO Simulation is stopping after running for 39.012 ms.; > [2023/02/15 08:10:46.490] INFO Model iteration 20 equals or exceeds stop iteration 20.; > [2023/02/15 08:10:46.492] INFO Δu: min=-2.910407e-08, max=+2.965560e-08, mean=+4.423683e-11, absmean=+1.880294e-09, std=+5.514070e-09 (16384",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430398013:1128,Test,Test,1128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430398013,1,['Test'],['Test']
Testability," slower; > than optimal performance.; >; > As it does not allocate memory, we can now calculate vertical profiles; > even when running large models that fill up memory.; >; > Although I should mention that an intermediate array with a size of at; > least 1*Ny*Nz is required for the parallel reduction step (so I'm using; > poisson_solvers.storage because it's a vanilla CuArray that can be; > overwritten).; >; > N, H = 512, 1; > T = N + 2H; >; > a = rand(T, T, T) |> CuArray; > h = zeros(N) |> CuArray; >; > What we were doing before:; >; > @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]); >; > BenchmarkTools.Trial:; > memory estimate: 1.01 GiB; > allocs estimate: 250; > --------------; > minimum time: 684.013 ms (2.29% GC); > median time: 712.570 ms (6.28% GC); > mean time: 732.480 ms (8.79% GC); > maximum time: 807.437 ms (16.95% GC); > --------------; > samples: 7; > evals/sample: 1; >; > What this PR does:; >; > Nx, Ny, Nz = 512, 512, 512; > C = rand(Nx, Ny, Nz) |> CuArray; > Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; > Rxy = zeros(Float64, 1, 1, Nz) |> CuArray; > @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +); >; > BenchmarkTools.Trial:; > memory estimate: 2.88 KiB; > allocs estimate: 64; > --------------; > minimum time: 39.129 ms (0.00% GC); > median time: 39.245 ms (0.00% GC); > mean time: 39.248 ms (0.00% GC); > maximum time: 39.374 ms (0.00% GC); > --------------; > samples: 128; > evals/sample: 1; >; > Probably optimal performance:; >; > @benchmark CuArrays.@sync mean(a, dims=[1, 2]); >; > BenchmarkTools.Trial:; > memory estimate: 8.56 KiB; > allocs estimate: 220; > --------------; > minimum time: 7.426 ms (0.00% GC); > median time: 7.526 ms (0.00% GC); > mean time: 7.527 ms (0.00% GC); > maximum time: 8.817 ms (0.00% GC); > --------------; > samples: 663; > evals/sample: 1; >; > Resolves #186; > <https://github.com/climate-machine/Oceananigans.jl/issues/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010:2366,benchmark,benchmark,2366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010,1,['benchmark'],['benchmark']
Testability," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:3171,benchmark,benchmark,3171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['benchmark'],['benchmark']
Testability," t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107160,Test,Test,107160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability," the Laplacian of the solution ∇²ϕ does not produce f(x,y,z) to machine precision if the Laplacian is discretized using a second-order centered difference scheme, which is what the ocean model essentially does to calculate the pressure gradients to step forward the velocities. If ∇²ϕ does not equal f(x,y,z) to machine precision then ∇·u will be non-zero and mass will accumulate, eventually leading the model to blow up. **""Second-order"" case**: We want ∇·u=0 so what we'll do now is discretize Poisson's equation using second-order centered differences so that ∇²ϕ = f(x,y,z) becomes; ```[ϕ(i+1, j, k) - 2ϕ(i, j, k) + ϕ(i-1, j, k)] / Δx² + ... similarly for y and z ... = f(i, j, k)```. Then you plug in the IDFT and IDCT expressions into all the ϕ(i+1, j, k), ϕ(i, j, k), ϕ(i-1, j, k), etc. terms and solve the equation in Fourier space. The solution will look again look like ϕh_lmn = - fh_lmn / (kx² + ky² + kz²) except now; ```; kx² = (4 / Δx²) * sin(πl / Nx)² # DFT; ky² = (4 / Δy²) * sin(πm / Ny)² # DFT; kz² = (2 / Δz²) * (cos(πn / Nz) - 1) # DCT; ```; If you use these wavenumbers then you lose the spectral convergence and instead only get second-order convergence as expected because we've discretized the derivative operator (I've tested this but only in a Jupyter notebook right now). However, because we've discretized the Laplacian in the same way we do so for calculating pressure gradients, calculating the discretized Laplacian ∇²ϕ now produces f(x,y,z) to machine precision, which should ensure that ∇·u=0. I have this working in the 1D periodic case (DFT) and the 1D case with Neumann boundary conditions (DCT) as well as the 2D periodic case (DFTs in x,y) but I'm still trying to figure out the 2D mixed case (e.g. DFT in x, DCT in y). I don't know if what I've written makes much sense (or if I'm even describing it correctly) but I know it works as we are chiefly interested in keeping ∇·u=0 which requires that ∇²ϕ = f(x,y,z) if ∇² is discretized using centered differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440817785:1868,test,tested,1868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440817785,1,['test'],['tested']
Testability," this file fall into three categories:; @inline Δzᵃᵃᶜ(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; @inline Δzᵃᵃᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; ; +@inline Δzᶠᶜᶜ(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; +@inline Δzᶜᶠᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4295,test,test,4295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406,1,['test'],['test']
Testability," time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:1020,log,log,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['log'],['log']
Testability," tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:4498,stub,stubborn,4498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['stub'],['stubborn']
Testability," to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition discrete_func(Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:162 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_discrete_func(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:163 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition parameterized_fun(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:165 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition field_dependent_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:166 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition exploding_fun(Any, Any, Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:16911,test,test,16911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability," to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:3456,test,tested,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tested']
Testability," top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114683,Benchmark,Benchmark,114683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability," tridiagonal solver in the pure FFT solver. You might argue that we just put nothing if we don't need it, but then we have more ""ambiguous"" fields like eigenvalues that are not needed in the tridiagonal solver and source_term that is not needed in the FFT. I am not convinced that a single solver would lead to less (or cleaner) code. Mostly because the underlying code (constructor and `solve!` functions) is compact and slender enough to justify writing individual functions for different grids (the number of lines in the docstring for the `DistributedFourierTridiagonalPoissonSolver` is comparable to the code related to the solver). I think this improves the interpretability of the algorithm. Maybe an improvement would be writing a unified constructor that would spit out the different solvers. > 2. It might make sense to split the constructor into two parts, so that we can build a tridiagonal solver even when all three directions are regular. That could be useful for testing, for example. . I have added this capability by passing the `stretched_direction` kwarg. > Also note that in terms of operation count the tridiagonal solve is cheaper than FFT... I think, all things considered, the mixed FFT / tridiagonal solve will have basically the same computational cost as the pure FFT solve only for a stretched x direction. The additional transposes required for a y or stretched z direction will completely dominate the cost of the actual operations. As an example, this is a slab decomposition with a fairly big grid (512 x 256^2) split on 2 GPUs on Tartarus; ![311333172-43dba752-a91f-4b33-8ade-5a6ec57c982b](https://github.com/user-attachments/assets/1a376c1e-9912-4e00-8dca-91deb46338f8); The AlltoAllv is the dominant cost, while the FFT (in between the two transposes) is quite irrelevant. In the near future, I'll perform scaling tests on Perlmutter, which has a much better network, so it might be that (even if I think it's unlikely) the cost is not all communication after all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073:2352,test,tests,2352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073,1,['test'],['tests']
Testability, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:14808,Log,Logging,14808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,2,"['Log', 'Test']","['Logging', 'Test']"
Testability," way that will not overwrite the original pressures. . I tried to start with the second term ($p_r'$) in the RHS of the equation. This term is the component that results from rapid distortion by the current shear. For this term, the vertical boundary condition is $\partial p_r' / \partial x_3 = 0$ (see more details about boundary conditions in Appendix A in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). So the goal is to solve an equation $\nabla^2p_r' = -2\frac{\partial U_i}{\partial x_j}\frac{\partial u_j'}{\partial x_i}$ with applying the boundary condition $\partial p_r' / \partial x_3 = 0$. I have written a part of the code (I start from the calculation of $p_r'$ because there is no need to consider the boundary conditions, and the calculation I think can directly follow the calculation of $p_{NHS}$). Now I have tested it on the CPU, and output the pressure (I call it “prapid” in my code) like ```model.pressures.prapid ```, but there are also some problems. I add part of the code in [https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/solve_for_pressure.jl](url) following the cacluation of $p_{NHS}$ like: . ```julia; @kernel function calculate_pressure_source_term_fft_based_solver_rapid!(rhs, grid, Δt, U★); i, j, k = @index(Global, NTuple); U = Field(Average(U★.u, dims=(1, 2))); V = Field(Average(U★.v, dims=(1, 2))); W = Field(Average(U★.w, dims=(1, 2))); u_prime = Field(U★.u - U); v_prime = Field(U★.v - V); w_prime = Field(U★.w - W). @inbounds rhs[i, j, k] = -2*( ∂xᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, U)*∂xᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂xᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, u_prime) + ∂yᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, v_prime) + ∂zᶜᶜᶜ(i, j, k, grid, V)*∂yᶜᶜᶜ(i, j, k, grid, w_prime) \; + ∂x",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:2079,test,tested,2079,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['test'],['tested']
Testability," we are always performing the reconstruction twice. This is not a huge problem for linear reconstruction schemes (`UpwindBiased`) but leads to register blowup for `WENO` schemes that are extremely heavy to compute. ; This PR aims to push the `left` - `right` choice _inside_ the reconstruction function by realizing that the only difference between left and right reconstruction is how the data is organized in the stencil.; In this way, only one reconstruction is required significantly reducing register pressure, and consequently, computation time.; This follows the same pattern found in [SpeedyWeather.jl](https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/4fd8c045fbc493f94b70f121cabf8f8fc3c15f66/src/dynamics/vertical_advection.jl#L124-L148). Some benchmarks are implemented in the [NESAPOceananigans.jl](https://github.com/simone-silvestri/NESAPOceananigans.jl) repository. . Here are some timing tests on main with a **NON-Immersed** grid (launching julia with `julia --project=""environments/main"" --check-bounds=no`); ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 21.916 ms … 22.784 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 22.036 ms ┊ GC (median): 0.00%; Time (mean ± σ): 22.144 ms ± 363.318 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ ██ █; ██▁▁▁▁▁▁██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 21.9 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 245.86 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 14.189 ms … 14.421 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.261 ms ┊ GC (median): 0.00%; Time (mean ± σ): 14.269 ms ± 93.553 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. ██ █ █ █; ██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658:1198,test,tests,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658,1,['test'],['tests']
Testability," Δx = L / N; k² = @. (4 / Δx^2) * sin(π*n / N)^2; elseif wavenumbers == :analytic; # Wavenumbers if the derivatives are not discretized, should give; # spectral convergence so that ϕ is accurate but ∇²ϕ ≈ f(x) as the ∇²; # operator must be discretized.; k² = @. ((2*π / L) * n)^2; end. # Forward transform the real-valued source term.; fh = FFTW.rfft(f). # Calculate the Fourier coefficients of the source term.; # We only need to compute the first (N-1)/2 + 1 Fourier coefficients; # as ϕh(N-i) = ϕh(i) for a real-valued f.; ϕh = - fh ./ k²[1:Int(N/2 + 1)]. # Setting the DC/zero Fourier component to zero.; ϕh[1] = 0. # Take the inverse transform of the . We need to specify that the input f; # had a length of N as an rrft of length N/2 may have come from an array; # of length N (if N is even) or N-1 (if N is odd).; ϕ = FFTW.irfft(ϕh, N); end; ```; where I use the ""analytic wavenumbers"" if I want spectral convergence for the solution; ```; # Testing with the cos(2πz/H) source term should give a spectral solution that; # is numerically accurate within ≈ machine epsilon, so in these tests we can; # use ≈ to check the spectral solution with the analytic solution.; #; # With the source term f(z) = cos(2πz/H), the analytic solution is given by; # ϕ(z) = -(H/2π)² cos(2πz/H) and is periodic as ϕ(0) = ϕ(H). function test_solve_poisson_1d_pbc_cosine_source(N); H = 12 # Length of domain.; Nz = N # Number of grid points.; Δz = H / Nz # Grid spacing.; z = Δz * (0:(Nz-1)) # Grid point locations. f = cos.(2*π*z ./ H) # Source term.; ϕa = @. -(H / (2π))^2 * cos((2π / H) * z) # Analytic solution. ϕs = solve_poisson_1d_pbc(f, H, :analytic). ϕs ≈ ϕa; end; ```; and the ""second-order wavenumbers"" if I want the discretized Laplacian of the solution to equal the source term to numerical precision; ```; function test_solve_poisson_1d_pbc_divergence_free(N); laplacian1d(f) = circshift(f, 1) - 2 .* f + circshift(f, -1). A = rand(N); A .= A .- mean(A); B = solve_poisson_1d_pbc(A, N, :second_order); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440721660:1927,Test,Testing,1927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-440721660,2,"['Test', 'test']","['Testing', 'tests']"
Testability," μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:4253,benchmark,benchmarks,4253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['benchmark'],['benchmarks']
Testability," … 0.00%; Time (median): 9.717 ms ┊ GC (median): 0.00%; Time (mean ± σ): 9.797 ms ± 271.120 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ █ █ █ █; █▁█▁▁▁▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 9.61 ms Histogram: frequency by time 10.3 ms <. Memory estimate: 89.45 KiB, allocs estimate: 320. ```. on this branch:; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(momentum_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(13.991 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 13.991 ms … 22.167 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.057 ms ┊ GC (median): 0.00%; Time (mean ± σ): 15.676 ms ± 3.629 ms ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁; 14 ms Histogram: frequency by time 22.2 ms <. Memory estimate: 487.70 KiB, allocs estimate: 766. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(tracer_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(4.807 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 4.807 ms … 5.457 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 4.819 ms ┊ GC (median): 0.00%; Time (mean ± σ): 4.958 ms ± 281.609 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █▁ ▁ ▁; ██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 4.81 ms Histogram: frequency by time 5.46 ms <. Memory estimate: 88.53 KiB, allocs estimate: 261. ```; A test on the global ocean configuration (found in [prototype_omip_simulation.jl](https://github.com/CliMA/ClimaOcean.jl/blob/aacd2e19b81e35a3b220bd45aa6b5bcb98dc876d/prototype_omip_simulation/prototype_omip_simulation.jl) ) is incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643:2347,Benchmark,BenchmarkTools,2347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643,2,"['Benchmark', 'test']","['BenchmarkTools', 'test']"
Testability," ───────────────────────; Tot / % measured: 2078s / 77.1% 15.0GiB / 0.14% ; Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 156ms 0.01% 15.6ms 2.59MiB 12.5% 265KiB; 32× 32× 32 [CPU, Float64] 10 162ms 0.01% 16.2ms 2.59MiB 12.5% 265KiB; 64× 64× 64 [CPU, Float32] 10 1.86s 0.12% 186ms 2.59MiB 12.5% 265KiB; 64× 64× 64 [CPU, Float64] 10 1.83s 0.11% 183ms 2.59MiB 12.5% 265KiB; 128×128×128 [CPU, Float32] 10 38.2s 2.38% 3.82s 2.59MiB 12.5% 265KiB; 128×128×128 [CPU, Float64] 10 38.3s 2.39% 3.83s 2.59MiB 12.5% 265KiB; 256×256×256 [CPU, Float32] 10 750s 46.8% 75.0s 2.60MiB 12.5% 266KiB; 256×256×256 [CPU, Float64] 10 771s 48.1% 77.1s 2.60MiB 12.5% 266KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. # GPU benchmarks (Titan V). ## v0.27.0. ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 53.5s / 1.62% 7.40GiB / 1.17% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [GPU, Float32] 10 28.9ms 3.34% 2.89ms 11.0MiB 12.5% 1.10MiB; 32× 32× 32 [GPU, Float64] 10 26.7ms 3.08% 2.67ms 11.0MiB 12.5% 1.10MiB; 64× 64× 64 [GPU, Float32] 10 31.7ms 3.66% 3.17ms 11.0MiB 12.5% 1.10MiB; 64× 64× 64 [GPU, Float64] 10 27.5ms 3.18% 2.75ms 11.0MiB 12.5% 1.10MiB; 128×128×128 [GPU, Float32] 10 45.6ms 5.27% 4.56ms 11.0MiB 12.5% 1.10MiB; 128×128×128 [GPU, Float64] 10 50.2ms 5.80% 5.02ms 11.0MiB 12.5% 1.10MiB; 256×256×256 [GPU, Float32] 10 328ms 37.9% 32.8ms 11.0MiB 12.5% 1.10MiB; 256×256×256 [GPU, Float64] 10 327ms 37.8% 32.7ms 11.0MiB 12.5% 1.10MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## This PR. ```; ───────────────────────────────────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660660104:2519,benchmark,benchmarks,2519,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660660104,1,['benchmark'],['benchmarks']
Testability, │ Float64 │ 128 │ 4.682 ms │ 4.725 ms │ 4.880 ms │ 5.654 ms │ 632.67 KiB │ 6655 │; │ GPU │ Float64 │ 256 │ 25.907 ms │ 32.091 ms │ 31.487 ms │ 32.483 ms │ 801.86 KiB │ 6763 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ### CPU to GPU speedup. ```; ┌─────────────┬─────┬─────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼─────────┼─────────┼─────────┤; │ Float32 │ 32 │ 2.93732 │ 3.62888 │ 3.63319 │; │ Float32 │ 64 │ 17.443 │ 3.9155 │ 3.63373 │; │ Float32 │ 128 │ 86.446 │ 4.52412 │ 3.63264 │; │ Float32 │ 256 │ 127.777 │ 5.72434 │ 3.63483 │; │ Float64 │ 32 │ 2.51868 │ 3.63039 │ 3.63319 │; │ Float64 │ 64 │ 17.1005 │ 3.91654 │ 3.63373 │; │ Float64 │ 128 │ 86.4912 │ 4.52413 │ 3.63264 │; │ Float64 │ 256 │ 135.031 │ 5.73397 │ 3.69159 │; └─────────────┴─────┴─────────┴─────────┴─────────┘; ```. ---. ## Incompressible model benchmarks (regular Rectilinear grid). ### Raw benchmarks. ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.408 ms │ 5.713 ms │ 5.871 ms │ 6.634 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 64 │ 36.120 ms │ 38.174 ms │ 38.435 ms │ 41.795 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 128 │ 304.741 ms │ 311.332 ms │ 311.085 ms │ 315.204 ms │ 287.98 KiB │ 2136 │; │ CPU │ Float32 │ 256 │ 2.598 s │ 2.598 s │ 2.598 s │ 2.599 s │ 287.98 KiB │ 2136 │; │ CPU │ Float64 │ 32 │ 6.419 ms │ 6.647 ms │ 6.733 ms │ 7.657 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 64 │ 42.856 ms │ 46.229 ms │ 45.719 ms │ 47.103 ms │ 350.52 KiB │ 2136 │; │ CPU │ Float64 │ 128 │ 369.043 ms │ 380.330 ms │ 380.214 ms │ 385.820 ms │ 350.52 KiB │ 2136 │; │ ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:3552,benchmark,benchmarks,3552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['benchmark'],['benchmarks']
Testability," │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` directory. # References. Jahn et al. (2015): https://doi.org/10.5194/gmd-8-317-2015; Klemp et al. (2007): https://doi.org/10.1175/MWR3440.1; Satoh (2003): https://doi.org/10.1175/1520-0493(2003)131%3C1033:CSFACN%3E2.0.CO;2; Skamarock et al. (2019): https://opensky.ucar.edu/islandora/object/opensky%3A2898; Sod (1978): https://doi.org/10.1016/0021-9991(78)90023-2; Straka et al. (1993): https://doi.org/10.1002/fld.1650170103; Wicker and Skamarock (1998): https://doi.org/10.1175/1520-0493(1998)126%3C1992:ATSSFT%3E2.0.CO;2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:10917,test,tests,10917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['test'],['tests']
Testability, │; │ 512 │ 32 │ 3.517 s │ 3.521 s │ 3.521 s │ 3.524 s │ 11.72 MiB │ 648129 │; │ 512 │ 36 │ 3.532 s │ 3.533 s │ 3.533 s │ 3.534 s │ 11.09 MiB │ 566273 │; └──────┴─────────┴──────────┴──────────┴──────────┴──────────┴────────────┴─────────┘; [2020/11/26 18:22:08.583] INFO Writing Multithreading_benchmarks.html...; Multithreading speedup; ┌──────┬─────────┬─────────┬─────────┬─────────┐; │ size │ threads │ speedup │ memory │ allocs │; ├──────┼─────────┼─────────┼─────────┼─────────┤; │ 512 │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ 512 │ 2 │ 1.2524 │ 432.949 │ 4209.06 │; │ 512 │ 4 │ 2.47574 │ 201.484 │ 1948.97 │; │ 512 │ 8 │ 4.56069 │ 87.897 │ 834.567 │; │ 512 │ 16 │ 6.30058 │ 405.837 │ 984.567 │; │ 512 │ 32 │ 6.77607 │ 39.9205 │ 328.999 │; │ 512 │ 36 │ 6.75252 │ 37.7587 │ 287.448 │; └──────┴─────────┴─────────┴─────────┴─────────┘. ```. Old branch **master**:. ```; Multithreading benchmarks; ┌──────┬─────────┬──────────┬──────────┬──────────┬──────────┬────────────┬──────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼─────────┼──────────┼──────────┼──────────┼──────────┼────────────┼──────────┤; │ 512 │ 1 │ 24.654 s │ 24.654 s │ 24.654 s │ 24.654 s │ 294.28 KiB │ 1930 │; │ 512 │ 2 │ 21.380 s │ 21.380 s │ 21.380 s │ 21.380 s │ 172.25 MiB │ 11250274 │; │ 512 │ 4 │ 9.585 s │ 9.585 s │ 9.585 s │ 9.585 s │ 63.01 MiB │ 4093201 │; │ 512 │ 8 │ 5.417 s │ 5.417 s │ 5.417 s │ 5.417 s │ 34.91 MiB │ 2242285 │; │ 512 │ 16 │ 3.989 s │ 3.991 s │ 3.991 s │ 3.993 s │ 123.02 MiB │ 2196707 │; │ 512 │ 32 │ 3.655 s │ 3.676 s │ 3.676 s │ 3.698 s │ 11.86 MiB │ 663272 │; │ 512 │ 36 │ 3.783 s │ 3.794 s │ 3.794 s │ 3.804 s │ 115.48 MiB │ 1646037 │; └──────┴─────────┴──────────┴──────────┴──────────┴──────────┴────────────┴──────────┘; [2020/11/26 16:58:13.592] INFO Writing Multithreading_benchmarks.html...; Multithreading speedup; ┌──────┬─────────┬─────────┬─────────┬─────────┐; │ size │ threads │ speedup │ memory │ allocs │; ├──────┼─────────┼─────────┼─────────┼─────────┤;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922:1574,benchmark,benchmarks,1574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922,1,['benchmark'],['benchmarks']
Testability,"!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 usin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113608,test,test,113608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; > │ CPU │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1391,Benchmark,Benchmarks,1391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['Benchmark'],['Benchmarks']
Testability,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:6125,Log,Logging,6125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['Log'],['Logging']
Testability,"""A PR without its tests is doomed."". (folklore saying)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1415#issuecomment-789160016:18,test,tests,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415#issuecomment-789160016,1,['test'],['tests']
Testability,"""Anything not tested is wrong.""; [adage]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1703#issuecomment-849107678:14,test,tested,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703#issuecomment-849107678,1,['test'],['tested']
Testability,"""Serialization"" means ""saving to disk"":. https://en.wikipedia.org/wiki/Serialization. Functions can't be serialized by JLD2:. ```julia; julia> using JLD2. julia> file = jldopen(""test.jld2"", ""a+""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read/write); (no datasets). julia> f(x) = println(""Hello world!""); f (generic function with 1 method). julia> file[""f""] = f; f (generic function with 1 method). julia> close(file). julia> exit(). # Restart julia; $ julia ; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using JLD2. julia> file = jldopen(""test.jld2""); JLDFile /Users/gregorywagner/Projects/OceanTurbulenceParameterEstimation.jl/test.jld2 (read-only); └─🔢 f. julia> f = file[""f""]; ┌ Warning: type Main.#f does not exist in workspace; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/b0tI9/src/data/reconstructing_datatypes.jl:364; JLD2.ReconstructedTypes.var""##Main.#f#257""(). julia> f(1); ERROR: MethodError: objects of type JLD2.ReconstructedTypes.var""##Main.#f#257"" are not callable; Stacktrace:; [1] top-level scope; @ REPL[5]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692:178,test,test,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039399692,4,['test'],['test']
Testability,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6704,test,testing,6704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['test'],['testing']
Testability,"""]; uuid = ""9a3f8284-a2c9-5f02-9a11-845980a1fd5c"". [[Reexport]]; git-tree-sha1 = ""57d8440b0c7d98fc4f889e478e80f268d534c9d5""; uuid = ""189a3867-3050-52da-a836-e630ba90ab69""; version = ""1.0.0"". [[Requires]]; deps = [""UUIDs""]; git-tree-sha1 = ""4036a3bd08ac7e968e27c203d45f5fff15020621""; uuid = ""ae029012-a4dd-5104-9daa-d747884805df""; version = ""1.1.3"". [[Rotations]]; deps = [""LinearAlgebra"", ""StaticArrays"", ""Statistics""]; git-tree-sha1 = ""2ed8d8a16d703f900168822d83699b8c3c1a5cd8""; uuid = ""6038ab10-8711-5258-84ad-4b1120ba62dc""; version = ""1.0.2"". [[SHA]]; uuid = ""ea8e919c-243c-51af-8825-aaa63cd721ce"". [[SafeTestsets]]; deps = [""Test""]; git-tree-sha1 = ""36ebc5622c82eb9324005cc75e7e2cc51181d181""; uuid = ""1bc83da4-3b8d-516f-aca4-4fe02f6d838f""; version = ""0.0.1"". [[Scratch]]; deps = [""Dates""]; git-tree-sha1 = ""ad4b278adb62d185bbcb6864dc24959ab0627bf6""; uuid = ""6c6a2e73-6563-6170-7368-637461726353""; version = ""1.0.3"". [[SeawaterPolynomials]]; deps = [""Test""]; git-tree-sha1 = ""6db1b6004791962cb12d425cd12691506ad7d2b6""; uuid = ""d496a93d-167e-4197-9f49-d3af4ff8fe40""; version = ""0.2.0"". [[Serialization]]; uuid = ""9e88b42a-f829-5b0c-bbe9-9e923198166b"". [[SharedArrays]]; deps = [""Distributed"", ""Mmap"", ""Random"", ""Serialization""]; uuid = ""1a1011a3-84de-559e-8e89-a11a2f7dc383"". [[Sockets]]; uuid = ""6462fe0b-24de-5631-8697-dd941f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 = ""ddec5466a1d2d7e58adf9a427ba69763661aacf6""; uuid = ""aedffcd0-7271-4cad-89d0-dc628f76c6d3""; version = ""0.2.4"". [[StaticArrays]]; deps = [""LinearAlgebra"", ""Random"", ""Statistics""]; git-tree-sha1 = ""e8cd1b100d37f5b4cfd2c83f45becf61c762eaf7""; uuid = ""90137ffa-7385-5640-81b9-e52037218182""; version = ""1.1.1"". [[StaticPermutati",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:14654,Test,Test,14654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability,"""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Bounded, Bounded)</td>; <td style = ""text-align: right; "">2.67701</td>; <td style = ""text-align: right; "">1.31634</td>; <td style = ""text-align: right; "">1.36185</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Bounded)</td>; <td style = ""text-align: right; "">1.10911</td>; <td style = ""text-align: right; "">1.1314</td>; <td style = ""text-align: right; "">1.13269</td>; </tr>; <tr>; <td style = ""text-align: right; "">GPU</td>; <td style = ""text-align: right; "">192</td>; <td style = ""text-align: right; "">(Periodic, Periodic, Periodic)</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. ## Turbulence closure benchmarks. <table>; <caption style = ""text-align: center; "">Turbulence closures relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Closures</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">AnisotropicBiharmonicDiffusivity</td>; <td style = ""text-align: right; "">2.05198</td>; <td style = ""text-align: right; "">1.00469</td>; <td style = ""text-align: right; "">1.00536</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">AnisotropicDiffusivity</td>; <td style = ""text-align: right; "">1.16121</td>; <td style = ""text-align: right; "">1.00469</td>; <td style = ""text-align: right; "">1.00536</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:16570,benchmark,benchmarks,16570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,1,['benchmark'],['benchmarks']
Testability,# A few benchmarks... ## `benchmark_nonhydrostatic_model.jl`. ### `main`. ```; Nonhydrostatic model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 7.436 ms │ 8.831 ms │ 8.815 ms │ 11.402 ms │ 2.42 MiB │ 7196 │ 10 │; │ CPU │ Float32 │ 64 │ 15.440 ms │ 15.923 ms │ 16.687 ms │ 20.447 ms │ 3.12 MiB │ 12808 │ 10 │; │ CPU │ Float32 │ 128 │ 43.847 ms │ 44.717 ms │ 44.792 ms │ 46.774 ms │ 3.40 MiB │ 15383 │ 10 │; │ CPU │ Float32 │ 256 │ 280.225 ms │ 289.133 ms │ 289.791 ms │ 307.004 ms │ 3.73 MiB │ 35573 │ 10 │; │ CPU │ Float64 │ 32 │ 8.626 ms │ 8.873 ms │ 8.903 ms │ 9.340 ms │ 3.15 MiB │ 7192 │ 10 │; │ CPU │ Float64 │ 64 │ 12.859 ms │ 13.495 ms │ 13.865 ms │ 16.695 ms │ 3.95 MiB │ 12925 │ 10 │; │ CPU │ Float64 │ 128 │ 52.882 ms │ 54.573 ms │ 56.634 ms │ 74.680 ms │ 4.31 MiB │ 16561 │ 10 │; │ CPU │ Float64 │ 256 │ 406.856 ms │ 414.115 ms │ 417.420 ms │ 441.158 ms │ 4.92 MiB │ 49543 │ 10 │; │ GPU │ Float32 │ 32 │ 1.932 ms │ 2.038 ms │ 2.177 ms │ 3.359 ms │ 1.42 MiB │ 4801 │ 10 │; │ GPU │ Float32 │ 64 │ 1.992 ms │ 2.064 ms │ 2.167 ms │ 3.109 ms │ 1.42 MiB │ 4832 │ 10 │; │ GPU │ Float32 │ 128 │ 2.746 ms │ 2.790 ms │ 3.045 ms │ 5.152 ms │ 1.42 MiB │ 5136 │ 10 │; │ GPU │ Float32 │ 256 │ 15.301 ms │ 19.004 ms │ 18.634 ms │ 19.064 ms │ 1.59 MiB │ 15777 │ 10 │; │ GPU │ Float64 │ 32 │ 2.167 ms │ 2.272 ms │ 2.411 ms │ 3.706 ms │ 1.84 MiB │ 4775 │ 10 │; │ GPU │ Float64 │ 64 │ 2.260 ms │ 2.380 ms │ 2.543 ms │ 3.984 ms │ 1.84 MiB │ 4827 │ 10 │; │ GPU │ Float64 │ 128 │ 4.640 ms │ 4.794 ms │ 4.875 ms │ 5.688 ms │ 1.86 MiB │ 6133 │ 10 │; │ GPU │ Float64 │ 256 │ 24.612 ms │ 36.082 ms │ 34.946 ms │ 36.210 ms │ 2.19 MiB │ 27483 │ 10 │; └───────────────┴─────────────┴─────┴───,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885:8,benchmark,benchmarks,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885,2,['benchmark'],['benchmarks']
Testability,"# Benchmarks!. As mentioned [in the docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/poisson_solvers/#Direct-method-with-a-vertically-stretched-grid), the Fourier-tridiagonal solver is theoretically faster for large problems. Raw numbers in all their glory below but to summarize:; 1. The Fourier-tridiagonal Poisson solver is indeed faster! But only on the GPU. About ~1.5x faster for 256³ grids (15 -> 10 ms/solve).; 2. As a result, GPU incompressible models are faster with `FourierTridiagonalPoissonSolver`! But only by ~1.15x.; 3. More features with a faster solver though, seems like a win-win. ; 4. I should clarify the speedup is only enjoyed by `(Periodic, Periodic, Bounded)` on the GPU. For channel topologies, `FourierTridiagonalPoissonSolver` is slower.; 5. Oceananigans.jl is roughly as fast as it was before `HydrostaticFreeSurfaceModel`. ---. ## Vertically stretched incompressible model benchmarks. ### Raw benchmarks. ```; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 6.370 ms │ 7.323 ms │ 7.089 ms │ 7.649 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 64 │ 48.449 ms │ 49.064 ms │ 49.345 ms │ 51.689 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 128 │ 400.112 ms │ 402.124 ms │ 409.183 ms │ 469.727 ms │ 139.61 KiB │ 1832 │; │ CPU │ Float32 │ 256 │ 4.036 s │ 4.074 s │ 4.074 s │ 4.112 s │ 139.61 KiB │ 1832 │; │ CPU │ Float64 │ 32 │ 6.343 ms │ 6.425 ms │ 6.573 ms │ 7.301 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 64 │ 47.988 ms │ 48.355 ms │ 48.603 ms │ 50.857 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 128 │ 405.724 ms │ 408.699 ms │ 409.013 ms │ 414.735 ms │ 139.84 KiB │ 1832 │; │ CPU │ Float64 │ 256 │ 4.333 s │ 4.333 s │ 4.333 s │ 4.334 s │ 139.84 K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:2,Benchmark,Benchmarks,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,3,"['Benchmark', 'benchmark']","['Benchmarks', 'benchmarks']"
Testability,"# Benchmarks. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 7.865 ms │ 8.157 ms │ 8.384 ms │ 9.923 ms │ 2.50 MiB │ 7004 │ 10 │; │ CPU │ Float32 │ 64 │ 13.237 ms │ 13.739 ms │ 14.162 ms │ 16.642 ms │ 3.20 MiB │ 12619 │ 10 │; │ CPU │ Float32 │ 128 │ 49.644 ms │ 53.133 ms │ 52.873 ms │ 56.953 ms │ 3.51 MiB │ 16344 │ 10 │; │ CPU │ Float32 │ 256 │ 338.545 ms │ 353.497 ms │ 353.048 ms │ 370.172 ms │ 3.81 MiB │ 35156 │ 10 │; │ CPU │ Float64 │ 32 │ 9.683 ms │ 10.028 ms │ 10.324 ms │ 12.479 ms │ 3.25 MiB │ 7003 │ 10 │; │ CPU │ Float64 │ 64 │ 14.979 ms │ 16.581 ms │ 17.035 ms │ 22.013 ms │ 4.07 MiB │ 12652 │ 10 │; │ CPU │ Float64 │ 128 │ 67.659 ms │ 68.736 ms │ 70.121 ms │ 84.62",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:2,Benchmark,Benchmarks,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974,1,['Benchmark'],['Benchmarks']
Testability,"# Some selected benchmark results. ## Advection scheme benchmarks. <table>; <caption style = ""text-align: center; "">Advection schemes relative performance (CPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Schemes</th>; <th style = ""text-align: right; "">slowdown</th>; <th style = ""text-align: right; "">memory</th>; <th style = ""text-align: right; "">allocs</th>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">CenteredFourthOrder</td>; <td style = ""text-align: right; "">2.68376</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">CenteredSecondOrder</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedFifthOrder</td>; <td style = ""text-align: right; "">3.19781</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">UpwindBiasedThirdOrder</td>; <td style = ""text-align: right; "">2.84754</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; <tr>; <td style = ""text-align: right; "">CPU</td>; <td style = ""text-align: right; "">WENO5</td>; <td style = ""text-align: right; "">8.25962</td>; <td style = ""text-align: right; "">1.0</td>; <td style = ""text-align: right; "">1.0</td>; </tr>; </table>. <table>; <caption style = ""text-align: center; "">Advection schemes relative performance (GPU)</caption>; <tr class = ""header headerLastRow"">; <th style = ""text-align: right; "">Architectures</th>; <th style = ""text-align: right; "">Schemes</th>; <th style = ""text-align: right; """,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594:16,benchmark,benchmark,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=h1) Report; > Merging [#790](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/1723136b1249332eb1ca4ff3adfad3c38017c452&el=desc) will **decrease** coverage by `0.01%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #790 +/- ##; ==========================================; - Coverage 71.69% 71.67% -0.02% ; ==========================================; Files 184 184 ; Lines 4780 4781 +1 ; ==========================================; Hits 3427 3427 ; - Misses 1353 1354 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <ø> (ø)` | |; | [src/Forcing/relaxation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcmVsYXhhdGlvbi5qbA==) | `81.25% <100.00%> (-5.42%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=footer). Last update [1723136...6d2d7b8](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/790?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/790#issuecomment-656856375:1003,test,test,1003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/790#issuecomment-656856375,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=h1) Report; > Merging [#805](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/ecc0fda4da3685143c72d9cb7fc4e528b799a409&el=desc) will **increase** coverage by `0.25%`.; > The diff coverage is `62.44%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #805 +/- ##; ==========================================; + Coverage 71.28% 71.54% +0.25% ; ==========================================; Files 186 185 -1 ; Lines 4876 5046 +170 ; ==========================================; + Hits 3476 3610 +134 ; - Misses 1400 1436 +36 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `66.66% <ø> (+33.33%)` | :arrow_up: |; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100.00% <ø> (ø)` | |; | [src/Diagnostics/diagnostics\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2RpYWdub3N0aWNzX2tlcm5lbHMuamw=) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <0.00%> ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378:1015,benchmark,benchmark,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378,2,['benchmark'],['benchmark']
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=h1) Report; > Merging [#807](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/80fb511ff5a5bb641481b6209ca101ea8c4b8149&el=desc) will **decrease** coverage by `0.11%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #807 +/- ##; ==========================================; - Coverage 71.15% 71.04% -0.12% ; ==========================================; Files 186 186 ; Lines 4839 4824 -15 ; ==========================================; - Hits 3443 3427 -16 ; - Misses 1396 1397 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `90.74% <100.00%> (-0.49%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <100.00%> (-5.32%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101:1010,test,test,1010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=h1) Report; > Merging [#823](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/40e7caf545cadb41733602989511d96c62687c7a&el=desc) will **increase** coverage by `0.66%`.; > The diff coverage is `90.10%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #823 +/- ##; ==========================================; + Coverage 70.72% 71.38% +0.66% ; ==========================================; Files 188 189 +1 ; Lines 5113 5270 +157 ; ==========================================; + Hits 3616 3762 +146 ; - Misses 1497 1508 +11 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aW,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956:1015,benchmark,benchmark,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956,2,['benchmark'],['benchmark']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=h1) Report; > Merging [#850](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/8198ca7c8c09d0ad0e7b1d72a377871ef671fa73&el=desc) will **decrease** coverage by `0.08%`.; > The diff coverage is `83.67%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #850 +/- ##; ==========================================; - Coverage 72.70% 72.62% -0.09% ; ==========================================; Files 188 188 ; Lines 5353 5337 -16 ; ==========================================; - Hits 3892 3876 -16 ; Misses 1461 1461 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | `91.42% <ø> (-0.24%)` | :arrow_down: |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `94.35% <ø> (+0.75%)` | :arrow_up: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `67.56% <73.33%> (+42.56%)` | :arrow_up: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397:1004,benchmark,benchmark,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397,2,['benchmark'],['benchmark']
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=h1) Report; > Merging [#887](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/edcedc38c55a9c219514c5234c1a663be03beced?el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `92.85%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #887 +/- ##; ==========================================; + Coverage 71.34% 71.39% +0.05% ; ==========================================; Files 187 187 ; Lines 5276 5289 +13 ; ==========================================; + Hits 3764 3776 +12 ; - Misses 1512 1513 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `91.52% <83.33%> (-0.93%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.29% <100.00%> (+0.13%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=footer). Last update [edcedc3...59d0e22](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/887?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/887#issuecomment-685908717:1234,test,test,1234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887#issuecomment-685908717,2,['test'],['test']
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=h1) Report; > Merging [#907](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/8d808881c5a277b44abff83f39dd470fe2f16324?el=desc) will **increase** coverage by `0.10%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #907 +/- ##; ==========================================; + Coverage 72.32% 72.42% +0.10% ; ==========================================; Files 187 187 ; Lines 5464 5484 +20 ; ==========================================; + Hits 3952 3972 +20 ; Misses 1512 1512 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (+0.42%)` | :arrow_up: |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.34% <100.00%> (+0.08%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=footer). Last update [8d80888...f0c2821](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/907?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/907#issuecomment-686553696:1198,test,test,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/907#issuecomment-686553696,2,['test'],['test']
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=h1) Report; > Merging [#909](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/8d808881c5a277b44abff83f39dd470fe2f16324?el=desc) will **increase** coverage by `0.03%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #909 +/- ##; ==========================================; + Coverage 72.32% 72.35% +0.03% ; ==========================================; Files 187 187 ; Lines 5464 5470 +6 ; ==========================================; + Hits 3952 3958 +6 ; Misses 1512 1512 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=footer). Last update [8d80888...06be99d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/909?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/909#issuecomment-686634596:1003,test,test,1003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/909#issuecomment-686634596,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=h1) Report; > Merging [#922](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/01b248145356586f921239701b14c2f0e2073b27?el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #922 +/- ##; ==========================================; + Coverage 72.78% 72.79% +0.01% ; ==========================================; Files 192 192 ; Lines 5643 5649 +6 ; ==========================================; + Hits 4107 4112 +5 ; - Misses 1536 1537 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <ø> (ø)` | |; | [src/AbstractOperations/multiary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9tdWx0aWFyeV9vcGVyYXRpb25zLmps) | `86.36% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <0.00%> (-3.18%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.29% <0.00%> (+0.14%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=continue).; > **Legend** -,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084:1008,test,test,1008,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=h1) Report; > Merging [#937](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/3b45ce5cbc561d3e951621a402204eb689df2000?el=desc) will **not change** coverage.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #937 +/- ##; =======================================; Coverage 72.61% 72.61% ; =======================================; Files 199 199 ; Lines 5806 5806 ; =======================================; Hits 4216 4216 ; Misses 1590 1590 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.29% <ø> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <ø> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592:968,test,test,968,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=h1) Report; > Merging [#968](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/c3f6ce0b52a4bb519d1a2efe87c755a9113d6851?el=desc) will **decrease** coverage by `0.00%`.; > The diff coverage is `78.12%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #968 +/- ##; ==========================================; - Coverage 72.04% 72.04% -0.01% ; ==========================================; Files 205 205 ; Lines 5964 5984 +20 ; ==========================================; + Hits 4297 4311 +14 ; - Misses 1667 1673 +6 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2F2ZXJhZ2VkX2ZpZWxkLmps) | `0.00% <ø> (ø)` | |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <62.50%> (+1.04%)` | :arrow_up: |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `87.50% <66.66%> (-12.50%)` | :arrow_down: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `90.47% <80.00%> (-3.97%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `76.19% <80.00%> (-1.59%)` | :arrow_down: |; | [src/Buo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698377343:1009,test,test,1009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698377343,2,['test'],['test']
Testability,"# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=h1) Report; > Merging [#970](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/c3f6ce0b52a4bb519d1a2efe87c755a9113d6851?el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `92.30%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #970 +/- ##; ==========================================; + Coverage 72.04% 72.06% +0.01% ; ==========================================; Files 205 205 ; Lines 5964 5968 +4 ; ==========================================; + Hits 4297 4301 +4 ; Misses 1667 1667 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2F2ZXJhZ2VkX2ZpZWxkLmps) | `0.00% <ø> (ø)` | |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `82.60% <91.66%> (+3.66%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `94.44% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/970?src=pr&el=footer). Last update [c3f6ce0...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970#issuecomment-698357988:1002,test,test,1002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970#issuecomment-698357988,2,['test'],['test']
Testability,# [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=h1) Report; > Merging [#989](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/417e8908d1c5f4896900e9c83894c4b42f1daebc?el=desc) will **decrease** coverage by `0.28%`.; > The diff coverage is `64.16%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #989 +/- ##; ==========================================; - Coverage 72.04% 71.75% -0.29% ; ==========================================; Files 218 220 +2 ; Lines 6379 6381 +2 ; ==========================================; - Hits 4596 4579 -17 ; - Misses 1783 1802 +19 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | `0.00% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:1012,benchmark,benchmark,1012,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,2,['benchmark'],['benchmark']
Testability,"# [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=h1) Report; > Merging [#478](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a511fdd2fedc9aae49a76905be24fdc60c2d60b0?src=pr&el=desc) will **decrease** coverage by `0.89%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #478 +/- ##; =========================================; - Coverage 67.72% 66.83% -0.9% ; =========================================; Files 69 70 +1 ; Lines 1952 1978 +26 ; =========================================; Hits 1322 1322 ; - Misses 630 656 +26; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `0% <0%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=footer). Last update [a511fdd...e31988c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/478?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-542355113:1239,log,logger,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-542355113,1,['log'],['logger']
Testability,## Pull Request Test Coverage Report for [Build 707](https://coveralls.io/builds/23883699). * **0** of **0** changed or added relevant lines in **0** files are covered.; * No unchanged relevant lines lost coverage.; * Overall coverage remained the same at **62.429%**. ---. | Totals | [![Coverage Status](https://coveralls.io/builds/23883699/badge)](https://coveralls.io/builds/23883699) |; | :-- | --: |; | Change from base [Build 698](https://coveralls.io/builds/23832209): | 0.0% |; | Covered Lines: | 550 |; | Relevant Lines: | 881 |. ---; ##### 💛 - [Coveralls](https://coveralls.io),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/277#issuecomment-500222086:16,Test,Test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/277#issuecomment-500222086,1,['Test'],['Test']
Testability,## Pull Request Test Coverage Report for [Build 713](https://coveralls.io/builds/23884404). * **0** of **0** changed or added relevant lines in **0** files are covered.; * No unchanged relevant lines lost coverage.; * Overall coverage remained the same at **62.429%**. ---. | Totals | [![Coverage Status](https://coveralls.io/builds/23884404/badge)](https://coveralls.io/builds/23884404) |; | :-- | --: |; | Change from base [Build 698](https://coveralls.io/builds/23832209): | 0.0% |; | Covered Lines: | 550 |; | Relevant Lines: | 881 |. ---; ##### 💛 - [Coveralls](https://coveralls.io),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/278#issuecomment-500224661:16,Test,Test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/278#issuecomment-500224661,1,['Test'],['Test']
Testability,## Pull Request Test Coverage Report for [Build 717](https://coveralls.io/builds/23884685). * **0** of **0** changed or added relevant lines in **0** files are covered.; * No unchanged relevant lines lost coverage.; * Overall coverage remained the same at **62.429%**. ---. | Totals | [![Coverage Status](https://coveralls.io/builds/23884685/badge)](https://coveralls.io/builds/23884685) |; | :-- | --: |; | Change from base [Build 698](https://coveralls.io/builds/23832209): | 0.0% |; | Covered Lines: | 550 |; | Relevant Lines: | 881 |. ---; ##### 💛 - [Coveralls](https://coveralls.io),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500233509:16,Test,Test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500233509,1,['Test'],['Test']
Testability,## Pull Request Test Coverage Report for [Build 723](https://coveralls.io/builds/23885273). * **0** of **0** changed or added relevant lines in **0** files are covered.; * No unchanged relevant lines lost coverage.; * Overall coverage increased (+**0.4%**) to **62.785%**. ---. | Totals | [![Coverage Status](https://coveralls.io/builds/23885273/badge)](https://coveralls.io/builds/23885273) |; | :-- | --: |; | Change from base [Build 719](https://coveralls.io/builds/23884946): | 0.4% |; | Covered Lines: | 550 |; | Relevant Lines: | 876 |. ---; ##### 💛 - [Coveralls](https://coveralls.io),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/281#issuecomment-500240662:16,Test,Test,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/281#issuecomment-500240662,1,['Test'],['Test']
Testability,"## Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.366 s │ 1.370 s │ 1.369 s │ 1.373 s │ 192 bytes │ 4 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.138 s │ 1.146 s │ 1.148 s │ 1.157 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.147 s │ 1.148 s │ 1.152 s │ 1.161 s │ 160 bytes │ 2 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 843.212 ms │ 849.492 ms │ 849.080 ms │ 853.401 ms │ 160 bytes │ 2 │; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 17.252 ms │ 38.642 ms │ 36.505 ms │ 38.756 ms │ 84.38 KiB │ 898 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 13.979 ms │ 31.085 ms │ 29.365 ms │ 31.110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:9753,benchmark,benchmarks,9753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['benchmark'],['benchmarks']
Testability,"########################################################### 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/sr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2051,log,log,2051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['log'],['log']
Testability,"###; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:113825,test,test,113825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,#1950 passed all tests and I approved and merged it. I'll open a new PR to add my branch with the updated benchmark docs back in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954:17,test,tests,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,#3733 introduces a very simple test for interpolation on field time series (testing trivial interpolation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3731#issuecomment-2310580405:31,test,test,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3731#issuecomment-2310580405,2,['test'],"['test', 'testing']"
Testability,#752 fixed the `example/internal_wave.jl`. The problem was that `k=1` which effectively implied that the continuity equation was not satisfied. Perhaps if you increase `k` in; https://github.com/CliMA/Oceananigans.jl/blob/b3b8162209409024c6847989ccd33780693f597c/test/test_dynamics.jl#L100; you may get the numerical solution in the test to agree with analytical at much better accuracy than `1e-4` as is now?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/674#issuecomment-633739342:263,test,test,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674#issuecomment-633739342,2,['test'],['test']
Testability,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/777:21,test,tests,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777,5,['test'],"['test', 'tests']"
Testability,"$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oceananigans` and nothing happens. I have tested this with other packages but this only happens with Oceananigans. Something ever weirder: after I get impatient I can cancel the command (pressing `Ctrl+C` repeatedly) and then if I issue the line again it works!:. ```julia; julia> using Oceananigans; ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C; ^C^C^C^CWARNING: Force throwing a SIGINT. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(1,1,1), extent=(1,1,1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0). julia> ; ```. So basically I'm very lost on this one. Two main questions are:. - Why is the `using` command hanging in the first place? (And then working if I cancel and try again?); - Why is the behavior different between these two machines? I thought I was ensuring that I was starting from a fresh environment in b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:3236,test,tested,3236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['test'],['tested']
Testability,"&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | ERROR: ERROR: ERROR: ERROR: Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:Package Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] pkgerrorPackage Oceananigans errored during testing; &nbsp; | Stacktrace:; &nbsp; | [1] (pkgerror; &nbsp; | [1] (pkgerror::(; &nbsp; | [1] ::pkgerrorString) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1938,test,tests,1938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['test'],['tests']
Testability,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:942,test,test,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,2,['test'],['test']
Testability,"(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDif",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1190,log,logic,1190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['log'],['logic']
Testability,(0.90.11) Tests for a distributed Immersed boundary grid + fix some `on_architecture` bugs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3487:10,Test,Tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3487,1,['Test'],['Tests']
Testability,(0.91.14) Extend Lagrangian advection to immersed grids and add tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3765:64,test,tests,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3765,1,['test'],['tests']
Testability,(0.92.2) Add more advection scheme tests; fix order adapting with tracer-specific schemes; fix WENOVectorInvariant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3864:35,test,tests,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3864,1,['test'],['tests']
Testability,"(16384/16384 matching grid points); [2023/02/21 06:38:46.005] INFO Δv: min=-5.495966e-10, max=+1.063640e-09, mean=-3.441143e-13, absmean=+4.699188e-11, std=+1.347006e-10 (16508/16512 matching grid points); [2023/02/21 06:38:46.005] INFO Δh: min=-4.766520e-07, max=+4.757091e-07, mean=+1.373701e-08, absmean=+2.044884e-07, std=+2.513218e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:16771,Test,Test,16771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['Test'],['Test']
Testability,"(4.632 seconds); [2023/02/21 06:37:32.539] INFO Executing initial time step...; [2023/02/21 06:37:52.296] WARN `query(s::CuStream)` is deprecated, use `isdone(s)` instead. -@-> /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:41; [2023/02/21 06:37:54.934] INFO ... initial time step complete (22.395 seconds).; [2023/02/21 06:37:56.880] INFO Simulation is stopping. Model iteration 20 has hit or exceeded simulation stop iteration 20.; [2023/02/21 06:38:00.743] INFO Δu: min=-3.188983e-08, max=+2.966291e-08, mean=+3.932481e-11, absmean=+1.978398e-09, std=+5.640766e-09 (16384/16384 matching grid points); [2023/02/21 06:38:00.744] INFO Δv: min=-2.539346e-09, max=+1.967717e-09, mean=+2.462280e-12, absmean=+1.480658e-10, std=+4.143014e-10 (16488/16512 matching grid points); [2023/02/21 06:38:00.744] INFO Δh: min=-4.767265e-07, max=+4.779508e-07, mean=+3.492460e-09, absmean=+2.039559e-07, std=+2.510841e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; [2023/02/21 06:38:01.335] INFO Testing shallow water Bickley jet simulation ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:13611,Test,Test,13611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Test'],['Test']
Testability,"(87); > - *M* test/test_abstract_operations.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-90>; > (34); > - *M* test/test_boundary_conditions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-91>; > (4); > - *M* test/test_buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-92>; > (10); > - *M* test/test_diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-93>; > (22); > - *M* test/test_dynamics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-94>; > (6); > - *M* test/test_examples.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-95>; > (2); > - *M* test/test_models.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-96>; > (2); > - *M* test/test_solvers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-97>; > (3); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-98>; > (14); > - *M* test/test_turbulence_closures.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-99>; > (12); > - *M* verification/stratified_couette_flow/stratified_couette_flow.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-100>; > (5); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/591.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/591.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/591?email_source=notifications&email_token=AA27DYBDXFRG32PFGDS36GDQ5HJRDA5CNFSM4KFSH6VKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IFQPEGA>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AA27DYGEF2LURE2X2PYMKQ3Q5HJRDANCNFSM4KFSH6VA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:14893,test,test,14893,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['test'],['test']
Testability,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:2602,Test,Test,2602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,9,"['Test', 'test']","['Test', 'test']"
Testability,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:42594,test,tests,42594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['test'],['tests']
Testability,"(@jbisits, we have some issues with the CI. But as soon as tests pass I'll merge this.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1498450464:59,test,tests,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035#issuecomment-1498450464,1,['test'],['tests']
Testability,"(I'm happy to fix it myself, but don't want to take away your chance to contribute.). You can submit a quick PR by clicking the little pencil in the top right of the file viewer:. ![image](https://user-images.githubusercontent.com/15271942/117840174-63ef5f80-b228-11eb-9080-95822ed37669.png). making the change you've suggested, and then following the prompt to open a PR. Apparently this example is not tested...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838655754:404,test,tested,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838655754,1,['test'],['tested']
Testability,(It's not that important for Oceananigans since most of our tests run with buildkite rather than with GitHub Actions. But it's a good thing to have anyway.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605256793:60,test,tests,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149#issuecomment-1605256793,1,['test'],['tests']
Testability,"(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and paramet",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106726,Test,Test,106726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:70,sandbox,sandbox,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['sandbox'],['sandbox']
Testability,(and none of the tests caught this...?). !!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725839972:17,test,tests,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725839972,1,['test'],['tests']
Testability,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:338,test,tested,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['test'],['tested']
Testability,"(f); ```. returns. ```Julia; julia> @show A; A = [-128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0]; 8×8 OffsetArray(::Matrix{Float64}, 1:8, 1:8) with eltype Float64 with indices 1:8×1:8:; -128.0 64.0 0.0 0.0 0.0 0.0 0.0 64.0; 64.0 -128.0 64.0 0.0 0.0 0.0 0.0 0.0; 0.0 64.0 -128.0 64.0 0.0 0.0 0.0 0.0; 0.0 0.0 64.0 -128.0 64.0 0.0 0.0 0.0; 0.0 0.0 0.0 64.0 -128.0 64.0 0.0 0.0; 0.0 0.0 0.0 0.0 64.0 -128.0 64.0 0.0; 0.0 0.0 0.0 0.0 0.0 64.0 -128.0 64.0; 64.0 0.0 0.0 0.0 0.0 0.0 64.0 -128.0; ```. and; ```julia; julia> isapprox(interior(∇²f), ∇²f_matrix); true; ```; For a 2D case with `A = ∂²/∂x² + ∂²/∂y²` we have:. ```Julia; using OffsetArrays. Lx = 2; Ly = 3; Nx = 12; Ny = 18; H = 1; δx = Lx/Nx; δy = Ly/Ny. poisson(f::OffsetMatrix, i, j) = (f[i+1, j] - 2*f[i, j] + f[i-1, j])/δx^2 + (f[i, j+1] - 2*f[i, j] + f[i, j-1])/δy^2. interior(f::OffsetMatrix) = f[1:Nx, 1:Ny]. function fill_halos!(f::OffsetMatrix); f[0, :] = f[Nx, :]; f[Nx+1, :] = f[1, :]. f[:, 0] = f[:, Ny]; f[:, Ny+1] = f[:, 1]. return nothing; end. A = OffsetArray(zeros(Nx*Ny, Nx*Ny)). make_column(f::OffsetMatrix) = reshape(interior(f), (Nx*Ny, 1)). for j in 1:Ny, i in 1:Nx; eᵢⱼ = OffsetArray(zeros(Nx+2H, Ny+2H), -H, -H); eᵢⱼ[i, j] = 1; fill_halos!(eᵢⱼ); ∇²eᵢⱼ = 0 * eᵢⱼ. for j in 1:Ny, i in 1:Nx; ∇²eᵢⱼ[i, j] = poisson(eᵢⱼ, i, j); end. A[:, Nx*(j-1)+i] = make_column(∇²eᵢⱼ); end. # test if A does the job. # compute the laplacian of f poisson() function; f = rand(Nx+2H, Ny+2H); f = OffsetArray(f, -H, -H); fill_halos!(f). ∇²f = 0 * f. for j in 1:Ny, i in 1:Nx; ∇²f[i, j] = poisson(f, i, j); end. # compute the laplacian of f using matrix A; ∇²f_matrix = A * make_column(f); ```. and we can confirm that. ```Julia; julia> isapprox(make_column(∇²f), ∇²f_matrix); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042:2601,test,test,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109351042,1,['test'],['test']
Testability,(fyi I stopped the tests because everything was clogged... all tests in PRs have been running for 6-7 hrs... so perhaps restart when there is less load),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470:19,test,tests,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470,6,['test'],['tests']
Testability,"(https://codecov.io/gh/CliMA/Oceananigans.jl/commit/810a3a1f8e425480340f4b3f386527be43e08515?el=desc) will **decrease** coverage by `0.08%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #863 +/- ##; ==========================================; - Coverage 70.90% 70.81% -0.09% ; ==========================================; Files 187 187 ; Lines 5180 5171 -9 ; ==========================================; - Hits 3673 3662 -11 ; - Misses 1507 1509 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <ø> (-0.12%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `92.78% <ø> (-0.18%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `80.51% <0.00%> (-1.30%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954:1186,test,test,1186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954,2,['test'],['test']
Testability,(ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `69.06% <0%> (-4.97%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `83.05% <0%> (-3.07%)` | :arrow_down: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `57.8% <0%> (-2.6%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `75.75% <0%> (-0.25%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `0% <0%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `76.92% <0%> (+1.92%)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `89.23% <0%> (+2.69%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `74.35% <0%> (+2.79%)` | :arrow_up: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/550/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.j,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/550#issuecomment-565760499:2278,log,logger,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/550#issuecomment-565760499,1,['log'],['logger']
Testability,") = RectilinearGrid(arch; topology=(Periodic, Flat, Bounded), size=(5, 5), x=(-1, 1), z). for arch in archs, timestepper in timesteppers, y_topo in y_topologies, (z_grid_type, z) in pairs(vertical_grids); @info "" Testing Lagrangian particle tracking [$(typeof(arch)), $timestepper] with y $(typeof(y_topo)) on vertically $z_grid_type grid ...""; grid = lagrangian_particle_test_grid(arch, y_topo, z); # run_simple_particle_tracking_tests(arch, grid, timestepper); @show grid; end; ```. which would give us these 8 (per architecture) test cases. ```julia; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:1406,Test,Testing,1406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['Test'],['Testing']
Testability,"), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields[i]); end; BenchmarkTools.Trial: 5334 samples with 1 evaluation.; Range (min … max): 688.320 μs … 40.334 ms ┊ GC (min … max): 0.00% … 48.53%; Time (median): 840.539 μs ┊ GC (median): 0.00%; Time (mean ± σ): 931.289 μs ± 1.680 ms ┊ GC (mean ± σ): 4.12% ± 2.23%. ▂▆▇▇█▅▃ ▁▅▄▃▁▁ ▁ ; ▁▁▁▁▁▂▃▄▅▆████████████████████▅▆▄▄▅▄▄▃▄▅▃▄▃▃▃▃▂▂▂▁▂▂▂▂▁▂▁▂▁▁ ▄; 688 μs Histogram: frequency by time 1.11 ms <. Memory estimate: 208.03 KiB, allocs estimate: 1771. julia> @benchmark fill_halo_regions!(fields); BenchmarkTools.Trial: 10000 samples with 1 evaluation.; Range (min … max): 112.632 μs … 19.348 ms ┊ GC (min … max): 0.00% … 51.80%; Time (median): 131.708 μs ┊ GC (median): 0.00%; Time (mean ± σ): 148.468 μs ± 459.310 μs ┊ GC (mean ± σ): 3.97% ± 1.28%. ▁▆█▆▄▂ ; ▂▂▂▂▂▂▃▅███████▆▅▄▄▄▄▄▄▄▄▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▂▁▂▂▂▂▂▂▂▃▂▂▂ ▃; 113 μs Histogram: frequency by time 208 μs <. Memory estimate: 64.69 KiB, allocs estimate: 258. julia> grid = RectilinearGrid(CPU(), size=(10, 10, 10), extent=(1, 1, 1), topology = (Periodic, Bounded, Bounded)); 10×10×10 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.1; ├── Bounded y ∈ [-1.61908e-17, 1.0] regularly spaced with Δy=0.1; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> fields = (); (). julia> for i in 1:7; fields = (fields..., Field((Center, Center, Center), grid)); end. julia> @benchmark for i in 1:7; fill_halo_regions!(fields",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065:1017,benchmark,benchmark,1017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065969065,2,"['Benchmark', 'benchmark']","['BenchmarkTools', 'benchmark']"
Testability,"), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:106605,test,test,106605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"): min=-2.0599841277224584e-18, max=-2.0599841277224584e-18, sum=1.222917052488197e-18, abs_sum=6.6839786899214464e-15; >; > [ Info: Velocity divergence after 1000 time steps (CPU(), Float64): min=-2.7755575615628914e-17, max=-2.7755575615628914e-17, sum=1.1918336233891488e-16, abs_sum=2.2196799400441293e-14; >; >; > so maybe we also need to compute the vertical velocity *w* from the; > continuity equation instead of time stepping it forward.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/228; > Commit Summary; >; > - Incompressibility test.; > - Log velocity divergence.; > - Projection method to ensure velocity remains divergence free.; > - Different div-free atol values for Float32 and Float64.; > - Update thermal bubble golden master test.; >; > File Changes; >; > - *M* src/time_steppers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-0>; > (12); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-1>; > (7); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-2>; > (41); > - *M* test/thermal_bubble_golden_master_10.nc; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-3>; > (0); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/228.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/228.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/pull/228?email_source=notifications&email_token=AKXUEQQ4PR3CMJKEDJMYE3DPWXSD3A5CNFSM4HOZAKC2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVKZJRA>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSUBV5ADRKZADPUPVTPWXSD3ANCNFSM4HOZAKCQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495026292:3310,test,test,3310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495026292,6,['test'],['test']
Testability,"); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:114042,test,test,114042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:3015,Test,Testing,3015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,"); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /home/ssilvest/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] macro expansion; @ ~/julia-1.8.0/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main ~/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; [2023/02/14 16:24:51.806] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/14 16:25:16.858] INFO Initializing simulation...; [2023/02/14 16:25:16.992] INFO ... simulation initialization complete (134.028 ms); [2023/02/14 16:25:16.992] INFO Executing initial time step...; [2023/02/14 16:25:47.962] INFO ... initial time step complete (30.969 seconds).; [2023/02/14 16:25:48.168] INFO Simulation is stopping after running for 31.304 seconds.; [2023/02/14 16:25:48.168] INFO Model iteration 20 equals or exceeds stop iteration 20.; [20",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:2085,test,test,2085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['test'],['test']
Testability,"); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1349,Log,Logging,1349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['Log'],['Logging']
Testability,"**Final Commit Details**. Remove 4/3 factor, && --> &, ζ=NaN where undefined. 1. Remove 4/3 Factor in Vorticity Computation: The 4/3 factor was initially introduced in the vorticity calculation at the corners because the area used to divide the circulation (in the denominator) was reduced to three-quarters of its original value. However, it turns out that by adopting the Haversine formula for calculating the quadrilateral area on a sphere---which simplifies to a triangle when two points coincide---the 4/3 factor is inherently accounted for. Therefore, the explicit inclusion of this factor is no longer necessary. 2. Replace Short-Circuiting && with Logical &: Changed the short-circuiting && operator to the logical & operator to ensure compatibility with GPU operations. 3. Set Circulation Γ and Vorticity ζ to NaN when Undefined: Updated the code to assign NaN (Not a Number) to circulation Γ and vorticity ζ in cases where they are undefined. @glwagner, @navidcy, could one of you please review this PR once the tests pass, so I can proceed with merging? Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543:656,Log,Logical,656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-2394511543,3,"['Log', 'log', 'test']","['Logical', 'logical', 'tests']"
Testability,"**IMPORTANT**: @glwagner @suyashbire1 we should delete all old repos and clone fresh. From the BFG website:. ""At this point, you're ready for everyone to ditch their old copies of the repo and do fresh clones of the nice, new pristine data. It's best to delete all old clones, as they'll have dirty history that you don't want to risk pushing back into your newly cleaned repo. "". ---. I used BFG Repo Cleaner to delete all files larger than 1 MB in git history. This deleted two files: `deep_convection_golden_master_model_checkpoint_10.jld` and `ocean_wind_mixing_and_convection.jld2`. I have a backup of the old ""dirty"" repository in case we need it for any reason. Before:; ```; $ du -hs Oceananigans.jl.git; 620M Oceananigans.jl.git; ```. After:; ```; $ du -hs Oceananigans.jl.git; 14M Oceananigans.jl.git; ```. BFG log:; ```; (base) [aramadhan@login-1 ~]$ java -jar bfg-1.13.0.jar --strip-blobs-bigger-than 1M Oceananigans.jl.git . Using repo : /home/gridsan/aramadhan/Oceananigans.jl.git. Scanning packfile for large blobs: 17491; Scanning packfile for large blobs completed in 209 ms.; Found 17 blob ids for large blobs - biggest=54015055 smallest=2524792; Total size (unpacked)=56539847; Found 155 objects to protect; Found 19 tag-pointing refs : refs/tags/v0.10.0, refs/tags/v0.10.1, refs/tags/v0.11.0, ...; Found 273 commit-pointing refs : HEAD, refs/heads/ar/lid-driven-cavity, refs/heads/ar/more-solvers, ... Protected commits; -----------------. These are your protected commits, and so their contents will NOT be altered:. * commit 91e5626e (protected by 'HEAD'). Cleaning; --------. Found 3270 commits; Cleaning commits: 100% (3270/3270); Cleaning commits completed in 35,468 ms. Updating 255 Refs; -----------------. Ref Before After ; ------------------------------------------------------------------------------; refs/heads/ar/lid-driven-cavity | 8eae1762 | 0401753a; refs/heads/ar/more-solvers | 5446ae47 | 4cf1d809; refs/heads/ar/vertically-stretched-grid | 695eb278 | 50fbc9d0; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736:821,log,log,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-549156736,2,['log'],"['log', 'login-']"
Testability,"**Note to self**: Seems like the golden master tests fail on Mac (Travis CI) so it seems that JLD might not be portable (although I generated the JLD checkpoint files on Windows and the Linux tests pass). So for golden master testing I should rely on NetCDF output which is guaranteed to be portable. **EDIT**: Hmmm, it might actually just be finicky (sometimes passes, sometimes doesn't). Another reason to use NetCDF. But so far if I keep running the tests on my laptop it always passes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474858478:47,test,tests,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474858478,4,['test'],"['testing', 'tests']"
Testability,+ ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] + LLVM v4.6.0; [2ab3a3ac] + LogExpFunctions v0.3.3; [da04e1cc] + MPI v0.19.0; [1914dd2f] + MacroTools v0.5.8; [85f8d34a] + NCDatasets v0.11.7; [77ba4419] + NaNMath v0.3.5; [9e8cae18] + Oceananigans v0.63.1; [6fe1bfb0] + OffsetArrays v1.10.7; [bac558e1] + OrderedCollections v1.4.1; [69de0a69] + Parsers v2.0.5; [0e08944d] + PencilArrays v0.10.0; [4a48f351] + PencilFFTs v0.12.5; [21216c6a] + Preferences v1.2.2; [74087812] + Random123 v1.4.2; [e6cf234a] + RandomNumbers v1.5.3; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + Tran,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:2065,Log,LogExpFunctions,2065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Log'],['LogExpFunctions']
Testability,+0.48%)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |; | [...ion/convergence\_tests/ConvergenceTests/analysis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvYW5hbHlzaXMuamw=) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [...nvergence\_tests/ConvergenceTests/file\_wrangling.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvZmlsZV93cmFuZ2xpbmcuamw=) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [...\_tests/ConvergenceTests/TwoDimensionalDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvVHdvRGltZW5zaW9uYWxEaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=continue).; > **Legend** - [Cli,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968:2225,test,test,2225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968,2,['test'],['test']
Testability,"+1 for CI tests in this PR!. Also, can someone please update the first comment with a brief example/description of the usage? I'm having a bit of trouble visualizing it just from the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287657693:10,test,tests,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287657693,1,['test'],['tests']
Testability,"+export ΔzF, ΔzC, Δzᵃᵃᶜ, Δzᵃᵃᶠ, Δzᶠᶜᶜ, Δzᶜᶠᶜ; export Δxᶜᶜᵃ, Δxᶠᶜᵃ, Δxᶠᶠᵃ, Δxᶜᶠᵃ; export Δyᶜᶜᵃ, Δyᶠᶜᵃ, Δyᶠᶠᵃ, Δyᶜᶠᵃ; export Axᵃᵃᶜ, Axᵃᵃᶠ, Axᶜᶜᶜ, Axᶠᶜᶜ, Axᶠᶠᶜ, Axᶠᶜᶠ, Axᶜᶠᶜ, Axᶜᶜᶠ; diff --git a/src/Operators/spacings_and_areas_and_volumes.jl b/src/Operators/spacings_and_areas_and_volumes.jl; index 8b7aaeb7..9988b320 100644; --- a/src/Operators/spacings_and_areas_and_volumes.jl; +++ b/src/Operators/spacings_and_areas_and_volumes.jl; @@ -46,6 +46,9 @@ The operators in this file fall into three categories:; @inline Δzᵃᵃᶜ(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; @inline Δzᵃᵃᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; ; +@inline Δzᶠᶜᶜ(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; +@inline Δzᶜᶠᶜ(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:3844,test,test,3844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406,1,['test'],['test']
Testability,", 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9291,Test,Test,9291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,", :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37420,test,test,37420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,", Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float64}}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, deflatelevel::Int64, verbose::Bool); > @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:392; > [6] top-level scope; > @ ~/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > in expression starting at /Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl:101; > ```. Huh, that error seems unrelated but I'm not sure. In particular, it looks like you cannot create a netcdf file in the first place (this takes place before any code is executed that has to do specifically with this PR). Does your code work on `main`? You could also try using `JLD2OutputWriter` to see if you still get an error. It also could help to see what code you're running. PS I changed you single ticks ""`"" to block ticks ""```"" to make your message more readable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:31483,log,loganknudsen,31483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['log'],['loganknudsen']
Testability,", Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104631,benchmark,benchmarks,104631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:3723,log,log,3723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['log'],['log']
Testability,", Nothing, Nothing, Nothing}}, NamedTuple{(:u, :v, :w), Tuple{ZeroField{Int64, 3}, ZeroField{Int64, 3}, ConstantField{Float64, 3}}}}, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdli",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21591,test,test,21591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635,1,['test'],['test']
Testability,", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107471,benchmark,benchmark,107471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,", max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /home/ssilvest/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] macro expansion; @ ~/julia-1.8.0/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main ~/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; [2023/02/14 16:24:51.806] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/14 16:25:16.858] INFO Initializing simulation...; [2023/02/14 16:25:16.992] INFO ... simulation initialization complete (134.028 ms); [2023/02/14 16:25:16.992] INFO Executing initial time step...; [2023/02/14 16:25:47.962] INFO ... initial time step complete (30.969 seconds).; [2023/02/14 16:25:48.168] INFO Simulation is stopping after running for 31.304 seconds.; [2023/02/14 16:25:48.168] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:25:48.190] INFO Δu: min=-1.672000e-04, max=+4.242261e-06, mean=-8.684623e-06, absmean=+8.777260e-06, std=+2.661194e-05 (16384/16384 matching grid points); [2023/02/14 16:25:48.191] INFO Δv: min=-2.345113e-05, max=+4.749113e-05, mean=+1.747024e-06, absmean=+3.169309e-06, std=+8.512156e-06 (10620/16512 matching grid points); [2023/02/14 16:25:48.191] INFO Δh: min=",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:2461,test,test,2461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['test'],['test']
Testability,", std=+4.237465e-11 (4096/4096 matching grid points); [2020/11/13 11:13:08.185] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-3.816392e-17, absmean=+3.587408e-15, std=+1.934380e-14 (4096/4096 matching grid points); Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; Expression: all(test_fields.u .≈ correct_fields.u); Stacktrace:. Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; Expression: all(test_fields.u .≈ correct_fields.u); Stacktrace:; [1] run_ocean_large_eddy_simulation_regression_test(::GPU, ::VerstappenAnisotropicMinimumDissipation{Float64,Float64,Float64,Float64}) at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; [2] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:77 [inlined]; [3] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [4] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:74 [inlined]; [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [6] top-level scope at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:60; Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:123; Expression: all(test_fields.v .≈ correct_fields.v); Stacktrace:; [1] run_ocean_large_eddy_simulation_regression_test(::GPU, ::VerstappenAnisotropicMinimumDissipation{Float64,Float64,Float64,Float64}) at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:123; [2] macro expansion at /home/fpoulin/software/Ocea",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818:6315,test,test,6315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818,1,['test'],['test']
Testability,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:1373,test,tests,1373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,6,['test'],"['test', 'tests']"
Testability,",3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:37996,test,test,37996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,",Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Dict{String,Field{X,Y,Z,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:101916,test,test,101916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,- ##; ==========================================; + Coverage 69.73% 72.31% +2.57% ; ==========================================; Files 160 228 +68 ; Lines 3512 6562 +3050 ; ==========================================; + Hits 2449 4745 +2296 ; - Misses 1063 1817 +754 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.25% <0.00%> (ø)` | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | `100.00% <0.00%> (ø)` | |; | [...ergence\_tests/one\_dimensional\_advection\_schemes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9hZHZlY3Rpb25fc2NoZW1lcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <0.00%> (ø)` | |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <0.00%> (ø)` | |; | [docs/bibliography.jl](ht,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132:1621,benchmark,benchmark,1621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132,2,['benchmark'],['benchmark']
Testability,- Fix doc test; - Revert GPUCompiler 359,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2906:10,test,test,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2906,1,['test'],['test']
Testability,- Uses NCDatasets.jl; - Allows slicing; - Should be fast because a new file is not created for every output time-step (I guess the previous netcdf writer was slow because it created a new file for every output time-step which added a lot of overhead); - See example for usage (it works on CPU!). TODO:; - Global and per variable attributes. Edit:; - Needs to be tested; - We need to discuss halo regions (the dimension lengths are not consistent with the array sizes thanks to halo regions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/433:362,test,tested,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433,1,['test'],['tested']
Testability,- [x] Changes `mode` and `force` to overwrite existing; - [x] Change `prefix` to something clearer (maybe `filename`); - [x] Separate keyword `filepath` in `NetcdfOutputWriter` into `dir` and `filename` (or whatever is replacing `prefix`); - [x] Maybe add a couple more tests for `NetcdfWriter`. Closes https://github.com/CliMA/Oceananigans.jl/issues/884; Closes https://github.com/CliMA/Oceananigans.jl/issues/2427,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416:270,test,tests,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416,1,['test'],['tests']
Testability,"- [x] Try comparing with an analytical solution, e.g. Poiseuille flow or Couette flow. This would test the pressure solver.; - [x] See if there's a difference between `Float64` on the CPU and GPU beyond machine epsilon.; - [x] Compare with MITgcm, both running `Float64` on the same CPU.; - [ ] Try comparing with MITgcm at different time steps to look at time-dependence.; - [ ] Try `Float128`. Might not play nice with the GPU.; - [x] We can try some of the stuff from #161 but that might be more work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/168:98,test,test,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168,1,['test'],['test']
Testability,---|---|---|; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `27.02% <ø> (+1.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <ø> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [...ce\_tests/ConvergenceTests/PointExponentialDecay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvUG9pbnRFeHBvbmVudGlhbERlY2F5Lmps) | `0.00% <ø> (ø)` | |; | [...ation/convergence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | `0.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `91.83% <66.66%> (-1.79%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `83.33% <81.81%> (+13.3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129:1998,test,test,1998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129,2,['test'],['test']
Testability,"---|; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/channel\_pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvY2hhbm5lbF9wcmVzc3VyZV9zb2x2ZXIuamw=) | `31.08% <0.00%> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `42.59% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <66.66%> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.59% <69.44%> (-0.20%)` | :arrow_down: |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | `95.00% <85.71%> (+0.35%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <100.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | `91.66% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851#issuecomment-672934210:2008,test,test,2008,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851#issuecomment-672934210,2,['test'],['test']
Testability,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1880,benchmark,benchmarks,1880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['benchmark'],['benchmarks']
Testability,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1309,test,tests,1309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['test'],['tests']
Testability,". To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that av",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1797,Test,Test,1797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['Test'],['Test']
Testability,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:2073,log,log,2073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,5,['log'],['log']
Testability,.03% +3.17% ; ==========================================; Files 118 118 ; Lines 2291 2363 +72 ; ==========================================; + Hits 1715 1844 +129 ; + Misses 576 519 -57; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0%> (-3.19%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <100%> (+12.96%)` | :arrow_up: |; | [src/Logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL0xvZ2dlci5qbA==) | `79.16% <0%> (-9.73%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0%> (-6.67%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/clima,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313:1758,Log,Logger,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313,1,['Log'],['Logger']
Testability,".1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-5462-911a-8362d720325c""; version = ""0.3.5"". [[ChainRulesCore]]; deps = [""Compat"", ""LinearAlgebra"", ""SparseArrays""]; git-tree-sha1 = ""5402b5674b3068ca570771c11da9a57bfa70acd4""; uuid = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; version = ""0.9.39"". [[Compat]]; deps = [""Base64"", ""Dates"", ""DelimitedFiles"", ""Distributed"", ""InteractiveUtils"", ""LibGit2"", ""Libdl"", ""LinearAlgebra"", ""Markdown"", ""Mmap"", ""Pkg"", ""Printf"", ""REPL"", ""Random"", ""SHA"", ""Serialization"", ""SharedArrays"", ""Sockets"", ""SparseArrays"", ""Statistics"", ""Test"", ""UUIDs"", ""Unicode""]; git-tree-sha1 = ""ac4132ad78082518ec2037ae5770b6e796f7f956""; uuid = ""34da2185-b29b-5c13-b0c7-acf172513d20""; version = ""3.27.0"". [[CompilerSupportLibraries_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""8e695f735fca77e9708e795eda62afdb869cbb70""; uuid = ""e66e0078-7015-5450-92f7-15fbd957f2ae""; version = ""0.3.4+0"". [[Crayons]]; git-tree-sha1 = ""3f71217b538d7aaee0b69ab47d9b7724ca8afa0d""; uuid = ""a8cc5b0e-0ffa-5ad4-8c14-923d3ee1735f""; version = ""4.0.4"". [[CubedSphere]]; deps = [""Elliptic"", ""Printf"", ""Requires"", ""Rotations"", ""TaylorSeries"", ""Test""]; git-tree-sha1 = ""b7df0c21789cb6adf5f1e2eb7a52accae5b867f6""; uuid = ""7445602f-e544-4518-8976-18f8e8ae6cdb""; version = ""0.1.0"". [[DataAPI]]; git-tree-sha1 = ""dfb3b7e89e395be1e25c2ad6d7690dc29cc53b1d""; uuid = ""9a962f9c-6df0-11e9-0e5d-c546b8b5ee8a""; version = ""1.6.0"". [[DataStructures]]; deps = [""Compat"", ""InteractiveUtils"", ""OrderedColl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:2550,Test,Test,2550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability,".127638e-10, abs_sum=4.6969774e-8; [ Info: Velocity divergence after 1 time steps (CPU(), Float64): min=-7.686559298536759e-19, max=-7.686559298536759e-19, sum=-1.2421179146024245e-21, abs_sum=1.5105296988410314e-16; [ Info: Velocity divergence after 10 time steps (CPU(), Float64): min=-9.020900888258299e-19, max=-9.020900888258299e-19, sum=5.79061971704065e-22, abs_sum=1.6794563169636008e-16; [ Info: Velocity divergence after 100 time steps (CPU(), Float64): min=-8.859964628279982e-19, max=-8.859964628279982e-19, sum=2.3878439877479045e-19, abs_sum=2.3371755428721667e-16; [ Info: Velocity divergence after 1 time steps (GPU(), Float32): min=-3.5742964e-11, max=-3.5742964e-11, sum=-3.127748e-12, abs_sum=6.8964283e-9; [ Info: Velocity divergence after 10 time steps (GPU(), Float32): min=-4.984102e-11, max=-4.984102e-11, sum=-4.652792e-12, abs_sum=9.790147e-9; [ Info: Velocity divergence after 100 time steps (GPU(), Float32): min=-5.684342e-11, max=-5.684342e-11, sum=2.8093305e-11, abs_sum=4.5857547e-8; [ Info: Velocity divergence after 1 time steps (GPU(), Float64): min=-7.321110903910831e-19, max=-7.321110903910831e-19, sum=-1.805321686896983e-22, abs_sum=1.5813009122639161e-16; [ Info: Velocity divergence after 10 time steps (GPU(), Float64): min=-9.399948132154598e-19, max=-9.399948132154598e-19, sum=-2.2989927699914332e-20, abs_sum=1.8113055478312138e-16; [ Info: Velocity divergence after 100 time steps (GPU(), Float64): min=-8.080694316806025e-19, max=-8.080694316806025e-19, sum=-2.2046007346005637e-19, abs_sum=2.3631237375347637e-16; ```. ```; Testing tracer conservation in channel...; [ Info: Tracer conservation after 10 time steps (CPU(), Float32): ⟨T⟩-T₀=-0.001209259 °C; [ Info: Tracer conservation after 10 time steps (CPU(), Float64): ⟨T⟩-T₀=6.750155989720952e-14 °C; [ Info: Tracer conservation after 10 time steps (GPU(), Float32): ⟨T⟩-T₀=-0.0012111664 °C; [ Info: Tracer conservation after 10 time steps (GPU(), Float64): ⟨T⟩-T₀=1.5987211554602254e-13 °C; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/338#issuecomment-519128279:3100,Test,Testing,3100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/338#issuecomment-519128279,1,['Test'],['Testing']
Testability,".14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 896.626 ms │ 899.133 ms │ 900.518 ms │ 909.853 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.069 ms │ 895.299 ms │ 895.293 ms │ 895.583 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 891.466 ms │ 891.811 ms │ 891.996 ms │ 893.026 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 899.668 ms │ 899.891 ms │ 899.881 ms │ 900.082 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 882.563 ms │ 883.710 ms │ 883.524 ms │ 884.131 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 912.389 ms │ 916.994 ms │ 915.908 ms │ 917.212 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:6259,benchmark,benchmarks,6259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['benchmark'],['benchmarks']
Testability,".185] INFO Δv: min=-5.248542e-10, max=+4.306961e-10, mean=-4.446923e-20, absmean=+3.446188e-12, std=+2.026341e-11 (4081/4096 matching grid points); [2020/11/13 11:13:08.185] INFO Δw: min=-8.810476e-10, max=+3.828646e-10, mean=-1.673779e-20, absmean=+2.695421e-12, std=+2.003712e-11 (3987/4096 matching grid points); [2020/11/13 11:13:08.185] INFO ΔT: min=-3.171294e-10, max=+1.584823e-09, mean=+1.933831e-12, absmean=+3.283801e-12, std=+4.237465e-11 (4096/4096 matching grid points); [2020/11/13 11:13:08.185] INFO ΔS: min=-5.826450e-13, max=+5.613288e-13, mean=-3.816392e-17, absmean=+3.587408e-15, std=+1.934380e-14 (4096/4096 matching grid points); Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; Expression: all(test_fields.u .≈ correct_fields.u); Stacktrace:. Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; Expression: all(test_fields.u .≈ correct_fields.u); Stacktrace:; [1] run_ocean_large_eddy_simulation_regression_test(::GPU, ::VerstappenAnisotropicMinimumDissipation{Float64,Float64,Float64,Float64}) at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; [2] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:77 [inlined]; [3] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [4] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:74 [inlined]; [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [6] top-level scope at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:60; Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regres",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818:5863,test,test,5863,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818,1,['test'],['test']
Testability,.525 ms │ 326.271 ms │ 353.112 ms │ 892.30 KiB │ 11580 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; [2020/11/26 18:37:36.115] INFO Writing Incompressible_model_benchmarks.html...; Incompressible model CPU -> GPU speedup; ┌─────────────┬─────┬──────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼──────────┼─────────┼─────────┤; │ Float32 │ 32 │ 1.51403 │ 3.28716 │ 6.12004 │; │ Float32 │ 64 │ 1.58924 │ 3.28791 │ 6.13048 │; │ Float32 │ 128 │ 1.81939 │ 3.28791 │ 6.13048 │; │ Float64 │ 32 │ 0.778644 │ 2.98009 │ 6.07724 │; │ Float64 │ 64 │ 0.835425 │ 2.97634 │ 6.04384 │; │ Float64 │ 128 │ 0.780995 │ 2.97634 │ 6.04384 │; └─────────────┴─────┴──────────┴─────────┴─────────┘. ```. Old branch **master**:; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 3.731 ms │ 4.014 ms │ 4.048 ms │ 4.752 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 25.071 ms │ 25.897 ms │ 26.004 ms │ 27.032 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 214.549 ms │ 216.681 ms │ 218.408 ms │ 227.438 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 4.230 ms │ 4.334 ms │ 4.430 ms │ 5.244 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 28.847 ms │ 29.348 ms │ 29.573 ms │ 30.704 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 254.216 ms │ 254.715 ms │ 255.230 ms │ 260.031 ms │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.474 ms │ 2.625 ms │ 2.764 ms │ 3.510 ms │ 802.67 KiB │ 11417 │; │ GPU │ Float32 │ 64 │ 10.381 ms │ 13.617 ms │ 13.292 ms │ 13.719 ms │ 802.48 KiB │ 11413 │; │ GPU │ Float32 │ 128 │ 76.589 ms │ 114.593 ms │ 113.372 ms │ 132.651 ms │ 802.48 KiB │ 11,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734478044:4633,benchmark,benchmarks,4633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734478044,1,['benchmark'],['benchmarks']
Testability,.8; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.13; [a2964d1f] Wayland_jll v1.17.0+4; [2381bf8a] Wayland_protocols_jll v1.18.0+4; [02c8fc9c] XML2_jll v2.9.10+3; [aed1982a] XSLT_jll v1.1.33+4; [4f6342f7] Xorg_libX11_jll v1.6.9+4; [0c0b7dd1] Xorg_libXau_jll v1.0.9+4; [935fb764] Xorg_libXcursor_jll v1.2.0+4; [a3789734] Xorg_libXdmcp_jll v1.1.3+4; [1082639a] Xorg_libXext_jll v1.3.4+4; [d091e8ba] Xorg_libXfixes_jll v5.0.3+4; [a51aa0fd] Xorg_libXi_jll v1.7.10+4; [d1454406] Xorg_libXinerama_jll v1.1.4+4; [ec84b674] Xorg_libXrandr_jll v1.5.2+4; [ea2f1a96] Xorg_libXrender_jll v0.9.10+4; [14d82f49] Xorg_libpthread_stubs_jll v0.1.0+3; [c7cfdc94] Xorg_libxcb_jll v1.13.0+3; [cc61e674] Xorg_libxkbfile_jll v1.1.0+4; [12413925] Xorg_xcb_util_image_jll v0.4.0+1; [2def613f] Xorg_xcb_util_jll v0.4.0+1; [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1; [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1; [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1; [35661453] Xorg_xkbcomp_jll v1.4.2+4; [33bec58e] Xorg_xkeyboard_config_jll v2.27.0+4; [c5fb5394] Xorg_xtrans_jll v1.4.0+3; [83775a58] Zlib_jll v1.2.11+18; [3161d3a3] Zstd_jll v1.4.8+0; [0ac62f75] libass_jll v0.14.0+4; [f638f0a6] libfdk_aac_jll v0.1.6+4; [b53b4c65] libpng_jll v1.6.37+6; [f27f6e37] libvorbis_jll v1.3.6+6; [8e850ede] nghttp2_jll v1.40.0+2; [1270edf5] x264_jll v2020.7.14+2; [dfaa095f] x265_jll v3.0.0+3; [d8fb68d0] xkbcommon_jll v0.9.1+5; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [b77e0a4c] InteractiveUtils; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; ```. I might be able to reproduce by starting from a fresh Manifest.toml; I'll look into that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:5996,Log,Logging,5996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,2,"['Log', 'Test']","['Logging', 'Test']"
Testability,".9% 6.67ms 7.79MiB 24.7% 798KiB; 64× 64× 64 (GPU, Float64) 10 50.6ms 10.5% 5.06ms 7.73MiB 24.5% 791KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-outer-loops`. ```julia; Oceananigans package status:; Status `~/.julia/environments/v1.1/Project.toml`; [9e8cae18] Oceananigans v0.11.0 #arbitrary-tracers-outer-loops (https://github.com/climate-machine/Oceananigans.jl.git). ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/fLiQ1/src/indexing.jl:16; Running static ocean benchmark: 32× 32× 32 (GPU, Float64)...; Running static ocean benchmark: 64× 64× 64 (GPU, Float64)...; Running static ocean benchmark: 128×128×128 (GPU, Float64)...; Running static ocean benchmark: 256×256×256 (GPU, Float64)...; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 85.2s / 0.56% 8.46GiB / 0.43% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 277ms 57.6% 27.7ms 9.16MiB 24.6% 938KiB; 32× 32× 32 (GPU, Float64) 10 82.2ms 17.1% 8.22ms 9.71MiB 26.1% 0.97MiB; 128×128×128 (GPU, Float64) 10 65.9ms 13.7% 6.59ms 9.16MiB 24.6% 938KiB; 64× 64× 64 (GPU, Float64) 10 55.5ms 11.6% 5.55ms 9.16MiB 24.6% 938KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-inner-loops`. ```julia; Oceananigans package status:; Status `~/.julia/environments/v1.1/Project.toml`; [9e8cae18] Oceananigans v0.11.0 #arbitrary-tracers-inner-loops (https://github.com/climate-machine/Oceananigans.jl.git). ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852:2826,benchmark,benchmarks,2826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852,1,['benchmark'],['benchmarks']
Testability,".979433e-08, max=+2.978377e-08, mean=-1.025389e-10, absmean=+1.911258e-09, std=+5.570608e-09 (16384/16384 matching grid points); [2023/02/15 08:09:49.338] INFO Δv: min=-2.709283e-11, max=+2.834728e-11, mean=-2.606411e-14, absmean=+1.007855e-12, std=+2.676083e-12 (16512/16512 matching grid points); [2023/02/15 08:09:49.339] INFO Δh: min=-4.765317e-07, max=+4.756881e-07, mean=+1.373701e-08, absmean=+2.044855e-07, std=+2.513230e-07 (16384/16384 matching grid points); Test Passed. julia> run_shallow_water_regression(arch, formulation; regenerate_data = false)VectorInvariantFormulation()^C. julia> run_shallow_water_regression(arch, VectorInvariantFormulation(); regenerate_data = false); [2023/02/15 08:10:46.432] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /g/data/v45/nc3020/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/15 08:10:46.449] INFO Initializing simulation...; [2023/02/15 08:10:46.450] INFO ... simulation initialization complete (580.963 μs); [2023/02/15 08:10:46.450] INFO Executing initial time step...; [2023/02/15 08:10:46.453] INFO ... initial time step complete (3.038 ms).; [2023/02/15 08:10:46.490] INFO Simulation is stopping after running for 39.012 ms.; [2023/02/15 08:10:46.490] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/15 08:10:46.492] INFO Δu: min=-2.910407e-08, max=+2.965560e-08, mean=+4.423683e-11, absmean=+1.880294e-09, std=+5.514070e-09 (16384/16384 matching grid points); [2023/02/15 08:10:46.492] INFO Δv: min=-2.905665e-11, max=+2.481851e-11, mean=-8.868305e-14, absmean=+1.029733e-12, std=+2.802455e-12 (16512/16512 matching grid points); [2023/02/15 08:10:46.492] INFO Δh: min=-4.765574e-07, max=+4.768079e-07, mean=+3.492460e-09, absmean=+2.039438e-07, std=+2.510525e-07 (16384/16384 matching grid points); Test Passed; ```. Weird. Why we get that warning for the VectorInvariant formulation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430385749:2544,Test,Test,2544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430385749,1,['Test'],['Test']
Testability,".; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Si",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:2954,Test,Testing,2954,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Testing']
Testability,".CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4669,test,test,4669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['test'],['test']
Testability,".com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1547,Benchmark,Benchmark,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['Benchmark'],['Benchmark']
Testability,.io/gh/CliMA/Oceananigans.jl/commit/810a3a1f8e425480340f4b3f386527be43e08515?el=desc) will **decrease** coverage by `2.23%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #564 +/- ##; ==========================================; - Coverage 70.90% 68.67% -2.24% ; ==========================================; Files 187 126 -61 ; Lines 5180 2678 -2502 ; ==========================================; - Hits 3673 1839 -1834 ; + Misses 1507 839 -668 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738:1203,test,test,1203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738,2,['test'],['test']
Testability,.io/gh/CliMA/Oceananigans.jl/commit/d383b6a27fc95837b591bd1e68e1aaca50f97da6&el=desc) will **increase** coverage by `0.12%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #792 +/- ##; ==========================================; + Coverage 71.67% 71.80% +0.12% ; ==========================================; Files 184 124 -60 ; Lines 4781 2476 -2305 ; ==========================================; - Hits 3427 1778 -1649 ; + Misses 1354 698 -656 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [test/runtests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0cy5qbA==) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [...ation/convergence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | [...ts/one\_dimensional\_gaussian\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceanan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230:1280,test,test,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230,1,['test'],['test']
Testability,".jl/test/utils_for_runtests.jl:167 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18563,test,test,18563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,".jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15248,test,test,15248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,".julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:112; [10] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:97; [11] run!(sim::Simulation{NonhydrostaticModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:85; [12] top-level scope; @ ~/repos/Oceananigans.jl/sandbox/mwe.jl:31; [13] include(fname::String); @ Base.MainInclude ./client.jl:489; ```. So it's not as trivial as the single change I just made. From glancing at the code we at least have to modify `initialize_nc_file!()` to take a `grid` option as well:. https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/OutputWriters/netcdf_output_writer.jl#L625-L636. plus a couple of other things. Still pretty easy, but more work/time that I have right now. @iuryt feel free to jump in here and make these changes if you feel it's necessary, since creating a whole separate model can be a bit onerous and wastes precious GPU memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:3084,sandbox,sandbox,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['sandbox'],['sandbox']
Testability,".pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:6774,test,tests,6774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['test'],['tests']
Testability,"/ % measured: 85.2s / 0.56% 8.46GiB / 0.43% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 277ms 57.6% 27.7ms 9.16MiB 24.6% 938KiB; 32× 32× 32 (GPU, Float64) 10 82.2ms 17.1% 8.22ms 9.71MiB 26.1% 0.97MiB; 128×128×128 (GPU, Float64) 10 65.9ms 13.7% 6.59ms 9.16MiB 24.6% 938KiB; 64× 64× 64 (GPU, Float64) 10 55.5ms 11.6% 5.55ms 9.16MiB 24.6% 938KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-inner-loops`. ```julia; Oceananigans package status:; Status `~/.julia/environments/v1.1/Project.toml`; [9e8cae18] Oceananigans v0.11.0 #arbitrary-tracers-inner-loops (https://github.com/climate-machine/Oceananigans.jl.git). ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/fLiQ1/src/indexing.jl:16; Running static ocean benchmark: 32× 32× 32 (GPU, Float64)...; Running static ocean benchmark: 64× 64× 64 (GPU, Float64)...; Running static ocean benchmark: 128×128×128 (GPU, Float64)...; Running static ocean benchmark: 256×256×256 (GPU, Float64)...; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 86.4s / 0.56% 8.40GiB / 0.37% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 288ms 59.9% 28.8ms 7.71MiB 24.5% 790KiB; 32× 32× 32 (GPU, Float64) 10 78.3ms 16.3% 7.83ms 8.39MiB 26.6% 859KiB; 128×128×128 (GPU, Float64) 10 62.0ms 12.9% 6.20ms 7.71MiB 24.5% 790KiB; 64× 64× 64 (GPU, Float64) 10 52.6ms 10.9% 5.26ms 7.71MiB 24.5% 790KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852:3941,benchmark,benchmark,3941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852,5,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"/ (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo())",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104128,Benchmark,Benchmark,104128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Benchmark', 'benchmark']","['Benchmark', 'benchmarking']"
Testability,"/ 0.37% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 287ms 59.8% 28.7ms 7.73MiB 24.5% 791KiB; 32× 32× 32 (GPU, Float64) 10 75.9ms 15.8% 7.59ms 8.28MiB 26.3% 848KiB; 128×128×128 (GPU, Float64) 10 66.7ms 13.9% 6.67ms 7.79MiB 24.7% 798KiB; 64× 64× 64 (GPU, Float64) 10 50.6ms 10.5% 5.06ms 7.73MiB 24.5% 791KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-outer-loops`. ```julia; Oceananigans package status:; Status `~/.julia/environments/v1.1/Project.toml`; [9e8cae18] Oceananigans v0.11.0 #arbitrary-tracers-outer-loops (https://github.com/climate-machine/Oceananigans.jl.git). ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/fLiQ1/src/indexing.jl:16; Running static ocean benchmark: 32× 32× 32 (GPU, Float64)...; Running static ocean benchmark: 64× 64× 64 (GPU, Float64)...; Running static ocean benchmark: 128×128×128 (GPU, Float64)...; Running static ocean benchmark: 256×256×256 (GPU, Float64)...; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 85.2s / 0.56% 8.46GiB / 0.43% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (GPU, Float64) 10 277ms 57.6% 27.7ms 9.16MiB 24.6% 938KiB; 32× 32× 32 (GPU, Float64) 10 82.2ms 17.1% 8.22ms 9.71MiB 26.1% 0.97MiB; 128×128×128 (GPU, Float64) 10 65.9ms 13.7% 6.59ms 9.16MiB 24.6% 938KiB; 64× 64× 64 (GPU, Float64) 10 55.5ms 11.6% 5.55ms 9.16MiB 24.6% 938KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ## `arbitrary-tracers-inner-loops`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852:2496,benchmark,benchmark,2496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-542262852,1,['benchmark'],['benchmark']
Testability,"/16384 matching grid points); [2023/02/21 06:38:00.744] INFO Δv: min=-2.539346e-09, max=+1.967717e-09, mean=+2.462280e-12, absmean=+1.480658e-10, std=+4.143014e-10 (16488/16512 matching grid points); [2023/02/21 06:38:00.744] INFO Δh: min=-4.767265e-07, max=+4.779508e-07, mean=+3.492460e-09, absmean=+2.039559e-07, std=+2.510841e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; [2023/02/21 06:38:01.335] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/21 06:38:01.772] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:14163,Test,Test,14163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['Test'],['Test']
Testability,"/4352 matching grid points);   | [2023/05/22 15:07:12.176] INFO ΔT: min=-1.303846e-12, max=+1.495692e-12, mean=-4.293441e-17, absmean=+1.875657e-13, std=+2.728047e-13 (4096/4096 matching grid points);   | [2023/05/22 15:07:12.177] INFO ΔS: min=-4.632739e-12, max=+5.300649e-12, mean=-1.405126e-16, absmean=+6.662951e-13, std=+9.690186e-13 (4096/4096 matching grid points);   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Expression: all(test_fields.u .≈ correct_fields.u);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:76;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Expression: all(test_fields.v .≈ correct_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /storage5/buildkite-agent/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_thermal_bubble_regression_test(arch::CPU, grid_type::Symbol);   | @ Main ~/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:77;   | Thermal bubble [CPU, vertically_unstretched grid]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/test/regression_tests/thermal_bubble_regression_test.jl:78;   | Expression: all(test_fields.w .≈ correct_fields.w); ```. You can see that u, v, and w fail, but the errors are really small and most points are a match. As far as I can tell, for other regression simulations only `w` fails and the results seem to be the same both on the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586:1861,Test,Test,1861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1559671586,7,"['Test', 'test']","['Test', 'test']"
Testability,/CliMA/Oceananigans.jl/pull/911?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `82.60% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | ... and [60 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Ocean,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822:1964,test,test,1964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822,2,['test'],['test']
Testability,/CliMA/Oceananigans.jl/pull/993?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <71.42%> (-1.67%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `56.25% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <0.00%> (ø)` | |; | ... and [35 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree-mor,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566:1928,test,test,1928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566,2,['test'],['test']
Testability,"/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `91.66% <80.00%> (+8.33%)` | :arrow_up: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `92.00% <80.00%> (+3.57%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (+0.74%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `71.42% <100.00%> (+8.09%)` | :arrow_up: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <100.00%> (+0.05%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | ... and [17 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=foote",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898:2561,test,test,2561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898,2,['test'],['test']
Testability,"/Test/src/Test.jl:1119 [inlined]; &nbsp; | [4] macro expansion at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:475 [inlined]; &nbsp; | [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [6] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:448; &nbsp; | Halo communication: Test Failed at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:366; &nbsp; | Expression: all(south_halo(field, include_corners = false) .== arch.connectivity.south); &nbsp; | Stacktrace:; &nbsp; | [1] test_triply_periodic_halo_communication_with_411_ranks(::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:366; &nbsp; | [2] macro expansion at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:477 [inlined]; &nbsp; | [3] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [4] macro expansion at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:475 [inlined]; &nbsp; | [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1119 [inlined]; &nbsp; | [6] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:448; &nbsp; | Halo communication: Halo communication: Test Failed at Test Failed at /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:365; &nbsp; | /storage7/buildkite-agent/builds/tartarus-mit-edu-9/clima/oceananigans/test/test_distributed_models.jl:365; &nbsp; | Halo communication: Test Failed at /sto",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843439802:1881,test,test,1881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843439802,1,['test'],['test']
Testability,/codecov.io/gh/CliMA/Oceananigans.jl/pull/823/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #823 +/- ##; ==========================================; + Coverage 70.72% 71.38% +0.66% ; ==========================================; Files 188 189 +1 ; Lines 5113 5270 +157 ; ==========================================; + Hits 3616 3762 +146 ; - Misses 1497 1508 +11 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <50.00%> (-8.19%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `89,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956:1393,benchmark,benchmark,1393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956,2,['benchmark'],['benchmark']
Testability,"/codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvY2hhbm5lbF9wcmVzc3VyZV9zb2x2ZXIuamw=) | `31.08% <0.00%> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `42.59% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <66.66%> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.59% <69.44%> (-0.20%)` | :arrow_down: |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | `95.00% <85.71%> (+0.35%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <100.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | `91.66% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851?src=pr&el=footer). Last update [a8c35f5...a30e597](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/851?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851#issuecomment-672934210:2506,test,test,2506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851#issuecomment-672934210,2,['test'],['test']
Testability,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1100,Test,Test,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Test'],['Test']
Testability,"/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:18.729] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:19.136] INFO Running shallow water regression tests...; [2023/02/21 06:36:19.143] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/21 06:36:29.566] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:36:32.345] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:36:32.346] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:37:27.833] INFO Initializing simulation...; [2023/02/21 06:37:32.539] INFO ... simulation initialization complete (4.632 seconds); [2023/02/21 06:37:32.539] INFO Executing initial time step...; [2023/02/21 06:37:52.296] WARN `query(s::CuStream)` is deprecated, use `isdone(s)` instead. -@-> /g/data/v45/nc3020/.julia/packages/C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:11732,Test,Testing,11732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Test'],['Testing']
Testability,"/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #937 +/- ##; =======================================; Coverage 72.61% 72.61% ; =======================================; Files 199 199 ; Lines 5806 5806 ; =======================================; Hits 4216 4216 ; Misses 1590 1590 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.29% <ø> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <ø> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100.00% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592:1514,test,test,1514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592,2,['test'],['test']
Testability,/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #979 +/- ##; ==========================================; - Coverage 72.54% 70.13% -2.42% ; ==========================================; Files 210 148 -62 ; Lines 6076 3154 -2922 ; ==========================================; - Hits 4408 2212 -2196 ; + Misses 1668 942 -726 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [test/test\_grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2dyaWRzLmps) | | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uam,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574:1556,test,test,1556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574,2,['test'],['test']
Testability,"/github.com/climate-machine/Oceananigans.jl/pull/462>.; > 2. Revise the RegularCartesianGrid struct so we're happy with it.; > Currently PR #464; > <https://github.com/climate-machine/Oceananigans.jl/pull/464>.; > 3. Add finite volume operators as a separate piece of code.; > Technically they won't be tested in this PR and could have mistakes.; > Currently PR #283; > <https://github.com/climate-machine/Oceananigans.jl/pull/283>; > 4. Nuke the old operators and start using the same set of finite; > volume operators for both Oceananigans.Operators and; > closure_operators.jl. This will test that the finite volume operators; > reduce down to the operators that currently work, but doesn't test them on; > a stretched grid.; > 5. Implement a VerticallyStretchedCartesianGrid. Might have to iterate; > bit to figure out what we need, e.g. I think we'll want ΔzC to include the; > distance between the first cell center and the halo cell center, etc.; > 6. Implement CPU and GPU pressure solvers for vertically stretched; > grids with tests. There will be two: one for horizontally periodic domains; > and another for channel models. I've figured most of this stuff out in; > Jupyter notebooks.; > 7. Ensure that models with vertically stretched grids pass basic; > tests: e.g. incompressibility, tracer conservation, etc. This will test the; > finite volume operators.; > 8. Run a model with a VerticallyStretchedCartesianGrid but with; > uniform grid spacing and make sure it produces the same numbers as a model; > with RegularCartesianGrid. This is a sanity check.; > 9. Run additional tests for vertically stretched grids: e.g. vertical; > diffusion, internal wave, etc. This will also test boundary conditions with; > stretched grids.; > 10. Rerun the stratified Couette flow verification experiment but with; > a stretching factor matching Vreugdenhil & Taylor (2018). This will test; > the AMD closure on stretched grids.; >; > Let me know if anyone has any thoughts. cc @jm-c <https://githu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187:2027,test,tests,2027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471#issuecomment-541363187,1,['test'],['tests']
Testability,/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #636 +/- ##; ==========================================; + Coverage 70.7% 77.99% +7.29% ; ==========================================; Files 118 118 ; Lines 2270 2345 +75 ; ==========================================; + Hits 1605 1829 +224 ; + Misses 665 516 -149; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `70.58% <0%> (-29.42%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `87.5% <0%> (-12.5%)` | :arrow_down: |; | [src/Logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL0xvZ2dlci5qbA==) | `79.16% <0%> (-9.73%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0%> (-6.67%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `35.84% <0%> (-2.45%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/c,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940:1498,Log,Logger,1498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940,1,['Log'],['Logger']
Testability,"/home/fpoulin/software/Oceananigans.jl/test/test_output_writers.jl:565; Expression: all(test_model.velocities.u.data .≈ true_model.velocities.u.data); Stacktrace:; [1] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_output_writers.jl:565 [inlined]; [2] macro expansion at /home/fpoulin/.julia/packages/GPUArrays/ZxsKE/src/host/indexing.jl:64 [inlined]; [3] test_model_equality(::IncompressibleModel{QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},Re. Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; Expression: all(test_fields.u .≈ correct_fields.u); Stacktrace:; [1] run_ocean_large_eddy_simulation_regression_test(::GPU, ::VerstappenAnisotropicMinimumDissipation{Float64,Float64,Float64,Float64}) at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:122; [2] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:77 [inlined]; [3] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [4] macro expansion at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:74 [inlined]; [5] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Test/src/Test.jl:1115 [inlined]; [6] top-level scope at /home/fpoulin/software/Oceananigans.jl/test/test_regression.jl:60; Ocean large eddy simulation [GPU]: Test Failed at /home/fpoulin/software/Oceananigans.jl/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl:123; Expression: all(test_fields.v .≈ correct_fields.v); Stacktrace:; [1] run_ocean_large_eddy_simulation_regression_test(::GPU, ::VerstappenAnisotropicMinimumDissipation{Float64,Float64,Float64,Float64}) at /home/fpoulin/software/Oceananigans.jl/test/regres",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818:1943,test,test,1943,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179#issuecomment-726923818,1,['test'],['test']
Testability,"/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.955788617241",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6500,test,test,6500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | | |; | ... and [52 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=footer). Last update [810a3a1...cc58382](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738:2447,test,test,2447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738,2,['test'],['test']
Testability,"/pull/966/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=footer). Last update [b444acf...639be06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=lastupdated). Read the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:2473,benchmark,benchmark,2473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,2,['benchmark'],['benchmark']
Testability,"/src/API.jl:80; &nbsp; | [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; &nbsp; | [9] top-level scope at none:1; &nbsp; | ::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2578/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:5173,test,test,5173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['test'],['test']
Testability,"/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition integer_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:170 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition float_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:171 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition irrational_bc(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:172 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:173 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition array_bc(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:18765,test,test,18765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,"/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:64 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition cpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_∇²!(Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition cpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition gpu_divergence!(Any, Any, Any, Any, Any, Any) in module Main overwritten.; WARNING: Method definition compute_∇²!(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:88 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition interior(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:100 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:104 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition datatuple(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:105 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition get_output_tuple(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:107 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:114 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition run_script(Any, Any, Any, Any) in module Main at /Users/navid/Research/OC11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:15444,test,test,15444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['test'],['test']
Testability,/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | ... and [58 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=continue).; > **Legend** - [Click here to learn more,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991:2078,test,test,2078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991,2,['test'],['test']
Testability,"0 s; #4 3100 MHz 940664 s 0 s 349843 s 47101853 s 0 s; #5 3100 MHz 5327039 s 0 s 1908912 s 41156410 s 0 s; #6 3100 MHz 958596 s 0 s 311019 s 47122744 s 0 s; #7 3100 MHz 4606842 s 0 s 1506190 s 42279330 s 0 s; #8 3100 MHz 985952 s 0 s 278546 s 47127861 s 0 s; ; Memory: 16.0 GB (398.0859375 MB free); Uptime: 4.914851e6 sec; Load Avg: 2.8193359375 2.333984375 1.83544921875; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); Environment:; JULIA_EDITOR = vim; TERM = xterm-256color; PALMHOME = /Users/gregorywagner/Software/palm; PATH = /Users/gregorywagner/opt/anaconda3/condabin:/opt/anaconda3/bin:/Users/gregorywagner/Software/palm/palm/current_version/trunk/SCRIPTS:/Applications/Julia-1.3.app/Contents/Resources/julia/bin:/usr/local/opt/ruby/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/TeX/texbin:/opt/X11/bin; XPC_FLAGS = 0x0; HOME = /Users/gregorywagner. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 104s / 55.2% 7.44GiB / 0.08% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 44.9ms 0.08% 4.49ms 752KiB 12.5% 75.2KiB; 32× 32× 32 [CPU, Float64] 10 39.1ms 0.07% 3.91ms 752KiB 12.5% 75.2KiB; 64× 64× 64 [CPU, Float32] 10 428ms 0.75% 42.8ms 752KiB 12.5% 75.2KiB; 64× 64× 64 [CPU, Float64] 10 330ms 0.57% 33.0ms 752KiB 12.5% 75.2KiB; 128×128×128 [CPU, Float32] 10 3.68s 6.41% 368ms 752KiB 12.5% 75.2KiB; 128×128×128 [CPU, Float64] 10 3.09s 5.38% 309ms 752KiB 12.5% 75.2KiB; 256×256×256 [CPU, Float32] 10 25.7s 44.8% 2.57s 752KiB 12.5% 75.2KiB; 256×256×256 [CPU, Float64] 10 24.1s 42.0% 2.41s 752KiB 12.5% 75.2KiB; ──────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32 : 0.871; 64× 64× 64 : 0.769; 128×128×128 : 0.839",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-629688917:1499,benchmark,benchmarks,1499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710#issuecomment-629688917,1,['benchmark'],['benchmarks']
Testability,"0.00% GC); > mean time: 7.527 ms (0.00% GC); > maximum time: 8.817 ms (0.00% GC); > --------------; > samples: 663; > evals/sample: 1; >; > Resolves #186; > <https://github.com/climate-machine/Oceananigans.jl/issues/186>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/352; > Commit Summary; >; > - Organize diagnostics a bit; > - Nuke super ancient and useless field summary diagnostic; > - Also nuke velocity divergence checker. We test this.; > - Use Dicts in NaN checker and give a sensible default; > - Add test for NaN checker; > - Architecture-dispatching zeros function for any 3D shape; > - Parallel cumulative sum CUDA kernel for horizontal averages.; > - Diagnostic for computing horizontally averaged vertical profiles.; > - Computing horizontal means on the GPU; > - Aha just use the Poisson solver storage for tmp reduction array; > - Finishing touches on vertical profiler; > - Test for horizontally averaged vertical profile; > - Add const second = 1 lol; > - Fix usual typos; >; > File Changes; >; > - *M* src/Oceananigans.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-0>; > (4); > - *M* src/diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-1>; > (169); > - *M* src/output_writers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-2>; > (2); > - *M* src/planetary_constants.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-3>; > (1); > - *M* src/utils.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-4>; > (6); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-5>; > (1); > - *A* test/test_diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/352/files#diff-6>; > (46); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010:4045,Test,Test,4045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010,1,['Test'],['Test']
Testability,0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.32; [692b3bcd] + JLLWrappers v1.4.1; [0f8b85d8] + JSON3 v1.13.1; [63c18a36] + KernelAbstractions v0.9.7; [929cbde3] + LLVM v6.1.0; [2ab3a3ac] + LogExpFunctions v0.3.24; [da04e1cc] + MPI v0.20.12; [3da0fdf6] + MPIPreferences v0.1.8; [1914dd2f] + MacroTools v0.5.10; [85f8d34a] + NCDatasets v0.12.17; [9e8cae18] + Oceananigans v0.84.1; [6fe1bfb0] + OffsetArrays v1.12.10; [bac558e1] + OrderedCollections v1.6.0; [69de0a69] + Parsers v2.7.1; ⌅ [0e08944d] + PencilArrays v0.18.0; [4a48f351] + PencilFFTs v0.15.0; [eebad327] + PkgVersion v0.3.2; [aea7be01] + PrecompileTools v1.1.2; [21216c6a] + Preferences v1.4.0; [49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:2218,Log,LogExpFunctions,2218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Log'],['LogExpFunctions']
Testability,"0.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`. julia> using Oceananigans. julia> grid = RectilinearGrid(size=(5, 4, 3), extent=(1, 2, 3));. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 5×4×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:5217,Test,Test,5217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Test'],['Test']
Testability,"00207786 -0.000570261 -0.00113736 -0.0011126 -0.00095512 -0.000668289 0.000187081 -2.50371e-5 -0.000234227 -3.30057e-5 7.37231e-5 4.74698e-5 0.0; 0.0 3.44085e-5 6.01794e-5 0.000160129 -5.71002e-5 -0.000251935 -0.000348341 0.000175676 0.000452654 0.000757255 0.000292256 1.47004e-5 -4.29739e-5 0.0; 0.0 0.000127176 0.000354777 0.000538542 0.000684584 0.000355887 0.000248227 0.000121747 -8.66234e-5 -5.15146e-5 0.000247927 0.000267242 0.000177876 0.0; 0.0 -0.000112676 -0.000247409 -0.000271409 -0.00044693 0.000199694 0.000249875 -0.000585559 -0.00072856 -0.000851675 -0.000696049 -0.000430978 -0.00022939 0.0; 0.0 -6.48691e-5 -0.0002854 -0.0005231 -0.000241099 -0.000523152 -0.000253047 … 0.000609541 0.0009479 0.000772055 0.000367521 0.000193174 8.25992e-5 0.0. julia> ds[""wτ2_yavg""] == ds[""wτ1_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ3_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ4_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ5_yavg""]; true. julia> ds[""wτ2_yavg""] == ds[""wτ6_yavg""]; true; ```. So seems that all is good? So the problem comes when I continue the integration longer?; But why do the `info` statements appear in this order?. ```Julia; [ Info: Initializing simulation...; [ Info: Writing to NetCDF: ./test.nc...; [ Info: Computing NetCDF outputs for time index 1: [""wτ3"", ""wτ2_yavg"", ""wτ6_yavg"", ""wτ1"", ""wτ5_yavg"", ""wτ6"", ""wτ2"", ""wτ5"", ""wτ4"", ""wτ1_yavg"", ""wτ4_yavg"", ""wτ3_yavg""]...; [ Info: Computing wτ3 done: time=439.823 ms; [ Info: Computing wτ2_yavg done: time=3.404 seconds; [ Info: Computing wτ6_yavg done: time=3.018 seconds; [ Info: Computing wτ1 done: time=225.326 ms; [ Info: Computing wτ5_yavg done: time=2.950 seconds; [ Info: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:7888,test,test,7888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['test'],['test']
Testability,"01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ1(x, y, z) = x + (1 - y)^2 + tanh(z); λ2(x, y, z) = x + (1 - y)^2 + tanh(4z). Fc1(x, y, z, t, c1) = - λ1(x, y, z) * c1; Fc2(x, y, z, t, c2) = - λ2(x, y, z) * c2; ; c1_forcing = Forcing(Fc1, field_dependencies=:c1); c2_forcing = Forcing(Fc2, field_dependencies=:c2). model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; tracers = (:c1, :c2),; forcing = (c1=c1_forcing, c2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:1327,test,tests,1327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,1,['test'],['tests']
Testability,"020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:30.393] INFO Initializing simulation...; [2023/02/21 06:38:30.504] INFO ... simulation initialization complete (110.043 ms); [2023/02/21 06:38:30.504] INFO Executing initial time step...; [2023/02/21 06:38:40.776] INFO ... initial time step complete (10.272 seconds).; [2023/02/21 06:38:42.742] INFO Simulation is stopping. Model iteration 20 has hit or exceeded simulation stop iteration 20.; [2023/02/21 06:38:46.004] INFO Δu: min=-3.698171e-08, max=+2.977649e-08, mean=-9.793714e-11, absmean=+2.315996e-09, std=+6.206031e-09 (16384/16384 matching grid points); [2023/02/21 06:38:46.005] INFO Δv: min=-5.495966e-10, max=+1.063640e-09, mean=-3.441143e-13, absmean=+4.699188e-11, std=+1.347006e-10 (16508/16512 matching grid points); [2023/02/21 06:38:46.005] INFO Δh: min=-4.766520e-07, max=+4.757091e-07, mean=+1.373701e-08, absmean=+2.044884e-07, std=+2.513218e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:16222,Test,Test,16222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Test'],['Test']
Testability,03c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2724,test,test,2724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"06% 73.3KiB; 64× 64× 64 (CPU, Float64) 10 314ms 0.48% 31.4ms 733KiB 1.06% 73.3KiB; 256×256×256 (GPU, Float32) 10 278ms 0.42% 27.8ms 7.71MiB 11.4% 789KiB; 256×256×256 (GPU, Float64) 10 270ms 0.41% 27.0ms 7.73MiB 11.4% 791KiB; 128×128×128 (GPU, Float64) 10 45.4ms 0.07% 4.54ms 7.73MiB 11.4% 791KiB; 128×128×128 (GPU, Float32) 10 43.1ms 0.07% 4.31ms 7.71MiB 11.4% 789KiB; 32× 32× 32 (CPU, Float32) 10 41.0ms 0.06% 4.10ms 733KiB 1.06% 73.3KiB; 32× 32× 32 (CPU, Float64) 10 41.0ms 0.06% 4.10ms 733KiB 1.06% 73.3KiB; 64× 64× 64 (GPU, Float64) 10 36.2ms 0.06% 3.62ms 7.84MiB 11.6% 803KiB; 64× 64× 64 (GPU, Float32) 10 36.2ms 0.06% 3.62ms 7.82MiB 11.6% 801KiB; 32× 32× 32 (GPU, Float32) 10 33.2ms 0.05% 3.32ms 7.70MiB 11.4% 789KiB; 32× 32× 32 (GPU, Float64) 10 32.2ms 0.05% 3.22ms 7.72MiB 11.4% 791KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. ### This PR; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 176s / 38.7% 15.2GiB / 0.51% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 30.0s 44.1% 3.00s 725KiB 0.90% 72.5KiB; 256×256×256 (CPU, Float32) 10 29.3s 42.9% 2.93s 725KiB 0.90% 72.5KiB; 128×128×128 (CPU, Float32) 10 3.26s 4.78% 326ms 725KiB 0.90% 72.5KiB; 128×128×128 (CPU, Float64) 10 2.93s 4.30% 293ms 725KiB 0.90% 72.5KiB; 256×256×256 (GPU, Float64) 10 780ms 1.14% 78.0ms 9.16MiB 11.6% 938KiB; 256×256×256 (GPU, Float32) 10 779ms 1.14% 77.9ms 9.16MiB 11.6% 938KiB; 64× 64× 64 (CPU, Float32) 10 351ms 0.51% 35.1ms 725KiB 0.90% 72.5KiB; 64× 64× 64 (CPU, Float64) 10 325ms 0.48% 32.5ms 725KiB 0.90% 72.5KiB; 128×128×128 (GPU, Float64) 10 107ms 0.16% 10.7ms 9.16MiB 11.6% 938KiB; 128×128×128 (GPU, Float32) 10 106ms 0.16% 10.6ms 9.16MiB 11.6% 938KiB; 32× 32× 32 (CPU, Float64) 10 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541323374:2088,benchmark,benchmarks,2088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541323374,1,['benchmark'],['benchmarks']
Testability,"07508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8534,Test,Test,8534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:1789,Log,Logging,1789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Log'],['Logging']
Testability,"0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `80.00% <0.00%> (+24.00%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <77.55%> (-14.67%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `80.00% <80.00%> (ø)` | |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `82.60% <82.60%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | ... and [20 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=footer). Last update [eeb62d1...d5dfc74](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=lastup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480:2479,test,test,2479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480,2,['test'],['test']
Testability,"0X3JlZ3Jlc3Npb24uamw=) | `91.42% <ø> (-0.24%)` | :arrow_down: |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `94.35% <ø> (+0.75%)` | :arrow_up: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `67.56% <73.33%> (+42.56%)` | :arrow_up: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <100.00%> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <100.00%> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `76.66% <100.00%> (-9.34%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=footer). Last update [8198ca7...871b448](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/doc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397:2453,test,test,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397,2,['test'],['test']
Testability,"1 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.0064944 0.0106821. [:, :, 6] =; -0.00852329 -0.00657626 -0.00455259 -0.00300401 -0.00193944 -0.00123966 -0.000788713 … -0.000470821 -0.000722127 -0.00106354 -0.00141766 -0.00138651 0.000390487. [:, :, 7] =; -0.0156445 -0.0109965 -0.0071831 -0.00459454 -0.00291877 -0.00184967 -0.00117105 … -0.00143385 -0.00226136 -0.00355998 -0.00557919 -0.00863921 -0.0129097 -0.0170153. [:, :, 8] =; -0.0260963 -0.0148272 -0.00893539 -0.00552894 -0.00346128 -0.00217808 -0.00137374 … -0.00251345 -0.00397508 -0.00630142 -0.0100415 -0.0161907 -0.0268075 -0.0470868. ```. (Btw, the example above obviously works fine with `architecture=CPU()`, where I can check that `dwpdz_nested` actually produces the correct result.). I even ran some other tests with even increased complexity. And they all appear to work on GPUs. For example this one:. ```julia; function crazy_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); dwpdz = ComputedField(dwpdz); dwpdz2 = ComputedField(dwpdz^2); return ComputedField(dwpdz2+dwpdz); end; ```. I'd appreciate if some of you could try to reproduce this result on other machines. I ran this in one of NCAR's Tesla V100s. If you can reproduce this behavior, then this kinda makes `KernelComputedField`s obsolete, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:7948,test,tests,7948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['test'],['tests']
Testability,1) did we merge this before the tests passed?. 2) how OceanBioME.jl was working without this?. 3) I think this definitely deserves a patch release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105:32,test,tests,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3173#issuecomment-1624201105,1,['test'],['tests']
Testability,"1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11397,Test,Test,11397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"11, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7923,test,test,7923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,12 1581 +69 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Coriolis/Coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL0NvcmlvbGlzLmps) | `100.00% <ø> (ø)` | |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `62.50% <0.00%> (+18.75%)` | :arrow_up: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `80.00% <0.00%> (+24.00%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <77.55%> (-14.67%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `80.00% <80.00%> (ø)` | |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `82.60% <82.60%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480:1873,test,test,1873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480,2,['test'],['test']
Testability,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5956,Test,Test,5956,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10164,Test,Test,10164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:7228,test,test,7228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,14] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL v0.6.3; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions v1.2.0; [44cfe95a] + Pkg v1.8.0; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA v0.7.0; [9e88b42a] + Serialization; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [4607b0f0] + SuiteSparse; [fa267f1f] + TOML v1.0.0; [a4e569a6] + Tar v1.10.1; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll v1.0.1+0; [deac9b47] + LibCURL_jll v7.84.0+0; [29816b5a] + LibSSH2_jll v1.10.2+0; [c8ffd9c3] + MbedTLS_jll v2.28.0+0; [14a3606d] + MozillaCACerts_jll v2022.2.1; [4536629a] + OpenBLAS_jll v0.3.20+0; [05823500] + OpenLibm_jll v0.8.1+0; [83775a58] + Zlib_jll v1.2.12+3; [8e850b90] + libblastrampoline_jll v5.1.1+0; [8e850ede] + nghttp2_jll v1.48.0+0; [3f19e933] + p7zip_jll v17.4.0+0; Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `sta,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:4826,Log,Logging,4826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Log'],['Logging']
Testability,"165e-18, sum=8.88871484143291e-21, abs_sum=5.841423607171149e-15; >; > [ Info: Velocity divergence after 10 time steps (CPU(), Float64): min=-1.8295911660692887e-18, max=-1.8295911660692887e-18, sum=6.904962541589997e-20, abs_sum=6.221726243321258e-15; >; > [ Info: Velocity divergence after 100 time steps (CPU(), Float64): min=-2.0599841277224584e-18, max=-2.0599841277224584e-18, sum=1.222917052488197e-18, abs_sum=6.6839786899214464e-15; >; > [ Info: Velocity divergence after 1000 time steps (CPU(), Float64): min=-2.7755575615628914e-17, max=-2.7755575615628914e-17, sum=1.1918336233891488e-16, abs_sum=2.2196799400441293e-14; >; >; > so maybe we also need to compute the vertical velocity *w* from the; > continuity equation instead of time stepping it forward.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/228; > Commit Summary; >; > - Incompressibility test.; > - Log velocity divergence.; > - Projection method to ensure velocity remains divergence free.; > - Different div-free atol values for Float32 and Float64.; > - Update thermal bubble golden master test.; >; > File Changes; >; > - *M* src/time_steppers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-0>; > (12); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-1>; > (7); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-2>; > (41); > - *M* test/thermal_bubble_golden_master_10.nc; > <https://github.com/climate-machine/Oceananigans.jl/pull/228/files#diff-3>; > (0); >; > Patch Links:; >; > - https://github.com/climate-machine/Oceananigans.jl/pull/228.patch; > - https://github.com/climate-machine/Oceananigans.jl/pull/228.diff; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495026292:2963,Log,Log,2963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495026292,2,['Log'],['Log']
Testability,1D periodic advection convergence test results are still good (ignore `UpwindBiasedThirdOrder`):. ![one_dimensional_convergence (1)](https://user-images.githubusercontent.com/20099589/94342227-9c199900-ffdd-11ea-9eb8-0222f55ae6a4.png),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497993:34,test,test,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699497993,1,['test'],['test']
Testability,"1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:111117,benchmark,benchmark,111117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"2 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simula",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:3068,Test,Test,3068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:1364,test,test,1364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846,1,['test'],['test']
Testability,"2 │ 1.60842 │ 3.28596 │; │ Float64 │ 32 │ 1.72783 │ 1.58487 │ 3.00478 │; │ Float64 │ 64 │ 11.0611 │ 1.57428 │ 3.02521 │; │ Float64 │ 128 │ 84.2143 │ 1.5844 │ 3.53368 │; ```; Tracers, with grid size being 256 x 256 x 128:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ┌───────────────┬─────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ tracers │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (0, 0) │ 1.439 s │ 1.440 s │ 1.440 s │ 1.441 s │ 908.03 KiB │ 1656 │ 4 │; │ CPU │ (0, 1) │ 1.539 s │ 1.574 s │ 1.575 s │ 1.613 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (0, 2) │ 1.668 s │ 1.669 s │ 1.670 s │ 1.671 s │ 1.76 MiB │ 2291 │ 3 │; │ CPU │ (1, 0) │ 1.527 s │ 1.532 s │ 1.532 s │ 1.536 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (2, 0) │ 1.690 s │ 1.697 s │ 1.695 s │ 1.698 s │ 1.77 MiB │ 2301 │ 3 │; │ CPU │ (2, 3) │ 2.234 s │ 2.239 s │ 2.241 s │ 2.251 s │ 3.59 MiB │ 3928 │ 3 │; │ CPU │ (2, 5) │ 2.755 s │ 2.838 s │ 2.838 s │ 2.921 s │ 5.18 MiB │ 4908 │ 2 │; │ CPU │ (2, 10) │ 3.588 s │ 3.748 s │ 3.748 s │ 3.908 s │ 10.39 MiB │ 7682 │ 2 │; │ GPU │ (0, 0) │ 9.702 ms │ 12.755 ms │ 12.458 ms │ 12.894 ms │ 1.59 MiB │ 12321 │ 10 │; │ GPU │ (0, 1) │ 13.863 ms │ 13.956 ms │ 14.184 ms │ 16.297 ms │ 2.20 MiB │ 14294 │ 10 │; │ GPU │ (0, 2) │ 15.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:7879,benchmark,benchmarks,7879,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,"21 06:38:00.744] INFO Δh: min=-4.767265e-07, max=+4.779508e-07, mean=+3.492460e-09, absmean=+2.039559e-07, std=+2.510841e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; [2023/02/21 06:38:01.335] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/21 06:38:01.772] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:30.393] INFO Initializing simulation...; [2023/02/21 06:38:30.504] INFO ... simulation initialization complete (110.043 ms); [202",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:14372,Test,Test,14372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['Test'],['Test']
Testability,"23/02/21 06:38:46.005] INFO Δh: min=-4.766520e-07, max=+4.757091e-07, mean=+1.373701e-08, absmean=+2.044884e-07, std=+2.513218e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:16980,Test,Test,16980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['Test'],['Test']
Testability,"27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl) and [`computed_field.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl). This line was changed. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L47. but... I tested this by changing just that line back to the 0.85 version, and still hit the very long compile time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:12279,test,tested,12279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['test'],['tested']
Testability,"2]); >; > BenchmarkTools.Trial:; > memory estimate: 1.01 GiB; > allocs estimate: 250; > --------------; > minimum time: 684.013 ms (2.29% GC); > median time: 712.570 ms (6.28% GC); > mean time: 732.480 ms (8.79% GC); > maximum time: 807.437 ms (16.95% GC); > --------------; > samples: 7; > evals/sample: 1; >; > What this PR does:; >; > Nx, Ny, Nz = 512, 512, 512; > C = rand(Nx, Ny, Nz) |> CuArray; > Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; > Rxy = zeros(Float64, 1, 1, Nz) |> CuArray; > @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +); >; > BenchmarkTools.Trial:; > memory estimate: 2.88 KiB; > allocs estimate: 64; > --------------; > minimum time: 39.129 ms (0.00% GC); > median time: 39.245 ms (0.00% GC); > mean time: 39.248 ms (0.00% GC); > maximum time: 39.374 ms (0.00% GC); > --------------; > samples: 128; > evals/sample: 1; >; > Probably optimal performance:; >; > @benchmark CuArrays.@sync mean(a, dims=[1, 2]); >; > BenchmarkTools.Trial:; > memory estimate: 8.56 KiB; > allocs estimate: 220; > --------------; > minimum time: 7.426 ms (0.00% GC); > median time: 7.526 ms (0.00% GC); > mean time: 7.527 ms (0.00% GC); > maximum time: 8.817 ms (0.00% GC); > --------------; > samples: 663; > evals/sample: 1; >; > Resolves #186; > <https://github.com/climate-machine/Oceananigans.jl/issues/186>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/climate-machine/Oceananigans.jl/pull/352; > Commit Summary; >; > - Organize diagnostics a bit; > - Nuke super ancient and useless field summary diagnostic; > - Also nuke velocity divergence checker. We test this.; > - Use Dicts in NaN checker and give a sensible default; > - Add test for NaN checker; > - Architecture-dispatching zeros function for any 3D shape; > - Parallel cumulative sum CUDA kernel for horizontal averages.; > - Diagnostic for computing horizontally averaged vertica",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010:2881,Benchmark,BenchmarkTools,2881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520187010,1,['Benchmark'],['BenchmarkTools']
Testability,2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 47,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2569,test,test,2569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,3.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```. ### GPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ GPU │ RectilinearGrid │ ExplicitFreeSurface │ 1.455 ms │ 1.632 ms │ 1.786 ms │ 3.695 ms │ 1.07 MiB │ 3495 │ 10 │; │ GPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 2.277 ms │ 2.315 ms │ 2.472 ms │ 3.774 ms │ 1.56 MiB │ 5257 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 3.285 ms │ 3.347 ms │ 3.543 ms │ 5.177 ms │ 1.70 MiB │ 7742 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 6.804 ms │ 6.924 ms │ 7.050 ms │ 8.149 ms │ 1.74 MiB │ 14313 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.323 ms │ 6.400 ms │ 6.639 ms │ 7.688 ms │ 1.68 MiB │ 12378 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:4160,benchmark,benchmarks,4160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['benchmark'],['benchmarks']
Testability,"3.731 ms │ 4.014 ms │ 4.048 ms │ 4.752 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 25.071 ms │ 25.897 ms │ 26.004 ms │ 27.032 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 214.549 ms │ 216.681 ms │ 218.408 ms │ 227.438 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 4.230 ms │ 4.334 ms │ 4.430 ms │ 5.244 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 28.847 ms │ 29.348 ms │ 29.573 ms │ 30.704 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 254.216 ms │ 254.715 ms │ 255.230 ms │ 260.031 ms │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.474 ms │ 2.625 ms │ 2.764 ms │ 3.510 ms │ 802.67 KiB │ 11417 │; │ GPU │ Float32 │ 64 │ 10.381 ms │ 13.617 ms │ 13.292 ms │ 13.719 ms │ 802.48 KiB │ 11413 │; │ GPU │ Float32 │ 128 │ 76.589 ms │ 114.593 ms │ 113.372 ms │ 132.651 ms │ 802.48 KiB │ 11413 │; │ GPU │ Float64 │ 32 │ 5.366 ms │ 5.420 ms │ 5.439 ms │ 5.610 ms │ 877.02 KiB │ 11251 │; │ GPU │ Float64 │ 64 │ 33.735 ms │ 38.491 ms │ 38.027 ms │ 38.614 ms │ 876.83 KiB │ 11247 │; │ GPU │ Float64 │ 128 │ 293.481 ms │ 316.512 ms │ 316.715 ms │ 343.279 ms │ 876.83 KiB │ 11247 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; [2020/11/26 16:09:31.583] INFO Writing Incompressible_model_benchmarks.html...; Incompressible model CPU -> GPU speedup; ┌─────────────┬─────┬──────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼─────┼──────────┼─────────┼─────────┤; │ Float32 │ 32 │ 1.52907 │ 3.31105 │ 6.08582 │; │ Float32 │ 64 │ 1.90176 │ 3.31028 │ 6.08369 │; │ Float32 │ 128 │ 1.89087 │ 3.31028 │ 6.08369 │; │ Float64 │ 32 │ 0.799624 │ 2.98876 │ 5.99733 │; │ Float64 │ 64 │ 0.76246 │ 2.98813 │ 5.9952 │; │ Float64 │ 128 │ 0.804754 │ 2.98813 │ 5.9952 │; └─────────────┴─────┴──────────┴─────────┴─────────┘; ```. For this one single test (clearly more needs to be done) it seems that on average the speedup is slightly lower and the memory is also slightly lower, compared to master",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734478044:6829,test,test,6829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734478044,1,['test'],['test']
Testability,"3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:104553,Benchmark,Benchmark,104553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['Benchmark']
Testability,3315 │ 10 │; └───────────────┴─────────────┴─────┴───────────┴────────────┴────────┴─────────┘. origin/main. Nonhydrostatic model benchmarks (Ns³); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 81.958 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 128 │ 405.241 ms │ 636.84 KiB │ 1576 │ 10 │; │ CPU │ Float64 │ 256 │ 6.018 s │ 636.84 KiB │ 1576 │ 1 │; │ GPU │ Float64 │ 64 │ 3.386 ms │ 953.50 KiB │ 4124 │ 10 │; │ GPU │ Float64 │ 128 │ 11.686 ms │ 979.23 KiB │ 5771 │ 10 │; │ GPU │ Float64 │ 256 │ 68.086 ms │ 1.24 MiB │ 24592 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴────────┴─────────┘. HydrostaticFreeSurface model benchmarks (Ns²×10); ┌───────────────┬─────────────┬─────┬────────────┬────────────┬─────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼─────────┼─────────┤; │ CPU │ Float64 │ 64 │ 9.178 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 128 │ 29.660 ms │ 1.39 MiB │ 2714 │ 10 │; │ CPU │ Float64 │ 256 │ 225.186 ms │ 1.39 MiB │ 2714 │ 10 │; │ GPU │ Float64 │ 64 │ 6.415 ms │ 1.82 MiB │ 5793 │ 10 │; │ GPU │ Float64 │ 128 │ 6.660 ms │ 1.82 MiB │ 5806 │ 10 │; │ GPU │ Float64 │ 256 │ 4.325 ms │ 1.82 MiB │ 5813 │ 10 │; └───────────────┴─────────────┴─────┴────────────┴────────────┴─────────┴─────────┘. ShallowWater model benchmarks (Ns²); ┌───────────────┬─────────────┬─────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ median │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ Float64 │ 64 │ 2.512 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 128 │ 9.964 ms │ 801.66 KiB │ 1742 │ 10 │; │ CPU │ Float64 │ 256 │ 33,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763:2997,benchmark,benchmarks,2997,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1066030763,1,['benchmark'],['benchmarks']
Testability,"3340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9334,test,test,9334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"341a] Lz4_jll v1.9.4+0; [856f044c] MKL_jll v2024.2.0+0; [7cb0a576] MPICH_jll v4.2.1+1; [f1f71cc9] MPItrampoline_jll v5.4.0+0; [9237b28f] MicrosoftMPI_jll v10.1.4+2; [e98f9f5b] NVTX_jll v3.1.0+2; ⌃ [7243133f] NetCDF_jll v400.902.209+0; ⌅ [4c82536e] Nettle_jll v3.7.2+0; [fe0851c0] OpenMPI_jll v5.0.3+0; [458c3c95] OpenSSL_jll v3.0.14+0; [efe28fd5] OpenSpecFun_jll v0.5.5+0; [c2071276] P11Kit_jll v0.24.1+0; [02c8fc9c] XML2_jll v2.13.1+0; [ffd25f8a] XZ_jll v5.4.6+0; [3161d3a3] Zstd_jll v1.5.6+0; [477f73a3] libaec_jll v1.1.2+0; [337d8026] libzip_jll v1.10.1+0; [1317d2d5] oneTBB_jll v2021.12.0+0; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.3; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.9.2; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics v1.9.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.0.5+0; [781609d7] GMP_jll v6.2.1+2; [deac9b47] LibCURL_jll v7.84.0+0; [29816b5a] LibSSH2_jll v1.10.2+0; [c8ffd9c3] MbedTLS_jll v2.28.2+0; [14a3606d] MozillaCACerts_jll v2022.10.11; [4536629a] OpenBLAS_jll v0.3.21+4; [05823500] OpenLibm_jll v0.8.1+0; [bea87d4a] SuiteSparse_jll v5.10.1+6; [83775a58] Zlib_jll v1.2.13+0; [8e850b90] libblastrampoline_jll v5.8.0+0; [8e850ede] nghttp2_jll v1.48.0+0; [3f19e933] p7zip_jll v17.4.0+0; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ are restricted by compatibility constraints from upgrading. To see why use `status --outdated -m`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:21074,Test,Test,21074,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Test'],['Test']
Testability,"387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /home/ssilvest/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] macro expansion; @ ~/julia-1.8.0/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main ~/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; [2023/02/14 16:24:51.806] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/14 16:25:16.858] INFO Initializing simulation...; [2023/02/14 16:25:16.992] INFO ... simulation initialization complete (134.028 ms); [2023/02/14 16:25:16.992] INFO Executing initial time step...; [2023/02/14 16:25:47.962] INFO ... initial time step complete (30.969 seconds).; [2023/02/14 16:25:48.168] INFO Simulation is stopping after running for 31.304 seconds.; [2023/02/14 16:25:48.168] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:25:48.190] INFO Δu: min=-1.672000e-04, max=+4.242261e-06, mean=-8.684623e-06, absmean=+8.777260e-06, std=+2.661194e-05 (16384/16384 matching grid points); [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:2275,Test,Test,2275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,2,['Test'],['Test']
Testability,"3; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = Incom",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:107414,benchmark,benchmark,107414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"3; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:108078,benchmark,benchmark,108078,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['benchmark'],['benchmark']
Testability,"3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <ø> (ø)` | |; | [src/BoundaryConditions/fill\_halo\_regions\_flux.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc19mbHV4Lmps) | `25.00% <25.00%> (ø)` | |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `82.60% <76.47%> (-17.40%)` | :arrow_down: |; | [...c/BoundaryConditions/fill\_halo\_regions\_periodic.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc19wZXJpb2RpYy5qbA==) | `100.00% <100.00%> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `98.24% <100.00%> (-1.76%)` | :arrow_down: |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | `100.00% <100.00%> (ø)` | |; | ... and [11 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904?src=pr&el=footer). Last update [edcedc3...9b584e7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/904?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686359551:3157,test,test,3157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904#issuecomment-686359551,2,['test'],['test']
Testability,"3b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:11018,Test,Test,11018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Test'],['Test']
Testability,"3e51a0ecc8d904993226fcbb70fa88b45/src/OutputWriters/windowed_time_average.jl) successfully passes the [NetCDF OutputWriter test](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_netcdf_output_writer.jl). However, when running the existing MWE, [test_netcdf_time_averaging ](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_netcdf_output_writer.jl#L636), setting [Δt](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_netcdf_output_writer.jl#L657) to 0.01 and an average window of 3Δt produces a similar discontinuity to what was observed in https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259395775, as shown in the figure below. The vertical lines indicate the start and end of the windows.; <img width=""584"" alt=""image"" src=""https://github.com/user-attachments/assets/6a14b489-622a-440a-a73a-4030b52b71e9"">. With this new [PR](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877), the same test now yields a smooth solution: ; <img width=""593"" alt=""image"" src=""https://github.com/user-attachments/assets/0a436474-cd81-4378-bfbd-110eb8417b5d"">. While the discontinuity caused by rounding errors has been resolved, not all cases with different Δt pass the test, e.g., ; ```julia; for (n, t) in enumerate(single_ds[""time""][2:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=1e-5)); end; ```; Here is an example of a case that does not pass the test:; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test. arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ1(x, y, z) = x + (1 - y)^2 + tanh(z); λ2(x, y, z) = x + (1 - y)^2 + tanh(4z). Fc1(x, y, z, t, c1) = - λ1(x, y, z) * c1; Fc2(x, y, z, t, c2) = - λ2(x, y, z) * c2; ; c1_forcing = Forcing(Fc1, field_depe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073:1104,test,test,1104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073,1,['test'],['test']
Testability,"3lhbmN5L0J1b3lhbmN5Lmps) | `59.37% <0.00%> (-3.79%)` | :arrow_down: |; | [src/Buoyancy/nonlinear\_equation\_of\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L25vbmxpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `72.00% <0.00%> (-3.00%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `87.50% <0.00%> (-1.39%)` | :arrow_down: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <0.00%> (ø)` | |; | [...ence\_tests/ConvergenceTests/ForcedFlowFixedSlip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRm9yY2VkRmxvd0ZpeGVkU2xpcC5qbA==) | | |; | [test/test\_averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2F2ZXJhZ2VkX2ZpZWxkLmps) | | |; | ... and [75 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572?src=pr&el=footer). Last update [3b45ce5...08d5cb5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/572?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/572#issuecomment-596513569:2887,test,test,2887,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572#issuecomment-596513569,2,['test'],['test']
Testability,"3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76781,Test,Test,76781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,4 workers increase the pressure on Tartarus a lot if we are testing multiple branches at the same time,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592136209:60,test,testing,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1592136209,1,['test'],['testing']
Testability,"4, 3}, ZeroField{Int64, 3}, ConstantField{Float64, 3}}}}, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC5.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:175; [21] test_biogeochemistry!(grid::LatitudeLongitudeGrid{Float64, Periodic, Flat, Bounded, Nothing, Nothing, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:21667,test,test,21667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635,1,['test'],['test']
Testability,"4,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16437,sandbox,sandbox,16437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Testability,"4/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Print",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:110560,Test,Test,110560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['Test'],['Test']
Testability,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1056,Test,Test,1056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['Test'],['Test']
Testability,"40103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:11440,test,test,11440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"4096 │ 185.419 │ 1.83529 │ 21.2678 │; │ Float64 │ 8192 │ 189.573 │ 3.52748 │ 86.6092 │; │ Float64 │16384 │ 193.026 │ 10.376 │ 350.986 │; └─────────────┴──────┴──────────┴─────────┴─────────┘; ```; Benchmarkable incompressible model:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 6.121 ms │ 6.225 ms │ 6.393 ms │ 7.995 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 64 │ 39.352 ms │ 39.706 ms │ 39.950 ms │ 42.529 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 128 │ 323.897 ms │ 325.763 ms │ 325.708 ms │ 327.232 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 32 │ 6.517 ms │ 6.661 ms │ 6.892 ms │ 9.248 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 45.077 ms │ 45.430 ms │ 45.821 ms │ 49.910 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 390.134 ms │ 390.948 ms │ 391.456 ms │ 395.682 ms │ 1.77 MiB │ 2301 │ 10 │; │ GPU │ Float32 │ 32 │ 3.543 ms │ 3.679 ms │ 3.813 ms │ 5.210 ms │ 2.23 MiB │ 6920 │ 10 │; │ GPU │ Float32 │ 64 │ 3.732 ms │ 3.782 ms │ 3.907 ms │ 4.982 ms │ 2.22 MiB │ 6939 │ 10 │; │ GPU │ Float32 │ 128 │ 3.940 ms │ 4.023 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:5129,benchmark,benchmarks,5129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['benchmark'],['benchmarks']
Testability,413c3d8399127d3f4c15c2beb429c8db4adf3a?el=desc) will **decrease** coverage by `0.02%`.; > The diff coverage is `77.55%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1020 +/- ##; ==========================================; - Coverage 70.72% 70.69% -0.03% ; ==========================================; Files 226 226 ; Lines 6626 6648 +22 ; ==========================================; + Hits 4686 4700 +14 ; - Misses 1940 1948 +8 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <ø> (ø)` | |; | [test/test\_averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2F2ZXJhZ2VkX2ZpZWxkLmps) | `0.00% <ø> (ø)` | |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `76.92% <44.44%> (-13.56%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `69.56% <60.00%> (-6.63%)` | :arrow_down: |; | [src/Buoyancy/buoyancy\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L2J1b3lhbmN5X2ZpZWxkLmps) | `68.96% <66.66%> (-6.04%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1020/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl],MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1020#issuecomment-702338478:1240,test,test,1240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020#issuecomment-702338478,2,['test'],['test']
Testability,"42207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:6428,Test,Test,6428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"43] INFO Δu: min=-3.188983e-08, max=+2.966291e-08, mean=+3.932481e-11, absmean=+1.978398e-09, std=+5.640766e-09 (16384/16384 matching grid points); [2023/02/21 06:38:00.744] INFO Δv: min=-2.539346e-09, max=+1.967717e-09, mean=+2.462280e-12, absmean=+1.480658e-10, std=+4.143014e-10 (16488/16512 matching grid points); [2023/02/21 06:38:00.744] INFO Δh: min=-4.767265e-07, max=+4.779508e-07, mean=+3.492460e-09, absmean=+2.039559e-07, std=+2.510841e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; [2023/02/21 06:38:01.335] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/21 06:38:01.772] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:14035,test,test,14035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['test'],['test']
Testability,"44 successful checks :rocket:. I think this PR is ready to be merged. All the existing convergence tests are now in CI and pass, and the plots are uploaded as Buildkite artifacts. This PR might conflict with @francispoulin's PR #1276 (I'm happy to fix conflicts no matter which PR is merged first). There are a few tests that take a long time. This can be shortened in a future PR as it might involve some trial and error and fiddling with rate of convergence tolerances. Other validation experiments should also be added. Right now I have set the validation pipeline to only run on master (and every night at 3am ET).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769873005:99,test,tests,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-769873005,2,['test'],['tests']
Testability,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:5819,test,test,5819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10027,test,test,10027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['test'],['test']
Testability,"4841c96. I wrote a new script test/test_multi_region_cubed_sphere_scalar_halos.jl to verify the correct halo filling for scalar fields at locations cca, fca, cfa, and ffa. I manually filled out the halos of the parent (off-set) array and compared them against the halos of the array filled out with the fill_halo_regions! function. At the ffa locations, the tests fail for all halos. At the cca, fca, and cfa locations, the tests fail for (a) the north and west halos of the odd-numbered panels 1, 3, 5 (with non-trivial connectivities), and (b) the south and east halos of the even-numbered panels 2, 4, 6 (with non-trivial connectivities). The tests which fail are currently commented out in the script test/test_multi_region_cubed_sphere_scalar_halos.jl. After some digging, I found out that both the latitude and longitude values are not correctly defined on these halos. . To delve into the root of the issue, I first replace the line ; ```julia; Ψᵣ(λ, φ, z) = - U * R * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)); ```; with; ```julia; Ψᵣ(λ, φ, z) = λ ; ```; in test/test_multi_region_cubed_sphere_scalar_halos.jl, and run the script:; ```julia; julia> include(""test/test_multi_region_cubed_sphere_scalar_halos.jl""); ```; Then I type the following commands over the terminal and study the output:; ```julia; julia> Nx, Ny, Nz = 3, 3, 1; (3, 3, 1). julia> grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, Nz), z = (0, 1), radius = 1, horizontal_direction_halo = 3, z_halo = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 3×3×1 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> data_1 = create_c_test_data(grid); CubedSphereField{Center, Center, Center}; ├── g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511:1117,test,test,1117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3280#issuecomment-1743842511,1,['test'],['test']
Testability,49 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:2256,test,test,2256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,1,['test'],['test']
Testability,"49ee12237627992a99d5e30ae63e4d78cd24a""; ---; > git-tree-sha1 = ""3bac05bc7e74a75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_constructi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:10992,Test,Test,10992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Test'],['Test']
Testability,"4; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:77063,test,test,77063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,"4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38134,test,test,38134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,4] DocStringExtensions v0.8.6; [fa6b7ba4] DualNumbers v0.6.8; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.8; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.4.6; [5789e2e9] FileIO v1.14.0; [53c48c17] FixedPointNumbers v0.8.4; [59287772] Formatting v0.4.2; [0c68f7d7] GPUArrays v8.3.2; [61eb1bfa] GPUCompiler v0.15.2; [28b8d3ca] GR v0.69.5; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.7.4; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.0; [83e8ac13] IniFile v0.5.1; [842dd82b] InlineStrings v1.4.0; [3587e190] InverseFunctions v0.1.4; [92d709cd] IrrationalConstants v0.1.1; [42fd0dbc] IterativeSolvers v0.9.2; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.22; [1019f520] JLFzf v0.1.5; [692b3bcd] JLLWrappers v1.4.1; [682c06a0] JSON v0.21.3; [0f8b85d8] JSON3 v1.9.5; [63c18a36] KernelAbstractions v0.7.2; [929cbde3] LLVM v4.11.1; [b964fa9f] LaTeXStrings v1.3.0; [23fbe1c1] Latexify v0.15.18; [2ab3a3ac] LogExpFunctions v0.3.15; [e6f89c97] LoggingExtras v1.0.0; [da04e1cc] MPI v0.19.2; [3da0fdf6] MPIPreferences v0.1.7; [1914dd2f] MacroTools v0.5.9; [739be429] MbedTLS v1.1.7; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.5; [85f8d34a] NCDatasets v0.12.4; [77ba4419] NaNMath v1.0.0; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [4d8831e6] OpenSSL v1.3.3; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v2.3.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [b98c9c47] Pipe v1.3.0; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.3.4; [91a5bcdd] Plots v1.36.0; [21216c6a] Preferences v1.3.0; [94ee1d12] Quaternions v0.5.6; [74087812] Random123 v1.5.0; [e6cf234a] RandomNumbers v1.5.3; [3cdcf5f2] RecipesBase v1.2.1; [01d81517] RecipesPipeline v0.6.9; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.0; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:3866,Log,LoggingExtras,3866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Log'],['LoggingExtras']
Testability,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3743,benchmark,benchmark,3743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['benchmark'],['benchmark']
Testability,"52; &nbsp; | [2] (),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; &nbsp; | [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; &nbsp; | [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; &nbsp; | [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; &nbsp; | [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; &nbsp; | [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; &nbsp; | [9] top-level scope at none:1; &nbsp; | ::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2578/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:4404,test,test,4404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['test'],['test']
Testability,"52; &nbsp; | [2] (::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] (),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; &nbsp; | [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; &nbsp; | [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; &nbsp; | [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; &nbsp; | [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; &nbsp; | [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; &nbsp; | [9] top-level scope at none:1; &nbsp; | ::test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; &nbsp; | [2] coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; &nbsp; | [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:3807,test,test,3807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['test'],['test']
Testability,52c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNumbers v0.6.8; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.8; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.4.6; [5789e2e9] FileIO v1.14.0; [53c48c17] FixedPointNumbers v0.8.4; [59287772] Formatting v0.4.2; [0c68f7d7] GPUArrays v8.3.2; [61eb1bfa] GPUCompiler v0.15.2; [28b8d3ca] GR v0.69.5; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.7.4; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.0; [83e8ac13] IniFile v0.5.1; [842dd82b] InlineStrings v1.4.0; [3587e190] InverseFunctions v0.1.4; [92d709cd] IrrationalConstants v0.1.1; [42fd0dbc] IterativeSolvers v0.9.2; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.22; [1019f520] JLFzf v0.1.5; [692b3bcd] JLLWrappers v1.4.1; [682c06a0] JSON v0.21.3; [0f8b85d8] JSON3 v1.9.5; [63c18a36] KernelAbstractions v0.7.2; [929cbde3] LLVM v4.11.1; [b964fa9f] LaTeXStrings v1.3.0; [23fbe1c1] Latexify v0.15.18; [2ab3a3ac] LogExpFunctions v0.3.15; [e6f89c97] LoggingExtras v1.0.0; [da04e1cc] MPI v0.19.2; [3da0fdf6] MPIPreferences v0.1.7; [1914dd2f] MacroTools v0.5.9; [739be429] MbedTLS v1.1.7; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.5; [85f8d34a] NCDatasets v0.12.4; [77ba4419] NaNMath v1.0.0; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [4d8831e6] OpenSSL v1.3.3; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v2.3.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [b98c9c47] Pipe v1.3.0; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.3.4; [91a5bcdd] Plots v1.36.0; [21216c6a] Preferences v1.3.0; [94ee1d12] Quaternions v0.5.6; [74087812] Random123 v1.5.0; [e6cf234a] RandomNumbers v1.5.3; [3cdcf5f2] RecipesBase v1.2.1; [01d81517] RecipesPipeline v0.6.9; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.0; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTe,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:3830,Log,LogExpFunctions,3830,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Log'],['LogExpFunctions']
Testability,"57 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00973 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.994272 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 1.00813 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.98639 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.98391 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.973739 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬───────────────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 23.527 ms │ 23.573 ms │ 23.652 ms │ 24.354 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 30.958 ms │ 31.004 ms │ 31.160 ms │ 31.948 ms │ 575.12 KiB │ 1010 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 23.061 ms │ 23.442 ms │ 25.189 ms │ 39.441 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:3454,benchmark,benchmarks,3454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['benchmark'],['benchmarks']
Testability,"59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117228,test,test,117228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['test'],['test']
Testability,591/files#diff-82>; > (33); > - *D* src/boundary_conditions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-83>; > (523); > - *D* src/buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-84>; > (359); > - *D* src/coriolis.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-85>; > (123); > - *D* src/halo_regions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-86>; > (208); > - *D* src/utils.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-87>; > (448); > - *M* test/regression_tests/rayleigh_benard_regression_test.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-88>; > (2); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-89>; > (87); > - *M* test/test_abstract_operations.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-90>; > (34); > - *M* test/test_boundary_conditions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-91>; > (4); > - *M* test/test_buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-92>; > (10); > - *M* test/test_diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-93>; > (22); > - *M* test/test_dynamics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-94>; > (6); > - *M* test/test_examples.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-95>; > (2); > - *M* test/test_models.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-96>; > (2); > - *M* test/test_solvers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-97>; > (3); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-98>; > (14); > - *M* test/test_turbulence_closures.jl; > <h,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:13938,test,test,13938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['test'],['test']
Testability,591/files#diff-83>; > (523); > - *D* src/buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-84>; > (359); > - *D* src/coriolis.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-85>; > (123); > - *D* src/halo_regions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-86>; > (208); > - *D* src/utils.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-87>; > (448); > - *M* test/regression_tests/rayleigh_benard_regression_test.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-88>; > (2); > - *M* test/runtests.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-89>; > (87); > - *M* test/test_abstract_operations.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-90>; > (34); > - *M* test/test_boundary_conditions.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-91>; > (4); > - *M* test/test_buoyancy.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-92>; > (10); > - *M* test/test_diagnostics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-93>; > (22); > - *M* test/test_dynamics.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-94>; > (6); > - *M* test/test_examples.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-95>; > (2); > - *M* test/test_models.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-96>; > (2); > - *M* test/test_solvers.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-97>; > (3); > - *M* test/test_time_stepping.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-98>; > (14); > - *M* test/test_turbulence_closures.jl; > <https://github.com/climate-machine/Oceananigans.jl/pull/591/files#diff-99>; > (12); > - *M* verification/stratified_couette_,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618:14066,test,test,14066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573468618,1,['test'],['test']
Testability,"5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 171.290 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 2.341 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.25, 0.5], y(particle): [0.0, 0.25, 0.5, 0.25, 0.5], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; ```. We see that the particles with x- and y- coordinates larger than 0.5 get moved after the first time step when I think it shouldn't be. This is because of the following lines:; https://github.com/CliMA/Oceananigans.jl/blob/3e2650373e9c73231681535aadb5b720a830dc97/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L102C4-L104C27. Instead of ; ```julia; iᴿ = length(f, tx, Nx); jᴿ = length(f, ty, Ny); kᴿ = length(f, tz, Nz); ```; I think it should be ; ```julia; iᴿ = length(f, tx, Nx) + ifelse(tx == Periodic(), 1, 0); jᴿ = length(f, ty, Ny) + ifelse(ty == Periodic(), 1, 0); kᴿ = length(f, tz, Nz) + ifelse(tz == Periodic(), 1, 0); ```; The change gives an output log of; ```; [ Info: Initializing simulation...; i: 0, t: 0 seconds, wall time: 59.256 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: ... simulation initialization complete (58.949 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (86.845 ms).; i: 1, t: 100 ms, wall time: 91.015 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 100 ms; [ Info: x(particle): [0.0, 0.25, 0.5, 0.75, 1.0], y(particle): [0.0, 0.25, 0.5, 0.75, 1.0], z(particle): [-0.5, -0.5, -0.5, -0.5, -0.5]; [ Info: Simulation is stopping after running for 152.524 ms.; [ Info: Model iteration 2 equals or exceeds stop iteration 2.; i: 2, t: 200 ms, wall time: 3.068 ms, max(u)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3415:3630,log,log,3630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3415,1,['log'],['log']
Testability,"6 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.027 s │ 1.034 s │ 1.053 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.335 s │ 2.339 s │ 2.343 s │ 2.353 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ UpwindBiasedThirdOrder │ 1.787 s │ 1.892 s │ 1.867 s │ 1.922 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.935 s │ 6.935 s │ 6.935 s │ 6.935 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.856 ms │ 21.016 ms │ 21.146 ms │ 22.351 ms │ 2.14 MiB │ 18750 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.201 ms │ 15.574 ms │ 15.175 ms │ 15.932 ms │ 2.05 MiB │ 13243 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.296 ms │ 23.514 ms │ 25.463 ms │ 43.065 ms │ 2.18 MiB │ 21868 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.859 ms │ 19.041 ms │ 19.338 ms │ 22.157 ms │ 2.10 MiB │ 16584 │ 10 │; │ GPU │ WENO5 │ 22.645 ms │ 28.377 ms │ 27.818 ms │ 28.571 ms │ 2.26 MiB │ 27075 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; to test the new WENO methods on a stretched grid modify the code in benchmark_advection_schemes.jl as seen below. ```; function benchmark_advection_scheme(Arch, Scheme); grid = RectilinearGrid(size=(192, 192, 192), x = (0, 1), y = (0, 1), z = collect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ┌───────────────┬─────────────────────┬────────────┬────────────┬────────────┬────────────┬──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:3292,test,test,3292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['test'],['test']
Testability,"6%)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `69.06% <0%> (-4.97%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `83.05% <0%> (-3.07%)` | :arrow_down: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `57.8% <0%> (-2.6%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `75.75% <0%> (-0.25%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `0% <0%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `76.92% <0%> (+1.92%)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `89.23% <0%> (+2.69%)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/557?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/557#issuecomment-562864567:2690,log,logger,2690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/557#issuecomment-562864567,1,['log'],['logger']
Testability,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3031:3328,test,test,3328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031,5,['test'],['test']
Testability,"64, 3}, ::BatchedTridiagonalSolver{Vector{Float64}, Vector{Float64}, Vector{Float64}, Array{Float64, 3}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Nothing, ZDirection}, ::Vector{Float64}); > @ Oceananigans.Solvers ~/repos/Oceananigans.jl3/src/Solvers/batched_tridiagonal_solver.jl:83; > [4] can_solve_single_tridiagonal_system(arch::CPU, N::Int64; tridiagonal_direction::ZDirection); > @ Main ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:39; > [5] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; > [6] macro expansion; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:169 [inlined]; > [7] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]; > [8] macro expansion; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:167 [inlined]; > [9] macro expansion; > @ ~/bin/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:1363 [inlined]; > [10] top-level scope; > @ ~/repos/Oceananigans.jl3/test/test_batched_tridiagonal_solver.jl:163; > ```; > ; > I'm not very familiar with `KernelAbsractions` so I don't really understand what's happening, but my guess is that I need to define `work_layout` for `ZDirection`. Problem is I have no idea what it should be.; > ; > Let me know if you want me to push the code I have with `ZDirection` and this error to the branch. I don't know what you did but note that for `tridiagonal_direction isa ZDirection`, then `work_layout = :xy`. We don't need to define the work layout for `ZDirection` (I don't know what that would mean either)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399:3719,test,test,3719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564940399,7,"['Test', 'test']","['Test', 'test']"
Testability,"64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51446,sandbox,sandbox,51446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Testability,"64},; verbose = true,; filename = single_time_average_nc_filepath,; schedule = AveragedTimeInterval(interval, window = window, stride = stride),; dimensions = single_nc_dimension,; overwrite_existing = true); run!(simulation). ##### For each λ, horizontal average should evaluate to; #####; ##### c̄(z, t) = ∫₀¹ ∫₀¹ exp{- λ(x, y, z) * t} dx dy; ##### = 1 / (Nx*Ny) * Σᵢ₌₁ᴺˣ Σⱼ₌₁ᴺʸ exp{- λ(i, j, k) * t}; #####; ##### which we can compute analytically. # ds = NCDataset(horizontal_average_nc_filepath). Nx, Ny, Nz = size(grid); xs, ys, zs = nodes(model.tracers.c1). c̄1(z, t) = 1 / (Nx * Ny) * sum(exp(-λ1(x, y, z) * t) for x in xs for y in ys); c̄2(z, t) = 1 / (Nx * Ny) * sum(exp(-λ2(x, y, z) * t) for x in xs for y in ys). rtol = 1e-5 # need custom rtol for isapprox because roundoff errors accumulate (?). # Compute time averages...; c̄1(ts) = 1/length(ts) * sum(c̄1.(zs, t) for t in ts); c̄2(ts) = 1/length(ts) * sum(c̄2.(zs, t) for t in ts). #####; ##### Test strided windowed time average against analytic solution; ##### for *single* NetCDF output; #####; ; single_ds = NCDataset(single_time_average_nc_filepath). attribute_names = (""schedule"", ""interval"", ""output time interval"",; ""time_averaging_window"", ""time averaging window"",; ""time_averaging_stride"", ""time averaging stride""). for name in attribute_names; @test haskey(single_ds.attrib, name) && !isnothing(single_ds.attrib[name]); end. window_size = Int(window/Δt). @info "" Testing time-averaging of a single NetCDF output [$(typeof(arch))]..."". for (n, t) in enumerate(single_ds[""time""][2:end]); averaging_times = [t - n*Δt for n in 0:stride:window_size-1 if t - n*Δt >= 0]; # @info n,t,averaging_times, c̄1(averaging_times).-single_ds[""c1""][:, n+1]; @test all(isapprox.(single_ds[""c1""][:, n+1], c̄1(averaging_times), rtol=rtol)); end ; ```; I believe there might be some minor issues in our new [PR](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877) that still need to be addressed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073:4017,Test,Test,4017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2378113073,4,"['Test', 'test']","['Test', 'Testing', 'test']"
Testability,"66.66%> (-12.50%)` | :arrow_down: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `90.47% <80.00%> (-3.97%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `76.19% <80.00%> (-1.59%)` | :arrow_down: |; | [src/Buoyancy/buoyancy\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L2J1b3lhbmN5X2ZpZWxkLmps) | `75.00% <83.33%> (+3.57%)` | :arrow_up: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <100.00%> (ø)` | |; | [src/Fields/pressure\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9wcmVzc3VyZV9maWVsZC5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.39% <100.00%> (+<0.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=footer). Last update [c3f6ce0...c42d2de](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/968?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698377343:2773,test,test,2773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968#issuecomment-698377343,2,['test'],['test']
Testability,"690dc29cc53b1d""; uuid = ""9a962f9c-6df0-11e9-0e5d-c546b8b5ee8a""; version = ""1.6.0"". [[DataStructures]]; deps = [""Compat"", ""InteractiveUtils"", ""OrderedCollections""]; git-tree-sha1 = ""4437b64df1e0adccc3e5d1adbc3ac741095e4677""; uuid = ""864edb3b-99cc-5e75-8d2d-829cb0a9cfe8""; version = ""0.18.9"". [[DataValueInterfaces]]; git-tree-sha1 = ""bfc1187b79289637fa0ef6d4436ebdfe6905cbd6""; uuid = ""e2d170a0-9d28-54be-80f0-106bbe20a464""; version = ""1.0.0"". [[Dates]]; deps = [""Printf""]; uuid = ""ade2ca70-3891-5945-98fb-dc099432e06a"". [[DelimitedFiles]]; deps = [""Mmap""]; uuid = ""8bb1440f-4735-579b-a4ab-409b98df4dab"". [[DiffRules]]; deps = [""NaNMath"", ""Random"", ""SpecialFunctions""]; git-tree-sha1 = ""214c3fcac57755cfda163d91c58893a8723f93e9""; uuid = ""b552c78f-8df3-52c6-915a-8e097449b14b""; version = ""1.0.2"". [[Distributed]]; deps = [""Random"", ""Serialization"", ""Sockets""]; uuid = ""8ba89e20-285c-5b6f-9357-94700520ee1b"". [[DocStringExtensions]]; deps = [""LibGit2"", ""Markdown"", ""Pkg"", ""Test""]; git-tree-sha1 = ""9d4f64f79012636741cf01133158a54b24924c32""; uuid = ""ffbed154-4ef7-542d-bbb7-c09d3a79fcae""; version = ""0.8.4"". [[Elliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:4307,Test,Test,4307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability,"6a762c4a3bdb0b""; uuid = ""15972242-4b8f-49a0-b8a1-9ac0e7a1a45d""; version = ""0.3.0"". [[Statistics]]; deps = [""LinearAlgebra"", ""SparseArrays""]; uuid = ""10745b16-79ce-11e8-11f9-7d13ad32a3b2"". [[StructArrays]]; deps = [""Adapt"", ""DataAPI"", ""Tables""]; git-tree-sha1 = ""44b3afd37b17422a62aea25f04c1f7e09ce6b07f""; uuid = ""09ab397b-f2b6-538f-b94a-2f83cf4a842a""; version = ""0.5.1"". [[StructTypes]]; deps = [""Dates"", ""UUIDs""]; git-tree-sha1 = ""e36adc471280e8b346ea24c5c87ba0571204be7a""; uuid = ""856f2bd8-1eba-4b0a-8007-ebc267875bd4""; version = ""1.7.2"". [[TOML]]; deps = [""Dates""]; git-tree-sha1 = ""44aaac2d2aec4a850302f9aa69127c74f0c3787e""; uuid = ""fa267f1f-6049-4f14-aa54-33bafae1ed76""; version = ""1.0.3"". [[TableTraits]]; deps = [""IteratorInterfaceExtensions""]; git-tree-sha1 = ""c06b2f539df1c6efa794486abfb6ed2022561a39""; uuid = ""3783bdb8-4a98-5b6b-af9a-565f29a5fe9c""; version = ""1.0.1"". [[Tables]]; deps = [""DataAPI"", ""DataValueInterfaces"", ""IteratorInterfaceExtensions"", ""LinearAlgebra"", ""TableTraits"", ""Test""]; git-tree-sha1 = ""c9d2d262e9a327be1f35844df25fe4561d258dc9""; uuid = ""bd369af6-aec1-5ad0-b16a-f7cc5008161c""; version = ""1.4.2"". [[TaylorSeries]]; deps = [""InteractiveUtils"", ""LinearAlgebra"", ""Markdown"", ""Requires"", ""SparseArrays""]; git-tree-sha1 = ""66f4d1993bae49eeba21a1634b5f65782585a42c""; uuid = ""6aa5eb33-94cf-58f4-a9d0-e4b2c4fc25ea""; version = ""0.10.13"". [[Test]]; deps = [""Distributed"", ""InteractiveUtils"", ""Logging"", ""Random""]; uuid = ""8dfed614-e22c-5e08-85e1-65c5234f0b40"". [[TimerOutputs]]; deps = [""Printf""]; git-tree-sha1 = ""32cdbe6cd2d214c25a0b88f985c9e0092877c236""; uuid = ""a759f4b9-e2f1-59dc-863e-4aeb61b1ea8f""; version = ""0.5.8"". [[TranscodingStreams]]; deps = [""Random"", ""Test""]; git-tree-sha1 = ""7c53c35547de1c5b9d46a4797cf6d8253807108c""; uuid = ""3bb67fe8-82b1-5028-8e26-92a6c54297fa""; version = ""0.9.5"". [[Tullio]]; deps = [""DiffRules"", ""LinearAlgebra"", ""Requires""]; git-tree-sha1 = ""7201bbb4c138c18bf14511c4cc8daeac6a52c148""; uuid = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:16747,Test,Test,16747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3271,Log,Logging,3271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Log'],['Logging']
Testability,"7 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:9751,Test,Test,9751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:8060,Test,Test,8060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_m,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:3324,test,test,3324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['test'],['test']
Testability,709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_m,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867:2943,test,test,2943,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069#issuecomment-711046867,1,['test'],['test']
Testability,"7208cd3bc5d29631a26bc0cff78902""; uuid = ""21216c6a-2e73-6563-6e65-726566657250""; version = ""1.2.1"". [[Printf]]; deps = [""Unicode""]; uuid = ""de0858da-6303-5e67-8744-51eddeeeb8d7"". [[REPL]]; deps = [""InteractiveUtils"", ""Markdown"", ""Sockets""]; uuid = ""3fa0cd96-eef1-5676-8a61-b3b8758bbffb"". [[Random]]; deps = [""Serialization""]; uuid = ""9a3f8284-a2c9-5f02-9a11-845980a1fd5c"". [[Reexport]]; git-tree-sha1 = ""57d8440b0c7d98fc4f889e478e80f268d534c9d5""; uuid = ""189a3867-3050-52da-a836-e630ba90ab69""; version = ""1.0.0"". [[Requires]]; deps = [""UUIDs""]; git-tree-sha1 = ""4036a3bd08ac7e968e27c203d45f5fff15020621""; uuid = ""ae029012-a4dd-5104-9daa-d747884805df""; version = ""1.1.3"". [[Rotations]]; deps = [""LinearAlgebra"", ""StaticArrays"", ""Statistics""]; git-tree-sha1 = ""2ed8d8a16d703f900168822d83699b8c3c1a5cd8""; uuid = ""6038ab10-8711-5258-84ad-4b1120ba62dc""; version = ""1.0.2"". [[SHA]]; uuid = ""ea8e919c-243c-51af-8825-aaa63cd721ce"". [[SafeTestsets]]; deps = [""Test""]; git-tree-sha1 = ""36ebc5622c82eb9324005cc75e7e2cc51181d181""; uuid = ""1bc83da4-3b8d-516f-aca4-4fe02f6d838f""; version = ""0.0.1"". [[Scratch]]; deps = [""Dates""]; git-tree-sha1 = ""ad4b278adb62d185bbcb6864dc24959ab0627bf6""; uuid = ""6c6a2e73-6563-6170-7368-637461726353""; version = ""1.0.3"". [[SeawaterPolynomials]]; deps = [""Test""]; git-tree-sha1 = ""6db1b6004791962cb12d425cd12691506ad7d2b6""; uuid = ""d496a93d-167e-4197-9f49-d3af4ff8fe40""; version = ""0.2.0"". [[Serialization]]; uuid = ""9e88b42a-f829-5b0c-bbe9-9e923198166b"". [[SharedArrays]]; deps = [""Distributed"", ""Mmap"", ""Random"", ""Serialization""]; uuid = ""1a1011a3-84de-559e-8e89-a11a2f7dc383"". [[Sockets]]; uuid = ""6462fe0b-24de-5631-8697-dd941f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:14329,Test,Test,14329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Test'],['Test']
Testability,"75fd9cba4295cde4045d9fe2386""; 750c787; < version = ""1.2.0""; ---; > version = ""1.2.1""; 759c796; < git-tree-sha1 = ""04bdff0b09c65ff3e06a05e3eb7b120223da3d39""; ---; > git-tree-sha1 = ""0e7508ff27ba32f26cd459474ca2ede1bc10991f""; 761c798; < version = ""1.4.0""; ---; > version = ""1.4.1""; 771c808; < git-tree-sha1 = ""c60ec5c62180f27efea3ba2908480f8055e17cee""; ---; > git-tree-sha1 = ""5165dfb9fd131cf0c6957a3a7605dede376e7b63""; 773c810; < version = ""1.1.1""; ---; > version = ""1.2.0""; 895c932; < git-tree-sha1 = ""a1f34829d5ac0ef499f6d84428bd6b4c71f02ead""; ---; > git-tree-sha1 = ""cb76cf677714c095e535e3501ac7954732aeea2d""; 897c934; < version = ""1.11.0""; ---; > version = ""1.11.1""; 927,928c964; < deps = [""Random"", ""Test""]; < git-tree-sha1 = ""9a6ae7ed916312b41236fcef7e0af564ef934769""; ---; > git-tree-sha1 = ""1fbeaaca45801b4ba17c251dd8603ef24801dd84""; 930c966,970; < version = ""0.9.13""; ---; > version = ""0.10.2""; > weakdeps = [""Random"", ""Test""]; >; > [deps.TranscodingStreams.extensions]; > TestExt = [""Test"", ""Random""]; 987a1028,1033; > [[deps.libevent_jll]]; > deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""OpenSSL_jll""]; > git-tree-sha1 = ""f04ec6d9a186115fb38f858f05c0c4e1b7fc9dcb""; > uuid = ""1080aeaf-3a6a-583e-a51c-c537b09f60ec""; > version = ""2.1.13+1""; >; 996a1043,1048; >; > [[deps.prrte_jll]]; > deps = [""Artifacts"", ""Hwloc_jll"", ""JLLWrappers"", ""Libdl"", ""PMIx_jll"", ""libevent_jll""]; > git-tree-sha1 = ""5adb2d7a18a30280feb66cad6f1a1dfdca2dc7b0""; > uuid = ""eb928a42-fffd-568d-ab9c-3f5d54fc65b9""; > version = ""3.0.2+0""; ```. </details>. There are quite a few differences to some suspicious packages (eg those involved in LLVM) so... (PS, is there a better way to compare Manifests? I wonder.). It might not be anything to do with our code. Nevertheless, @navidcy and I combed through the `git blame` for two files: [`output_construction.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl) and [`computed_field.jl`](https://github.com/CliMA/Oceananigans.jl/blob",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:11045,Test,TestExt,11045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Test'],"['Test', 'TestExt']"
Testability,"76d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-5462-911a-8362d720325c""; version = ""0.3.5"". [[ChainRulesCore]]; deps = [""Compat"", ""LinearAlgebra"", ""SparseArrays""]; git-tree-sha1 = ""5402b5674b3068ca570771c11da9a57bfa70acd4""; uuid = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; version = ""0.9.39"". [[Compat]]; deps = [""Base64"", ""Dates"", ""DelimitedFiles"", ""Distributed"", ""InteractiveUtils"", ""LibGit2"", ""Libdl"", ""LinearAlgebra"", ""Markdown"", ""Mmap"", ""Pkg"", ""Printf"", ""REPL"", ""Random"", ""SHA"", ""Serialization"", ""SharedArrays"", ""Sockets"", ""SparseArrays"", ""Statistics"", ""Test"", ""UUIDs"", ""Unicode""]; git-tree-sha1 = ""ac4132ad78082518ec2037ae5770b6e796f7f956""; uuid = ""34da2185-b29b-5c13-b0c7-acf172513d20""; version = ""3.27.0"". [[CompilerSup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:1688,Log,Logging,1688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Log'],['Logging']
Testability,"77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:117690,Benchmark,BenchmarkTools,117690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Benchmark'],['BenchmarkTools']
Testability,"792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /home/ssilvest/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] macro expansion; @ ~/julia-1.8.0/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main ~/stable_oceananigans/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; [2023/02/14 16:24:51.806] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/14 16:25:16.858] INFO Initializing simulation...; [2023/02/14 16:25:16.992] INFO ... simulation initialization complete (134.028 ms); [2023/02/14 16:25:16.992] INFO Executing initial time step...; [2023/02/14 16:25:47.962] INFO ... initial time step complete (30.969 seconds).; [2023/02/14 16:25:48.168] INFO Simulation is stopping afte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:2019,Test,Test,2019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['Test'],['Test']
Testability,"799057e-15 (4096/4096 matching grid points); Δw: min=-2.242651e-14, max=+2.160425e-14, mean=+3.640442e-18, absmean=+1.618786e-15, std=+2.583244e-15 (4096/4096 matching grid points); Δb: min=-1.665335e-14, max=+2.053913e-14, mean=+9.239435e-18, absmean=+1.249038e-15, std=+1.938872e-15 (4096/4096 matching grid points); Δc: min=-6.022960e-15, max=+7.648396e-15, mean=-4.893137e-19, absmean=+5.861175e-16, std=+9.281398e-16 (4096/4096 matching grid points). Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; Δu: min=-2.772501e-07, max=+1.865995e-07, mean=-1.633351e-20, absmean=+6.868489e-10, std=+6.155992e-09 (2959/4096 matching grid points); Δv: min=-1.600098e-07, max=+1.647848e-07, mean=+1.619951e-20, absmean=+6.257578e-10, std=+5.220796e-09 (3396/4096 matching grid points); Δw: min=-9.857415e-08, max=+1.515074e-07, mean=+7.983410e-20, absmean=+4.958399e-10, std=+3.887294e-09 (2458/4096 matching grid points); ΔT: min=-3.295630e-07, max=+5.110846e-07, mean=-2.005688e-10, absmean=+2.047434e-09, std=+1.735861e-08 (4092/4096 matching grid points); ΔS: min=-3.296776e-10, max=+5.103402e-10, mean=-8.673617e-17, absmean=+2.002898e-12, std=+1.753659e-11 (4096/4096 matching grid points). Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; Δu: min=-2.139048e-08, max=+1.303954e-08, mean=-1.313232e-20, absmean=+5.768485e-11, std=+5.320877e-10 (3793/4096 matching grid points); Δv: min=-2.835820e-08, max=+2.339656e-08, mean=+1.094790e-19, absmean=+7.089837e-11, std=+7.190216e-10 (3927/4096 matching grid points); Δw: min=-1.251260e-08, max=+2.051015e-08, mean=-5.553442e-20, absmean=+5.353006e-11, std=+5.098444e-10 (3508/4096 matching grid points); ΔT: min=-8.801552e-08, max=+1.836259e-08, mean=-3.245009e-11, absmean=+6.785232e-11, std=+1.609149e-09 (4096/4096 matching grid points); ΔS: min=-1.598721e-11, max=+1.057288e-11, mean=-3.816392e-17, absmean=+3.764697e-14, std=+4.486543e-13 (4096/4096 matching grid points); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-690400562:2825,Test,Testing,2825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711#issuecomment-690400562,1,['Test'],['Testing']
Testability,7?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/3b45ce5cbc561d3e951621a402204eb689df2000?el=desc) will **not change** coverage.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #937 +/- ##; =======================================; Coverage 72.61% 72.61% ; =======================================; Files 199 199 ; Lines 5806 5806 ; =======================================; Hits 4216 4216 ; Misses 1590 1590 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.29% <ø> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <ø> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/937/diff?src=pr&el=tree#diff-dGVzdC90ZX,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592:1155,test,test,1155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937#issuecomment-691244592,2,['test'],['test']
Testability,80 2678 -2502 ; ==========================================; - Hits 3673 1839 -1834 ; + Misses 1507 839 -668 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | | |; | ... and [52 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/564/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738:1804,test,test,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564#issuecomment-564625738,2,['test'],['test']
Testability,"8317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12746,Test,Test,12746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12818,test,test,12818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,8,"['Test', 'test']","['Test', 'test', 'tests']"
Testability,"8:46.004] INFO Δu: min=-3.698171e-08, max=+2.977649e-08, mean=-9.793714e-11, absmean=+2.315996e-09, std=+6.206031e-09 (16384/16384 matching grid points); [2023/02/21 06:38:46.005] INFO Δv: min=-5.495966e-10, max=+1.063640e-09, mean=-3.441143e-13, absmean=+4.699188e-11, std=+1.347006e-10 (16508/16512 matching grid points); [2023/02/21 06:38:46.005] INFO Δh: min=-4.766520e-07, max=+4.757091e-07, mean=+1.373701e-08, absmean=+2.044884e-07, std=+2.513218e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:16643,test,test,16643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['test'],['test']
Testability,8c17] FixedPointNumbers v0.8.4; [59287772] Formatting v0.4.2; [0c68f7d7] GPUArrays v8.3.2; [61eb1bfa] GPUCompiler v0.15.2; [28b8d3ca] GR v0.69.5; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.7.4; [615f187c] IfElse v0.1.1; [40713840] IncompleteLU v0.2.0; [83e8ac13] IniFile v0.5.1; [842dd82b] InlineStrings v1.4.0; [3587e190] InverseFunctions v0.1.4; [92d709cd] IrrationalConstants v0.1.1; [42fd0dbc] IterativeSolvers v0.9.2; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.22; [1019f520] JLFzf v0.1.5; [692b3bcd] JLLWrappers v1.4.1; [682c06a0] JSON v0.21.3; [0f8b85d8] JSON3 v1.9.5; [63c18a36] KernelAbstractions v0.7.2; [929cbde3] LLVM v4.11.1; [b964fa9f] LaTeXStrings v1.3.0; [23fbe1c1] Latexify v0.15.18; [2ab3a3ac] LogExpFunctions v0.3.15; [e6f89c97] LoggingExtras v1.0.0; [da04e1cc] MPI v0.19.2; [3da0fdf6] MPIPreferences v0.1.7; [1914dd2f] MacroTools v0.5.9; [739be429] MbedTLS v1.1.7; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.5; [85f8d34a] NCDatasets v0.12.4; [77ba4419] NaNMath v1.0.0; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [4d8831e6] OpenSSL v1.3.3; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v2.3.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [b98c9c47] Pipe v1.3.0; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.3.4; [91a5bcdd] Plots v1.36.0; [21216c6a] Preferences v1.3.0; [94ee1d12] Quaternions v0.5.6; [74087812] Random123 v1.5.0; [e6cf234a] RandomNumbers v1.5.3; [3cdcf5f2] RecipesBase v1.2.1; [01d81517] RecipesPipeline v0.6.9; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.0; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.1.1; [d496a93d] SeawaterPolynomials v0.2.3; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [66db9d55] SnoopPrecompile v1.0.3; [a2af1166] SortingAlgorithms v1.1.0; [276daf66] SpecialF,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:4070,Mock,Mocking,4070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Mock'],['Mocking']
Testability,"8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Ar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:1267,test,test,1267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['test'],['test']
Testability,"8e-16, std=7.36011e-16; [ Info: Δv: min=-3.01208e-15, max=3.00899e-15, mean=-1.19521e-21, absmean=5.13326e-16, std=7.35825e-16; [ Info: Δw: min=-7.64756e-15, max=5.88619e-15, mean=1.35968e-21, absmean=1.03765e-15, std=1.48909e-15; [ Info: ΔT: min=-1.77636e-15, max=1.77636e-15, mean=7.80626e-18, absmean=3.55618e-17, std=2.51247e-16; [ Info: ΔS: min=0, max=0, mean=0, absmean=0, std=0; Testing Rayleigh–Bénard tracer regression [CPU]; [ Info: Δu: min=-3.65818e-14, max=3.21965e-14, mean=-1.92406e-18, absmean=3.3529e-15, std=4.83978e-15; [ Info: Δv: min=-2.85535e-14, max=3.72202e-14, mean=1.62974e-19, absmean=3.29709e-15, std=4.79574e-15; [ Info: Δw: min=-4.56857e-14, max=4.32987e-14, mean=2.54957e-18, absmean=2.97761e-15, std=4.68161e-15; [ Info: ΔT: min=-5.19029e-14, max=3.71925e-14, mean=8.223e-18, absmean=2.55428e-15, std=4.14735e-15; [ Info: ΔS: min=-2.37588e-14, max=1.60982e-14, mean=1.15112e-18, absmean=1.13258e-15, std=1.79417e-15; Testing oceanic large eddy simulation regression [VerstappenAnisotropicMinimumDissipation, CPU]; [ Info: Δu: min=-8.1532e-16, max=7.47666e-16, mean=3.10996e-19, absmean=1.34093e-16, std=1.74514e-16; [ Info: Δv: min=-7.94503e-16, max=7.32053e-16, mean=1.62668e-19, absmean=1.30967e-16, std=1.70133e-16; [ Info: Δw: min=-2.21871e-15, max=2.4928e-15, mean=-4.54454e-18, absmean=2.67538e-16, std=4.09625e-16; [ Info: ΔT: min=-1.06581e-14, max=1.06581e-14, mean=-1.76661e-17, absmean=1.34445e-15, std=2.4561e-15; [ Info: ΔS: min=-2.13163e-14, max=2.13163e-14, mean=-9.38131e-17, absmean=2.61336e-15, std=4.82786e-15; Testing oceanic large eddy simulation regression [SmagorinskyLilly, CPU]; [ Info: Δu: min=-7.65013e-16, max=8.1532e-16, mean=-4.16382e-20, absmean=1.23114e-16, std=1.62955e-16; [ Info: Δv: min=-7.56339e-16, max=8.43076e-16, mean=-1.08495e-19, absmean=1.21821e-16, std=1.61572e-16; [ Info: Δw: min=-2.19616e-15, max=1.9585e-15, mean=6.95974e-18, absmean=2.40883e-16, std=3.76408e-16; [ Info: ΔT: min=-1.06581e-14, max=1.06581e-14, mean=-9.137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-544732689:1299,Test,Testing,1299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-544732689,1,['Test'],['Testing']
Testability,"9, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:12274,Test,Test,12274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Test'],['Test']
Testability,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:134,test,test,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632,1,['test'],['test']
Testability,"93167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.90",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:10638,Test,Test,10638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,['Test'],['Test']
Testability,94/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `57.14% <ø> (-28.58%)` | :arrow_down: |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tre,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:2086,test,test,2086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,2,['test'],['test']
Testability,"967717e-09, mean=+2.462280e-12, absmean=+1.480658e-10, std=+4.143014e-10 (16488/16512 matching grid points); [2023/02/21 06:38:00.744] INFO Δh: min=-4.767265e-07, max=+4.779508e-07, mean=+3.492460e-09, absmean=+2.039559e-07, std=+2.510841e-07 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation]: Test Failed at /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::VectorInvariantFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; [2023/02/21 06:38:01.335] INFO Testing shallow water Bickley jet simulation regression [GPU, ConservativeFormulation]; [2023/02/21 06:38:01.772] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:01.916] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /g/data/v45/nc3020/OC.jl/src/Advection/weno_fifth_order.jl:187; [2023/02/21 06:38:30.393] INF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:14244,test,test,14244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['test'],['test']
Testability,984?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [...undaryConditions/coordinate\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9jb29yZGluYXRlX2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `100.00% <ø> (+40.00%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `91.30% <93.75%> (+1.30%)` | :arrow_up: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `98.07% <100.00%> (+0.21%)` | :arrow_up: |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <100.00%> (-0.25%)` | :arrow_down: |; | [src/Simulations/simulation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3NpbXVsYXRpb24uamw=) | `68.75% <0.00%> (-6.25%)` | :arrow_down: |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `92.30% <0.00%> (+0.47%)` | :arrow_up: |; | [src/Buoyancy/seawater\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L3NlYXdhdGVyX2J1b3lhbmN5Lmps) | `74.07% <0.00%> (,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385:1945,test,test,1945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385,2,['test'],['test']
Testability,": /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:1214,test,test,1214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['test'],['test']
