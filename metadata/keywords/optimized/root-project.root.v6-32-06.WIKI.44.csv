quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"Tree::GetEntry. ; Reimplemented from TBranch.; Definition at line 2671 of file TBranchElement.cxx. ◆ GetExpectedType(). Int_t TBranchElement::GetExpectedType ; (; TClass *& ; clptr, . EDataType & ; type . ). overridevirtual . Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure. ; Reimplemented from TBranch.; Definition at line 2804 of file TBranchElement.cxx. ◆ GetFullName(). TString TBranchElement::GetFullName ; (; ); const. overridevirtual . Return the 'full' name of the branch. ; In particular prefix the mother's name when it does not end in a trailing dot and thus is not part of the branch name ; Reimplemented from TBranch.; Definition at line 2839 of file TBranchElement.cxx. ◆ GetIconName(). const char * TBranchElement::GetIconName ; (; ); const. overridevirtual . Return icon name depending on type of branch element. ; Reimplemented from TBranch.; Definition at line 2853 of file TBranchElement.cxx. ◆ GetID(). Int_t TBranchElement::GetID ; (; ); const. inline . Definition at line 195 of file TBranchElement.h. ◆ GetInfo(). TStreamerInfo * TBranchElement::GetInfo ; (; ); const. Get streamer info for the branch class. ; Definition at line 1024 of file TBranchElement.cxx. ◆ GetInfoImp(). TStreamerInfo * TBranchElement::GetInfoImp ; (; ); const. inlineprotected . Get streamer info for the branch class. ; Definition at line 1011 of file TBranchElement.cxx. ◆ GetMakeClass(). bool TBranchElement::GetMakeClass ; (; ); const. overridevirtual . Return whether this branch is in a mode where the object are decomposed or not (Also known as MakeClass mode). ; Reimplemented from TBranch.; Definition at line 2866 of file TBranchElement.cxx. ◆ GetMaximum(). Int_t TBranchElement::GetMaximum ; (; ); const. virtual . Return maximum count value of the branchcount if any. ; Definition at line 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:52978,depend,depending,52978,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['depend'],['depending']
Integrability,Tree; TTreeViewer A GUI oriented tree viewer; TUDPSocket This class implements UDP client sockets; TUUID Universally Unique IDentifier; TUnfold Unfolding with support for L-curve analysis; TUnfoldBinning Complex binning schemes for TUnfoldDensity; TUnfoldDensity Unfolding with densisty regularisation; TUnfoldSys Unfolding with support for systematic error propagation; TUnixSystem Interface to Unix OS services; TUnuran ; TUnuranBaseDist Base class for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> ; TVectorT<float> ; TView 3-D View abstract interface for 3-D views; TView3D 3-D View; TViewer3DPad A 3D Viewer painter for TPads; TViewerX3D Interface to the X3D viewer; TVirtualArray ; TVirtualAuth client auth interface; TVirtualBranchBrowsable Base class for helper objects used for browsing; TVirtualCollectionProxy ; TVirtualDragManager drag and drop manager; TVirtualFFT abstract interface for FFT calculations; TVirtualFitter Abstract interface for fitting; TVirtualGLManip Interface for GL manipulator; TVirtualGLPainter Interface for OpenGL painter; TVirtualGeoPainter Abstract interface for geometry painters; TVirtualGeoTrack virtual geometry tracks; TVirtualGraphPainter Abstract interface for histogram painters; TVirtualHistPainter Abstract interface for histogram painters; TVirtualIndex Abstract interface for Tree Index; TVirtualIsAProxy ; TVirtualMC Interface to Monte Carlo; TVirtualMCApplication Interface to MonteCarlo application; TVirtualMCDecayer Particle Decayer Base Class; TVirtualMCGeometry Interface to Monte Carlo geome,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:132106,interface,interface,132106,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['interface'],['interface']
Integrability,"TreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:214261,interface,interface,214261,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['interface'],['interface']
Integrability,"TreesTrue if Trees should not be merged (default is kFALSE); TFile*fOutputFilethe outputfile for merging; TStringfOutputFilenamethe name of the outputfile for merging; TStringfOutputFilename1the name of the temporary outputfile for merging; TStopwatchfWatchstop watch to measure file copy speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); Create file merger object. ~TFileMerger(); Cleanup. void Reset(); Reset merger file list. Bool_t AddFile(const char* url, Bool_t cpProgress = kTRUE); Add file to file merger. Bool_t OutputFile(const char* url); Open merger output file. void PrintFiles(Option_t* options); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist); Merge all objects in a directory; NB. This function is a copy of the hadd function MergeROOTFile. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}. » Author: Andreas Peters + Fons Rademakers 26/5/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TFileMerger.h 32130 2010-01-28 10:45:53Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileMerger.html:7670,interface,interface,7670,root/html528/TFileMerger.html,https://root.cern,https://root.cern/root/html528/TFileMerger.html,1,['interface'],['interface']
Integrability,"TrueType fonts are used. ; Reimplemented from TVirtualX. ◆ IconifyWindow(). void TGWin32VirtualXProxy::IconifyWindow ; (; Window_t ; id). overridevirtual . Iconifies the window ""id"". ; Reimplemented from TVirtualX. ◆ Init(). Bool_t TGWin32VirtualXProxy::Init ; (; void * ; display = nullptr). overridevirtual . Initializes the X system. ; Returns kFALSE in case of failure. It is implementation dependent. ; Reimplemented from TVirtualX. ◆ InitWindow(). Int_t TGWin32VirtualXProxy::InitWindow ; (; ULongptr_t ; window). overridevirtual . Creates a new window and return window number. ; Returns -1 if window initialization fails. ; Reimplemented from TVirtualX. ◆ InternAtom(). Atom_t TGWin32VirtualXProxy::InternAtom ; (; const char * ; atom_name, . Bool_t ; only_if_exist . ). overridevirtual . Returns the atom identifier associated with the specified ""atom_name"" string. ; If ""only_if_exists"" is False, the atom is created if it does not exist. If the atom name is not in the Host Portable Character Encoding, the result is implementation dependent. Uppercase and lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all designate different atoms. ; Reimplemented from TVirtualX. ◆ IntersectRegion(). void TGWin32VirtualXProxy::IntersectRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Computes the intersection of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX. ◆ IsCmdThread(). Bool_t TGWin32VirtualXProxy::IsCmdThread ; (; ); const. overridevirtual . Return kTRUE if we are inside cmd/server thread. ; Reimplemented from TVirtualX.; Definition at line 328 of file TGWin32VirtualXProxy.cxx. ◆ IsDNDAware(). Bool_t TGWin32VirtualXProxy::IsDNDAware ; (; Window_t ; win, . Atom_t * ; typelist . ). overridevirtual . Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:90999,depend,dependent,90999,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['depend'],['dependent']
Integrability,"Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no error occurred; 4420 if (notfound) {; 4421 SafeDelete(f);; 4422 // Save the arguments in the handler, so that a standard open can be; 4423 // attempted later on; 4424 fh = new TFileOpenHandle(name, option, ftitle, compress, netopt);; 4425 } else if (f) {; 4426 // Fill the opaque handler to be use to attach the file later on; 4427 fh = new TFileOpenHandle(f);; 4428 }; 4429 ; 4430 // Record this request; 4431 if (fh) {; 4432 // Create the lst, if not done already; 4433 if (!fgAsyncOpenRequests); 4434 fgAsyncOpenRequests = new TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asyn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:161376,message,messages,161376,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['message'],['messages']
Integrability,"TupleImporter object.; auto importer = RNTupleImporter::Create(kTreeFileName, kTreeName, kNTupleFileName);; ; // Begin importing.; importer->Import();; ; // Inspect the schema of the written RNTuple.; auto file = std::unique_ptr<TFile>(TFile::Open(kNTupleFileName));; if (!file || file->IsZombie()) {; std::cerr << ""cannot open "" << kNTupleFileName << std::endl;; return;; }; auto ntpl = std::unique_ptr<ROOT::RNTuple>(file->Get<ROOT::RNTuple>(""Events""));; auto reader = RNTupleReader::Open(*ntpl);; reader->PrintInfo();; ; ROOT::RDataFrame df(""Events"", kNTupleFileName);; df.Histo1D({""Jet_pt"", ""Jet_pt"", 100, 0, 0}, ""Jet_pt"")->DrawCopy();; }; RNTupleDS.hxx; RNTupleImporter.hxx; RNTupleReader.hxx; RPageStorageFile.hxx; TFile.h; TROOT.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::Experimental::RNTupleImporterConverts a TTree into an RNTuple.Definition RNTupleImporter.hxx:103; ROOT::Experimental::RNTupleReaderAn RNTuple that is used to read data from storage.Definition RNTupleReader.hxx:71; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; DateDecember 2022 ; AuthorThe ROOT Team ; Definition in file ntpl008_import.C. tutorialsv7ntuplentpl008_import.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ntpl008__import_8C.html:2579,interface,interface,2579,doc/master/ntpl008__import_8C.html,https://root.cern,https://root.cern/doc/master/ntpl008__import_8C.html,1,['interface'],['interface']
Integrability,"Tutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of Gaussians for all dimensions; gaussians = []; for j in range(n_dimensions):; gaussian = ROOT.RooGaussian(f""gdim{j}"", f""gdim{j}"", x_vars[j], mu_helps[j], sigmas[j]); gaussians.append(gaussian); ; # Create a product PDF for the multidi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:1284,message,messages,1284,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['message'],['messages']
Integrability,"Type == ""DENSE"") {; 558 ParseDenseLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 559 } else if (strLayerType == ""CONV"") {; 560 ParseConvLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 561 } else if (strLayerType == ""MAXPOOL"") {; 562 ParseMaxPoolLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 563 } else if (strLayerType == ""RESHAPE"") {; 564 ParseReshapeLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 565 } else if (strLayerType == ""BNORM"") {; 566 ParseBatchNormLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 567 } else if (strLayerType == ""RNN"") {; 568 ParseRecurrentLayer(kLayerRNN, deepNet, nets, layerString->GetString(), subDelimiter);; 569 } else if (strLayerType == ""LSTM"") {; 570 ParseRecurrentLayer(kLayerLSTM, deepNet, nets, layerString->GetString(), subDelimiter);; 571 } else if (strLayerType == ""GRU"") {; 572 ParseRecurrentLayer(kLayerGRU, deepNet, nets, layerString->GetString(), subDelimiter);; 573 } else {; 574 // no type of layer specified - assume is dense layer as in old DNN interface; 575 ParseDenseLayer(deepNet, nets, layerString->GetString(), subDelimiter);; 576 }; 577 }; 578}; 579 ; 580////////////////////////////////////////////////////////////////////////////////; 581/// Pases the layer string and creates the appropriate dense layer; 582template <typename Architecture_t, typename Layer_t>; 583void MethodDL::ParseDenseLayer(DNN::TDeepNet<Architecture_t, Layer_t> &deepNet,; 584 std::vector<DNN::TDeepNet<Architecture_t, Layer_t>> & /*nets*/, TString layerString,; 585 TString delim); 586{; 587 int width = 0;; 588 EActivationFunction activationFunction = EActivationFunction::kTanh;; 589 ; 590 // this return number of input variables for the method; 591 // it can be used to deduce width of dense layer if specified as N+10; 592 // where N is the number of input variables; 593 const size_t inputSize = GetNvar();; 594 ; 595 // Split layer details; 596 TObjArray *subStrings = layerString.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:22422,interface,interface,22422,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['interface'],['interface']
Integrability,"Type< vec, gen >;  ; class  AlgebraicProdType< vec, sym >;  ; class  AlgebraicSumType;  ; class  AlgebraicSumType< gen, vec >;  ; class  AlgebraicSumType< sym, vec >;  ; class  AlgebraicSumType< T, T >;  ; class  AlgebraicSumType< vec, gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliGradientCalculator;  Fumili gradient calculator using exte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html:1693,wrap,wrapped,1693,doc/v632/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Minuit2.html,1,['wrap'],['wrapped']
Integrability,"Type< vec, gen >;  ; class  AlgebraicProdType< vec, sym >;  ; class  AlgebraicSumType;  ; class  AlgebraicSumType< gen, vec >;  ; class  AlgebraicSumType< sym, vec >;  ; class  AlgebraicSumType< T, T >;  ; class  AlgebraicSumType< vec, gen >;  ; class  AlgebraicSumType< vec, sym >;  ; class  AnalyticalGradientCalculator;  ; class  BFGSErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; class  BFGSMinimizerType;  ; class  CombinedMinimizer;  Combined minimizer: combination of Migrad and Simplex. More...;  ; class  CombinedMinimumBuilder;  ; class  ContoursError;  ; class  DavidonErrorUpdator;  Update of the covariance matrix for the Variable Metric minimizer (MIGRAD) More...;  ; struct  DerivatorElement;  ; class  ExternalInternalGradientCalculator;  Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator supplies Minuit with an externally calculated gradient. More...;  ; class  FCNAdapter;  template wrapped class for adapting to FCNBase signature More...;  ; class  FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  FCNGradAdapter;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  FCNGradientBase;  Extension of the FCNBase for providing the analytical Gradient of the function. More...;  ; class  FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  FumiliFCNAdapter;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  FumiliFCNBase;  Extension of the FCNBase for the Fumili m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:1694,wrap,wrapped,1694,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,1,['wrap'],['wrapped']
Integrability,"Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kLogLikelihood; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kUndefined. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:5342,interface,interface,5342,root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,1,['interface'],['interface']
Integrability,"TypedefInfo_t*fInfopointer to CINT typedef info; Long_tfPropertyThe property information for the (potential) underlying class; Int_tfSizesize of type; TStringfTrueNameTrue name of the (potential) underlying class ; EDataTypefTypetype id. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataType(TypedefInfo_t* info = 0); Default TDataType ctor. TDataTypes are constructed in TROOT via; a call to TCint::UpdateListOfTypes(). TDataType(const char* typenam); Constructor for basic data types, like ""char"", ""unsigned char"", etc. TDataType(const TDataType& ); copy constructor. TDataType& operator=(const TDataType& ); assignement operator. ~TDataType(); TDataType dtor deletes adopted CINT TypedefInfo object. const char * GetTypeName(EDataType type); Return the name of the type. const char * GetTypeName() const; Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of typedef, e,g.: ""class TDirectory*"". EDataType GetType(const type_info& typeinfo); Set type id depending on name. const char * AsString(void* buf) const; Return string containing value in buffer formatted according to; the basic data type. The result needs to be used or copied immediately. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void SetType(const char* name); Set type id depending on name. Int_t Size() const; Get size of basic typedef'ed type. void CheckInfo(); Refresh the underlying information. Int_t GetType() const; { return (Int_t)fType; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataType.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2010-09-23 20:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataType.html:7210,depend,depending,7210,root/html528/TDataType.html,https://root.cern,https://root.cern/root/html528/TDataType.html,2,['depend'],['depending']
Integrability,"TypedefInfo_t*fInfopointer to CINT typedef info; Long_tfPropertyThe property information for the (potential) underlying class; Int_tfSizesize of type; TStringfTrueNameTrue name of the (potential) underlying class ; EDataTypefTypetype id. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataType(TypedefInfo_t* info = 0); Default TDataType ctor. TDataTypes are constructed in TROOT via; a call to TCint::UpdateListOfTypes(). TDataType(const char* typenam); Constructor for basic data types, like ""char"", ""unsigned char"", etc. TDataType(const TDataType& ); copy constructor. TDataType& operator=(const TDataType& ); assignement operator. ~TDataType(); TDataType dtor deletes adopted CINT TypedefInfo object. const char * GetTypeName(EDataType type); Return the name of the type. const char * GetTypeName() const; Get basic type of typedef, e,g.: ""class TDirectory*"" -> ""TDirectory"".; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of typedef, e,g.: ""class TDirectory*"". EDataType GetType(const type_info& typeinfo); Set type id depending on name. const char * AsString(void* buf) const; Return string containing value in buffer formatted according to; the basic data type. The result needs to be used or copied immediately. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void SetType(const char* name); Set type id depending on name. Int_t Size() const; Get size of basic typedef'ed type. void CheckInfo(); Refresh the underlying information. Int_t GetType() const; { return (Int_t)fType; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TDataType.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TDataType.html:7279,depend,depending,7279,root/html530/TDataType.html,https://root.cern,https://root.cern/root/html530/TDataType.html,2,['depend'],['depending']
Integrability,"U ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsOptTestStatistic::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooChi2Var.html:18255,message,message,18255,root/html528/RooChi2Var.html,https://root.cern,https://root.cern/root/html528/RooChi2Var.html,4,['message'],['message']
Integrability,"U ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:17388,message,message,17388,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,2,['message'],['message']
Integrability,"U:Layout=TANH|100,TANH|50,TANH|10,LINEAR:TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Architecture=GPU:Layout=TANH|100,TANH|50,TANH|10,LINEAR:TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|100,TANH|50,TANH|10,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""GPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:5058,message,message,5058,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['message'],['message']
Integrability,"UE); Create structure to store sum of squares of weights. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before.; If flag = false the structure is deleted. TF1 * GetFunction(const char* name) const; Return pointer to function with name. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; Return value of error associated to bin number bin. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. Double_t GetBinErrorLow(Int_t bin) const; Return lower error associated to bin number bin. The error will depend on the statistic option used will return; the binContent - lower interval value. Double_t GetBinErrorUp(Int_t bin) const; Return upper error associated to bin number bin. The error will depend on the statistic option used will return; the binContent - upper interval value. Double_t GetBinCenter(Int_t bin) const; return bin center for 1D historam; Better to use h1.GetXaxis().GetBinCenter(bin). Double_t GetBinLowEdge(Int_t bin) const; return bin lower edge for 1D historam; Better to use h1.GetXaxis().GetBinLowEdge(bin). Double_t GetBinWidth(Int_t bin) const; return bin width for 1D historam; Better to use h1.GetXaxis().GetBinWidth(bin). void GetCenter(Double_t* center) const; Fill array with center of bins for 1D histogram; Better to use h1.GetXaxis().GetCenter(center). void GetLowEdge(Double_t* edge) const; Fill array with low edge of bins for 1D histogram; Better to use h1.GetXaxis().GetLowEdge(edge). void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:128200,depend,depend,128200,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['depend'],['depend']
Integrability,"UE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; Bool_t fActive;  true if active ;  ; FontStruct_t fFontStruct;  font ;  ; GContext_t fNormGC;  entry drawing context ;  ; TGString * fPath;  entry path ;  ; const TGPicture * fPic;  entry picture ;  ; TGSelectedPicture * fSelPic;  selected picture ;  ; TGString * fText;  entry description ;  ; UInt_t fTHeight;  height of entry text ;  ; UInt_t fTWidth;  width of entry text ;  ;  Protected Attributes inherited from TGLBEntry; Bool_t fActive;  true if entry is active ;  ; Pixel_t fBkcolor;  entry background color ;  ; Int_t fEntryId;  message id of listbox entry ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTreeLBEntry.html:24147,message,message,24147,doc/master/classTGTreeLBEntry.html,https://root.cern,https://root.cern/doc/master/classTGTreeLBEntry.html,1,['message'],['message']
Integrability,"UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:3622,depend,dependsOnValue,3622,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,4,['depend'],['dependsOnValue']
Integrability,"UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorDialog(const TGWindow* p = 0, const TGWindow* m = 0, Int_t* retc = 0, Pixel_t* color = 0, Bool_t wait = kTRUE); Color selection dialog constructor.; The TGColorDialog presents a full featured color selection dialog.; It uses 2 TGColorPalette's and the TGColorPick widgets. ~TGColorDialog(); TGColorDialog destructor. void SetCurrentColor(Pixel_t col); Change current color. void ColorSelected(Pixel_t ); Emit signal about selected color. void AlphaColorSelected(ULong_t ); Emit signal about selected alpha and color. void CloseWindow(); Called when window is closed via window manager. void UpdateAlpha(Pixel_t* c); Upadate Opacity text entry with alpha value of color c. void UpdateRGBentries(Pixel_t* c); Update RGB text entries with RGB values of color c. void UpdateHLSentries(Pixel_t* c); Update HLS text entries with HLS values of color c. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for the color selection dialog. void SetColorInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Set the color info in RGB and HLS parts. void DoPreview(); Slot method called when Preview button is clicked. TGColorPalette& operator=(const TGColorDialog& ). TGColorDialog(const TGColorDialog& ). TGColorPalette * GetPalette() const; { return fPalette; }. TGColorPalette * GetCustomPalette() const; { return fCpalette; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGColorDialog.html:24787,message,messages,24787,root/html534/TGColorDialog.html,https://root.cern,https://root.cern/root/html534/TGColorDialog.html,1,['message'],['messages']
Integrability,"ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Attributes inherited from TGWin32ProxyBase; static ULong_t fgMainThreadId = 0;  main thread ID ;  ; static ULong_t fgPingMessageId = 0;  ping message ID ;  ; static ULong_t fgPostMessageId = 0;  post message ID ;  ; static ULong_t fgUserThreadId = 0;  user (e.g. python) thread ID ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGWin32ProxyBase; virtual Bool_t ForwardCallBack (Bool_t sync);  if sync is kTRUE: ;  ; virtual void SendExitMessage ();  send exit message to server thread ;  ;  Protected Attributes inherited from TVirtualX; EDrawMode fDrawMode;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  ;  Protected Attributes inherited from TAttText; Short_t fTextAlign;  Text alignment. ;  ; Float_t fTextAngle;  Text angle. ;  ; Color_t fTextColor;  Text color. ;  ; Font_t fTextFont;  Text font. ;  ; Float_t fTextSize;  Text size. ;  ;  Protected Attributes inherited from TAttMarker; Color_t fMarkerColor;  Marker color. ;  ; Size_t fMarkerSize;  Marker size. ;  ; Style_t fMarkerStyle;  Marker style. ;  ;  Protected Attributes inherited from TGWin32ProxyBase; Int_t fBatchLimit;  batch limit ;  ; TGWin32CallBack fCallBack;  callback function (execu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:50369,message,message,50369,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['message'],['message']
Integrability,"ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TServerSocket (const char *service, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object for a named service. ;  ;  TServerSocket (Int_t port, Bool_t reuse=kFALSE, Int_t backlog=kDefaultBacklog, Int_t tcpwindowsize=-1);  Create a server socket object on a specified port. ;  ; virtual ~TServerSocket ();  Destructor: cleanup authentication stuff (if any) and close. ;  ; virtual TSocket * Accept (UChar_t Opt=0);  Accept a connection on a server socket. ;  ; TInetAddress GetLocalInetAddress () override;  Return internet address of host to which the server socket is bound, i.e. ;  ; Int_t GetLocalPort () override;  Get port # to which server socket is bound. In case of error returns -1. ;  ; TClass * IsA () const override;  ; Int_t Recv (char *, Int_t) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *, Int_t, Int_t &) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &, Int_t &) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *, Int_t, ESendRecvOptions=kDefault) override;  Receive a raw buffer of specified length bytes. ;  ; Int_t Send (const char *, Int_t=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Send (const TMessage &) override;  Send a TMessage object. ;  ; Int_t Send (Int_t) override;  Send a single message opcode. ;  ; Int_t Send (Int_t, Int_t) override;  Send a status and a single message opcode. ;  ; Int_t SendObject (const TObject *, Int_t=kMESS_OBJECT) override;  Send an object. ;  ; Int_t SendRaw (const void *, Int_t, ESendRecvOptions=kDefault) override;  Send a raw buffer of specified length. ;  ; void Streamer (TBuffer &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:2197,message,message,2197,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['message'],['message']
Integrability,"ULL);; 3312 if (tm != NULL) {; 3313#else; 3314 struct tm _tm;; 3315 struct tm *tm = &_tm;; 3316 ; 3317 if (t != NULL) {; 3318 gmtime_r(t, tm);; 3319#endif; 3320 strftime(buf, buf_len, ""%a, %d %b %Y %H:%M:%S GMT"", tm);; 3321 } else {; 3322 mg_strlcpy(buf, ""Thu, 01 Jan 1970 00:00:00 GMT"", buf_len);; 3323 buf[buf_len - 1] = '\0';; 3324 }; 3325}; 3326 ; 3327 ; 3328/* difftime for struct timespec. Return value is in seconds. */; 3329static double; 3330mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before); 3331{; 3332 return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9; 3333 + (double)(ts_now->tv_sec - ts_before->tv_sec);; 3334}; 3335 ; 3336 ; 3337#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl); 3338static void mg_cry_internal_impl(const struct mg_connection *conn,; 3339 const char *func,; 3340 unsigned line,; 3341 const char *fmt,; 3342 va_list ap);; 3343#include ""external_mg_cry_internal_impl.inl""; 3344#elif !defined(NO_FILESYSTEMS); 3345 ; 3346/* Print error message to the opened error log stream. */; 3347static void; 3348mg_cry_internal_impl(const struct mg_connection *conn,; 3349 const char *func,; 3350 unsigned line,; 3351 const char *fmt,; 3352 va_list ap); 3353{; 3354 char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];; 3355 struct mg_file fi;; 3356 time_t timestamp;; 3357 ; 3358 /* Unused, in the RELEASE build */; 3359 (void)func;; 3360 (void)line;; 3361 ; 3362#if defined(GCC_DIAGNOSTIC); 3363#pragma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:99663,message,message,99663,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['message']
Integrability,"ULL);; 3313 if (tm != NULL) {; 3314#else; 3315 struct tm _tm;; 3316 struct tm *tm = &_tm;; 3317 ; 3318 if (t != NULL) {; 3319 gmtime_r(t, tm);; 3320#endif; 3321 strftime(buf, buf_len, ""%a, %d %b %Y %H:%M:%S GMT"", tm);; 3322 } else {; 3323 mg_strlcpy(buf, ""Thu, 01 Jan 1970 00:00:00 GMT"", buf_len);; 3324 buf[buf_len - 1] = '\0';; 3325 }; 3326}; 3327 ; 3328 ; 3329/* difftime for struct timespec. Return value is in seconds. */; 3330static double; 3331mg_difftimespec(const struct timespec *ts_now, const struct timespec *ts_before); 3332{; 3333 return (double)(ts_now->tv_nsec - ts_before->tv_nsec) * 1.0E-9; 3334 + (double)(ts_now->tv_sec - ts_before->tv_sec);; 3335}; 3336 ; 3337 ; 3338#if defined(MG_EXTERNAL_FUNCTION_mg_cry_internal_impl); 3339static void mg_cry_internal_impl(const struct mg_connection *conn,; 3340 const char *func,; 3341 unsigned line,; 3342 const char *fmt,; 3343 va_list ap);; 3344#include ""external_mg_cry_internal_impl.inl""; 3345#elif !defined(NO_FILESYSTEMS); 3346 ; 3347/* Print error message to the opened error log stream. */; 3348static void; 3349mg_cry_internal_impl(const struct mg_connection *conn,; 3350 const char *func,; 3351 unsigned line,; 3352 const char *fmt,; 3353 va_list ap); 3354{; 3355 char buf[MG_BUF_LEN], src_addr[IP_ADDR_STR_LEN];; 3356 struct mg_file fi;; 3357 time_t timestamp;; 3358 ; 3359 /* Unused, in the RELEASE build */; 3360 (void)func;; 3361 (void)line;; 3362 ; 3363#if defined(GCC_DIAGNOSTIC); 3364#pragma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:99695,message,message,99695,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['message']
Integrability,"ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback)Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's ...Definition RResultPtr.hxx:364; ROOT::RDF::RResultPtr::operator=RResultPtr & operator=(RResultPtr &&)=default; ROOT::RDF::RResultPtr::operator==friend bool operator==(const RResultPtr< T1 > &lhs, const RResultPtr< T2 > &rhs)Definition RResultPtr.hxx:401; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(const RResultPtr< T2 > &r)Convert a RResultPtr<T2> to a RResultPtr<T>.Definition RResultPtr.hxx:222; ROOT::RDF::RResultPtr::fActionPtrstd::shared_ptr< RDFInternal::RActionBase > fActionPtrOwning pointer to the action that will produce this result.Definition RResultPtr.hxx:178; ROOT::RDF::RResultPtr::SPT_tstd::shared_ptr< T > SPT_tDefinition RResultPtr.hxx:121; ROOT::RDF::RResultPtr::operator->T * operator->()Get a pointer to the encapsulated object.Definition RResultPtr.hxx:249; ROOT::RDF::RResultPtr::fObjPtrSPT_t fObjPtrShared pointer encapsulating the wrapped result.Definition RResultPtr.hxx:175; ROOT::RDF::RResultPtr::kOncestatic constexpr ULong64_t kOnceConvenience definition to express a callback must be executed once.Definition RResultPtr.hxx:207; ROOT::RDF::RResultPtr::RResultPtrRResultPtr(std::shared_ptr< T > objPtr, RDFDetail::RLoopManager *lm, std::shared_ptr< RDFInternal::RActionBase > actionPtr)Definition RResultPtr.hxx:199; ROOT::RDF::RResultPtr::endRIterationHelper< T >::Iterator_t end()Return an iterator to the end of the contained object if this makes sense, throw a compilation error ...Definition RResultPtr.hxx:267; bool; T2#define T2Definition md5.inl:147; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80; ROOT::Detail::RDF::GetMergeableValuestd::unique_ptr< RMergeableVariations< T > > GetMergeableValue(ROOT::RDF::Experimental::RResultMap< T > &rmap)Retrieve mergeable values after calling ROOT::RDF::VariationsFor .Definition RResultMap.hxx:211; ROOT::Detail::RDF::MakeResultPtrRResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:25481,wrap,wrapped,25481,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['wrap'],['wrapped']
Integrability,"UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via rootd daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:26545,message,message,26545,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,6,['message'],['message']
Integrability,"URL has been visited before or not. ;  ; SHtmlTokenMap_t * GetMarkupMap (int n);  Returns token map at location n. ;  ; const char * GetPctWidth (TGHtmlElement *p, char *opt, char *ret);  Return the height and width, converting to percent if required ret must be at least 16 characters long. ;  ; const char * GetUid (const char *string);  Given a string, this procedure returns a unique identifier for the string. ;  ; void HClear ();  Erase all data from the HTML widget. Bring it back to an empty screen. ;  ; void ImageChanged (TGHtmlImage *image, int newWidth, int newHeight);  This routine is called when an image changes. ;  ; int IndexMod (TGHtmlElement **pp, int *ip, char *cp);  Modify an index for both pointer and char +/-/=N. ;  ; void IndexToBlockIndex (SHtmlIndex_t sIndex, TGHtmlBlock **ppBlock, int *piIndex);  Convert an Element-based index into a Block-based index. ;  ; TGHtmlElement * InsertToken (TGHtmlElement *pToken, char *zType, char *zArgs, int offs);  This routine takes a text representation of a token, converts it into an TGHtmlElement object and inserts it immediately prior to pToken. ;  ; int IsDarkColor (ColorStruct_t *p);  Check to see if the given color is too dark to be easily distinguished from black. ;  ; int IsLightColor (ColorStruct_t *p);  Check to see if the given color is too light to be easily distinguished from white. ;  ; void LayoutDoc ();  Advance the layout as far as possible. ;  ; void LostSelection ();  Clear selection. ;  ; void MakeInvisible (TGHtmlElement *p_first, TGHtmlElement *p_last);  Add the STY_Invisible style to every token between p_first and p_last. ;  ; TGHtmlMarkupElement * MakeMarkupEntry (int objType, int type, int argc, int arglen[], char *argv[]);  Make one markup entry. ;  ; int MapControls ();  Map any control that should be visible according to the current scroll position. ;  ; void MaxIndex (TGHtmlElement *p, int *pIndex, int isLast);  Find the maximum index for the given token. ;  ; TGHtmlElement * MinMax (T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:33628,rout,routine,33628,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['rout'],['routine']
Integrability,"USER"" - dummy - see documentation. int Pycomp(int kf); interface with fortran routine pycomp. void Pyedit(int medit); interface with fortran routine pyedit. void Pydiff(); interface with fortran routine pydiff. void Pyevnt(); interface with fortran routine pyevnt. void Pyexec(); interface with fortran routine pyexec. void Pygive(const char* param); interface with fortran routine pygive. void Pyhepc(int mconv); interface with fortran routine pyhepc. void Pylist(int flag); interface with fortran routine pylist. void Pyname(int kf, char* name); Note that the array name must be dimensioned in the calling program; to at least name[16]. double Pyr(int idummy); interface with fortran routine pyr. void Pyrget(int lun, int move); interface with fortran routine pyrget. void Pyrset(int lun, int move); interface with fortran routine pyrset. void Pystat(int flag); interface with fortran routine pystat. void Pytest(int flag); interface with fortran routine pytest. void Pyupda(int mupda, int lun); interface with fortran routine pyupda. double Pymass(int kf); interface with fortran routine pymass. int Pychge(int kf); interface with fortran routine pychge. void Py1ent(Int_t line, Int_t kf, Double_t pe, Double_t theta, Double_t phi); Add one entry to the event record, i.e. either a parton or a; particle. IP: normally line number for the parton/particle. There are two; exceptions:. If IP = 0: line number 1 is used and PYEXEC is called.; If IP < 0: line -IP is used, with status code K(-IP,2)=2; rather than 1; thus a parton system may be built; up by filling all but the last parton of the; system with IP < 0.; KF: parton/particle flavour code (PDG code); PE: parton/particle energy. If PE is smaller than the mass,; the parton/particle is taken to be at rest.; THETA:; PHI: polar and azimuthal angle for the momentum vector of the; parton/particle. void SetupTest(); Exemplary setup of Pythia parameters:; Switches on processes 102,123,124 (Higgs generation) and switches off; interactions, fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPythia6.html:16406,interface,interface,16406,root/html532/TPythia6.html,https://root.cern,https://root.cern/root/html532/TPythia6.html,2,"['interface', 'rout']","['interface', 'routine']"
Integrability,"UUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions; virtual ~TSQLServer ();  ; virtual void Close (Option_t *option="""")=0;  ; virtual Bool_t Commit ();  submit ""COMMIT"" query to database return kTRUE, if successful ;  ; virtual Int_t CreateDataBase (const char *dbname)=0;  ; virtual Int_t DropDataBase (const char *dbname)=0;  ; virtual void EnableErrorOutput (Bool_t on=kTRUE);  ; virtual Bool_t Exec (const char *sql);  Execute sql query. ;  ; virtual TSQLResult * GetColumns (const char *dbname, const char *table, const char *wild=nullptr)=0;  ; virtual TSQLResult * GetDataBases (const char *wild=nullptr)=0;  ; const char * GetDB () const;  ; const char * GetDBMS () const;  ; virtual Int_t GetErrorCode () const;  returns error code of last operation if res==0, no error Each specific implementation of TSQLServer provides its own error coding ;  ; virtual const char * GetErrorMsg () const;  returns error message of last operation if no errors, return 0 Each specific implementation of TSQLServer provides its own error messages ;  ; const char * GetHost () const;  ; virtual Int_t GetMaxIdentifierLength ();  ; Int_t GetPort () const;  ; virtual TSQLTableInfo * GetTableInfo (const char *tablename);  Produce TSQLTableInfo object, which contain info about table itself and each table column Object must be deleted by user. ;  ; virtual TSQLResult * GetTables (const char *dbname, const char *wild=nullptr)=0;  ; virtual TList * GetTablesList (const char *wild=nullptr);  Return list of user tables Parameter wild specifies wildcard for table names. ;  ; virtual Bool_t HasStatement () const;  ; virtual Bool_t HasTable (const char *tablename);  Tests if table of that name exists in database Return kTRUE, if table exists. ;  ; virtual Bool_t HasTransactionInFlight ();  returns kTRUE when transaction is running Must be implemented in derived classes ;  ; TClass * IsA () con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLServer.html:2247,message,message,2247,doc/master/classTSQLServer.html,https://root.cern,https://root.cern/doc/master/classTSQLServer.html,2,['message'],"['message', 'messages']"
Integrability,"UUID.h. ◆ FillBuffer(). void TUUID::FillBuffer ; (; char *& ; buffer). Stream UUID into output buffer. ; Definition at line 275 of file TUUID.cxx. ◆ Format(). void TUUID::Format ; (; UShort_t ; clockseq, . uuid_time_t ; ts . ). protected . Make a UUID from timestamp, clockseq and node id. ; Definition at line 324 of file TUUID.cxx. ◆ GetCurrentTime(). void TUUID::GetCurrentTime ; (; uuid_time_t * ; timestamp). protected . Get current time as 60 bit 100ns ticks since whenever. ; Compensate for the fact that real clock resolution is less than 100ns. ; Definition at line 341 of file TUUID.cxx. ◆ GetHostAddress(). TInetAddress TUUID::GetHostAddress ; (; ); const. Get address of host encoded in UUID. ; If host id is not an ethernet address, but random info, then the returned TInetAddress is not valid. ; Definition at line 657 of file TUUID.cxx. ◆ GetNodeIdentifier(). void TUUID::GetNodeIdentifier ; (; ). protected . Get node identifier. ; Try first to get network address, if no network interface try random info based on some machine parameters. ; Definition at line 426 of file TUUID.cxx. ◆ GetRandomInfo(). void TUUID::GetRandomInfo ; (; UChar_t ; seed[16]). protected . Get random info based on some machine parameters. ; Definition at line 511 of file TUUID.cxx. ◆ GetSystemTime(). void TUUID::GetSystemTime ; (; uuid_time_t * ; timestamp). protected . Get system time with 100ns precision. Time is since Oct 15, 1582. ; Definition at line 393 of file TUUID.cxx. ◆ GetTime(). TDatime TUUID::GetTime ; (; ); const. Get time from UUID. ; Definition at line 670 of file TUUID.cxx. ◆ GetUUID(). void TUUID::GetUUID ; (; UChar_t ; uuid[16]); const. Return uuid in specified buffer (16 byte = 128 bits). ; Definition at line 695 of file TUUID.cxx. ◆ GetUUIDNumber(). UInt_t TUUID::GetUUIDNumber ; (; ); const. inline . Definition at line 79 of file TUUID.h. ◆ Hash(). UShort_t TUUID::Hash ; (; ); const. Compute 16-bit hash value of the UUID. ; Definition at line 586 of file TUUID.cxx. ◆ IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUUID.html:9642,interface,interface,9642,doc/master/classTUUID.html,https://root.cern,https://root.cern/doc/master/classTUUID.html,1,['interface'],['interface']
Integrability,"UnBinData (unsigned int n, const double *dataX, const double *dataY, bool isWeighted=false);  constructor for 2D external data (data are not copied inside) or 1D data with a weight (if isWeighted = true) ;  ;  UnBinData (unsigned int n, const double *dataX, const double *dataY, const double *dataZ, bool isWeighted=false);  constructor for 3D external data (data are not copied inside) or 2D data with a weight (if isWeighted = true) ;  ; template<class Iterator > ;  UnBinData (unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false);  constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of a list (or vector) containing the const double * of the data An example could be the std::vector<const double *>::begin In case of weighted data, the external data must have a dim+1 lists of data The passed dim refers just to the coordinate size ;  ;  ~UnBinData () override;  destructor, delete pointer to internal data or external data wrapper ;  ; void Add (const double *x);  add multi-dim coordinate data ;  ; void Add (const double *x, double w);  add multi-dim coordinate data + weight ;  ; void Add (double x);  add one dim coordinate data (unweighted) ;  ; void Add (double x, double y);  add 2-dim coordinate data can also be used to add 1-dim data with a weight ;  ; void Add (double x, double y, double z);  add 3-dim coordinate data can also be used to add 2-dim data with a weight ;  ; void Append (unsigned int newPoints, unsigned int dim=1, bool isWeighted=false);  ; bool IsWeighted () const;  ; unsigned int NDim () const;  return coordinate data dimension ;  ; UnBinData & operator= (const UnBinData &);  assignment operator ;  ; double Weight (unsigned int ipoint) const;  return weight ;  ; const double * WeightsPtr (unsigned int ipoint) const;  ;  Public Member Functions inherited from ROOT::Fit::FitData;  FitData (const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1);  constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html:4078,wrap,wrapper,4078,doc/master/classROOT_1_1Fit_1_1UnBinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html,1,['wrap'],['wrapper']
Integrability,"Uniform () const;  ; virtual double lowBound () const =0;  ; virtual RooAbsReal * lowBoundFunc () const;  Return pointer to RooAbsReal parameterized lower bound, if any. ;  ; Int_t numBins () const;  Return number of bins. ;  ; virtual Int_t numBoundaries () const =0;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printArgs (std::ostream &os) const override;  Print binning arguments (the RooAbsReal objects represening the variable bin boundaries for parameterized binning implementations. ;  ; void printClassName (std::ostream &os) const override;  Print binning class name. ;  ; void printName (std::ostream &os) const override;  Print binning name. ;  ; void printTitle (std::ostream &os) const override;  Print binning title. ;  ; void printValue (std::ostream &os) const override;  Print binning value, i.e the bin boundary positions. ;  ; virtual void removeHook (RooAbsRealLValue &) const;  Hook interface function to execute code upon removal from a RooAbsRealLValue. ;  ; virtual void setMax (double xhi);  Change upper bound to xhi. ;  ; virtual void setMin (double xlo);  Change lower bound to xlo. ;  ; virtual void setRange (double xlo, double xhi)=0;  ; void Streamer (TBuffer &) override;  Custom streamer implementing schema evolution between V1 and V2 persistent binnings. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsBinning.html:2853,interface,interface,2853,doc/master/classRooAbsBinning.html,https://root.cern,https://root.cern/doc/master/classRooAbsBinning.html,1,['interface'],['interface']
Integrability,"Unit for objects value; Bool_t_useWindowSwitch to activate window convolution; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Int_t_verboseThreshCall count threshold for verbose printing; RooListProxy_windowParamHolder for optional convolution integration window scaling parameter; Double_t_windowScaleScale factor for window parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumConvolution(). RooNumConvolution(const char* name, const char* title, RooRealVar& convVar, RooAbsReal& pdf, RooAbsReal& resmodel, const RooNumConvolution* proto = 0); Constructor of convolution operator PDF. convVar : convolution variable (on which both pdf and resmodel should depend); pdf : input 'physics' pdf; resmodel : input 'resultion' pdf. output is pdf(x) (X) resmodel(x) = Int [ pdf(x') resmodel (x-x') ] dx'. RooNumConvolution(const RooNumConvolution& other, const char* name = 0); Copy constructor. void initialize() const; One-time initialization of object. ~RooNumConvolution(); Destructor. Double_t evaluate() const; Calculate convolution integral. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. void clearConvolutionWindow(); Removes previously defined convolution window, reverting to convolution from -inf to +inf. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); Restrict convolution integral to finite range [ x - C - S*W, x - C + S*W ]; where x is current value of convolution variablem, C = centerPara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:36359,depend,depend,36359,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,7,['depend'],['depend']
Integrability,"Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfFunctions.cxx:409; TListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information.Definition TListOfTypes.h:31; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMacOSXSystemDefinition TMacOSXSystem.h:39; TMessageHandlerHandle messages that might be generated by the system.Definition TMessageHandler.h:34; TMessageHandler::HandleMessagevirtual void HandleMessage(Long_t id, const TObject *obj)Store message origin, keep statistics and call Notify().Definition TMessageHandler.cxx:133; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:140752,message,message,140752,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['message'],['message']
Integrability,"Unloadvoid Unload()Mark 'all func' as being unloaded.Definition TListOfFunctions.cxx:409; TListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information.Definition TListOfTypes.h:31; TListA doubly linked list.Definition TList.h:38; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AddLastvoid AddLast(TObject *obj) overrideAdd object at the end of the list.Definition TList.cxx:150; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMacOSXSystemDefinition TMacOSXSystem.h:39; TMessageHandlerHandle messages that might be generated by the system.Definition TMessageHandler.h:34; TMessageHandler::HandleMessagevirtual void HandleMessage(Long_t id, const TObject *obj)Store message origin, keep statistics and call Notify().Definition TMessageHandler.cxx:133; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1074; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:140928,message,message,140928,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['message'],['message']
Integrability,"Unused, not instantiatable. Only the partial specialization RActionCRTP<RAction<...>> can be used ;  CRActionCRTP< RAction< Helper, PrevDataFrame, ColumnTypes_t > >A common template base class for all RActions ;  CRBookedCustomColumnsEncapsulates the columns defined by the user ;  CRDisplayElementHelper class to let Display print compact tabular representations of the events ;  CRJittedAction;  CRSlotStackThis is an helper class to allow to pick a slot resorting to a map indexed by thread ids ;  CRTypeErasedColumnValueA type-erasing wrapper around RColumnValue ;  CSnapshotHelper;  CSnapshotHelperMT;  CTRDFValueTuple;  CTRDFValueTuple< TypeList< BranchTypes... > >;  CTReaderValueOrArrayChoose between TTreeReader{Array,Value} depending on whether the branch type T is a RVec<T> or any other type (respectively) ;  CTReaderValueOrArray< RVec< T > >;  ►NSHA256;  Csha256_t;  ►NTDS;  CTPointerHolderMother class of TTypedPointerHolder ;  CTTypedPointerHolderClass to wrap a pointer and delete the memory associated to it correctly ;  ►NTThreadedObjectUtils;  CClonerReturn a copy of the object or a ""Clone"" if the copy constructor is not implemented ;  CCloner< T, false >;  CDetacher;  CDetacher< T, true >;  CDirCreator;  CDirCreator< T, true >;  ►NVecOps;  CREmplaceBackHelper;  CREmplaceBackHelper< std::vector< bool >, Args... >;  CClassDefGenerateInitInstanceLocalInjector;  CEntryClusterA cluster of entries ;  CFriendInfo;  CGetFunctorType;  CGetFunctorType< T(F::*)(const T *, const double *) const >;  CGetFunctorType< T(F::*)(const T *, const double *)>;  CGetFunctorType< T(F::*)(T *, double *) const >;  CGetFunctorType< T(F::*)(T *, double *)>;  CInterpreterMutexRegistrationRAII;  ►CRConcurrentHashCollThis class is a TS set of unsigned set ;  CHashValue;  CRecurseCounts;  CTArrayCharProxy;  CTArrayProxy;  CTArrayType;  CTArrayType< T, 0 >;  CTAtomicPointerHelper class to manage atomic pointers ;  CTBranchCacheInfo;  CTBranchDescriptor;  CTBranchIMTHelper;  CTBranchProxyClassD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:28300,depend,depending,28300,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,4,"['depend', 'wrap']","['depending', 'wrap']"
Integrability,"UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. Int_t GetCompressionLevel() const. TProof * GetProof() const; { return fProof; }. const char * GetService() const; { return fService; }. const char * GetConfDir() const; { return fConfDir; }. const char * GetConfFile() const; { return fConfFile; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetImage() const; { return fImage; }. const char * GetSessionTag() const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdina",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:31055,message,message,31055,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,2,['message'],['message']
Integrability,"UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. TProof * GetProof() const; { return fProof; }. const char * GetService() const; { return fService; }. const char * GetConfDir() const; { return fConfDir; }. const char * GetConfFile() const; { return fConfFile; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetImage() const; { return fImage; }. const char * GetSessionTag() const; { return fTopSessionTag; }. const char * GetSessionDir() const; { return fSessionDir; }. const char * GetPackageDir() const; { return fPackageDir; }. const char * GetDataDir() const; { return fDataDir; }. Int_t GetProtocol() const; { return fProtocol; }. const char * GetOrdinal() const; { return fOrdinal; }. Int_t GetGroupId() const; { r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:30682,message,message,30682,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['message'],['message']
Integrability,"UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. void SetLastEntry(Long64_t lastentry); Set the last entry before exception. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. void GetLocalServer(TString& dsrv); Extract LOCALDATASERVER info in 'dsrv'. void FilterLocalroot(TString& path, const char* url = ""root://dum/""); If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings,; if any.; The final path via the server is dsrv+path. Int_t GetCompressionLevel() const. TProof * GetProof() const; { return fProof; }. const char * GetService() const; { return fService; }. const char * GetConfDir() const; { return fConfDir; }. const char * GetConfFile() const; { return fConfFile; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetImage() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:32220,message,message,32220,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,1,['message'],['message']
Integrability,"UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. void SetLastEntry(Long64_t lastentry); Set the last entry before exception. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. void GetLocalServer(TString& dsrv); Extract LOCALDATASERVER info in 'dsrv'. void FilterLocalroot(TString& path, const char* url = ""root://dum/""); If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings,; if any.; The final path via the server is dsrv+path. Int_t GetCompressionLevel() const. TProofServ(Int_t* argc, char** argv, FILE* flog = 0). TProof * GetProof() const; { return fProof; }. const char * GetService() const; { return fService; }. const char * GetConfDir() const; { return fConfDir; }. const char * GetConfFile() const; { return fConfFile; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. const char * GetWorkDir() const; { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServ.html:32965,message,message,32965,root/html602/TProofServ.html,https://root.cern,https://root.cern/root/html602/TProofServ.html,2,['message'],['message']
Integrability,"Upgrade: websocket\r\n""; 18252 ""Connection: Upgrade\r\n""; 18253 ""Sec-WebSocket-Key: %s\r\n""; 18254 ""Sec-WebSocket-Version: 13\r\n""; 18255 ""\r\n"",; 18256 path,; 18257 host,; 18258 magic);; 18259 }; 18260 }; 18261 if (i <= 0) {; 18262 mg_snprintf(conn,; 18263 NULL, /* No truncation check for ebuf */; 18264 error_buffer,; 18265 error_buffer_size,; 18266 ""%s"",; 18267 ""Error sending request"");; 18268 mg_close_connection(conn);; 18269 return NULL;; 18270 }; 18271 ; 18272 conn->data_len = 0;; 18273 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18274 mg_close_connection(conn);; 18275 return NULL;; 18276 }; 18277 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18278 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18279 ; 18280#if defined(__clang__); 18281#pragma clang diagnostic pop; 18282#endif; 18283 ; 18284 if (conn->response_info.status_code != 101) {; 18285 /* We sent an ""upgrade"" request. For a correct websocket; 18286 * protocol handshake, we expect a ""101 Continue"" response.; 18287 * Otherwise it is a protocol violation. Maybe the HTTP; 18288 * Server does not know websockets. */; 18289 if (!*error_buffer) {; 18290 /* set an error, if not yet set */; 18291 mg_snprintf(conn,; 18292 NULL, /* No truncation check for ebuf */; 18293 error_buffer,; 18294 error_buffer_size,; 18295 ""Unexpected server reply"");; 18296 }; 18297 ; 18298 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18299 mg_close_connection(conn);; 18300 return NULL;; 18301 }; 18302 ; 18303 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18304 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18305 if (!thread_data) {; 18306 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18307 mg_close_connection(conn);; 18308 return NULL;; 18309 }; 18310 ; 18311 thread_data->conn = conn;; 18312 thread_data->data_handler = data_func;; 18313 thread_data->close_handler = close_func;; 18314 thread_data->callback_data = us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:542368,protocol,protocol,542368,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['protocol'],['protocol']
Integrability,"Upgrade: websocket\r\n""; 18253 ""Connection: Upgrade\r\n""; 18254 ""Sec-WebSocket-Key: %s\r\n""; 18255 ""Sec-WebSocket-Version: 13\r\n""; 18256 ""\r\n"",; 18257 path,; 18258 host,; 18259 magic);; 18260 }; 18261 }; 18262 if (i <= 0) {; 18263 mg_snprintf(conn,; 18264 NULL, /* No truncation check for ebuf */; 18265 error_buffer,; 18266 error_buffer_size,; 18267 ""%s"",; 18268 ""Error sending request"");; 18269 mg_close_connection(conn);; 18270 return NULL;; 18271 }; 18272 ; 18273 conn->data_len = 0;; 18274 if (!get_response(conn, error_buffer, error_buffer_size, &i)) {; 18275 mg_close_connection(conn);; 18276 return NULL;; 18277 }; 18278 conn->request_info.local_uri_raw = conn->request_info.request_uri;; 18279 conn->request_info.local_uri = conn->request_info.local_uri_raw;; 18280 ; 18281#if defined(__clang__); 18282#pragma clang diagnostic pop; 18283#endif; 18284 ; 18285 if (conn->response_info.status_code != 101) {; 18286 /* We sent an ""upgrade"" request. For a correct websocket; 18287 * protocol handshake, we expect a ""101 Continue"" response.; 18288 * Otherwise it is a protocol violation. Maybe the HTTP; 18289 * Server does not know websockets. */; 18290 if (!*error_buffer) {; 18291 /* set an error, if not yet set */; 18292 mg_snprintf(conn,; 18293 NULL, /* No truncation check for ebuf */; 18294 error_buffer,; 18295 error_buffer_size,; 18296 ""Unexpected server reply"");; 18297 }; 18298 ; 18299 DEBUG_TRACE(""Websocket client connect error: %s\r\n"", error_buffer);; 18300 mg_close_connection(conn);; 18301 return NULL;; 18302 }; 18303 ; 18304 thread_data = (struct websocket_client_thread_data *)mg_calloc_ctx(; 18305 1, sizeof(struct websocket_client_thread_data), conn->phys_ctx);; 18306 if (!thread_data) {; 18307 DEBUG_TRACE(""%s\r\n"", ""Out of memory"");; 18308 mg_close_connection(conn);; 18309 return NULL;; 18310 }; 18311 ; 18312 thread_data->conn = conn;; 18313 thread_data->data_handler = data_func;; 18314 thread_data->close_handler = close_func;; 18315 thread_data->callback_data = us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:542401,protocol,protocol,542401,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['protocol'],['protocol']
Integrability,"Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TPSocket, TSSLSocket, and TServerSocket.; Definition at line 481 of file TSocket.cxx. ◆ SendObject(). Int_t TSocket::SendObject ; (; const TObject * ; obj, . Int_t ; kind = kMESS_OBJECT . ). virtual . Send an object. ; Returns the number of bytes sent and -1 in case of error. In case the ""kind"" has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending synchronous. ; Reimplemented in TServerSocket.; Definition at line 600 of file TSocket.cxx. ◆ SendProcessIDs(). void TSocket::SendProcessIDs ; (; const TMessage & ; mess). protected . Check if TProcessIDs must be sent. ; The list of TProcessIDs in the object in the message is found by looking in the TMessage bits. We send only the TProcessIDs not yet send on this socket. ; Definition at line 684 of file TSocket.cxx. ◆ SendRaw(). Int_t TSocket::SendRaw ; (; const void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Send a raw buffer of specified length. ; Using option kOob one can send OOB data. Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 620 of file TSocket.cxx. ◆ SendStreamerInfos(). void TSocket::SendStreamerInfos ; (; const TMessage & ; mess). protected . Check if TStreamerInfo must be sent. ; The list of TStreamerInfo of classes in the object in the message is in the fInfos list of the message. We send only the TStreamerInfos not yet sent on this socket. ; Definition at line 649 of file TSocket.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:37639,message,message,37639,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['message'],['message']
Integrability,"User-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:42556,integrat,integrator,42556,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,1,['integrat'],['integrator']
Integrability,"Utils::DemangleNameForDlsym ; (; const std::string & ; name). inlinestatic . Definition at line 574 of file TClingUtils.h. ◆ ElementStreamer(). int ROOT::TMetaUtils::ElementStreamer ; (; std::ostream & ; finalString, . const clang::NamedDecl & ; forcontext, . const clang::QualType & ; qti, . const char * ; t, . int ; rwmode, . const cling::Interpreter & ; interp, . const char * ; tcl = nullptr . ). Definition at line 821 of file TClingUtils.cxx. ◆ EndsWith(). bool ROOT::TMetaUtils::EndsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5077 of file TClingUtils.cxx. ◆ Error(). void ROOT::TMetaUtils::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). inline . Definition at line 817 of file TClingUtils.h. ◆ ExtractAttrIntPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrIntPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . int & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1672 of file TClingUtils.cxx. ◆ ExtractAttrPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . std::string & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1649 of file TClingUtils.cxx. ◆ extractAttrString(). int ROOT::TMetaUtils::extractAttrString ; (; clang::Attr * ; attribute, . std::string & ; attrString . ). Extract attr string. ; Definition at line 1608 of file TClingUtils.cxx. ◆ ExtractCtxtEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractCtxtEnclosingNameSpaces ; (; const clang::DeclContext & ; ctxt, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract enclosing namespaces recursively. ; Definition at line 4930 of file TClingUtils.cxx. ◆ ExtractEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractEnclosingNameSpaces ; (; const clang::Decl & ; decl, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:24346,rout,routine,24346,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['rout'],['routine']
Integrability,"Utils::DemangleNameForDlsym ; (; const std::string & ; name). inlinestatic . Definition at line 597 of file TClingUtils.h. ◆ ElementStreamer(). int ROOT::TMetaUtils::ElementStreamer ; (; std::ostream & ; finalString, . const clang::NamedDecl & ; forcontext, . const clang::QualType & ; qti, . const char * ; t, . int ; rwmode, . const cling::Interpreter & ; interp, . const char * ; tcl = nullptr . ). Definition at line 861 of file TClingUtils.cxx. ◆ EndsWith(). bool ROOT::TMetaUtils::EndsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5124 of file TClingUtils.cxx. ◆ Error(). void ROOT::TMetaUtils::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). inline . Definition at line 840 of file TClingUtils.h. ◆ ExtractAttrIntPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrIntPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . int & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1712 of file TClingUtils.cxx. ◆ ExtractAttrPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . std::string & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1689 of file TClingUtils.cxx. ◆ extractAttrString(). int ROOT::TMetaUtils::extractAttrString ; (; clang::Attr * ; attribute, . std::string & ; attrString . ). Extract attr string. ; Definition at line 1648 of file TClingUtils.cxx. ◆ ExtractCtxtEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractCtxtEnclosingNameSpaces ; (; const clang::DeclContext & ; ctxt, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract enclosing namespaces recursively. ; Definition at line 4977 of file TClingUtils.cxx. ◆ ExtractEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractEnclosingNameSpaces ; (; const clang::Decl & ; decl, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:24343,rout,routine,24343,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['rout'],['routine']
Integrability,"V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3"",selection);. Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important note: By default TTree::Draw creates the arrays obtained; with GetV1, GetV2, GetV3, GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=1000000 and can be modified; via TTree::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accomodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comittin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:81775,interface,interface,81775,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['interface'],['interface']
Integrability,"VA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . Int_t ; NsigTrain, . Int_t ; NbkgTrain, . Int_t ; NsigTest, . Int_t ; NbkgTest, . const TString & ; otherOpt = ""SplitMode=Random:!V"" . ). prepare the training and test trees ; Definition at line 602 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [3/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . Int_t ; Ntrain, . Int_t ; Ntest = -1 . ). prepare the training and test trees kept for backward compatibility ; Definition at line 618 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [4/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; TCut ; sigcut, . TCut ; bkgcut, . const TString & ; splitOpt . ). prepare the training and test trees ; Definition at line 644 of file DataLoader.cxx. ◆ RecombineKFoldDataSet(). void TMVA::DataLoader::RecombineKFoldDataSet ; (; CvSplit & ; s, . Types::ETreeType ; tt = Types::kTraining . ). Recombines the dataset. ; The precise semantics depend on the actual split.; Similar to the inverse operation of MakeKFoldDataSet but will differ. See documentation for each particular split for more information. ; Definition at line 683 of file DataLoader.cxx. ◆ SetBackgroundTree(). void TMVA::DataLoader::SetBackgroundTree ; (; TTree * ; background, . Double_t ; weight = 1.0 . ). Definition at line 439 of file DataLoader.cxx. ◆ SetBackgroundWeightExpression(). void TMVA::DataLoader::SetBackgroundWeightExpression ; (; const TString & ; variable). Definition at line 556 of file DataLoader.cxx. ◆ SetCut() [1/2]. void TMVA::DataLoader::SetCut ; (; const TCut & ; cut, . const TString & ; className = """" . ). Definition at line 581 of file DataLoader.cxx. ◆ SetCut() [2/2]. void TMVA::DataLoader::SetCut ; (; const TString & ; cut, . const TString & ; className = """" . ). Definition at line 575 of file DataLoader.cxx. ◆ SetInputTrees() [1/3]. void TMVA::DataLoader::SetInputTrees ; (; const TString & ; signalFileName, . const TString & ; backg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:32162,depend,depend,32162,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['depend'],['depend']
Integrability,"VA::TNeuronInput* calculator); set input calculator. void SetActivationEqn(TMVA::TActivation* activation); set activation equation. void AddPreLink(TMVA::TSynapse* pre); add synapse as a pre-link to this neuron. void AddPostLink(TMVA::TSynapse* post); add synapse as a post-link to this neuron. void DeletePreLinks(); delete all pre-links. void DeleteLinksArray(TObjArray*& links); delete an array of TSynapses. void SetError(Double_t error); set error, this should only be done for an output neuron. void UpdateSynapsesBatch(); update and adjust the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void UpdateSynapsesSequential(); update the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in sequential mode. void AdjustSynapseWeights(); adjust the pre-synapses' weights for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void InitSynapseDeltas(); initialize the error fields of all pre-neurons; this method should only be called in batch mode. void PrintLinks(TObjArray* links) const; print an array of TSynapses, for debugging. void PrintActivationEqn(); print activation equation, for debugging. void PrintMessage(TMVA::EMsgType , TString message); print message, for debugging. TNeuron(ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """" ); {}. Double_t GetValue() const. void SetDEDw(Double_t DEDw). Double_t GetDEDw() const; { return fDEDw; }. TNeuron& operator=(const TMVA::TNeuron& ). » Author: Christophe.Delaere@cern.ch 20/07/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id: TNeuron.h 22428 2008-03-03 18:17:03Z brun $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TNeuron.html:8613,message,message,8613,root/html528/TMVA__TNeuron.html,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html,2,['message'],['message']
Integrability,"VSession::GetEntriesInt_t GetEntries()Definition TTVSession.h:91; TTVSession::FirstTTVRecord * First()Definition TTVSession.h:94; TTVSession::RemoveLastRecordvoid RemoveLastRecord()Remove current record from list.Definition TTVSession.cxx:224; TTVSession::NextTTVRecord * Next()Definition TTVSession.h:96; TTVSession::UpdateRecordvoid UpdateRecord(const char *name)Updates current record according to new X, Y, Z settings.Definition TTVSession.cxx:272; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram...Definition TTreePlayer.h:37; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid UpdateRecord(const char *name=""new name""); TTreeViewer::fBarOptionTGTextEntry * fBarOptionHistogram drawing option entry.Definition TTreeViewer.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:140222,interface,interface,140222,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['interface'],['interface']
Integrability,"Val() method.; creates a TGraph object with a number of points corresponding to the number of entries selected by the expression ""pz>4"", the x points of the graph being the px values of the Tree and the y points the py values.; Important note: By default TTree::Draw creates the arrays obtained with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding to the parameter fEstimate. The content will be the last GetSelectedRows() % GetEstimate() values calculated. By default fEstimate=1000000 and can be modified via TTree::SetEstimate. To keep in memory all the results (in case where there is only one result per entry), use tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows you need to look at is greater than 1000000.; You can use the option ""goff"" to turn off the graphics output of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer; A complete graphical interface to this function is implemented in the class TTreeViewer. To start the TTreeViewer, three possibilities:; select TTree context menu item ""StartViewer""; type the command ""TTreeViewer TV(treeName)""; execute statement ""tree->StartViewer();"" . Reimplemented in TChain, and TProofChain.; Definition at line 4507 of file TTree.cxx. ◆ Draw() [2/3]. Long64_t TTree::Draw ; (; const char * ; varexp, . const TCut & ; selection, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Draw expression varexp for specified entries. ; Returns-1 in case of error or number of selected events in case of success.; This function accepts TCut objects as arguments. Useful to use the string operator +; Example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Reimplemented in TChain, and TProofChain.; Definition at line 3855 of file TTree.cxx. ◆ Draw() [3/3]. void TTree::Draw ; (; Option_t * ; option). inlineoverridevirtual . Default Draw method for all objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:135820,interface,interface,135820,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['interface'],['interface']
Integrability,"Value &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:22070,integrat,integration,22070,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['integrat'],['integration']
Integrability,"Value &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for now) ;  ;  Public Member F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstraintSum.html:17358,integrat,integration,17358,doc/master/classRooConstraintSum.html,https://root.cern,https://root.cern/doc/master/classRooConstraintSum.html,1,['integrat'],['integration']
Integrability,"Value! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFracRemainder.html:31787,integrat,integrator,31787,root/html526/RooFracRemainder.html,https://root.cern,https://root.cern/root/html526/RooFracRemainder.html,2,['integrat'],['integrator']
Integrability,"Value! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPEffDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& CPeigenval, RooAbsReal& a, RooAbsReal& b, RooAbsReal& effRatio, RooAbsReal& delMistag, const RooResolutionModel& model, RooBCPEffDecay::DecayType type = DoubleSided); Constructor. RooBCPEffDecay(const RooBCPEffDecay& other, const char* name = 0); Copy constructor. ~RooBCPEffDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPEffDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPEffDecay(*this,newname) ; }. » Last changed: Mon Dec 7 13:46:00 2009 » Last generated: 2009-12-07 13:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:42621,depend,dependent,42621,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,1,['depend'],['dependent']
Integrability,"Value! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPEffDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& CPeigenval, RooAbsReal& a, RooAbsReal& b, RooAbsReal& effRatio, RooAbsReal& delMistag, const RooResolutionModel& model, RooBCPEffDecay::DecayType type = DoubleSided); Constructor. RooBCPEffDecay(const RooBCPEffDecay& other, const char* name = 0); Copy constructor. ~RooBCPEffDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPEffDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPEffDecay(*this,newname) ; }. » Last changed: Mon Jul 4 15:21:40 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPEffDecay.html:43657,depend,dependent,43657,root/html530/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPEffDecay.html,1,['depend'],['dependent']
Integrability,"Value! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPEffDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& CPeigenval, RooAbsReal& a, RooAbsReal& b, RooAbsReal& effRatio, RooAbsReal& delMistag, const RooResolutionModel& model, RooBCPEffDecay::DecayType type = DoubleSided); Constructor. RooBCPEffDecay(const RooBCPEffDecay& other, const char* name = 0); Copy constructor. ~RooBCPEffDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPEffDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPEffDecay(*this,newname) ; }. » Last changed: Sat Oct 9 22:38:35 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:43289,depend,dependent,43289,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,1,['depend'],['dependent']
Integrability,"Value! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPEffDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& CPeigenval, RooAbsReal& a, RooAbsReal& b, RooAbsReal& effRatio, RooAbsReal& delMistag, const RooResolutionModel& model, RooBCPEffDecay::DecayType type = DoubleSided); Constructor. RooBCPEffDecay(const RooBCPEffDecay& other, const char* name = 0); Copy constructor. ~RooBCPEffDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPEffDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPEffDecay(*this,newname) ; }. » Last changed: Thu Nov 3 20:07:00 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:44064,depend,dependent,44064,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,1,['depend'],['dependent']
Integrability,"Value::createHistogram ; (; const char * ; name, . RooArgList & ; vars, . const char * ; tAxisLabel, . double * ; xlo, . double * ; xhi, . Int_t * ; nBins . ). static . Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ; The dimensions of the arrays xlo,xhi, nBins should match the number of objects in vars. ; Definition at line 897 of file RooAbsRealLValue.cxx. ◆ createIntegral(). RooFit::OwningPtr< RooAbsReal > RooAbsRealLValue::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 1056 of file RooAbsRealLValue.cxx. ◆ DeclFileName(). static const char * RooAbsRealLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 164 of file RooAbsRealLValue.h. ◆ fitRangeOKForPlotting(). bool RooAbsRealLValue::fitRangeOKForPlotting ; (; ); const. protected . Check if fit range is usable as plot range, i.e. ; it is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:75688,integrat,integrates,75688,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,2,['integrat'],['integrates']
Integrability,Values;  ; Bool_t fBootstrap;  ; TString fClassWeight;  ; TString fCriterion;  ; TString fFilenameClassifier;  ; TString fMaxDepth;  ; TString fMaxFeatures;  ; TString fMaxLeafNodes;  ; Int_t fMinSamplesLeaf;  ; Int_t fMinSamplesSplit;  ; Double_t fMinWeightFractionLeaf;  ; Int_t fNestimators;  ; Int_t fNjobs;  ; UInt_t fNoutputs;  ; UInt_t fNvars;  ; Bool_t fOobScore;  ; TString fRandomState;  ; Int_t fVerbose;  ; Bool_t fWarmStart;  ; std::vector< Double_t > mvaValues;  ; PyObject * pBootstrap;  ; PyObject * pClassWeight;  ; PyObject * pCriterion;  ; PyObject * pMaxDepth;  ; PyObject * pMaxFeatures;  ; PyObject * pMaxLeafNodes;  ; PyObject * pMinSamplesLeaf;  ; PyObject * pMinSamplesSplit;  ; PyObject * pMinWeightFractionLeaf;  ; PyObject * pNestimators;  ; PyObject * pNjobs;  ; PyObject * pOobScore;  ; PyObject * pRandomState;  ; PyObject * pVerbose;  ; PyObject * pWarmStart;  ;  Protected Attributes inherited from TMVA::PyMethodBase; PyObject * fClassifier;  ; PyObject * fLocalNS;  ; PyObject * fModule;  ; PyObject * fPyReturn;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  .,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyRandomForest.html:26154,message,message,26154,doc/master/classTMVA_1_1MethodPyRandomForest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyRandomForest.html,1,['message'],['message']
Integrability,"Valuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:31256,integrat,integration,31256,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['integrat'],['integration']
Integrability,"Vars, . const RooArgSet * ; projectedVars, . RooArgSet *& ; cloneSet, . const char * ; rangeName = nullptr, . const RooArgSet * ; condObs = nullptr . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; Create a new object \( G \) that represents the normalized projection: ; \[; G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; \]. where \( F[x,y,p] \) is the function we represent, and \( \{ p \} \) are the remaining variables (""parameters"").; Parameters. [in]dependentVarsDependent variables over which to normalise, \( \{x\} \). ; [in]projectedVarsVariables to project out, \( \{ y \} \). ; [out]cloneSetWill be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object. The latter will also be returned. The caller takes ownership of this set. ; [in]rangeNameOptional range for projection integrals ; [in]condObsConditional observables, which are not integrated for normalisation, even if they are in dependentVars or projectedVars. . ReturnsA pointer to the newly created object, or zero in case of an error. The caller is responsible for deleting the cloneSet (which includes the returned projection object). ; Definition at line 816 of file RooAbsReal.cxx. ◆ createPlotProjection() [2/2]. const RooAbsReal * RooAbsReal::createPlotProjection ; (; const RooArgSet & ; depVars, . const RooArgSet & ; projVars, . RooArgSet *& ; cloneSet . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; createPlotProjection() ; Definition at line 787 of file RooAbsReal.cxx. ◆ createProfile(). RooFit::OwningPtr< RooAbsReal > RooAbsReal::createProfile ; (; const RooArgSet & ; paramsOfInterest). virtual . Create a RooProfileLL object that eliminates all nuisance parameters in the present function. ; The nuisance parameters are defined as all parameters of the function except the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:91646,integrat,integrated,91646,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['depend', 'integrat']","['dependentVars', 'integrated']"
Integrability,"Vars, . const RooArgSet * ; projectedVars, . RooArgSet *& ; cloneSet, . const char * ; rangeName = nullptr, . const RooArgSet * ; condObs = nullptr . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; Create a new object \( G \) that represents the normalized projection: ; \[; G[x,p] = \frac{\int F[x,y,p] \; \mathrm{d}\{y\}}; {\int F[x,y,p] \; \mathrm{d}\{x\} \, \mathrm{d}\{y\}}; \]. where \( F[x,y,p] \) is the function we represent, and \( \{ p \} \) are the remaining variables (""parameters"").; Parameters. [in]dependentVarsDependent variables over which to normalise, \( \{x\} \). ; [in]projectedVarsVariables to project out, \( \{ y \} \). ; [out]cloneSetWill be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object. The latter will also be returned. The caller takes ownership of this set. ; [in]rangeNameOptional range for projection integrals ; [in]condObsConditional observables, which are not integrated for normalisation, even if they are in dependentVars or projectedVars. . ReturnsA pointer to the newly created object, or zero in case of an error. The caller is responsible for deleting the cloneSet (which includes the returned projection object). ; Definition at line 842 of file RooAbsReal.cxx. ◆ createPlotProjection() [2/2]. const RooAbsReal * RooAbsReal::createPlotProjection ; (; const RooArgSet & ; depVars, . const RooArgSet & ; projVars, . RooArgSet *& ; cloneSet . ); const. Utility function for plotOn() that creates a projection of a function or p.d.f to be plotted on a RooPlot. ; createPlotProjection() ; Definition at line 813 of file RooAbsReal.cxx. ◆ createProfile(). RooFit::OwningPtr< RooAbsReal > RooAbsReal::createProfile ; (; const RooArgSet & ; paramsOfInterest). virtual . Create a RooProfileLL object that eliminates all nuisance parameters in the present function. ; The nuisance parameters are defined as all parameters of the function except the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:92914,integrat,integrated,92914,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['depend', 'integrat']","['dependentVars', 'integrated']"
Integrability,"Vector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5538,interface,interface,5538,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,4,['interface'],['interface']
Integrability,"Vector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5538,interface,interface,5538,root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,4,['interface'],['interface']
Integrability,"Vector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5538,interface,interface,5538,root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,4,['interface'],['interface']
Integrability,"Vector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5538,interface,interface,5538,root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,4,['interface'],['interface']
Integrability,"VectorDfTestQuantityTest sample, dependent quantity; Int_tfTestSampleSizeSize of test sample; TVectorDfTestSqErrorTest sample, Error in quantity; TVectorDfTestVariablesTest sample, independent variables; TStringTNamed::fTitleobject title; TVectorDfVariablesTraining sample, independent variables. private:. static TMultiDimFit*fgInstanceStatic instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:25507,depend,dependent,25507,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,12,['depend'],['dependent']
Integrability,"VerboseLevel>; 3707gOptVerboseLevel(llvm::cl::desc(""Choose verbosity level:""),; 3708 llvm::cl::values(clEnumVal(v, ""Show errors.""),; 3709 clEnumVal(v0, ""Show only fatal errors.""),; 3710 clEnumVal(v1, ""Show errors (the same as -v).""),; 3711 clEnumVal(v2, ""Show warnings (default).""),; 3712 clEnumVal(v3, ""Show notes.""),; 3713 clEnumVal(v4, ""Show information."")),; 3714 llvm::cl::init(v2),; 3715 llvm::cl::cat(gRootclingOptions));; 3716 ; 3717static llvm::cl::opt<bool>; 3718gOptCint(""cint"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3719 llvm::cl::Hidden,; 3720 llvm::cl::cat(gRootclingOptions));; 3721static llvm::cl::opt<bool>; 3722gOptReflex(""reflex"", llvm::cl::desc(""Behave internally like genreflex.""),; 3723 llvm::cl::cat(gRootclingOptions));; 3724static llvm::cl::opt<bool>; 3725gOptGccXml(""gccxml"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3726 llvm::cl::Hidden,; 3727 llvm::cl::cat(gRootclingOptions));; 3728static llvm::cl::opt<std::string>; 3729gOptLibListPrefix(""lib-list-prefix"",; 3730 llvm::cl::desc(""An ACLiC feature which exports the list of dependent libraries.""),; 3731 llvm::cl::Hidden,; 3732 llvm::cl::cat(gRootclingOptions));; 3733static llvm::cl::opt<bool>; 3734gOptGeneratePCH(""generate-pch"",; 3735 llvm::cl::desc(""Generates a pch file from a predefined set of headers. See makepch.py.""),; 3736 llvm::cl::Hidden,; 3737 llvm::cl::cat(gRootclingOptions));; 3738static llvm::cl::opt<bool>; 3739gOptC(""c"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3740 llvm::cl::cat(gRootclingOptions));; 3741static llvm::cl::opt<bool>; 3742gOptP(""p"", llvm::cl::desc(""Deprecated, legacy flag which is ignored.""),; 3743 llvm::cl::cat(gRootclingOptions));; 3744static llvm::cl::list<std::string>; 3745gOptRootmapLibNames(""rml"", llvm::cl::ZeroOrMore,; 3746 llvm::cl::desc(""Generate rootmap file.""),; 3747 llvm::cl::cat(gRootclingOptions));; 3748static llvm::cl::opt<std::string>; 3749gOptRootMapFileName(""rmf"",; 3750 llvm::cl::desc(""Generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:149103,depend,dependent,149103,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['depend'],['dependent']
Integrability,"Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EUseEstOpt { kEstOff = 0; , kEstCurrent = 1; , kEstAverage = 2; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TVirtualPacketizer (const TVirtualPacketizer &);  ;  TVirtualPacketizer (TList *input, TProofProgressStatus *st=0);  Constructor. ;  ; TDSetElement * CreateNewPacket (TDSetElement *base, Long64_t first, Long64_t num);  Creates a new TDSetElement from from base packet starting from the first entry with num entries. ;  ; Long64_t GetEntries (Bool_t tree, TDSetElement *e);  Get entries. ;  ; Bool_t HandleTimer (TTimer *timer) override;  Send progress message to client. ;  ; void operator= (const TVirtualPacketizer &);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t fActWrksLast;  ; Bool_t fAWLastFill;  ; Long_t fCircN;  ; TNtupleD * fCircProg;  ; TList * fConfigParams;  ; TString fDataSet;  ; Float_t fEffSessLast;  ; Float_t fEvtRateLast;  ; TList * fFailedPackets;  ; Float_t fInitTime;  ; TList * fInput;  ; Double_t fMaxPacketTime;  ; Float_t fMBsReadLast;  ; Double_t fMinPacketTime;  ; Float_t fProcTime;  ; Float_t fProcTimeLast;  ; TTimer * fProgress;  ; TNtuple * fProgressPerf;  ; TProofProgressStatus * fProgressStatus;  ; Float_t fReportPeriod;  ; TMap * fSlaveStats;  ; TTime fStartTime;  ; Bool_t fStop;  ; Float_t fTimeUpdt;  ; Long64_t fTotalEntries;  ; EUseEstOpt fUseEstOpt;  ; Bool_t fValid;  . #include <TVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPacketizer.html:12454,message,message,12454,doc/master/classTVirtualPacketizer.html,https://root.cern,https://root.cern/doc/master/classTVirtualPacketizer.html,1,['message'],['message']
Integrability,"Version of this class ; Definition at line 95 of file TDatime.h. ◆ Convert(). UInt_t TDatime::Convert ; (; Bool_t ; toGMT = kFALSE); const. Convert fDatime from TDatime format to the standard time_t format. ; If toGMT is true, the time offset of the current local time zone is subtracted from the returned time_t. One use of such a non-standard time_t value is to convert a TDatime object that contains local time to GMT, as in this example: TDatime now;; now.Set(now.Convert(kTRUE));; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::Setvoid Set()Set Date/Time to current time as reported by the system.Definition TDatime.cxx:289; TDatime::ConvertUInt_t Convert(Bool_t toGMT=kFALSE) constConvert fDatime from TDatime format to the standard time_t format.Definition TDatime.cxx:182; Caution: the time_t returned from Convert(kTRUE) is incompatible with regular Unix time - it contains an artificial, locale-dependent offset. ; Definition at line 182 of file TDatime.cxx. ◆ Copy(). void TDatime::Copy ; (; TDatime & ; datime); const. Copy this to datime. ; Definition at line 221 of file TDatime.cxx. ◆ DeclFileName(). static const char * TDatime::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 95 of file TDatime.h. ◆ FillBuffer(). void TDatime::FillBuffer ; (; char *& ; buffer). Encode Date/Time into buffer, used by I/O system. ; Definition at line 229 of file TDatime.cxx. ◆ Get(). UInt_t TDatime::Get ; (; ); const. Return raw date/time as encoded by TDatime. ; Note, this value cannot be used to e.g. calculate time differences, as it is an encoded value. To calculate time differences use the Convert() method to get a time in seconds and then subtract the values. ; Definition at line 240 of file TDatime.cxx. ◆ GetDate(). Int_t TDatime::GetDate ; (; ); const. Return date i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDatime.html:8043,depend,dependent,8043,doc/master/classTDatime.html,https://root.cern,https://root.cern/doc/master/classTDatime.html,1,['depend'],['dependent']
Integrability,"Virtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuranContDist.html:2366,interface,interfaces,2366,root/html528/TUnuranContDist.html,https://root.cern,https://root.cern/root/html528/TUnuranContDist.html,3,['interface'],['interfaces']
Integrability,"VirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:6818,wrap,wrapper,6818,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"VirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is alre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:23854,message,message,23854,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,10,['message'],['message']
Integrability,"VirtualStreamerInfo; Int_tfStreamerType!cached of the streaming method to use; const type_info*fTypeInfopointer to the C++ type information.; Bool_tfVersionUsed!Indicates whether GetClassVersion has been called; static TClass::ENewTypefgCallingNewIntent of why/how TClass::New() is called; static Int_tfgClassCountprovides unique id for a each class; static THashTable*fgClassShortTypedefHash; static THashTable*fgClassTypedefHash. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IdMap_t * GetIdMap(). void AddClass(TClass* cl); static: Add a class to the list and map of classes. void RemoveClass(TClass* cl); static: Remove a class from the list and map of classes. TClass(); Default ctor. TClass(const char* name, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods.; Use this ctor to create a standalone TClass object. Most useful; to get a TClass interface to an interpreted class. Used by TTabCom.; Normally you would use TClass::GetClass(""class"") to get access to a; TClass object for a certain class. TClass(const char* name, Version_t cversion, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. TClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent = kFALSE); Create a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. void ForceReload(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:17798,interface,interface,17798,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['interface'],['interface']
Integrability,"VirtualX.; Definition at line 7564 of file TGWin32.cxx. ◆ Streamer(). void TGWin32::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGWin32::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 401 of file TGWin32.h. ◆ SubtractRegion(). void TGWin32::SubtractRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Subtract rega from regb. ; Reimplemented from TVirtualX.; Definition at line 7177 of file TGWin32.cxx. ◆ Sync(). void TGWin32::Sync ; (; Int_t ; mode). overridevirtual . Set synchronisation on or off. ; Parameters. [in]modesynchronisation on/off; mode=1 on; mode<>0 off . Reimplemented from TVirtualX.; Definition at line 4212 of file TGWin32.cxx. ◆ TextWidth(). Int_t TGWin32::TextWidth ; (; FontStruct_t ; font, . const char * ; s, . Int_t ; len . ). overridevirtual . Return length of string in pixels. Size depends on font. ; Reimplemented from TVirtualX.; Definition at line 6678 of file TGWin32.cxx. ◆ TranslateCoordinates(). void TGWin32::TranslateCoordinates ; (; Window_t ; src, . Window_t ; dest, . Int_t ; src_x, . Int_t ; src_y, . Int_t & ; dest_x, . Int_t & ; dest_y, . Window_t & ; child . ). overridevirtual . TranslateCoordinates translates coordinates from the frame of reference of one window to another. ; If the point is contained in a mapped child of the destination, the id of that child is returned as well. ; Reimplemented from TVirtualX.; Definition at line 6945 of file TGWin32.cxx. ◆ UnionRectWithRegion(). void TGWin32::UnionRectWithRegion ; (; Rectangle_t * ; rect, . Region_t ; src, . Region_t ; dest . ). overridevirtual . Union of rectangle with a region. ; Reimplemented from TVirtualX.; Definition at line 7135 of file TGWin32.cxx. ◆ UnionRegion(). void TGWin32::UnionRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Compute the union of re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:118015,depend,depends,118015,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['depend'],['depends']
Integrability,"VirtualXProxy.cxx:44; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; RooAbsReal::NumEvent@ NumEventDefinition RooAbsReal.h:276; RooAbsReal::Relative@ RelativeDefinition RooAbsReal.h:276; RooAbsReal::Raw@ RawDefinition RooAbsReal.h:276. Reimplemented from RooAbsReal.; Reimplemented in RooSimultaneous.; Definition at line 2221 of file RooAbsPdf.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsPdf::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. overridevirtual . Plot (project) PDF on specified frame. . If a PDF is plotted in an empty frame, it will show a unit-normalized curve in the frame variable. When projecting a multi- dimensional PDF onto the frame axis, hidden parameters are taken are taken at their current value.; If a PDF is plotted in a frame in which a dataset has already been plotted, it will show a projection integrated over all variables that were present in the shown dataset (except for the one on the x-axis). The normalization of the curve will be adjusted to the event count of the plotted dataset. An informational message will be printed for each projection step that is performed.; If a PDF is plotted in a frame showing a dataset after a fit, the above happens, but the PDF will be drawn and normalised only in the fit range. If this is not desired, plotting and normalisation range can be overridden using Range() and NormRange() as documented in the table below. This function takes the following named arguments (for more arguments, see also RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&) const ). Type of argument Controlling normalisation . NormRange(const char* name) Calculate curve normalization w.r.t. specified range[s]. See the tuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:139258,integrat,integrated,139258,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integrated']
Integrability,"Virtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_tGetBoxVolume(); TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::MsgLogger*fLogger! message logger. private:. vector<Double_t>fBoxrange-searching box; Bool_tfBoxHasChangedrange searching box has changed; Double_tfBoxVolumevolume of range searching box. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~PDEFoamDensityBase(); destructor. void FillBinarySearchTree(const TMVA::Event* ev); This method inserts the given event 'ev' it into the binary; search tree. Double_t GetBoxVolume(); Returns the volume of range searching box fBox. If the range searching box 'fBox' has changed (fBoxHasChanged is; kTRUE), recalculate the box volume and set fBoxHasChanged to; kFALSE. void SetBox(vector<Double_t> box); set the range-searching box. { fBox = box; fBoxHasChanged = kTRUE; }. const std::vector<Double_t>& GetBox() const; get the range-searching box. { return fBox; }. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); main function used by PDEFoam; returns density at a given point by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__PDEFoamDensityBase.html:6378,message,message,6378,root/html534/TMVA__PDEFoamDensityBase.html,https://root.cern,https://root.cern/root/html534/TMVA__PDEFoamDensityBase.html,1,['message'],['message']
Integrability,"Virtual_b);  ;  Public Member Functions inherited from RooAbsLValue; virtual ~RooAbsLValue ()=default;  ; virtual std::list< std::string > getBinningNames () const =0;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, const RooAbsBinning **bins);  Create a 1,2, or 3D-histogram with appropriate scale and labels. ;  ; static TH1 * createHistogram (const char *name, RooArgList &vars, const char *tAxisLabel, double *xlo, double *xhi, Int_t *nBins);  Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:53002,message,messages,53002,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['message'],['messages']
Integrability,"W, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. A TWebFile cannot be reopened in update mode. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer10(char* buf, Int_t len); Read specified byte range from remote file via HTTP 1.0 daemon (without; mod-root installed). This routine connects to the remote host, sends the; request and returns the buffer. Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read specified byte ranges from remote file via HTTP daemon.; Reads the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t ReadBuffers10(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read specified byte ranges from remote file via HTTP 1.0 daemon (without; mod-root installed). Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t GetFromWeb(char* buf, Int_t len, const TString& msg); Read requ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:26102,rout,routine,26102,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,6,['rout'],['routine']
Integrability,"WMSizeHints (UInt_t &wmin, UInt_t &hmin, UInt_t &wmax, UInt_t &hmax, UInt_t &winc, UInt_t &hinc) const;  ; EInitialState GetWMState () const;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button events. ;  ; Bool_t HandleClientMessage (Event_t *event) override;  Handle client messages sent to this frame. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle keyboard events. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion events. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle primary selection event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle selection request event. ;  ; virtual void RemoveBind (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Remove key binding. ;  ; virtual Bool_t SaveFrameAsCodeOrImage ();  Opens dialog window allowing user to save the frame contents as a ROOT macro or as an image. ;  ; virtual Bool_t SaveFrameAsCodeOrImage (const TString &fileName);  Saves the frame contents as a ROOT macro or as an image, depending on the extension of the fileName argument. ;  ; virtual void SendCloseMessage ();  Send close message to self. ;  ; void SetClassHints (const char *className, const char *resourceName);  Set the windows class and resource name. ;  ; void SetIconName (const char *name);  Set window icon name. This is typically done via the window manager. ;  ; void SetIconPixmap (char **xpm_array);  Set window icon by xpm array. ;  ; const TGPicture * SetIconPixmap (const char *iconName);  Set window icon pixmap by name. ;  ; void SetMWMHints (UInt_t value, UInt_t funcs, UInt_t input);  Set decoration style for MWM-compatible wm (mwm, ncdwm, fvwm?). ;  ; void SetWindowName (const char *name=nullptr) override;  Set window name. This is typically done via the window manager. ;  ; void SetWMPosition (Int_t x, Int_t y);  Give the window manager a window position hint. ;  ; void SetWMSize (UInt_t w, UInt_t h);  Give the window manager a window size hint. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAdvancedGraphicsDialog.html:4146,depend,depending,4146,doc/master/classTAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/doc/master/classTAdvancedGraphicsDialog.html,17,['depend'],['depending']
Integrability,"WMSizeHints (UInt_t &wmin, UInt_t &hmin, UInt_t &wmax, UInt_t &hmax, UInt_t &winc, UInt_t &hinc) const;  ; EInitialState GetWMState () const;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button events. ;  ; Bool_t HandleClientMessage (Event_t *event) override;  Handle client messages sent to this frame. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle keyboard events. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion events. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle primary selection event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle selection request event. ;  ; virtual void RemoveBind (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Remove key binding. ;  ; virtual Bool_t SaveFrameAsCodeOrImage ();  Opens dialog window allowing user to save the frame contents as a ROOT macro or as an image. ;  ; virtual Bool_t SaveFrameAsCodeOrImage (const TString &fileName);  Saves the frame contents as a ROOT macro or as an image, depending on the extension of the fileName argument. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a main frame widget as a C++ statement(s) on output stream out. ;  ; virtual void SaveSource (const char *filename=""Rootappl.C"", Option_t *option="""");  Save the GUI main frame widget in a C++ macro file. ;  ; virtual void SendCloseMessage ();  Send close message to self. ;  ; void SetClassHints (const char *className, const char *resourceName);  Set the windows class and resource name. ;  ; void SetIconName (const char *name);  Set window icon name. This is typically done via the window manager. ;  ; void SetIconPixmap (char **xpm_array);  Set window icon by xpm array. ;  ; const TGPicture * SetIconPixmap (const char *iconName);  Set window icon pixmap by name. ;  ; void SetMWMHints (UInt_t value, UInt_t funcs, UInt_t input);  Set decoration style for MWM-compatible wm (mwm, ncdwm, fvwm?). ;  ; void SetWindowName (co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGRecorder.html:3241,depend,depending,3241,doc/master/classTGRecorder.html,https://root.cern,https://root.cern/doc/master/classTGRecorder.html,4,['depend'],['depending']
Integrability,"WMSizeHints (UInt_t &wmin, UInt_t &hmin, UInt_t &wmax, UInt_t &hmax, UInt_t &winc, UInt_t &hinc) const;  ; EInitialState GetWMState () const;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button events. ;  ; Bool_t HandleClientMessage (Event_t *event) override;  Handle client messages sent to this frame. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle keyboard events. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion events. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle primary selection event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle selection request event. ;  ; virtual void RemoveBind (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Remove key binding. ;  ; virtual Bool_t SaveFrameAsCodeOrImage ();  Opens dialog window allowing user to save the frame contents as a ROOT macro or as an image. ;  ; virtual Bool_t SaveFrameAsCodeOrImage (const TString &fileName);  Saves the frame contents as a ROOT macro or as an image, depending on the extension of the fileName argument. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a main frame widget as a C++ statement(s) on output stream out. ;  ; virtual void SendCloseMessage ();  Send close message to self. ;  ; void SetClassHints (const char *className, const char *resourceName);  Set the windows class and resource name. ;  ; void SetIconName (const char *name);  Set window icon name. This is typically done via the window manager. ;  ; void SetIconPixmap (char **xpm_array);  Set window icon by xpm array. ;  ; const TGPicture * SetIconPixmap (const char *iconName);  Set window icon pixmap by name. ;  ; void SetMWMHints (UInt_t value, UInt_t funcs, UInt_t input);  Set decoration style for MWM-compatible wm (mwm, ncdwm, fvwm?). ;  ; void SetWindowName (const char *name=nullptr) override;  Set window name. This is typically done via the window manager. ;  ; void SetWMPosition (Int_t x, Int_t y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeViewer.html:13897,depend,depending,13897,doc/master/classTTreeViewer.html,https://root.cern,https://root.cern/doc/master/classTTreeViewer.html,1,['depend'],['depending']
Integrability,"WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:156; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:167; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:703; ROOT::RWebWindow::GetRelativeAddrstd::string GetRelativeAddr(const std::shared_ptr< RWebWindow > &win) constReturns relative URL address for the specified window Address can be required if one needs to access ...Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36875,protocol,protocol,36875,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['protocol'],['protocol']
Integrability,"WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RWebWindow.hxx:159; ROOT::RWebWindow::fXint fXDefinition RWebWindow.hxx:170; ROOT::RWebWindow::GetConnLimitunsigned GetConnLimit() constreturns configured connections limit (0 - default)Definition RWebWindow.cxx:704; ROOT::RWebWindow::SetStartDialogFuncstatic void SetStartDialogFunc(std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>)Configure func which has to be used for starting dialog.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:37264,protocol,protocol,37264,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['protocol'],['protocol']
Integrability,"Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet) . Member RooTemplateProxy< T >::lvptr (const LValue_t *) const; This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. ; Member RooTemplateProxy< T >::R__DEPRECATED (6, 36, ""Use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy::putOwnedArg()."") RooTemplateProxy(const char *theName; Kept for backwards compatibility and will be removed in ROOT 6.36. Either use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool), and transfer the ownership with RooTemplateProxy::putOwnedArg(), or use RooTemplateProxy(const char*, const char*, RooAbsArg*, std::unique_ptr<T>, bool, bool) if you want the proxy to own the argument. depending if you want to transfer ownership or not. ; Member TFitter::Chisquare (Int_t npar, Double_t *params) const override; Use ROOT::Fit::Chisquare class instead. ; Class TGeoTrack ; Use of TGeoTrack is deprecated. For the event display please switch to TEve (using TEveTracks or TEvePointSet to display tracks specifically) or to REve. ; Class THtml ; We keep THtml for those who still need it for legacy use cases. ROOT has since several years moved to doxygen as documentation generator. THtml is not developed nor supported anymore; please migrate to doxygen instead. ; Member THttpCallArg::SetPostData (void *data, Long_t length, Bool_t make_copy=kFALSE); Use signature with std::string ; Member THttpServer::ReadFileContent (const char *filename, Int_t &len); ; Member TPython::Eval (const char *expr) R__DEPRECATED(6; Use TPython::Exec() with an std::any output parameter instead. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/deprecated.html:6217,depend,depending,6217,doc/master/deprecated.html,https://root.cern,https://root.cern/doc/master/deprecated.html,1,['depend'],['depending']
Integrability,"Win32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; kMaxCutsconst Int_t kMaxCutsDefinition THistPainter.h:41; TString.h; TVirtualHistPainter.h; TAxisClass to manage histogram axis.Definition TAxis.h:31; TCutGGraphical cut class.Definition TCutG.h:20; TF11-Dim function classDefinition TF1.h:233; TF3A 3-Dim function with parameters.Definition TF3.h:28; TGaxisThe axis painter class.Definition TGaxis.h:24; TGraph2DPainterThe TGraphDelaunay painting class.Definition TGraph2DPainter.h:31; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; THistPainterThe histogram painter class.Definition THistPainter.h:50; THistPainter::ProjectSinusoidal2xystatic Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function code for sinusoidal projection from Ernst-Jan Buis Source https://en....Definition THistPainter.cxx:10380; THistPainter::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histogramsDefinition THistPainter.cxx:4470; THistPainter::fYaxisTAxis * fYaxisPointer to Y axis.Definition THistPainter.h:55; THistPainter::fLegostd::unique_ptr< TPainter3dAlgorithms > fLegoPointer to a TPainter3dAlgorithms object.Definition THistPainter.h:58; THistPainter::fXbufstd::vector< Double_t > fXbufX buffer coordinates.Definition THistPainter.h:61; THistPainter::fXHighlightBinInt_t fXHighlightBinX highlight bin.Definition THistPainter.h:70; THistPainter::fCurrentF3TF3 * fCurrentF3Current TF3 function.Definition THistPainter.h:72; THistPainter::PaintErrorsvirtual void PaintErrors(Option_t *option)Draw 1D histograms error bars.Definition THistPainter.cxx:6314; THistPainter::~THistPainter~THistPainter() overridedestructor.Definition THistPainter.cxx:3242; THistPainter::fShowProjection2Int_t fShowProjection2True if a second projection must be drawn (when calling SetShowProjectionXY on a TH2)Definition THistPainter.h:68; THistPainter::PaintTF3vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8h_source.html:8978,rout,routine,8978,doc/master/THistPainter_8h_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8h_source.html,1,['rout'],['routine']
Integrability,"Window ();  Delete window. ;  ; virtual void DrawBorder ();  Draw frame border. ;  ; void DrawClass () const override;  Draw class inheritance tree of the class to which this object belongs. ;  ; TObject * DrawClone (Option_t *="""") const override;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void DrawCopy (Handle_t, Int_t, Int_t);  ; void Dump () const override;  Dump contents of object on stdout. ;  ; virtual Pixel_t GetBackground () const;  ; Int_t GetBorderWidth () const;  ; virtual Int_t GetDragType () const;  Returns drag source type. ;  ; virtual Int_t GetDropType () const;  Returns drop target type. ;  ; UInt_t GetEventMask () const;  ; virtual Pixel_t GetForeground () const;  Return frame foreground color. ;  ; TGFrameElement * GetFrameElement () const;  ; UInt_t GetHeight () const;  ; UInt_t GetMaxHeight () const;  ; UInt_t GetMaxWidth () const;  ; UInt_t GetMinHeight () const;  ; UInt_t GetMinWidth () const;  ; virtual UInt_t GetOptions () const;  ; TGDimension GetSize () const;  ; UInt_t GetWidth () const;  ; Int_t GetX () const;  ; Int_t GetY () const;  ; virtual Bool_t HandleClientMessage (Event_t *event);  Handle a client message. ;  ; virtual Bool_t HandleColormapChange (Event_t *);  ; virtual Bool_t HandleConfigureNotify (Event_t *event);  This event is generated when the frame is resized. ;  ; Bool_t HandleEvent (Event_t *event) override;  Handle all frame events. ;  ; virtual Bool_t HandleSelectionClear (Event_t *);  ; virtual Bool_t HandleSelectionRequest (Event_t *);  ; void Inspect () const override;  Dump contents of this object in a graphics canvas. ;  ; virtual Bool_t IsActive () const;  ; Bool_t IsDNDSource () const;  ; Bool_t IsDNDTarget () const;  ; Bool_t IsEditable () const override;  ; void MapRaised () override;  map raised ;  ; void MapSubwindows () override;  map sub windows ;  ; void MapWindow () override;  map window ;  ; void Move (Int_t x, Int_t y) override;  Move frame. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:19369,message,message,19369,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['message'],['message']
Integrability,"Window*TGedPopup::fMsgWindow; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); Create marker popup window. ~TGedMarkerPopup(); Destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the marker popup window. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGedMarkerPopup.html:19382,message,messages,19382,root/html534/TGedMarkerPopup.html,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html,1,['message'],['messages']
Integrability,"Window.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 168 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 140 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 149 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 144 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 171 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 172 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 170 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 173 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 146 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:57877,protocol,protocol,57877,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['protocol'],['protocol']
Integrability,"Window.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default 50s ; Definition at line 171 of file RWebWindow.hxx. ◆ fPanelName. std::string ROOT::RWebWindow::fPanelName. private . ! panel name which should be shown in the window ; Definition at line 143 of file RWebWindow.hxx. ◆ fPendingConn. ConnectionsList_t ROOT::RWebWindow::fPendingConn. private . ! list of pending connection with pre-assigned keys ; Definition at line 152 of file RWebWindow.hxx. ◆ fProcessMT. bool ROOT::RWebWindow::fProcessMT {false}. private . ! if window event processing performed in dedicated thread ; Definition at line 147 of file RWebWindow.hxx. ◆ fProtocol. std::string ROOT::RWebWindow::fProtocol. private . ! protocol ; Definition at line 177 of file RWebWindow.hxx. ◆ fProtocolCnt. int ROOT::RWebWindow::fProtocolCnt {-1}. private . ! counter for protocol recording ; Definition at line 174 of file RWebWindow.hxx. ◆ fProtocolConnId. unsigned ROOT::RWebWindow::fProtocolConnId {0}. private . ! connection id, which is used for writing protocol ; Definition at line 175 of file RWebWindow.hxx. ◆ fProtocolFileName. std::string ROOT::RWebWindow::fProtocolFileName. private . ! local file where communication protocol will be written ; Definition at line 173 of file RWebWindow.hxx. ◆ fProtocolPrefix. std::string ROOT::RWebWindow::fProtocolPrefix. private . ! prefix for created files names ; Definition at line 176 of file RWebWindow.hxx. ◆ fRequireAuthKey. bool ROOT::RWebWindow::fRequireAuthKey {true}. private . ! defines if authentication key always required when connect to the widget ; Definition at line 149 of file RWebWindow.hxx. ◆ fSendMT. bool ROOT::RWebWindow::fSendMT {false}. private . ! true is special threads should b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:56761,protocol,protocol,56761,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['protocol'],['protocol']
Integrability,"WindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGGotoDialog.html:22804,message,messages,22804,root/html528/TGGotoDialog.html,https://root.cern,https://root.cern/root/html528/TGGotoDialog.html,1,['message'],['messages']
Integrability,"WindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 25499 2008-09-22 19:54:46Z bellenot $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGGotoDialog.html:22957,message,messages,22957,root/html530/TGGotoDialog.html,https://root.cern,https://root.cern/root/html530/TGGotoDialog.html,1,['message'],['messages']
Integrability,"WindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGGotoDialog(const TGWindow* p = 0, const TGWindow* main = 0, UInt_t w = 1, UInt_t h = 1, Long_t* ret_code = 0, UInt_t options = kVerticalFrame); Create a dialog to GoTo a specific line number. Returns -1 in; ret_code in case no valid line number was given or in case; cancel was pressed. If on input *ret_code is > 0 then this value; will be used as default value. ~TGGotoDialog(); Clean up goto dialog. void CloseWindow(); Close the dialog. On close the dialog will be deleted and cannot be; re-used. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process goto dialog widget messages. » Author: Fons Rademakers 10/7/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGTextEditDialogs.h 40451 2011-08-04 09:58:12Z bellenot $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGGotoDialog.html:22957,message,messages,22957,root/html532/TGGotoDialog.html,https://root.cern,https://root.cern/root/html532/TGGotoDialog.html,1,['message'],['messages']
Integrability,"WindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 61 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 84 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 87 of file RWebWindowsManager.hxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from remote. ; Definition at line 600 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 227 of file RWebWindowsManager.cxx. ◆ Instance(). std::shared_ptr< RWebWindowsManager > & RWebWindowsManager::Instance ; (; ). static . Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ; Definition at line 78 of file RWebWindowsManager.cxx. ◆ IsLoopbackMode(). bool RWebWindowsManager::IsLoopbackMode ; (; ). static . Returns true if loopback mode used by THttpServer for web widgets. ; Definition at line 146 of file RWebWindowsManager.cxx. ◆ IsMainThrd(). bool RWebWindowsManager::IsMainThrd ; (; ). static . Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ; Definition at line 104 of file RWebWindowsManager.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:12022,message,message,12022,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['message'],['message']
Integrability,"Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . Typedefs; typedef TRandomEngine DefaultEngineType;  Documentation for the RandomFunction class. ;  ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGenFunction > FitMethodFunction;  ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGradFunction > FitMethodGradFunction;  ; typedef double(* FreeFunctionPtr) (double);  ; typedef double(* FreeMultiFunctionPtr) (const double *);  ; typedef double(* FreeParamMultiFunctionPtr) (const double *, const double *);  ; typedef void(* GSLFdfPointer) (double, void *, double *, double *);  ; typedef double(* GSLFuncPointer) (double, void *);  Function pointer corresponding to gsl_function signature. ;  ; typedef double(* GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  ; typedef void(* GSLMultiFitDfPointer) (const gsl_vector *, void *, gsl_matrix *);  ; typedef void(* GSLMultiFitFdfPointer) (const gsl_vector *, void *, gsl_vector *, gsl_matrix *);  ; typedef double(* GSLMultiFitFPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef void(* GSLMultiMinDfPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef void(* GSLMultiMinFdfPointer) (const gsl_vector *, void *, double *, gsl_vector *);  ; typedef double(* GSLMultiMinFuncPointer) (const gsl_vector *, void *);  ; typedef void(* GSLMultiRootDfPointer) (const gsl_vector *, void *, gsl_matrix *);  ; typedef void(* GSLMultiRootFdfPointer) (const gsl_vector *, void *, gsl_vector *, gsl_matrix *);  ; typedef double(* GSLMultiRootFPointer) (const gsl_vector *, void *, gsl_vector *);  ; typedef GSLRngRanLuxS1 GSLRngRanLux1;  ; typedef GSLRngRanLuxS2 GSLRngRanLux2;  ; typedef GSLRngRanLuxD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:35805,integrat,integration,35805,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['integrat'],['integration']
Integrability,"WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::DoEvaldouble DoEval(const double *x) const overrideevaluate the function (re-implement for being more efficient)Definition WrappedParamFunction.h:213; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)Constructor a wrapped function from a pointer to a generic callable object implementation operator()(...Definition WrappedParamFunction.h:152; ROOT::Math::WrappedParamFunctionGen::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:200; ROOT::Math::WrappedParamFunctionGen::SetParValuesvoid SetParValues(unsigned int npar, const double *p) constDefinition WrappedParamFunction.h:281; ROOT::Math::WrappedParamFunctionGen::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:192; ROOT::Math::WrappedParamFunctionGen::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:198; ROOT::Math::WrappedParamFunctionGen::fParIndicesstd::vector< unsigned int > fParIndicesDefinition WrappedParamFunction.h:294; ROOT::Math::WrappedP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:11369,wrap,wrapped,11369,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,1,['wrap'],['wrapped']
Integrability,"Wrapper * fFunction;  ; double fRelTol;  ; double fResult;  ; GSLRngWrapper * fRng;  ; int fStatus;  ; MCIntegration::Type fType;  ; GSLMCIntegrationWorkspace * fWorkspace;  . #include <Math/GSLMCIntegrator.h>. Inheritance diagram for ROOT::Math::GSLMCIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer) (double *, size_t, void *). Definition at line 141 of file GSLMCIntegrator.h. ◆ Type. typedef MCIntegration::Type ROOT::Math::GSLMCIntegrator::Type. Definition at line 78 of file GSLMCIntegrator.h. Constructor & Destructor Documentation. ◆ GSLMCIntegrator() [1/3]. ROOT::Math::GSLMCIntegrator::GSLMCIntegrator ; (; MCIntegration::Type ; type = MCIntegration::kVEGAS, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; calls = 0 . ). explicit . constructor of GSL MCIntegrator. ; VEGAS MC is set as default integration type; Parameters. typetype of integration. The possible types are defined in the MCIntegration::Type enumeration Default is VEGAS ; absToldesired absolute Error (this parameter is actually not used and it can be ignored. The tolerance is fixed by the number of given calls) ; relToldesired relative Error (this parameter is actually not used and it can be ignored. The tolerance is fixed by the number of given calls) ; callsmaximum number of function calls. NOTE: When the default values are used , the options are taken from the static method of ROOT::Math::IntegratorMultiDimOptions ; Definition at line 73 of file GSLMCIntegrator.cxx. ◆ GSLMCIntegrator() [2/3]. ROOT::Math::GSLMCIntegrator::GSLMCIntegrator ; (; const char * ; type, . double ; absTol, . double ; relTol, . unsigned int ; calls . ). constructor of GSL MCIntegrator. ; VEGAS MC is set as default integration type; Parameters. typetype of integration using a char * (required by plug-in manager) ; absToldesired absolute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html:5321,integrat,integration,5321,doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMCIntegrator.html,1,['integrat'],['integration']
Integrability,"WrapperPdf::evaluate ; (; ); const. inlineoverrideprivatevirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 113 of file RooWrapperPdf.h. ◆ forceAnalyticalInt(). bool RooWrapperPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 56 of file RooWrapperPdf.h. ◆ getAnalyticalIntegral(). Int_t RooWrapperPdf::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 63 of file RooWrapperPdf.h. ◆ getAnalyticalIntegralWN(). Int_t RooWrapperPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 59 of file RooWrapperPdf.h. ◆ getMaxVal(). Int_t RooWrapperPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Get specialised generator. Since the underlying function is not a PDF, this will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:78307,integrat,integration,78307,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['integrat'],['integration']
Integrability,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t *i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t *i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t *l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t *l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t *l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t *l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t *f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t *d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void *obj, const type_info &typeinfo, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(void *obj, const char *className, const TClass* /* onFileClass */ ); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void *obj, const TClass *cl, const TClass* /* onfileClass */ ); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:38364,message,message,38364,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,1,['message'],['message']
Integrability,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); steram object to/from buffer. void StreamObject(TObject* obj); steram object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); steram object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferXML.html:40295,message,message,40295,root/html528/TBufferXML.html,https://root.cern,https://root.cern/root/html528/TBufferXML.html,6,['message'],['message']
Integrability,"Write array of UShort_t to buffer. void WriteFastArray(const Int_t* i, Int_t n); Write array of Int_t to buffer. void WriteFastArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteFastArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteFastArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteFastArray(const Long64_t* l, Int_t n); Write array of Long64_t to buffer. void WriteFastArray(const ULong64_t* l, Int_t n); Write array of ULong64_t to buffer. void WriteFastArray(const Float_t* f, Int_t n); Write array of Float_t to buffer. void WriteFastArray(const Double_t* d, Int_t n); Write array of Double_t to buffer. void WriteFastArrayFloat16(const Float_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Float16_t to buffer. void WriteFastArrayDouble32(const Double_t* d, Int_t n, TStreamerElement* ele = 0); Write array of Double32_t to buffer. void WriteFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. Int_t WriteFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0); Recall TBuffer function to avoid gcc warning message. void StreamObject(void* obj, const type_info& typeinfo, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(void* obj, const char* className, const TClass* onFileClass = 0); stream object to/from buffer. void StreamObject(TObject* obj); stream object to/from buffer. void StreamObject(void* obj, const TClass* cl, const TClass* onFileClass = 0); stream object to/from buffer. void ReadBool(Bool_t& b); Reads Bool_t value from buffer. void ReadChar(Char_t& c); Reads Char_t value from buffer. void ReadUChar(UChar_t& c); Reads UChar_t value from buffer. void ReadShort(Short_t& s); Reads Short_t value from buffer. void ReadUShort(UShort_t& s); Reads UShort_t value from buffer. void ReadInt(Int_t& i); Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:35721,message,message,35721,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['message'],['message']
Integrability,"WriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TMVA/PDEFoamKernelBase.h>. Inheritance diagram for TMVA::PDEFoamKernelBase:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ PDEFoamKernelBase() [1/2]. TMVA::PDEFoamKernelBase::PDEFoamKernelBase ; (; ). message logger ; Default constructor for streamer. ; Definition at line 51 of file PDEFoamKernelBase.cxx. ◆ PDEFoamKernelBase() [2/2]. TMVA::PDEFoamKernelBase::PDEFoamKernelBase ; (; const PDEFoamKernelBase & ; other). Copy constructor. ; Definition at line 60 of file PDEFoamKernelBase.cxx. ◆ ~PDEFoamKernelBase(). TMVA::PDEFoamKernelBase::~PDEFoamKernelBase ; (; ). virtual . Destructor. ; Definition at line 69 of file PDEFoamKernelBase.cxx. Member Function Documentation. ◆ Class(). static TClass * TMVA::PDEFoamKernelBase::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDEFoamKernelBase::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDEFoamKernelBase::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 57 of file PDEFoamKernelBase.h. ◆ DeclFileName(). static const char * TMVA::PDEFoamKernelBase::DeclFileName ; (; ). inlinestatic . ReturnsName of the fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelBase.html:10712,message,message,10712,doc/master/classTMVA_1_1PDEFoamKernelBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamKernelBase.html,1,['message'],['message']
Integrability,"WriteDelete; };. protected:. Double_t_epsAbsAbsolute precision; Double_t_epsRelRelative precision; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_useIntegrandLimitsUse limits in function binding?; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t*_x! do not persist; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooGaussKronrodIntegrator1D, its parameters and capabilities with RooNumIntConfig. RooGaussKronrodIntegrator1D(); Default constructor. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object. The integration; range is taken from the definition in the function binding. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object in the given range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with given function and configuration. Needed for RooNumIntFactory. Bool_t initialize(); Perform one-time initialization of integrator. ~RooGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussKronrodIntegrator1D.html:8047,integrat,integration,8047,root/html526/RooGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooGaussKronrodIntegrator1D.html,2,['integrat'],['integration']
Integrability,"X ang Y; NX - number of steps along X; NY - number of steps along Y. FUN(IX,IY,F,T) - external routine; IX - X number of the cell; IY - Y number of the cell; F(3,4) - face which corresponds to the cell; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IX; ICODES(2) - IY; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceFunction(Int_t ia, Int_t ib, Double_t* f, Double_t* t); Service function for Surfaces. void SurfacePolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in polar coordinates. Input: IORDR - order of variables (0 - R,PHI, 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:30163,rout,routine,30163,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,6,['rout'],['routine']
Integrability,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:33276,message,message,33276,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['message'],['message']
Integrability,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 353 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 993 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 364 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:32989,message,message,32989,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['message'],['message']
Integrability,"X11.; Definition at line 2152 of file TVirtualX.cxx. ◆ UnionRegion(). void TVirtualX::UnionRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). virtual . Computes the union of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2177 of file TVirtualX.cxx. ◆ UnmapWindow(). void TVirtualX::UnmapWindow ; (; Window_t ; id). virtual . Unmaps the specified window ""id"". ; If the specified window is already unmapped, this function has no effect. Any child window will no longer be visible (but they are still mapped) until another map call is made on the parent. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1027 of file TVirtualX.cxx. ◆ Update(). void TVirtualX::Update ; (; Int_t ; mode = 0). virtual . Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer. ; Flush flushes output buffer. Sync flushes buffer and waits till all requests have been processed by X server. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 2125 of file TVirtualX.cxx. ◆ UpdateWindow(). void TVirtualX::UpdateWindow ; (; Int_t ; mode). virtual . Updates or synchronises client and server once (not permanent). ; according to ""mode"".; Parameters. [in]modeupdate mode.; mode = 1 update; mode = 0 sync . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 955 of file TVirtualX.cxx. ◆ Warp(). void TVirtualX::Warp ; (; Int_t ; ix, . Int_t ; iy, . Window_t ; id = 0 . ). virtual . Sets the pointer position. ; Parameters. [in]ixnew X coordinate of pointer ; [in]iynew Y coordinate of pointer ; [in]idwindow identifier. Coordinates are relative to the origin of the window id or to the origin of the current window if id == 0. ; Reimplemented in TGWin32, TGWin32VirtualXP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:136613,synchroniz,synchronizes,136613,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['synchroniz'],['synchronizes']
Integrability,"Xmin;  lower value of the domain ;  . #include <TUnuranContDist.h>. Inheritance diagram for TUnuranContDist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TUnuranContDist() [1/5]. TUnuranContDist::TUnuranContDist ; (; TF1 * ; pdf = nullptr, . TF1 * ; deriv = nullptr, . bool ; isLogPdf = false . ). explicit . Constructor from a TF1 objects specifying the pdf and optionally from another function representing the derivative of the pdf. ; The flag isLogPdf can be used to pass instead of the pdf (and its derivative) the log (and the derivative of the log) of the pdf. By default the distribution has not domain set (it is defined between [-inf,+inf], no mode, no pdf area and no cdf explicitly defined. UnuRan, if needed, can compute some of this quantities, but the user if they know them can set them in order to speed up the algorithm. For example in case of the Cdf, if the user has not set it, a numerical integration algorithm is used to estimate the Cdf from the Pdf. ; Definition at line 64 of file TUnuranContDist.cxx. ◆ TUnuranContDist() [2/5]. TUnuranContDist::TUnuranContDist ; (; TF1 * ; pdf, . TF1 * ; deriv, . TF1 * ; cdf, . bool ; isLogPdf = false . ). Constructor as above but with the possibility to pass also the Cdf. ; In case an algorithm requiring only the Cdf (no Pdf), one can use this constructor passing nullptr for Pdf and derivative of the Pdf ; Definition at line 46 of file TUnuranContDist.cxx. ◆ TUnuranContDist() [3/5]. TUnuranContDist::TUnuranContDist ; (; const ROOT::Math::IGenFunction & ; pdf, . const ROOT::Math::IGenFunction * ; dpdf = nullptr, . bool ; isLogPdf = false, . bool ; copyFunc = false . ). explicit . Constructor as before but from a generic function object interface for one-dim functions. ; Definition at line 42 of file TUnuranContDist.cxx. ◆ TUnuranContDist() [4/5]. TUnuranContDist::TUnuranContDist ; (; const ROOT::Math::IGenFunction * ; pdf, . cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranContDist.html:6289,integrat,integration,6289,doc/master/classTUnuranContDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranContDist.html,1,['integrat'],['integration']
Integrability,"Y, double rho, double& x, double& y) const; doubleGaussianRatio(double sigma) const; doubleGaussianTail(double a, double sigma) const; doubleGaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineGSLRandomEngine(); ROOT::Math::GSLRandomEngineGSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineGSLRandomEngine(const ROOT::Math::GSLRandomEngine&); voidInitialize(); doubleLandau() const; doubleLogNormal(double zeta, double sigma) const; vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p) const; stringName() const; doubleoperator()() const; ROOT::Math::GSLRandomEngine&operator=(const ROOT::Math::GSLRandomEngine&); unsigned intPoisson(double mu) const; voidRandomArray(double* begin, double* end) const; unsigned intRndmInt(unsigned int max) const; voidSetSeed(unsigned int seed) const; unsigned intSize() const; doubletDist(double nu) const; voidTerminate(). Data Members; private:. unsigned intfCurTimecurrent time used to seed the generator; ROOT::Math::GSLRngWrapper*fRngpointer to GSL generator wrapper. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). {}. void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is excluded and 1 is included. unsigned int RndmInt(unsigned int max) const. Generate an integer number between [0,max-1] (including 0 and max-1); if max is larger than available range of algorithm; an error message is printed and zero is returned. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLRandomEngine.html:2446,wrap,wrapper,2446,root/html526/ROOT__Math__GSLRandomEngine.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLRandomEngine.html,1,['wrap'],['wrapper']
Integrability,"YChi2Var& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Mon Dec 7 13:49:53 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:41715,integrat,integration,41715,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"YS/tutorials (or sub-directories) by setting your current directory in the script directory or from any user directory with write access.; Several tutorials create new files. If you have write access to the tutorials directory, the new files will be created in the tutorials directory, otherwise they will be created in the user directory.; You can start by executing the standard ROOT demos with a session like:; root > .x demos.C; or; root > .x $ROOTSYS/tutorials/demos.C; You can execute the standard ROOT graphics benchmark with; root > .x benchmarks.C; or; root > .x $ROOTSYS/tutorials/benchmarks.C; The $ROOTSYS/tutorials directory includes several sub-directories: . Modules;  Histograms tutorials;  Examples showing the ""histograms' classes"" usage. ;  ;  Tree tutorials;  Example code which illustrates how to use ROOT trees and ntuples. ;  ;  Dataframe tutorials;  These examples show various features of RDataFrame: ROOT's declarative analysis interface. ;  ;  ROOT 7 tutorials;  Various examples showing the ROOT 7 interface. ;  ;  FOAM tutorials;  Examples showing how to use FOAM. ;  ;  Containers tutorials;  Examples showing the ""containers' classes"" usage. ;  ;  Event display tutorials;  Examples showing the ""Event display classes"" usage. ;  ;  Event display ROOT7 tutorials;  Examples showing the ""Event display classes"" usage with ROOT7. ;  ;  Geometry tutorials;  Various ROOT geometry package examples. ;  ;  Fast Fourier Transforms tutorials;  Example showing the Fast Fourier Transforms interface in ROOT. ;  ;  Fit Tutorials;  These tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code. ;  ;  RooFit Tutorials;  These tutorials illustrate the main features of RooFit: the name of the examples and their short description help in figuring out their objective. ;  ;  Graphs tutorials;  Examples showing the ""graphs classes"" usage. ;  ;  Graphics tutorials;  Various examples showing the basic ROOT graphics. ;  ;  O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Tutorials.html:1288,interface,interface,1288,doc/master/group__Tutorials.html,https://root.cern,https://root.cern/doc/master/group__Tutorials.html,1,['interface'],['interface']
Integrability,"YS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPRegexpDefinition TPRegexp.h:36; TPRegexp::MatchBBool_t MatchB(const TString &s, const TString &mods="""", Int_t start=0, Int_t nMaxMatch=10)Definition TPRegexp.h:78; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:38703,message,message,38703,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['message'],['message']
Integrability,"Z != nullptr);; 2703 ; 2704 Int_t outmin = outAxis->GetFirst();; 2705 Int_t outmax = outAxis->GetLast();; 2706 // GetFirst, GetLast can return underflow or overflow bins; 2707 // correct for underflow/overflows; 2708 if (useUF && !outAxis->TestBit(TAxis::kAxisRange) ) outmin -= 1;; 2709 if (useOF && !outAxis->TestBit(TAxis::kAxisRange) ) outmax += 1;; 2710 ; 2711 TArrayD & binSumw2 = *(p2->GetBinSumw2());; 2712 if (useWeights && binSumw2.fN <= 0) useWeights = false;; 2713 if (!useWeights) p2->SetBit(TH1::kIsNotW);; 2714 ; 2715 // Call specific method for the projection; 2716 for (ixbin=0;ixbin<=1+projX->GetNbins();ixbin++) {; 2717 if ( (ixbin < ixmin || ixbin > ixmax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2718 for ( iybin=0;iybin<=1+projY->GetNbins();iybin++) {; 2719 if ( (iybin < iymin || iybin > iymax) && projX->TestBit(TAxis::kAxisRange)) continue;; 2720 ; 2721 // profile output bin; 2722 Int_t poutBin = p2->FindBin(projY->GetBinCenter(iybin), projX->GetBinCenter(ixbin));; 2723 if (poutBin <0) continue;; 2724 // loop on the bins to be integrated (outbin should be called inbin); 2725 for (outbin = outmin; outbin <= outmax; outbin++) {; 2726 ; 2727 Int_t bin = GetBin(*refX,*refY,*refZ);; 2728 ; 2729 //DoFillProfileProjection(p2, *projY, *projX, *outAxis, iybin, ixbin, outbin, bin, useWeights);; 2730 ; 2731 Double_t cont = RetrieveBinContent(bin);; 2732 if (!cont) continue;; 2733 ; 2734 Double_t tmp = 0;; 2735 // the following fill update wrongly the fBinSumw2- need to save it before; 2736 if ( useWeights ) tmp = binSumw2.fArray[poutBin];; 2737 p2->Fill( projY->GetBinCenter(iybin) , projX->GetBinCenter(ixbin), outAxis->GetBinCenter(outbin), cont);; 2738 if (useWeights ) binSumw2.fArray[poutBin] = tmp + fSumw2.fArray[bin];; 2739 ; 2740 }; 2741 }; 2742 }; 2743 ; 2744 // recompute statistics for the projected profiles; 2745 // forget about preserving old statistics; 2746 bool resetStats = true;; 2747 Double_t stats[kNstat];; 2748 // reset statistics; 2749 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:107880,integrat,integrated,107880,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['integrat'],['integrated']
Integrability,"Zombie(). private:. TFTP(); TFTP(const TFTP&); voidInit(const char* url, Int_t parallel, Int_t wsize); voidoperator=(const TFTP&); voidPrintError(const char* where, Int_t err) const; Int_tRecv(Int_t& status, EMessageTypes& kind) const; voidSetMode(Int_t mode). Data Members; public:. enum { kDfltBlockSize; kDfltWindowSize; kBinary; kAscii; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBlockSizesize of data buffer used to transfer; Long64_tfBytesReadnumber of bytes received; Long64_tfBytesWritenumber of bytes sent; TStringfCurrentFilefile currently being get or put; Bool_tfDirIndicates if a remote directory is open; TStringfHostFQDN of remote host; Int_tfLastBlocklast block successfully transfered; Int_tfModebinary or ascii file transfer mode; Int_tfParallelnumber of parallel sockets; Int_tfPortport to which to connect; Int_tfProtocolrootd protocol level; Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:7398,protocol,protocol,7398,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,4,['protocol'],['protocol']
Integrability,"Zombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooDataHist_dh; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:35169,integrat,integration,35169,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,2,['integrat'],['integration']
Integrability,"[#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_pxData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2) Calculating sum-of-weights-squared correction matrix for covariance matrix; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:NumericIntegration -- RooRealIntegral::init(genPdf_Int[x]) using numeric integrator RooIntegrator1D to calculate Int(x); [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_p2_over_p2_Int[x]_genPdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(p2_over_p2_Int[x]) fixing normalization set for coefficien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf403__weightedevts_8C.html:11696,integrat,integrator,11696,doc/master/rf403__weightedevts_8C.html,https://root.cern,https://root.cern/doc/master/rf403__weightedevts_8C.html,2,['integrat'],['integrator']
Integrability,"[0], eta[0], phi[0], e[0]};; ROOT::Math::PtEtaPhiEVector p2{pt[1], eta[1], phi[1], e[1]};; ROOT::Math::PtEtaPhiEVector p3{pt[2], eta[2], phi[2], e[2]};; ROOT::Math::PtEtaPhiEVector p4{pt[3], eta[3], phi[3], e[3]};; return 0.001 * (p1 + p2 + p3 + p4).M();; }; """"""; ); ; df = df.Define(""m4l"", ""ComputeInvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); ; # Save data for statistical analysis tutorial (rf618_mixture_models.py) ; df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); ; # Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); histos = []; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; histos.append(; df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; ""m4l"",; ""weight"",; ); ); ; # Evaluate the systematic uncertainty; ; # The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; # kinematics such as pT or pseudorapidity.; # Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; # Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; # The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; ; # Create a VaryHelper to interpolate the available data.; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT::VecOps;; ; class VaryHelper; {; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph;; ; public:; VaryHelper() : graph(x.size(), x.data(), y.data()) {}; RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:6654,depend,depends,6654,doc/master/df106__HiggsToFourLeptons_8py.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html,1,['depend'],['depends']
Integrability,"[2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.01562 , s = 4.5; [5] h = 0.003906 , s = 3.75; [6] h = 0.0009766 , s = 4.125; [7] h = 0.0002441 , s = 3.938; [8] h = 6.104e-05 , s = 4.031; [9] h = 1.526e-05 , s = 3.984; [10] h = 3.815e-06 , s = 4.008; [11] h = 9.537e-07 , s = 3.996; [12] h = 2.384e-07 , s = 4.002; [13] h = 5.96e-08 , s = 3.999; [14] h = 1.49e-08 , s = 4; [15] h = 3.725e-09 , s = 4; [16] h = 9.313e-10 , s = 4; [17] h = 2.328e-10 , s = 4; [18] h = 5.821e-11 , s = 4; [19] h = 1.455e-11 , s = 4; [20] h = 3.638e-12 , s = 4; ; prevFCN = 2171.25988 mean=-1.438, ; prevFCN = 2171.25988 mean=1.465, ; prevFCN = 2171.25988 mean=-1.465, ; prevFCN = 2171.25988 mean=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.1921; ; prevFCN = 2171.25988 a=2.017, ; prevFCN = 2171.25988 a=1.983, ; prevFCN = 2171.25988 a=2.172, ; prevFCN = 2171.691427 a=1.84, [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.01562 , s = 4.5; [5] h = 0.003906 , s = 3.75; [6] h = 0.0009766 , s = 3.375; [7] h = 0.0002441 , s = 3.562; [8] h = 6.104e-05 , s = 3.656; [9] h = 1.526e-05 , s = 3.703; [10] h = 3.815e-06 , s = 3.68; [11] h = 9.537e-07 , s = 3.691; [12] h = 2.384e-07 , s = 3.686; [13] h = 5.96e-08 , s = 3.683; [14] h = 1.49e-08 , s = 3.681; [15] h = 3.725e-09 , s = 3.68; [16] h = 9.313e-10 , s = 3.68; [17] h = 2.328e-10 , s = 3.68; [18] h = 5.821e-11 , s = 3.68; [19] h = 1.455e-11 , s = 3.68; [20] h = 3.638e-12 , s = 3.68; [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:29200,synchroniz,synchronize,29200,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,2,['synchroniz'],['synchronize']
Integrability,"[] (size_t sz);  ; void * operator new[] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:24654,message,message,24654,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,38,['message'],['message']
Integrability,"[] (size_t sz);  ; void * operator new[] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostream &out, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:33523,message,message,33523,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['message'],['message']
Integrability,"[](). RooAbsCategory::value_type & RooCategory::operator[] ; (; const std::string & ; stateName). Access a named state. ; If a state with this name doesn't exist yet, the state is assigned the next available positive integer. Parameters. [in]stateNameName of the state to be accessed. . ReturnsReference to the category index. If no state exists, it will be created on the fly. ; Definition at line 256 of file RooCategory.cxx. ◆ readFromStream(). bool RooCategory::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from given stream. ; If token is a decimal digit, try to find a corresponding state for it. If that succeeds, the state denoted by this index is used. Otherwise, interpret it as a label. ; Reimplemented from RooAbsCategory.; Definition at line 288 of file RooCategory.cxx. ◆ recomputeShape(). void RooCategory::recomputeShape ; (; ). inlineoverrideprotectedvirtual . This category's shape does not depend on others, and does not need recomputing. ; Implements RooAbsCategory.; Definition at line 124 of file RooCategory.h. ◆ setIndex() [1/3]. bool RooAbsCategoryLValue::setIndex ; (; const std::pair< std::string, value_type > & ; nameIdxPair, . bool ; printError = true . ). inline . Change category state to state specified by another category state. ; If printError is set, a message will be printed if the specified index does not represent a valid state. NoteThe state name of the other category is ignored. ; Returnsbool to signal an error. ; Definition at line 48 of file RooAbsCategoryLValue.h. ◆ setIndex() [2/3]. bool RooCategory::setIndex ; (; Int_t ; index, . bool ; printError = true . ). overridevirtual . Set value by specifying the index code of the desired state. ; If printError is set, a message will be printed if the specified index does not represent a valid state. Returnsbool signalling if an error occurred. ; Implements RooAbsCategoryLValue.; Definition at line 164 of file RooCat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:61550,depend,depend,61550,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['depend'],['depend']
Integrability,"[in] v2Name The name of the column that will fill the y axis.; 2028 /// \param[in] v3Name The name of the column that will fill the z axis.; 2029 /// \return the tridimensional histogram wrapped in a RResultPtr.; 2030 ///; 2031 /// This action is *lazy*: upon invocation of this method the calculation is; 2032 /// booked but not executed. Also see RResultPtr.; 2033 ///; 2034 /// ### Example usage:; 2035 /// ~~~{.cpp}; 2036 /// // Deduce column types (this invocation needs jitting internally); 2037 /// auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; 2038 /// ""myValueX"", ""myValueY"", ""myValueZ"");; 2039 /// // Explicit column types; 2040 /// auto myHist2 = myDf.Histo3D<double, double, float>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; 2041 /// ""myValueX"", ""myValueY"", ""myValueZ"");; 2042 /// ~~~; 2043 ///; 2044 /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; 2045 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 2046 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 2047 template <typename V1 = RDFDetail::RInferredType, typename V2 = RDFDetail::RInferredType,; 2048 typename V3 = RDFDetail::RInferredType>; 2049 RResultPtr<::TH3D> Histo3D(const TH3DModel &model, std::string_view v1Name = """", std::string_view v2Name = """",; 2050 std::string_view v3Name = """"); 2051 {; 2052 std::shared_ptr<::TH3D> h(nullptr);; 2053 {; 2054 ROOT::Internal::RDF::RIgnoreErrorLevelRAII iel(kError);; 2055 h = model.GetHistogram();; 2056 }; 2057 if (!RDFInternal::HistoUtils<::TH3D>::HasAxisLimits(*h)) {; 2058 throw std::runtime_error(""3D histograms with no axes limits are not supported yet."");; 2059 }; 2060 const std::vector<std::string_view> columnViews = {v1Name, v2Name, v3Name};; 2061 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2062 ? Column",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:114755,interface,interfaces,114755,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['interface'],['interfaces']
Integrability,"\); aund this is using the previous expressions for \( W_\mathrm{expect} \) and \( W_\mathrm{observed} \):; \( \sum w_{i}^2 / \sum w_{i} \cdot N_\mathrm{expect} - \sum w_{i}^2 \cdot \log{W_\mathrm{expect}} \); Since the weights are constants in the likelihood we can use \(\log{N_\mathrm{expect}}\) instead of \(\log{W_\mathrm{expect}}\).; See also RooAbsPdf::extendedTerm(RooAbsData const& data, bool weightSquared, bool doOffset), which takes a dataset to extract \(N_\mathrm{observed}\) and the normalization set. ; Definition at line 725 of file RooAbsPdf.cxx. ◆ extendedTerm() [3/3]. double RooAbsPdf::extendedTerm ; (; RooAbsData const & ; data, . bool ; weightSquared, . bool ; doOffset = false . ); const. Return the extended likelihood term ( \( N_\mathrm{expect} - N_\mathrm{observed} \cdot \log(N_\mathrm{expect} \)) of this PDF for the given number of observed events. ; This function is a wrapper around RooAbsPdf::extendedTerm(double, RooArgSet const *, double, bool) const, where the number of observed events and observables to be used as the normalization set for the pdf is extracted from a RooAbsData.; For successful operation, the PDF implementation must indicate that it is extendable by overloading canBeExtended(), and must implement the expectedEvents() function.; Parameters. [in]dataThe RooAbsData to retrieve the set of observables and number of expected events. ; [in]weightSquaredIf set to true, the extended term will be scaled by the ratio of squared event weights over event weights: \( \sum w_{i}^2 / \sum w_{i} \). Intended to be used by fits with the SumW2Error() option that can be passed to RooAbsPdf::fitTo() (see the documentation of said function to learn more about the interpretation of fits with squared weights). ; [in]doOffsetSee RooAbsPdf::extendedTerm(double, RooArgSet const*, double, bool) const. . Definition at line 793 of file RooAbsPdf.cxx. ◆ extendMode(). virtual ExtendMode RooAbsPdf::extendMode ; (; ); const. inlinevirtual . Returns ability o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:102315,wrap,wrapper,102315,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['wrap'],['wrapper']
Integrability,"] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:14784,message,message,14784,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['message'],['message']
Integrability,"] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSpline1.html:9226,message,message,9226,doc/master/classTMVA_1_1TSpline1.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSpline1.html,3,['message'],['message']
Integrability,"] - 6.22 PyROOT seg faults when accessing array members; [#6675] - Jitted RDataFrame.Histo1D broken for vector<bool> types; [#6465] - ROOT signed-char conversion issue on AARCH64; [#6666] - TClass::GetListOfDataMembers returns an empty list even-though the information is available.; [#6725] - rootpcm does not record TEnum’s underlying type; [#6726] - TStreamerInfo::GenerateInfoForPair generates the wrong offset if an enum type is first.; [#6670] - segfault in TClass::InheritsFrom() depending on linking order; [#6443] - Spurrious auto-parsing (as seen with CMS file and libraries); [#6509] - [ROOT I/O] Warning: writing 1 byte into a region of size 0; [#6597] - pytest shipped in roottest is not compatible with py3.9; [#6677] - [bug] Clang builds ROOT libraries that emit FPEs; [#6784] - external nlohmann/json.hpp is not forwarded as dependency or should be linked PRIVATE?; [#6523] - TBufferMerger cannot handle TTree spanning over multiple files; [#6743] - ROOT crashes with no helpful error messages if a TApplication is not present and tree->StartViewer() is called; [#6840] - TClass for pair sometimes have the wrong offset/size; [#6839] - Compilation fails on macosx 11.0 with arm processor; [#6838] - build/unix/compiledata.sh assumes macOS will always have major version 10; [#6817] - macOS packaging broken in master; [#6856] - error when creating a python class inheriting from a ROOT class, 6.22/02; [#6797] - TCling::UpdateListOfLoadedSharedLibraries() Linux thread safety; [#6483] - [GUI] Crashes when creating TGClient in a standalone application; [#6563] - Test failures on MacOS with Xcode 12; [#6624] - TRandom: signature mismatch between getter and setter; [#6815] - PowerShell version of thisroot.bat; [#6853] - [DF] SaveGraph can be confused by shared upstream Defines; [#6731] - Compilation error on CentOS 7 of root V6.22.02 c++17; [#6974] - pyROOT doesn’t work with ipyparallel; [#6964] - [TTree] GetLeaf ignores the branchname arg if friend trees are present; [#6944] -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:41439,depend,dependency,41439,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,2,"['depend', 'message']","['dependency', 'messages']"
Integrability,"] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); For more graph examples see the scripts: $ROOTSYS/tutorials directory graph.C, gerrors.C, zdemo.C, and gerrors2.C. A graph with axis titles. 4.14 Zooming a Graph; To zoom a graph you can create a histogram with the desired axis range first. Draw the empty histogram and then draw the graph using the existing axis from the histogram.; {; c1 = new TCanvas(""c1"",""A Zoomed Graph"",200,10,700,500);; hpx = new TH2F(""hpx"",""Zoomed Graph Example"",10,0,0.5,10,1.0,8.0);; hpx->SetStats(kFALSE); // no statistics; hpx->Draw();; Int_t n = 10;; Double_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; gr = new TGraph(n,x,y);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(20);; gr->Draw(""LP"");// and draw it without an axis; }; The next example is the same graph as above with a zoom in the x and y directions. A zoomed graph. 4.15 The User Interface for Graphs; The class TGraphEditor provides the user interface for setting the following graph attributes interactively:. Title text entry field … sets the title of the graph.; Shape radio button group - sets the graph shapes:. No Line: draw unconnected points;; Smooth Line: a smooth curve;; Simple Line: a simple poly-line;; Bart Chart: a bar chart at each point.; Fill Area: a fill area is drawn. Show Marker - sets markers as visible or invisible.; Exclusion Zone - specifies the exclusion zone parameters :. ’+-‘ check button: sets on which side of the line the exclusion zone will be drawn;; Width combo box: defines the width of the zone. 5 Fitting Histograms; To fit a histogram you can use the Fit Panel on a visible histogram via the context menu, or you can use the TH1::Fit method. The Fit Panel, which is limited, is best for prototyping. The histogram needs to be drawn in a pad before the Fit Panel is invoked. The method TH1::Fit is more powerful and is used in scripts and programs.; 5.1 The Fit Method; The Fit method is implemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:162644,interface,interface,162644,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. G__dictpositionfDictPosCINT dictionary context after init; G__dictpositionfDictPosGlobalsCINT dictionary context after ResetGlobals(); Int_tfExitCodevalue passed to exit() in interpreter; TStringfIncludePathlist of CINT include paths; Bool_tfLockProcessLinetrue if ProcessLine should lock gCINTMutex; TEnv*fMapfilemap of classes and libraries; Int_tfMore1 if more input is required; charfPrompt[64]proposed prompt string; TObjArray*fRootmapFileslist of non-default rootmap files loaded; TStringfRootmapLoadPathdynamic load path used for loading rootmap files; TStringfSharedLibslist of shared libraries loaded by G__loadfile; static void*fgSetOfSpecialsset of TObject*s used in CINT variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCint(const char* name, const char* title); Initialize the CINT interpreter interface. ~TCint(); Destroy the CINT interpreter interface. void ClearFileBusy(); Reset CINT internal state in case a previous action was not correctly; terminated by G__init_cint() and G__dlmod(). void ClearStack(); Delete existing temporary values. Int_t InitializeDictionaries(); Initialize all registered dictionaries. Normally this is already done; by G__init_cint() and G__dlmod(). void EnableWrappers(bool value = true); Enable call wrappers (also known as stubs) if value is true;; disable if value is false. void EnableAutoLoading(); Enable the automatic loading of shared libraries when a class; is used that is stored in a not yet loaded library. Uses the; information stored in the class/library map (typically; $ROOTSYS/etc/system.rootmap). void EndOfLineAction(); It calls a ""fantom"" method to synchronize user keyboard input; and ROOT prompt line. Bool_t IsLoaded(const char* filename) const; Return true if the file has already been loade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:19457,interface,interface,19457,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,1,['interface'],['interface']
Integrability,"], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void Release",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:58441,integrat,integration,58441,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['integrat'],['integration']
Integrability,"], e[1]};; 135 ROOT::Math::PtEtaPhiEVector p3{pt[2], eta[2], phi[2], e[2]};; 136 ROOT::Math::PtEtaPhiEVector p4{pt[3], eta[3], phi[3], e[3]};; 137 return 0.001 * (p1 + p2 + p3 + p4).M();; 138}; 139""""""; 140); 141 ; 142df = df.Define(""m4l"", ""ComputeInvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); 143 ; 144# Save data for statistical analysis tutorial (rf618_mixture_models.py) ; 145df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); 146 ; 147# Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7446,depend,depends,7446,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['depend'],['depends']
Integrability,"],[binz1,binz2] for a 3-D histogra...Definition TH3.cxx:1421; TH3::ProjectionZvirtual TH1D * ProjectionZ(const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along Z.Definition TH3.cxx:1812; TH3::ProjectionXvirtual TH1D * ProjectionX(const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") constProject a 3-D histogram into a 1-D histogram along X.Definition TH3.cxx:1747; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::Classstatic TClass * Class(); TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; TH3::GetBinWithContent3virtual Double_t GetBinWithContent3(Double_t c, Int_t &binx, Int_t &biny, Int_t &binz, Int_t firstx=0, Int_t lastx=0, Int_t firsty=0, Int_t lasty=0, Int_t firstz=0, Int_t lastz=0, Double_t maxdiff=0) constCompute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,...Definition TH3.cxx:1151; TH3::DoFillProfileProjectionvoid DoFillProfileProjection(TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) constinternal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile...Definition TH3.cxx:2550; TH3::RebinZvirtual TH3 * RebinZ(Int_t ngroup=2, const char *newname="""")Rebin only the Z axis see Rebin3D.Definition TH3.cxx:2926; TH3::Streamervoid Streamer(TBuffer &) overrideStream an object of class TH3.Definition TH3.cxx:3481",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:208778,depend,depending,208778,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['depend'],['depending']
Integrability,"]. ; Definition at line 1806 of file TColor.cxx. ◆ RGB2HSV(). void TColor::RGB2HSV ; (; Float_t ; r, . Float_t ; g, . Float_t ; b, . Float_t & ; hue, . Float_t & ; satur, . Float_t & ; value . ). static . Static method to compute HSV from RGB. . The input values:; r,g,b triplet is between [0,1]. The returned values:; The hue value runs from 0 to 360.; The saturation is the degree of strength or purity and is from 0 to 1. Purity is how much white is added to the color, so S=1 makes the purest color (no white).; Brightness value also ranges from 0 to 1, where 0 is the black. . Definition at line 1771 of file TColor.cxx. ◆ RGB2Pixel() [1/2]. ULong_t TColor::RGB2Pixel ; (; Float_t ; r, . Float_t ; g, . Float_t ; b . ). static . Convert r,g,b to graphics system dependent pixel value. ; The r,g,b triplet must be [0,1]. ; Definition at line 2453 of file TColor.cxx. ◆ RGB2Pixel() [2/2]. ULong_t TColor::RGB2Pixel ; (; Int_t ; r, . Int_t ; g, . Int_t ; b . ). static . Convert r,g,b to graphics system dependent pixel value. ; The r,g,b triplet must be [0,255]. ; Definition at line 2475 of file TColor.cxx. ◆ RGBtoHLS(). static void TColor::RGBtoHLS ; (; Float_t ; r, . Float_t ; g, . Float_t ; b, . Float_t & ; h, . Float_t & ; l, . Float_t & ; s . ). inlinestatic . Definition at line 82 of file TColor.h. ◆ SaveColor(). Bool_t TColor::SaveColor ; (; std::ostream & ; out, . Int_t ; ci . ). static . Save a color with index > 228 as a C++ statement(s) on output stream out. ; Return kFALSE if color not saved in the output stream ; Definition at line 2543 of file TColor.cxx. ◆ SetAlpha(). virtual void TColor::SetAlpha ; (; Float_t ; a). inlinevirtual . Definition at line 70 of file TColor.h. ◆ SetColorThreshold(). void TColor::SetColorThreshold ; (; Float_t ; t). static . This method specifies the color threshold used by GetColor to retrieve a color. ; Parameters. [in]tColor threshold. By default is equal to 1./31. or 1./255. depending on the number of available color planes. When Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:64536,depend,dependent,64536,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['depend'],['dependent']
Integrability,"]. ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder ; (; const char * ; name = nullptr). Definition at line 85 of file GSLMultiRootFinder.cxx. ◆ ~GSLMultiRootFinder(). ROOT::Math::GSLMultiRootFinder::~GSLMultiRootFinder ; (; ). virtual . destructor ; Definition at line 95 of file GSLMultiRootFinder.cxx. ◆ GSLMultiRootFinder() [4/5]. ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder ; (; const GSLMultiRootFinder & ; ). delete . ◆ GSLMultiRootFinder() [5/5]. ROOT::Math::GSLMultiRootFinder::GSLMultiRootFinder ; (; GSLMultiRootFinder && ; ). delete . Member Function Documentation. ◆ AddFunction() [1/2]. int ROOT::Math::GSLMultiRootFinder::AddFunction ; (; const ROOT::Math::IMultiGenFunction & ; func). Definition at line 110 of file GSLMultiRootFinder.cxx. ◆ AddFunction() [2/2]. template<class Function > . int ROOT::Math::GSLMultiRootFinder::AddFunction ; (; Function & ; f, . int ; ndim . ). inline . same method as before but using any function implementing the operator(), so can be wrapped in a IMultiGenFunction interface ; Definition at line 193 of file GSLMultiRootFinder.h. ◆ Clear(). void ROOT::Math::GSLMultiRootFinder::Clear ; (; ). clear list of functions ; Definition at line 127 of file GSLMultiRootFinder.cxx. ◆ ClearFunctions(). void ROOT::Math::GSLMultiRootFinder::ClearFunctions ; (; ). protected . Definition at line 118 of file GSLMultiRootFinder.cxx. ◆ Dim(). unsigned int ROOT::Math::GSLMultiRootFinder::Dim ; (; ); const. inline . return the number of sunctions set in the class. ; The number must be equal to the dimension of the functions ; Definition at line 203 of file GSLMultiRootFinder.h. ◆ Dx(). const double * ROOT::Math::GSLMultiRootFinder::Dx ; (; ); const. return the last step size ; Definition at line 139 of file GSLMultiRootFinder.cxx. ◆ FVal(). const double * ROOT::Math::GSLMultiRootFinder::FVal ; (; ); const. return the function values f(X) solving the system i.e. ; they must be close to zero at the solution ; Definition at line 143 of file GSLM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html:7629,wrap,wrapped,7629,doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootFinder.html,2,"['interface', 'wrap']","['interface', 'wrapped']"
Integrability,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151186,message,message,151186,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,3,['message'],"['message', 'messages']"
Integrability,"]=20:NSmoothBkg[0]=20:NSmooth=5:NAvEvtPerBin=50:VarTransform=Decorrelate"" );; 342 ; 343 // PCA-transformed likelihood; 344 if (Use[""LikelihoodPCA""]); 345 factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodPCA"",; 346 ""!H:!V:!TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmooth=5:NAvEvtPerBin=50:VarTransform=PCA"" );; 347 ; 348 // Use a kernel density estimator to approximate the PDFs; 349 if (Use[""LikelihoodKDE""]); 350 factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; 351 ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; 352 ; 353 // Use a variable-dependent mix of splines and kernel density estimator; 354 if (Use[""LikelihoodMIX""]); 355 factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodMIX"",; 356 ""!H:!V:!TransformOutput:PDFInterpolSig[0]=KDE:PDFInterpolBkg[0]=KDE:PDFInterpolSig[1]=KDE:PDFInterpolBkg[1]=KDE:PDFInterpolSig[2]=Spline2:PDFInterpolBkg[2]=Spline2:PDFInterpolSig[3]=Spline2:PDFInterpolBkg[3]=Spline2:KDEtype=Gauss:KDEiter=Nonadaptive:KDEborder=None:NAvEvtPerBin=50"" );; 357 ; 358 // Test the multi-dimensional probability density estimator; 359 // here are the options strings for the MinMax and RMS methods, respectively:; 360 //; 361 // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; 362 // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; 363 if (Use[""PDERS""]); 364 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; 365 ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600"" );; 366 ; 367 if (Use[""PDERSD""]); 368 factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSD"",; 369 ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=Decorrelate"" );; 370 ; 371 if (Use[""PDERSPCA""]); 372 factory->BookMethod( da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C_source.html:16229,depend,dependent,16229,doc/master/TMVAClassification_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C_source.html,1,['depend'],['dependent']
Integrability,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1197 // an array with parameter values; 1198 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1199 der = rd.Derivative2(wf, x, h);; 1200 }; 1201 ; 1202 gErrorTF1 = rd.Error();; 1203 ; 1204 return der;; 1205}; 1206 ; 1207 ; 1208////////////////////////////////////////////////////////////////////////////////; 1209/// Returns the third derivative of the function at point x,; 1210/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1211/// to compute a third, more accurate estimation); 1212/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1213/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:42955,wrap,wrapper,42955,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1262 // an array with parameter values; 1263 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1264 der = rd.Derivative3(wf, x, h);; 1265 }; 1266 ; 1267 gErrorTF1 = rd.Error();; 1268 return der;; 1269 ; 1270}; 1271 ; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Static function returning the error of the last call to the of Derivative's; 1275/// functions; 1276 ; 1277Double_t TF1::DerivativeError(); 1278{; 1279 return gErrorTF1;; 1280}; 1281 ; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Compute distance from point px,py to a function.; 1285///; 1286/// Compute the closest distance of approach from point px,py to this; 1287/// function. The distance is computed in pixels units.; 1288///; 1289/// Note that px is called with a negative value when the TF1 is in; 1290/// TGraph or TH1 list of functions. In this case there is no point; 1291/// looking at the histogram axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:45579,wrap,wrapper,45579,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"^{o}"");; t1->Draw();; return Ta;; }. Text Color; The text color is a color index (integer) pointing in the ROOT; color table.; The text color of any class inheriting from TAttText can; be changed using the method SetTextColor and retrieved using the; method GetTextColor.; The following table shows the first 50 default colors. Picture; Source. {; TCanvas *c = new TCanvas(""c"",""Text colors"",0,0,500,200);; c.DrawColorTable();; return c;; }. Text Size; If the text precision (see next paragraph) is smaller than 3, the text; size (textsize) is a fraction of the current pad size. Therefore the; same textsize value can generate text outputs with different absolute; sizes in two different pads.; The text size in pixels (charheight) is computed the following way:. pad_width = gPad->XtoPixel(gPad->GetX2());; pad_height = gPad->YtoPixel(gPad->GetY1());; if (pad_width < pad_height) charheight = textsize*pad_width;; else charheight = textsize*pad_height;. If the text precision is equal to 3, the text size doesn't depend on the pad's; dimensions. A given textsize value always generates the same absolute; size. The text size (charheight) is given in pixels:. charheight = textsize;. Note that to scale fonts to the same size as the old True Type package a; scale factor of 0.93376068 is apply to the text size before drawing. The text size of any class inheriting from TAttText can; be changed using the method SetTextSize and retrieved using the; method GetTextSize.; Text Font and Precision; The text font code is combination of the font number and the precision. Text font code = 10*fontnumber + precision. Font numbers must be between 1 and 14. The precision can be:; precision = 0 fast hardware fonts (steps in the size); precision = 1 scalable and rotatable hardware fonts (see below); precision = 2 scalable and rotatable hardware fonts; precision = 3 scalable and rotatable hardware fonts. Text size; is given in pixels. The text font and precision of any class inheriting from TAttText can;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TAttText.html:4274,depend,depend,4274,root/html528/TAttText.html,https://root.cern,https://root.cern/root/html528/TAttText.html,3,['depend'],['depend']
Integrability,"_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:242852,message,message,242852,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['message'],['message']
Integrability,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:128771,message,message,128771,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['message'],['message']
Integrability,"_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__RootFinder.html:5441,message,message,5441,root/html534/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html534/TMVA__RootFinder.html,1,['message'],['message']
Integrability,"_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 44 of file TStatsFeedback.h. ◆ DeclFileName(). static const char * TStatsFeedback::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 44 of file TStatsFeedback.h. ◆ Feedback(). void TStatsFeedback::Feedback ; (; TList * ; objs). Display feedback. ; Definition at line 74 of file TStatsFeedback.cxx. ◆ GetName(). const char * TStatsFeedback::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 41 of file TStatsFeedback.h. ◆ Hash(). ULong_t TStatsFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatsFeedback.html:16245,rout,routine,16245,doc/master/classTStatsFeedback.html,https://root.cern,https://root.cern/doc/master/classTStatsFeedback.html,1,['rout'],['routine']
Integrability,"______________________; 66/**; 67 ; 68User Class for performing numerical integration of a function in one dimension.; 69It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; 70algorithms used in the QUADPACK, a numerical integration package written in Fortran.; 71 ; 72Various types of adaptive and non-adaptive integration are supported. These include; 73integration over infinite and semi-infinite ranges and singular integrals.; 74 ; 75The integration type is selected using the Integration::type enumeration; 76in the class constructor.; 77The default type is adaptive integration with singularity; 78(ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; 79In the case of ADAPTIVE type, the integration rule can also be specified via the; 80Integration::GKRule. The default rule is 31 points.; 81 ; 82In the case of integration over infinite and semi-infinite ranges, the type used is always; 83ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; 84 ; 85The ADAPTIVESINGULAR type is the most sophisticated type. When performances are; 86important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or; 87 ADAPTIVE with a lower Gauss-Kronrod rule.; 88 ; 89For detailed description on GSL integration algorithms see the; 90<A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>.; 91 ; 92 ; 93@ingroup Integration; 94 ; 95*/; 96 ; 97 ; 98class IntegratorOneDim {; 99 ; 100public:; 101 ; 102 typedef IntegrationOneDim::Type Type; // for the enumerations defining the types; 103 ; 104 // constructors; 105 ; 106 ; 107 /**; 108 Constructor of one dimensional Integrator, default type is adaptive; 109 ; 110 @param type integration type (adaptive, non-adaptive, etc..); 111 @param absTol desired absolute Error; 112 @param relTol desired relative Error; 113 @param size maximum number of sub-interva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:2960,integrat,integration,2960,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['integrat'],['integration']
Integrability,"______________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:119467,message,message,119467,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['message'],['message']
Integrability,"_basic.C;   Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ;  ; file  rf511_wsfactory_basic.py;   Organization and simultaneous fits: basic use of the 'object factory' associated with a workspace to rapidly build pdfs functions and their parameter components ;  ; file  rf512_wsfactory_oper.C;   Organization and simultaneous fits: operator expressions and expression-based basic pdfs in the workspace factory syntax ;  ; file  rf512_wsfactory_oper.py;   'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #512 ;  ; file  rf513_wsfactory_tools.C;   Organization and simultaneous fits: RooCustomizer and RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ;  ; file  rf513_wsfactory_tools.py;   Organization and simultaneous fits: illustration use of ROOT.RooCustomizer and ROOT.RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ;  ; file  rf514_RooCustomizer.C;   Using the RooCustomizer to create multiple PDFs that share a lot of properties, but have unique parameters for each category. ;  ; file  rf514_RooCustomizer.py;   Using the RooCustomizer to create multiple PDFs that share a lot of properties, but have unique parameters for each category. ;  ; file  rf515_hfJSON.py;   Code HistFactory Models in JSON. ;  ; file  rf601_intminuit.C;   Likelihood and minimization: interactive minimization with MINUIT ;  ; file  rf601_intminuit.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ;  ; file  rf602_chi2fit.C;   Likelihood and minimization: setting up a chi^2 fit to a binned dataset ;  ; file  rf602_chi2fit.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #602 ;  ; file  rf603_multicpu.C;   Likelihood and minimization: setting up a multi-core parallelized unbinned maximum likelihood fit ;  ; file  rf603_multicpu.py;   Likelihood and minimization: setting up a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:15239,interface,interface,15239,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['interface'],['interface']
Integrability,"_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41735,integrat,integration,41735,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,2,['integrat'],['integration']
Integrability,"_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:43387,integrat,integration,43387,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['integrat'],['integration']
Integrability,"_class) const; Case of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:44704,wrap,wrapper,44704,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,1,['wrap'],['wrapper']
Integrability,"_class) const; Case of TObjects when we do not have the library defining the class. void StreamerInstrumented(void* object, TBuffer& b, const TClass* onfile_class) const; Case of instrumented class with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:44045,wrap,wrapper,44045,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['wrap'],['wrapper']
Integrability,"_const operator[](unsigned int i) constread only access to matrix element, with indices starting from 0 : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMatrix::DiagonalSVector< T, D1 > Diagonal() constreturn diagonal elements of a matrix as a Vector.Definition SMatrix.icc:755; ROOT::Math::SMatrix::InverseCholSMatrix< T, D1, D2, R > InverseChol(int &ifail) constInvert of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:452; ROOT::Math::SMatrix::SetDiagonalvoid SetDiagonal(const Vector &v)Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (...Definition SMatrix.icc:770; ROOT::Math::SMatrix::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:327; ROOT::Math::SMatrix::iteratorT * iteratorSTL iterator interface.Definition SMatrix.h:112; ROOT::Math::SMatrix::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SMatrix.h:115; ROOT::Math::SMatrix::operator+=SMatrix< T, D1, D2, R > & operator+=(const T &rhs)addition with a scalarDefinition SMatrix.icc:197; ROOT::Math::SMatrix::InvertCholbool InvertChol()Inversion of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:446; ROOT::Math::SMatrix::Invertbool Invert()Invert a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:412; ROOT::Math::SMatrix::IsInUsebool IsInUse(const T *p) constFunction to check if a matrix is sharing same memory location of the passed pointer This function is ...Definition SMatrix.icc:895; ROOT::Math::SMatrix::rep_typeR rep_typestorage representation typeDefinition SMatrix.h:109; ROOT::Math::SMatrix::kCols@ kColsreturn no. of matrix columnsDefinition SMatrix.h:238; ROOT::Math::SMatrix::kRows@ kRowsretu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:30267,interface,interface,30267,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['interface'],['interface']
Integrability,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:32492,integrat,integrator,32492,root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,2,['integrat'],['integrator']
Integrability,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:32492,integrat,integrator,32492,root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,2,['integrat'],['integrator']
Integrability,"_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction1Binding_double_int_.html:33319,integrat,integrator,33319,root/html532/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction1Binding_double_int_.html,1,['integrat'],['integrator']
Integrability,"_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; int_m1; int_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLegendre(). RooLegendre(const char* name, const char* title, RooAbsReal& ctheta, int l, int m = 0); TODO: for now, we assume that ctheta has a range [-1,1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:36346,integrat,integrator,36346,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,2,['integrat'],['integrator']
Integrability,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2Binding_double_double_double_.html:35610,integrat,integrator,35610,root/html534/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2Binding_double_double_double_.html,1,['integrat'],['integrator']
Integrability,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:35760,integrat,integrator,35760,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,1,['integrat'],['integrator']
Integrability,"_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_xObservable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDerivative(); Default constructor. RooDerivative(const char* name, const char* t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:36891,integrat,integrator,36891,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,2,['integrat'],['integrator']
Integrability,"_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu_var], [x_var], grid, setting); ; # Normalizes the morphed object to be a pdf, set it false to prevent warning messages and gain computational speed up; morph_func.setPdfMode(); ; # Creating the morphed pdf; morph = ROOT.RooWrapperPdf(""morph"", ""morph"", morph_func, True); workspace.Import(morph); workspace[""morph""].plotOn(frame1, LineColor=""r""); ; return frame1; ; ; # Define the ""observed"" data in a workspade; def build_ws(mu_observed, sigma):; ws = ROOT.RooWorkspace(); ws.factory(f""Gaussian::gauss(x[-5,15], mu[{mu_observed},0,4], {sigma})"".format(mu_observed=mu_observed)); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace.pdf(""gauss""); obs_data = gauss.generate(x_var, n_samples); ; ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ; # Compute the morphed nll; frame1 = morphing(ROOT.RooMomentMorphFuncND.Linear); ; # TODO: Fix RooAddPdf::fixCoefNorma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf616__morphing_8py.html:2112,message,messages,2112,doc/master/rf616__morphing_8py.html,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html,1,['message'],['messages']
Integrability,"_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEfficiency.html:38879,integrat,integrator,38879,root/html526/RooEfficiency.html,https://root.cern,https://root.cern/root/html526/RooEfficiency.html,1,['integrat'],['integrator']
Integrability,"_normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:45162,integrat,integrator,45162,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,6,['integrat'],['integrator']
Integrability,"_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:39138,integrat,integrator,39138,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['integrat'],['integrator']
Integrability,"_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussian.html:38742,integrat,integrator,38742,root/html528/RooGaussian.html,https://root.cern,https://root.cern/root/html528/RooGaussian.html,2,['integrat'],['integrator']
Integrability,"_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBreitWigner.html:38870,integrat,integrator,38870,root/html528/RooBreitWigner.html,https://root.cern,https://root.cern/root/html528/RooBreitWigner.html,1,['integrat'],['integrator']
Integrability,"_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:43085,integrat,integrator,43085,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,1,['integrat'],['integrator']
Integrability,"_paramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:51138,integrat,integrator,51138,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['integrat'],['integrator']
Integrability,"_pow3', 'Numba::pypow(x, 3)')\; 31 .AsNumpy(); 32 ; 33print('pypow({}, 3) = {}'.format(data['x'], data['x_pow3'])); 34 ; 35# ROOT uses the numba Python package to create C++ functions from python ones.; 36# We support as input and return types of the callable fundamental types and; 37# ROOT::RVec thereof. See the following callable computing the power of the; 38# elements in an array.; 39@ROOT.Numba.Declare(['RVecF', 'int'], 'RVecF'); 40def pypowarray(x, y):; 41 return x**y; 42 ; 43ROOT.gInterpreter.ProcessLine('''; 44ROOT::RVecF x = {0, 1, 2, 3};; 45cout << ""pypowarray("" << x << "", 3) = "" << Numba::pypowarray(x, 3) << endl;; 46'''); 47 ; 48# and now with RDataFrame; 49s = ROOT.RDataFrame(1).Define('x', 'ROOT::RVecF{1,2,3}')\; 50 .Define('x2', 'Numba::pypowarray(x, 2)')\; 51 .Sum('x2') # 1 + 4 + 9 == 14; 52print('sum(pypowarray({ 1, 2, 3 }, 2)) = ', s.GetValue()); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. tutorialspyrootpyroot004_NumbaDeclare.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html:3114,interface,interface,3114,doc/master/pyroot004__NumbaDeclare_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot004__NumbaDeclare_8py_source.html,1,['interface'],['interface']
Integrability,_refCoefNorm;  Reference observable set for coefficient interpretation. ;  ; TNamed * _refCoefRangeName = nullptr;  Reference range name for coefficient interpretation. ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddPdf.html:72331,integrat,integration,72331,doc/master/classRooAddPdf.html,https://root.cern,https://root.cern/doc/master/classRooAddPdf.html,1,['integrat'],['integration']
Integrability,_refCoefNorm;  Reference observable set for coefficient interpretation. ;  ; TNamed * _refCoefRangeName = nullptr;  Reference range name for coefficient interpretation. ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; std::unique_ptr< TreeReadBuffer > _treeReadBuffer;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:73474,integrat,integration,73474,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,1,['integrat'],['integration']
Integrability,"_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:6112,interface,interface,6112,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,4,['interface'],['interface']
Integrability,"_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUUID.html:6146,interface,interface,6146,root/html602/TUUID.html,https://root.cern,https://root.cern/root/html602/TUUID.html,2,['interface'],['interface']
Integrability,"_t &higherBin, Double_t &lowerBinValue, Double_t &higherBinValue, Double_t y, Bool_t isMonotonouslyIncreasingFunction=kFALSE) const;  find bin from value on ordinate ;  ; Double_t GetIntegral () const;  computes normalisation ;  ; Double_t GetPdfHistBinWidth () const;  ; MsgLogger & Log () const;  ; void SmoothHistogram ();  ; Bool_t UseHistogram () const;  . Static Private Member Functions; static PDF *& GetThisPdfThreadLocal ();  ; static Double_t IGetVal (Double_t *, Double_t *);  static external auxiliary function (integrand) ;  ; static PDF * ThisPDF (void);  . Private Attributes; TString fBorderMethodString;  ; Bool_t fCheckHist;  check of source histogram ;  ; Float_t fFineFactor;  fine tuning factor for Adaptive KDE ;  ; TGraph * fGraph;  ! needed to create PDF from histogram ;  ; TH1 * fHist;  copy of input histogram ;  ; Int_t fHistAvgEvtPerBin;  avg event per source hist bin ;  ; Int_t fHistDefinedNBins;  source hist bin num set by user ;  ; TH1 * fHistOriginal;  the input histogram ;  ; TF1 * fIGetVal;  integration interface ;  ; TString fInterpolateString;  ; TMVA::PDF::EInterpolateMethod fInterpolMethod;  interpolation method ;  ; KDEKernel::EKernelBorder fKDEborder;  The method to take care about ""border"" effects (string) ;  ; KDEKernel::EKernelIter fKDEiter;  Number of iterations (adaptive or not) ;  ; TString fKDEiterString;  ; KDEKernel::EKernelType fKDEtype;  Kernel type to use for KDE. ;  ; TString fKDEtypeString;  strings used to read definitions ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t fMaxNsmooth;  Max number of smoothing iterations. ;  ; Int_t fMinNsmooth;  Min number of smoothing iterations. ;  ; Bool_t fNormalize;  normalize histogram (false for cumulative distribution used in GaussTranform) ;  ; Int_t fNsmooth;  Min number of smoothing iterations. ;  ; TH1 * fNSmoothHist;  number of smooth for each bin ;  ; TH1 * fPDFHist;  the high-binned histogram corresponding to the PDF ;  ; TString fPDFName;  for output ;  ; UInt_t fRead",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:16276,integrat,integration,16276,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"_t & ; val . ). overridevirtual . Get socket options. Returns -1 in case of error. ; Reimplemented from TSocket.; Definition at line 768 of file TPSocket.cxx. ◆ GetSize(). Int_t TPSocket::GetSize ; (; ); const. inline . Definition at line 83 of file TPSocket.h. ◆ Init(). void TPSocket::Init ; (; Int_t ; tcpwindowsize, . TSocket * ; sock = nullptr . ). private . Create a parallel socket to the specified host. ; Definition at line 356 of file TPSocket.cxx. ◆ IsA(). TClass * TPSocket::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 85 of file TPSocket.h. ◆ IsValid(). Bool_t TPSocket::IsValid ; (; ); const. inlineoverridevirtual . Reimplemented from TSocket.; Definition at line 79 of file TPSocket.h. ◆ operator=(). void TPSocket::operator= ; (; const TPSocket & ; ). privatedelete . ◆ Recv() [1/4]. Int_t TPSocket::Recv ; (; char * ; str, . Int_t ; max . ). inlineoverridevirtual . Receive a character string message of maximum max length. ; The expected message must be of type kMESS_STRING. Returns length of received string (can be 0 if otherside of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented from TSocket.; Definition at line 75 of file TPSocket.h. ◆ Recv() [2/4]. Int_t TPSocket::Recv ; (; char * ; str, . Int_t ; max, . Int_t & ; kind . ). inlineoverridevirtual . Receive a character string message of maximum max length. ; Returns in kind the message type. Returns length of received string+4 (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented from TSocket.; Definition at line 76 of file TPSocket.h. ◆ Recv() [3/4]. Int_t TPSocket::Recv ; (; Int_t & ; status, . Int_t & ; kind . ). inlineoverridevirtual . Receives a status and a message type. ; Returns length of received intege",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:26086,message,message,26086,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['message'],['message']
Integrability,"_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:6777,wrap,wrapper,6777,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"_t *iw, const Int_t liw, Int_t *perm, Int_t *nstk, const Int_t nsteps, Int_t &maxfrt, Int_t *nelim, Int_t *iw2, Int_t *icntl, Double_t *cntl, Int_t *info);  Help routine for factorization. ;  ; static void Factor_sub3 (Double_t *a, Int_t *iw, Int_t &j1, Int_t &j2, const Int_t itop, const Int_t ireal, Int_t &ncmpbr, Int_t &ncmpbi);  Help routine for factorization. ;  ; static Int_t IDiag (Int_t ix, Int_t iy);  ; static void InitPivot (const Int_t n, const Int_t nz, TArrayI &Airn, TArrayI &Aicn, TArrayI &Aiw, TArrayI &Aikeep, TArrayI &Aiw1, Int_t &nsteps, const Int_t iflag, Int_t *icntl, Double_t *cntl, Int_t *info, Double_t &ops);  Setup Pivoting variables. ;  ; static void InitPivot_sub1 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *nv, Int_t *nxt, Int_t *lst, Int_t *ipd, Int_t *flag, const Int_t iovflo, Int_t &ncmpa, const Double_t fratio);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2a (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub3 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub4 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *ips, Int_t *ipv, Int_t *nv, Int_t *flag, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub5 (const Int_t n, Int_t *ipe, Int_t *nv, Int_t *ips, Int_t *ne, Int_t *na, Int_t *nd, Int_t &nsteps, const Int_t nemin);  Help routine for pivoting setup. ;  ; static void InitPivot_sub6 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *na, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:13957,rout,routine,13957,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['rout'],['routine']
Integrability,"_t CheckWeights(const TH1 &pass, const TH1 &total)Check if both histogram are weighted.Definition TEfficiency.cxx:1638; TEfficiency::BetaMeanstatic Double_t BetaMean(Double_t alpha, Double_t beta)Compute the mean (average) of the beta distribution.Definition TEfficiency.cxx:1458; TEfficiency::TEfficiencyTEfficiency()Default constructor.Definition TEfficiency.cxx:691; TEfficiency::GetBetaAlphaDouble_t GetBetaAlpha(Int_t bin=-1) constDefinition TEfficiency.h:110; TEfficiency::FillWeightedvoid FillWeighted(Bool_t bPassed, Double_t weight, Double_t x, Double_t y=0, Double_t z=0)This function is used for filling the two histograms with a weight.Definition TEfficiency.cxx:2494; TEfficiency::~TEfficiency~TEfficiency() overridedefault destructorDefinition TEfficiency.cxx:1099; TEfficiency::GetListOfFunctionsTList * GetListOfFunctions()Definition TEfficiency.cxx:2897; TEfficiency::Bayesianstatic Double_t Bayesian(Double_t total, Double_t passed, Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper, Bool_t bShortest=false)Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending ...Definition TEfficiency.cxx:1324; TEfficiency::AgrestiCoullstatic Double_t AgrestiCoull(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Agresti-Coull interval.Definition TEfficiency.cxx:1149; TEfficiency::MergeLong64_t Merge(TCollection *list)Merges the TEfficiency objects in the given list to the given TEfficiency object using the operator+=...Definition TEfficiency.cxx:2915; TEfficiency::fBeta_bin_paramsstd::vector< std::pair< Double_t, Double_t > > fBeta_bin_paramsParameter for prior beta distribution different bin by bin (default vector is empty)Definition TEfficiency.h:49; TEfficiency::FeldmanCousinsstatic Double_t FeldmanCousins(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Feldman-Cousins interval.Definition TEfficiency.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:164349,depend,depending,164349,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['depend'],['depending']
Integrability,"_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:6539,wrap,wrapper,6539,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612. Reimplemented from TGeoMaterial.; Definition at line 1312 of file TGeoMaterial.cxx. ◆ GetAmixt(). Double_t * TGeoMixture::GetAmixt ; (; ); const. inline . Definition at line 203 of file TGeoMaterial.h. ◆ GetByteCount(). Int_t TGeoMixture::GetByteCount ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoMaterial.; Definition at line 193 of file TGeoMaterial.h. ◆ GetElement(). TGeoElement * TGeoMixture::GetElement ; (; Int_t ; i = 0); const. overridevirtual . Retrieve the pointer to the element corresponding to component I. ; Reimplemented from TGeoMaterial.; Definition at line 1122 of file TGeoMaterial.cxx. ◆ GetElementProp(). void TGeoMixture::GetElementProp ; (; Double_t & ; a, . Double_t & ; z, . Double_t & ; w, . Int_t ; i = 0 . ). inlineoverridevirtual . Single interface to get element properties. ; Reimplemented from TGeoMaterial.; Definition at line 195 of file TGeoMaterial.h. ◆ GetNelements(). Int_t TGeoMixture::GetNelements ; (; ); const. inlineoverridevirtual . Reimplemented from TGeoMaterial.; Definition at line 201 of file TGeoMaterial.h. ◆ GetNmixt(). Int_t * TGeoMixture::GetNmixt ; (; ); const. inline . Definition at line 205 of file TGeoMaterial.h. ◆ GetSpecificActivity(). Double_t TGeoMixture::GetSpecificActivity ; (; Int_t ; i = -1); const. overridevirtual . Get specific activity (in Bq/gram) for the whole mixture (no argument) or for a given component. ; Reimplemented from TGeoMaterial.; Definition at line 1141 of file TGeoMaterial.cxx. ◆ GetWmixt(). Double_t * TGeoMixture::GetWmixt ; (; ); const. inline . Definition at line 204 of file TGeoMaterial.h. ◆ GetZmixt(). Double_t * TGeoMixture::GetZmixt ; (; ); const. inline . Definition at line 202 of file TGeoMaterial.h. ◆ IsA(). TClass * TGeoMixture::IsA ; (; ); const. inlineoverridevirtual . Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoMixture.html:27382,interface,interface,27382,doc/master/classTGeoMixture.html,https://root.cern,https://root.cern/doc/master/classTGeoMixture.html,1,['interface'],['interface']
Integrability,"_t SinH(Double_t x); { return sinh(x); }. Double_t CosH(Double_t x); { return cosh(x); }. Double_t TanH(Double_t x); { return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with the maximum element.; If more than one element is maximum returns first found. Iterator LocMax(Iterator first, Iterator last); Return index of array with the maximum element.; If more than one element is maximum re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:39024,wrap,wrapper,39024,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,1,['wrap'],['wrapper']
Integrability,"_t TCollectionMethodBrowsable::GetBrowsables ; (; TList & ; li, . const TBranch * ; branch, . const TVirtualBranchBrowsable * ; parent = nullptr . ). static . This methods fills list with TMethodBrowsables for the branch's or parent's collection class and its base classes, and returns the number of added elements. ; If called from a TBranch::Browse overload, ""branch"" should be set to the calling TBranch, otherwise ""parent"" should be set to the TVirtualBranchBrowsable being browsed. ; Definition at line 925 of file TBranchBrowsable.cxx. ◆ IsA(). TClass * TCollectionMethodBrowsable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 191 of file TBranchBrowsable.h. ◆ Register(). void TCollectionMethodBrowsable::Register ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigned different addr to the same method, depending on what translation unit you're in... ; Definition at line 961 of file TBranchBrowsable.cxx. ◆ Streamer(). void TCollectionMethodBrowsable::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TCollectionMethodBrowsable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 191 of file TBranchBrowsable.h. ◆ Unregister(). void TCollectionMethodBrowsable::Unregister ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigned different addr to the same method, depending on what translation unit you're in... ; Definition at line 971 of file TBranchBrowsable.cxx. Libraries for TCollectionMethodBrowsable:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TBranchBrowsable.h; tree/tree/src/TBranchBrowsable.cxx. TCollectionMethodBrowsable. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:25 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCollectionMethodBrowsable.html:19645,depend,depending,19645,doc/master/classTCollectionMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTCollectionMethodBrowsable.html,1,['depend'],['depending']
Integrability,"_t bin, Int_t axis=0) const;  Return true if the bin is underflow. ;  ; virtual Bool_t IsHighlight () const;  ; virtual void LabelsDeflate (Option_t *axis=""X"");  Reduce the number of bins for the axis passed in the option to the number of bins having a label. ;  ; virtual void LabelsInflate (Option_t *axis=""X"");  Double the number of bins for axis. ;  ; virtual void LabelsOption (Option_t *option=""h"", Option_t *axis=""X"");  Sort bins with labels or set option(s) to draw axis with labels. ;  ; virtual Long64_t Merge (TCollection *list);  ; Long64_t Merge (TCollection *list, Option_t *option);  Add all histograms in the collection to this histogram. ;  ; virtual Bool_t Multiply (const TH1 *h1);  Multiply this histogram by h1. ;  ; virtual Bool_t Multiply (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by multiplication of h1 by h2. ;  ; virtual Bool_t Multiply (TF1 *f1, Double_t c1=1);  Performs the operation: ;  ; void Paint (Option_t *option="""") override;  Control routine to paint any kind of histograms. ;  ; void Print (Option_t *option="""") const override;  Print some global quantities for this histogram. ;  ; virtual TH1 * Rebin (Int_t ngroup=2, const char *newname="""", const Double_t *xbins=nullptr);  Rebin this histogram. ;  ; virtual void RebinAxis (Double_t x, TAxis *axis);  ; virtual void Rebuild (Option_t *option="""");  Using the current bin info, recompute the arrays for contents and errors. ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove object from the list of functions. ;  ; virtual void ResetStats ();  Reset the statistics including the number of entries and replace with values calculated from bin content. ;  ; void SaveAs (const char *filename=""hist"", Option_t *option="""") const override;  Save the histogram as .csv, .tsv or .txt. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:26420,rout,routine,26420,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,8,['rout'],['routine']
Integrability,"_t bin, Int_t axis=0) const;  Return true if the bin is underflow. ;  ; virtual Bool_t IsHighlight () const;  ; virtual void LabelsDeflate (Option_t *axis=""X"");  Reduce the number of bins for the axis passed in the option to the number of bins having a label. ;  ; virtual void LabelsInflate (Option_t *axis=""X"");  Double the number of bins for axis. ;  ; virtual void LabelsOption (Option_t *option=""h"", Option_t *axis=""X"");  Sort bins with labels or set option(s) to draw axis with labels. ;  ; virtual Long64_t Merge (TCollection *list);  ; Long64_t Merge (TCollection *list, Option_t *option);  Add all histograms in the collection to this histogram. ;  ; virtual Bool_t Multiply (const TH1 *h1);  Multiply this histogram by h1. ;  ; virtual Bool_t Multiply (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by multiplication of h1 by h2. ;  ; virtual Bool_t Multiply (TF1 *f1, Double_t c1=1);  Performs the operation: ;  ; void Paint (Option_t *option="""") override;  Control routine to paint any kind of histograms. ;  ; void Print (Option_t *option="""") const override;  Print some global quantities for this histogram. ;  ; virtual void RebinAxis (Double_t x, TAxis *axis);  ; virtual void Rebuild (Option_t *option="""");  Using the current bin info, recompute the arrays for contents and errors. ;  ; void RecursiveRemove (TObject *obj) override;  Recursively remove object from the list of functions. ;  ; virtual void ResetStats ();  Reset the statistics including the number of entries and replace with values calculated from bin content. ;  ; void SaveAs (const char *filename=""hist"", Option_t *option="""") const override;  Save the histogram as .csv, .tsv or .txt. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; virtual void Scale (Double_t c1=1, Option_t *option="""");  Multiply this histogram by a constant c1. ;  ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:24625,rout,routine,24625,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,7,['rout'],['routine']
Integrability,"_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:53667,rout,routine,53667,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['rout'],['routine']
Integrability,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:5665,rout,routine,5665,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['rout'],['routine']
Integrability,"_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:36458,interface,interface,36458,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['interface'],['interface']
Integrability,"_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3439; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3786; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1336; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2319; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7028; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5193; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6685; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4483; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:308998,wrap,wrapper,308998,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"_t fObjectVersionRepositoryDefinition TClass.h:344; TClass::fShowMembersShowMembersFunc_t fShowMembersDefinition TClass.h:225; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::fIsATVirtualIsAProxy * fIsADefinition TClass.h:229; TClass::GetListOfUsingDataMembersTList * GetListOfUsingDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of using declarations of a class.Definition TClass.cxx:3853; TClass::ForceReloadvoid ForceReload(TClass *oldcl)we found at least one equivalent.Definition TClass.cxx:1403; TClass::fDeleteArrayROOT::DelArrFunc_t fDeleteArrayDefinition TClass.h:238; TClass::CanSplitBool_t CanSplit() constReturn true if the data member of this TClass can be saved separately.Definition TClass.cxx:2386; TClass::fStreamerTClassStreamer * fStreamerDefinition TClass.h:226; TClass::SetDirectoryAutoAddvoid SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc)Install a new wrapper around the directory auto add function.Definition TClass.cxx:7095; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::fNoInfoOrEmuOrFwdDeclNameRegistrystatic TDeclNameRegistry fNoInfoOrEmuOrFwdDeclNameRegistryDefinition TClass.h:328; TClass::fFuncTemplateTListOfFunctionTemplates * fFuncTemplateDefinition TClass.h:206; TClass::fStreamerFuncClassStreamerFunc_t fStreamerFuncDefinition TClass.h:241; TClass::AdoptReferenceProxyvoid AdoptReferenceProxy(TVirtualRefProxy *proxy)Adopt the Reference proxy pointer to indicate that this class represents a reference.Definition TClass.cxx:6752; TClass::GetClassMethodTMethod * GetClassMethod(Longptr_t faddr)Look for a method in this class that has the interface function address faddr.Definition TClass.cxx:4550; TClass::DetermineCurrentStreamerInfoTVirtualStreamerInfo * De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:311636,wrap,wrapper,311636,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning and; a NULL pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t val",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:43685,message,message,43685,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,3,['message'],['message']
Integrability,"_t getValV(const RooArgSet* nset = 0) const; Return value of variable. void setVal(Double_t value); Set value of variable to 'value'. If 'value' is outside; range of object, clip value into range. void setVal(Double_t value, const char* rangeName); Set value of variable to 'value'. If 'value' is outside; range named 'rangeName' of object, clip value into that range. RooErrorVar* errorVar() const; Return a RooAbsRealLValue representing the error associated; with this variable. The callers takes ownership of the; return object. Bool_t hasBinning(const char* name) const; Returns true if variable has a binning with 'name'. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning definition with name. If binning with 'name' is not found it is created; on the fly as a clone of the default binning if createOnTheFly is true, otherwise; a reference to the default binning is returned. If verbose is true a message; is printed if a binning is created on the gly. void setBinning(const RooAbsBinning& binning, const char* name = 0); Add given binning under name 'name' with this variable. If name is null; the binning is installed as the default binning. void setMin(const char* name, Double_t value); Set minimum of name range to given value. If name is null; minimum of default range is set. void setMax(const char* name, Double_t value); Set maximum of name range to given value. If name is null; maximum of default range is set. void setRange(const char* name, Double_t min, Double_t max); Set range named 'name to [min,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:41811,message,message,41811,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,1,['message'],['message']
Integrability,"_t height, Option_t *opt = """");; 184 ; 185 ClassDefOverride(TRootBrowser, 0) // New ROOT Browser; 186};; 187 ; 188#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBrowserImp.h; TGFrame.h; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TBrowserImpABC describing GUI independent browser implementation protocol.Definition TBrowserImp.h:29; TBrowserPluginHelper class used to manage plugins (command or macro to be executed).Definition TRootBrowser.h:36; TBrowserPlugin::~TBrowserPlugin~TBrowserPlugin() overrideDefinition TRootBrowser.h:45; TBrowserPlugin::SetCommandvoid SetCommand(const char *cmd)Definition TRootBrowser.h:49; TBrowserPlugin::fCommandTString fCommandCommand to be executed.Definition TRootBrowser.h:40; TBrowserPlugin::fSubTabInt_t fSubTabTab element number.Definition TRootBrowser.h:39; TBrowserPlugin::fTabInt_t fTabTab number.Definition TRootBrowser.h:38; TBrowserPlugin::SetSubTabvoid SetSubTab(Int_t sub)Definition TRootBrowser.h:48; TBrowserPlugin::TBrowserPluginTBrowserPlugin(const char *name, const char *cmd="""", Int_t tab=1, Int_t sub=-1)Definition TRootBrowser.h:42; TBrowserPlugin::SetTabvoid SetTab(Int_t tab)Definition TRootBrowser.h:47; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGCompositeFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRootBrowser_8h_source.html:8594,protocol,protocol,8594,doc/master/TRootBrowser_8h_source.html,https://root.cern,https://root.cern/doc/master/TRootBrowser_8h_source.html,1,['protocol'],['protocol']
Integrability,"_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoElement_8cxx_source.html:77956,message,message,77956,doc/master/TGeoElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html,1,['message'],['message']
Integrability,"_t ignoreIndex = -1); virtual voidGetHelpMessage() const; TMVA::TNeuron*TMVA::MethodANNBase::GetInputNeuron(Int_t index); const TString&TMVA::MethodBase::GetInternalVarName(Int_t ivar) const; Double_tTMVA::MethodANNBase::GetNetworkOutput(); const TString&TMVA::MethodBase::GetOriginalVarName(Int_t ivar) const; TMVA::TNeuron*TMVA::MethodANNBase::GetOutputNeuron(Int_t index = 0); const TString&TMVA::Configurable::GetReferenceFile() const; static TMVA::MethodBase*TMVA::MethodBase::GetThisBase(); Float_tTMVA::MethodBase::GetTWeight(const TMVA::Event* ev) const; const TString&TMVA::MethodBase::GetWeightFileDir() const; Bool_tTMVA::MethodBase::HasTrainingTree() const; Bool_tTMVA::MethodBase::Help() const; Bool_tTMVA::MethodBase::IgnoreEventsWithNegWeightsInTraining() const; Bool_tTMVA::MethodBase::IsConstructedFromWeightFile() const; Bool_tTMVA::MethodBase::IsNormalised() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidTMVA::MethodBase::MakeClassSpecificHeader(ostream&, const TString& = """") const; voidTObject::MakeZombie(); voidTMVA::MethodBase::NoErrorCalc(Double_t *const err, Double_t *const errUpper); Int_tTMVA::MethodANNBase::NumCycles(); vector<Int_t>*TMVA::MethodANNBase::ParseLayoutString(TString layerSpec); voidTMVA::MethodANNBase::PrintMessage(TString message, Bool_t force = kFALSE) const; voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::MethodANNBase::WaitForKeyboard(); voidTMVA::Configurable::WriteOptionsReferenceToFile().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:14889,message,message,14889,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,3,['message'],['message']
Integrability,"_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3798; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4915; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7296; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:536; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:6993; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2205; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6244; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3917; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1920; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:316533,wrap,wrapper,316533,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::fImplFileNameconst char * fImplFileNameDefinition TClass.h:214; TClass::RegisterStreamerInfovoid RegisterStreamerInfo(TVirtualStreamerInfo *info)Register the StreamerInfo in the given slot, change the State of the TClass as appropriate.Definition TClass.cxx:7363; TClass::fCheckSumstd::atomic< UInt_t > fCheckSumDefinition TClass.h:219; TClass::UnregisterAddressInRepositoryvoid UnregisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:318; TClass::fMethodstd::atomic< TListOfFunctions * > fMethodDefinition TClass.h:207; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::SetNewArrayvoid SetNewArray(ROOT::NewArrFunc_t newArrayFunc)Install a new wrapper around 'new []'.Definition TClass.cxx:7060; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::fDeclFileNameconst char * fDeclFileNameDefinition TClass.h:213; TClass::SetCollectionProxyvoid SetCollectionProxy(const ROOT::Detail::TCollectionProxyInfo &)Create the collection proxy object (and the streamer object) from using the information in the TColle...Definition TClass.cxx:6311; TClass::HasDictionarySelectionstatic Bool_t HasDictionarySelection(const char *clname)Check whether a class has a dictionary or ROOT can load one.Definition TClass.cxx:3984; TClass::AdoptSchemaRulesvoid AdoptSchemaRules(ROOT::Detail::TSchemaRuleSet *rules)Adopt a new set of Data Model Evolution rules.Definition TClass.cxx:1987; TClass::StreamerInstrumentedstatic void StreamerInstrumented(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:319171,wrap,wrapper,319171,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Fri Dec 2 14:26:48 2011 » Last generated: 2011-12-02 14:26; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFormula.html:15711,interface,interface,15711,root/html532/RooFormula.html,https://root.cern,https://root.cern/root/html532/RooFormula.html,1,['interface'],['interface']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Mon Jul 4 15:22:51 2011 » Last generated: 2011-07-04 15:22; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormula.html:15647,interface,interface,15647,root/html530/RooFormula.html,https://root.cern,https://root.cern/root/html530/RooFormula.html,1,['interface'],['interface']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Sat Oct 9 22:38:42 2010 » Last generated: 2010-10-09 22:38; This page has b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFormula.html:15578,interface,interface,15578,root/html528/RooFormula.html,https://root.cern,https://root.cern/root/html528/RooFormula.html,1,['interface'],['interface']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Tue Jun 30 14:33:01 2015 » Last generated: 2015-06-30 14:33; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:20517,interface,interface,20517,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,1,['interface'],['interface']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name) const; Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index) const; Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Tue Mar 10 17:16:49 2015 » Last generated: 2015-03-10 17:16; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormula.html:15730,interface,interface,15730,root/html534/RooFormula.html,https://root.cern,https://root.cern/root/html534/RooFormula.html,1,['interface'],['interface']
Integrability,"_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name); Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index); Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Mon Dec 7 13:47:40 2009 » Last generated: 2009-12-07 13:47; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormula.html:15569,interface,interface,15569,root/html526/RooFormula.html,https://root.cern,https://root.cern/root/html526/RooFormula.html,1,['interface'],['interface']
Integrability,"_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0, const char* target_vol = 0, Bool_t check_norm = kFALSE); Random raytracing method. void Raytrace(Bool_t flag = kTRUE); Draw this volume with current settings and perform raytracing in the pad. void SaveAs(const char* filename, Option_t* option = """") const; Save geometry having this as top volume as a C++ macro. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the volume. The volume ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the volume. The volume ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void UnmarkSaved(); Reset SavePrimitive bits. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. TGeoNode * FindNode(const char* name) const; search a daughter inside the list of nodes. Int_t GetNodeIndex(const TGeoNode* node, Int_t* check_list, Int_t ncheck) const; Get the index of a daugther within check_list by providing the node ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:39050,interface,interface,39050,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,3,['interface'],['interface']
Integrability,"_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; const TGPicture * fPicture;  ;  Protected Attributes inherited from TGTextLBEntry; FontStruct_t fFontStruct;  font used to draw string ;  ; GContext_t fNormGC;  text drawing graphics context ;  ; TGString * fText;  entry text string ;  ; Bool_t fTextChanged;  true if text has been changed ;  ; UInt_t fTHeight;  text height ;  ; UInt_t fTWidth;  text width ;  ;  Protected Attributes inherited from TGLBEntry; Bool_t fActive;  true if entry is active ;  ; Pixel_t fBkcolor;  entry background color ;  ; Int_t fEntryId;  message id of listbox entry ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGIconLBEntry.html:25609,message,message,25609,doc/master/classTGIconLBEntry.html,https://root.cern,https://root.cern/doc/master/classTGIconLBEntry.html,1,['message'],['message']
Integrability,"_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; DataInputHandler & DataInput ();  ; MsgLogger & Log () const;  . Private Attributes; DataInputHandler * fDataInput;  source of input data ;  ; TMVA::DataSetFactory * fDatasetFactory;  ; TList fDataSetInfoCollection;  all registered dataset definitions ;  ; MsgLogger * fLogger;  ! message logger ;  . Friends; class Envelop;  ; class Factory;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSetManager.html:9744,message,message,9744,doc/master/classTMVA_1_1DataSetManager.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSetManager.html,1,['message'],['message']
Integrability,"_t reduceToConditional = kTRUE). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Tue Jun 2 15:32:20 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMultiVarGaussian.html:47193,integrat,integration,47193,root/html604/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html604/RooMultiVarGaussian.html,3,['integrat'],"['integrated', 'integration']"
Integrability,"_t src);  Handle DND leave event. ;  ; Bool_t HandleDNDPosition (Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp);  Handle DND position event. ;  ; Bool_t HandleDNDStatus (Window_t from, int accepted, Rectangle_t skip, Atom_t action);  Handle DND status event. ;  ; void InitAtoms ();  Initialize drag and drop atoms. ;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist=nullptr);  Check if window win is DND aware. ;  ; Bool_t IsTopLevel (Window_t win);  ; void SendDNDDrop (Window_t target);  Send DND drop message to target window. ;  ; void SendDNDEnter (Window_t target);  Send DND enter message to target window. ;  ; void SendDNDFinished (Window_t src);  Send DND finished message to source window. ;  ; void SendDNDLeave (Window_t target);  Send DND leave message to target window. ;  ; void SendDNDPosition (Window_t target, int x, int y, Atom_t action, Time_t timestamp);  Send DND position message to target window. ;  ; void SendDNDStatus (Window_t target, Atom_t action);  Send DND status message to source window. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Atom_t fAcceptedAction;  ; Cursor_t fDNDNoDropCursor;  no drop cursor type ;  ; Atom_t * fDraggerTypes;  lists of DND types ;  ; Bool_t fDragging;  kTRUE while dragging ;  ; TGDragWindow * fDragWin;  drag window ;  ; Bool_t fDropAccepted;  kTRUE if drop accepted ;  ; TTimer * fDropTimeout;  drop timeout ;  ; Atom_t fDropType;  drop type ;  ; UInt_t fGrabEventMask;  pointer grab event mask ;  ; Int_t fHotx;  ; Int_t fHoty;  hot point coordinates ;  ; Atom_t fLocalAction;  accepted and local actions ;  ; TGFrame * fLocalSource;  ; TGFrame * fLocalTarget;  local source and target ;  ; TGFrame * fMain;  pointer on TGMainFrame ;  ; Pixmap_t fMask;  pixmap used for the drag window ;  ; Pixmap_t fPic;  ; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:12141,message,message,12141,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['message'],['message']
Integrability,"_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMVA::TNeuronTNeuron(); TMVA::TNeuronTNeuron(const TMVA::TNeuron&); voidUpdateSynapsesBatch(); voidUpdateSynapsesSequential(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidDeleteLinksArray(TObjArray*& links); voidInitNeuron(); TMVA::MsgLogger&Log() const; voidNullifyLinks(TObjArray*& links); Int_tNumLinks(TObjArray* links) const; voidPrintLinks(TObjArray* links) const; voidPrintMessage(TMVA::EMsgType, TString message). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TNeuron.html:6071,message,message,6071,root/html534/TMVA__TNeuron.html,https://root.cern,https://root.cern/root/html534/TMVA__TNeuron.html,1,['message'],['message']
Integrability,"_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:23965,integrat,integrate,23965,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,2,['integrat'],['integrate']
Integrability,"_t yDim, Int_t zDim,; 161 Option_t* option = """") const {; 162 return THnBase::Projection(xDim, yDim, zDim, option);; 163 }; 164 ; 165 THn* Projection(Int_t ndim, const Int_t* dim,; 166 Option_t* option = """") const {; 167 return (THn*) ProjectionND(ndim, dim, option);; 168 }; 169 ; 170 THn* Rebin(Int_t group) const {; 171 return (THn*) RebinBase(group);; 172 }; 173 THn* Rebin(const Int_t* group) const {; 174 return (THn*) RebinBase(group);; 175 }; 176 ; 177 void Reset(Option_t* option = """") override;; 178 ; 179protected:; 180 TNDArrayT<Double_t> fSumw2; // bin error, lazy allocation happens in TNDArrayT; 181 mutable std::vector<Int_t> fCoordBuf; //! Temporary buffer; 182 ; 183 ClassDefOverride(THn, 1); //Base class for multi-dimensional histogram; 184};; 185 ; 186 ; 187//______________________________________________________________________________; 188/** \class THnT; 189 Templated implementation of the abstract base THn.; 190 All functionality and the interfaces to be used are in THn!; 191 ; 192 THn does not know how to store any bin content itself. Instead, this; 193 is delegated to the derived, templated class: the template parameter decides; 194 what the format for the bin content is. The actual storage is delegated to; 195 TNDArrayT<T>.; 196 ; 197 Typedefs exist for template parameters with ROOT's generic types:; 198 ; 199 Templated name | Typedef | Bin content type; 200 -----------------|---------------|--------------------; 201 THnT<Char_t> | THnC | Char_t; 202 THnT<Short_t> | THnS | Short_t; 203 THnT<Int_t> | THnI | Int_t; 204 THnT<Long64_t> | THnL | Long64_t; 205 THnT<Float_t> | THnF | Float_t; 206 THnT<Double_t> | THnD | Double_t; 207 ; 208 We recommend to use THnC wherever possible, and to map its value space; 209 of 256 possible values to e.g. float values outside the class. This saves an; 210 enormous amount of memory. Only if more than 256 values need to be; 211 distinguished should e.g. THnS or even THnF be chosen.; 212 ; 213 Implementation detail: the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8h_source.html:6639,interface,interfaces,6639,doc/master/THn_8h_source.html,https://root.cern,https://root.cern/doc/master/THn_8h_source.html,1,['interface'],['interfaces']
Integrability,"_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:6014,depend,depend,6014,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['depend'],['depend']
Integrability,"_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidzapToEnd(Bool_t inclContLines = kFALSE). Data Members; protected:. Bool_t_atEOF; Bool_t_atEOL; istream*_is; TString_prefix; TString_punct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooStreamParser(istream& is); Construct parser on given input stream. RooStreamParser(istream& is, const TString& errPrefix); Construct parser on given input stream. Use given errorPrefix to; prefix any parsing error messages. ~RooStreamParser(); Destructor. Bool_t atEOL(); If true, parser is at end of line in stream. void setPunctuation(const TString& punct); Change list of characters interpreted as punctuation. Bool_t isPunctChar(char c) const; Check if given char is considered punctuation. TString readToken(); Read one token separated by any of the know punctuation characters; This function recognizes and handles comment lines in the istream (those; starting with '#', quoted strings ("""") the content of which is not tokenized; and '+-.' characters that are part of a floating point numbers and are exempt; from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStreamParser.html:2549,message,messages,2549,root/html534/RooStreamParser.html,https://root.cern,https://root.cern/root/html534/RooStreamParser.html,1,['message'],['messages']
Integrability,"_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,3>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:5422,interface,interface,5422,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,1,['interface'],['interface']
Integrability,"_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,4>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_4_.html:5422,interface,interface,5422,root/html526/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_4_.html,1,['interface'],['interface']
Integrability,"_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,5>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_5_.html:5422,interface,interface,5422,root/html526/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_5_.html,1,['interface'],['interface']
Integrability,"_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,6>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_6_.html:5517,interface,interface,5517,root/html526/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_6_.html,1,['interface'],['interface']
Integrability,"_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t). By default, a variable will be copied to the buffer with the number of; bytes specified in the type descriptor character. However, if the type; consists of 2 characters, the second character is an integer that; specifies the number of bytes to be used when copying the variable; to the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet create). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranch.html:15723,rout,routine,15723,root/html526/TBranch.html,https://root.cern,https://root.cern/root/html526/TBranch.html,1,['rout'],['routine']
Integrability,"_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t). By default, a variable will be copied to the buffer with the number of; bytes specified in the type descriptor character. However, if the type; consists of 2 characters, the second character is an integer that; specifies the number of bytes to be used when copying the variable; to the output buffer. Example:; X ; variable X, type Float_t; Y/I : variable Y, type Int_t; Y/I2 ; variable Y, type Int_t converted to a 16 bits integer. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. *. void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:16070,rout,routine,16070,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,1,['rout'],['routine']
Integrability,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitely specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:27149,protocol,protocol,27149,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,3,['protocol'],['protocol']
Integrability,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:28142,protocol,protocol,28142,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,3,['protocol'],['protocol']
Integrability,"_t, a missing key returns -1. ;  ; const char * GetOptions () const;  ; const char * GetPasswd () const;  ; Int_t GetPort () const;  ; const char * GetProtocol () const;  ; const char * GetUrl (Bool_t withDeflt=kFALSE) const;  Return full URL. ;  ; const char * GetUser () const;  ; const char * GetValueFromOptions (const char *key) const;  Return a value for a given key from the URL options. ;  ; Bool_t HasOption (const char *key) const;  Returns true if the given key appears in the URL options list. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; Bool_t IsValid () const;  ; TUrl & operator= (const TUrl &rhs);  TUrl assignment operator. ;  ; void ParseOptions () const;  Parse URL options into a key/value map. ;  ; void Print (Option_t *option="""") const override;  Print URL on stdout. ;  ; void SetAnchor (const char *anchor);  ; void SetFile (const char *file);  ; void SetHost (const char *host);  ; void SetOptions (const char *opt);  ; void SetPasswd (const char *pw);  ; void SetPort (Int_t port);  ; void SetProtocol (const char *proto, Bool_t setDefaultPort=kFALSE);  Set protocol and, optionally, change the port accordingly. ;  ; void SetUrl (const char *url, Bool_t defaultIsFile=kFALSE);  Parse url character string and split in its different subcomponents. ;  ; void SetUser (const char *user);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUrl.html:2655,protocol,protocol,2655,doc/master/classTUrl.html,https://root.cern,https://root.cern/doc/master/classTUrl.html,1,['protocol'],['protocol']
Integrability,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__ROCCalc.html:1068,message,message,1068,root/html602/TMVA__ROCCalc.html,https://root.cern,https://root.cern/root/html602/TMVA__ROCCalc.html,2,['message'],['message']
Integrability,"_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsOpt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidPaint(Option_t* option); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* message, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* hist); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualHistPainter::SetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLHistPainter.html:9014,message,message,9014,root/html602/TGLHistPainter.html,https://root.cern,https://root.cern/root/html602/TGLHistPainter.html,2,['message'],['message']
Integrability,"_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooObjCacheManager_normIntMgrThe integration cache manager; Int_t_numBins; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParamHistFunc(). ParamHistFunc(const char* name, const char* title,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:34926,integrat,integration,34926,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,2,['integrat'],"['integration', 'integrator']"
Integrability,"_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:17475,message,message,17475,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,3,['message'],['message']
Integrability,"_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins(const RooAbsBinning& binning) const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:21109,message,message,21109,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,6,['message'],['message']
Integrability,"_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:40565,integrat,integration,40565,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,1,['integrat'],['integration']
Integrability,"_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,bool>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_bool_.html:32368,integrat,integrator,32368,root/html526/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3Binding_double_double_double_bool_.html,2,['integrat'],['integrator']
Integrability,"_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:44842,integrat,integrator,44842,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['integrat'],['integrator']
Integrability,"_tTMVA::PDEFoamDensityBase::GetBoxVolume(); TMVA::MsgLogger&TMVA::PDEFoamDensityBase::Log() const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMVA::BinarySearchTree*TMVA::PDEFoamDensityBase::fBstBinary tree to find events within a volume; TMVA::MsgLogger*TMVA::PDEFoamDensityBase::fLogger! message logger; UInt_tfTargetthe target to calculate the density for. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamTargetDensity(); {}. PDEFoamTargetDensity(vector<Double_t> box, UInt_t target); User construcor. Parameters:. - box - size of the range-searching box (n-dimensional; std::vector). - target - the target number to calculate the density for. PDEFoamTargetDensity(const TMVA::PDEFoamTargetDensity& ); Copy constructor. Double_t Density(vector<Double_t>& Xarg, Double_t& event_density); This function is needed during the foam buildup. It returns the; average target value within the range-searching box at point; xev, divided by volume (specified by fBox). Parameters:. - xev - event vector (in [fXmin,fXmax]) to place the box at. - event_density - here the event density is stored. Returns:. Average target value in the range-searching volume at point; 'xev', divided by the box volume. virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamTargetDensity.html:6800,message,message,6800,root/html602/TMVA__PDEFoamTargetDensity.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamTargetDensity.html,2,['message'],['message']
Integrability,"_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimultaneous.html:43595,integrat,integrator,43595,root/html534/RooSimultaneous.html,https://root.cern,https://root.cern/root/html534/RooSimultaneous.html,1,['integrat'],['integrator']
Integrability,"_t_useIntegrandLimitsIf true limits of function binding are ued; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t*_x! do not persist; vector<Double_t>_xmax! Upper integration bound; vector<Double_t>_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooBinIntegrator, is parameters and capabilities with RooNumIntFactory. RooBinIntegrator(); Default constructor. RooBinIntegrator(const RooAbsFunc& function); Construct integrator on given function binding binding. RooBinIntegrator(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding binding. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. ~RooBinIntegrator(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of function binding parameters. RooBinIntegrator(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kTRUE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. Double_t* xvec(Double_t& xx); { _x[0] = xx ; return _x ; }. Double_t* xvec(Double_t& xx, Double_t& yy); { _x[0] = xx ; _x[1] = yy ; return _x ; }. Double_t* xvec(Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinIntegrator.html:7634,integrat,integration,7634,root/html532/RooBinIntegrator.html,https://root.cern,https://root.cern/root/html532/RooBinIntegrator.html,4,['integrat'],['integration']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Mon Jul 4 15:23:56 2011 » Last generated: 2011-07-04 15:23; This page has been automatically gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSegmentedIntegrator1D.html:7729,integrat,integrator,7729,root/html530/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html530/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Sat Oct 9 06:58:43 2010 » Last generated: 2010-10-09 06:58; This page has been automatically gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSegmentedIntegrator1D.html:7660,integrat,integrator,7660,root/html528/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Thu Nov 3 20:09:12 2011 » Last generated: 2011-11-03 20:09; This page has been automatically gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSegmentedIntegrator1D.html:7729,integrat,integrator,7729,root/html532/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html532/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Mar 10 17:18:58 2015 » Last generated: 2015-03-10 17:18; This page has been automatically gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSegmentedIntegrator1D.html:7748,integrat,integrator,7748,root/html534/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html534/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 2 15:33:40 2015 » Last generated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSegmentedIntegrator1D.html:8289,integrat,integrator,8289,root/html604/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html604/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_t_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:35:35 2015 » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSegmentedIntegrator1D.html:8289,integrat,integrator,8289,root/html602/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_tfDoFrustumCheckPerform global frustum-check in UpdateSceneInfo(); Short_tfLODScene-lod.; TGLLockable::ELockTGLLockable::fLockLock state.; UInt_tfMinorStampCounter increased on minimal update.; TStringfNameObject identifier.; Float_tfOLLineWScene outline line-width.; UInt_tfSceneIDUnique scene id.; Bool_tfSelectableObjects in the scene are selectable.; Short_tfStyleScene-style.; UInt_tfTimeStampCounter increased on every update.; TStringfTitleObject title.; list<TGLViewerBase*>fViewers; Float_tfWFLineWScene wire-frame line-width. private:. static UInt_tfgSceneIDSrc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLSceneBase(); Destructor. void AddViewer(TGLViewerBase* viewer); Add viewer to the list. void RemoveViewer(TGLViewerBase* viewer); Remove viewer from the list.; If auto-destruct is on and the last viewer is removed the scene; destructs itself. void TagViewersChanged(); Tag all viewers as changed. const char* LockIdStr() const; Name printed on locking info messages. TGLSceneInfo* CreateSceneInfo(TGLViewerBase* view); Create a scene-info instance appropriate for this scene class.; Here we instantiate the scene-info base-class TGLSceneInfo. void RebuildSceneInfo(TGLRnrCtx& ctx); Fill scene-info with very basic information that is practically; view independent. This is called when scene content is changed; or when camera-interest changes. void UpdateSceneInfo(TGLRnrCtx& ctx); Fill scene-info with information needed for rendering, take into; account the render-context (viewer state, camera, clipping).; Usually called from TGLViewer before rendering a scene if some; moderately significant part of render-context has changed. Here we update the basic state (clear last-LOD, mark the time,; set global <-> scene transforamtion matrices) and potentially; study and refine the clipping planes based on scene bounding box. void LodifySceneInfo(TGLRnrCtx& ctx); Setup LOD-dependant values in scene-info. Nothing to be done here b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSceneBase.html:4668,message,messages,4668,root/html528/TGLSceneBase.html,https://root.cern,https://root.cern/root/html528/TGLSceneBase.html,4,['message'],['messages']
Integrability,"_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ←; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A. Bool_t IsRelative() const; Returns kTRUE if instance qualifies as relative-ref; relative-ref = relative-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsUri() const; Returns kTRUE if instance qualifies as URI; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsReference() const; Returns kTRUE if instance qualifies as URI-reference; URI-reference = URI / relative-ref; cf. Appendix A. Bool_t SetScheme(const TString& scheme); Set scheme component of URI:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / ""-"" / ""."" ). Bool_t IsScheme(const TString& ); Returns kTRUE if string qualifies as URI scheme:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUri.html:9228,rout,routine,9228,root/html602/TUri.html,https://root.cern,https://root.cern/root/html602/TUri.html,2,['rout'],['routine']
Integrability,"_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance Chart:. TObject. TAttLine. ←; TView. ←; TView3D. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd point of X-axis; IY1 - 1st point of Y-axis; IY2 - 2nd point of Y-axis; IZ1 - 1st point of Z-axis; IZ2 - 2nd point of Z-axis. 8 6; / \ /|\; 5 / \ 7 5 / | \ 7; |\ /| | | |; THETA < 90 | \6/ | THETA > 90 | /2\ |; (Top view) | | | (Bottom vie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TView3D.html:14157,depend,depending,14157,root/html602/TView3D.html,https://root.cern,https://root.cern/root/html602/TView3D.html,2,['depend'],['depending']
Integrability,"_tfNqs; Int_tfNxrast; Int_tfNyrast; Double_tfP8[8][3]; Double_tfPlines[1200]; Double_tfQA; Double_tfQD; Double_tfQS; Int_t*fRasterpointer to raster buffer; Double_tfRmax[3]Upper limits of lego; Double_tfRmin[3]Lower limits of lego; G__p2memfuncfSurfaceFunctionpointer to surface function; Int_tfSystemCoordinate system; Double_tfT[200]; Double_tfU[2000]; Double_tfVls[12]; Double_tfX0; Double_tfXrast; Double_tfYdl; Double_tfYls[4]; Double_tfYrast; static TF3*fgCurrentF3Pointer to the 3D function to be paint.; static Int_tfgF3ClippingClipping box is off (0) or on (1); static Double_tfgF3XClipClipping plne along X; static Double_tfgF3YClipClipping plne along Y; static Double_tfgF3ZClipClipping plne along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPainter3dAlgorithms(); Lego default constructor. TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); Normal default constructor. rmin[3], rmax[3] are the limits of the lego object depending on; the selected coordinate system. ~TPainter3dAlgorithms(); Lego default destructor. void BackBox(Double_t ang); Draw back surfaces of surrounding box. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:14194,depend,depending,14194,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,4,['depend'],['depending']
Integrability,"_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPGenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& a, RooAbsReal& b, RooAbsReal& delMistag, RooAbsReal& mu, const RooResolutionModel& model, RooBCPGenDecay::DecayType type = DoubleSided); Constructor. RooBCPGenDecay(const RooBCPGenDecay& other, const char* name = 0); Copy constructor. ~RooBCPGenDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPGenDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPGenDecay(*this,newname) ; }. » Last changed: Mon Dec 7 13:46:02 2009 » Last generated: 2009-12-07 13:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPGenDecay.html:42450,depend,dependent,42450,root/html526/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPGenDecay.html,1,['depend'],['dependent']
Integrability,"_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPGenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& a, RooAbsReal& b, RooAbsReal& delMistag, RooAbsReal& mu, const RooResolutionModel& model, RooBCPGenDecay::DecayType type = DoubleSided); Constructor. RooBCPGenDecay(const RooBCPGenDecay& other, const char* name = 0); Copy constructor. ~RooBCPGenDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPGenDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPGenDecay(*this,newname) ; }. » Last changed: Mon Jul 4 15:21:41 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPGenDecay.html:43486,depend,dependent,43486,root/html530/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPGenDecay.html,1,['depend'],['dependent']
Integrability,"_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPGenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& a, RooAbsReal& b, RooAbsReal& delMistag, RooAbsReal& mu, const RooResolutionModel& model, RooBCPGenDecay::DecayType type = DoubleSided); Constructor. RooBCPGenDecay(const RooBCPGenDecay& other, const char* name = 0); Copy constructor. ~RooBCPGenDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPGenDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPGenDecay(*this,newname) ; }. » Last changed: Sat Oct 9 22:38:36 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPGenDecay.html:43118,depend,dependent,43118,root/html528/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPGenDecay.html,1,['depend'],['dependent']
Integrability,"_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBCPGenDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& tag, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& avgMistag, RooAbsReal& a, RooAbsReal& b, RooAbsReal& delMistag, RooAbsReal& mu, const RooResolutionModel& model, RooBCPGenDecay::DecayType type = DoubleSided); Constructor. RooBCPGenDecay(const RooBCPGenDecay& other, const char* name = 0); Copy constructor. ~RooBCPGenDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; B0 : _tag = +1; B0bar : _tag = -1. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBCPGenDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBCPGenDecay(*this,newname) ; }. » Last changed: Thu Nov 3 20:07:00 2011 » Last generated: 2011-11-03 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPGenDecay.html:43893,depend,dependent,43893,root/html532/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPGenDecay.html,1,['depend'],['dependent']
Integrability,"_t ; , . Atom_t * ; , . Int_t * ; , . ULong_t * ; , . ULong_t * ; , . unsigned char ** ;  . ). overridevirtual . Returns the actual type of the property; the actual format of the property; the number of 8-bit, 16-bit, or 32-bit items transferred; the number of bytes remaining to be read in the property; and a pointer to the data actually returned. ; Reimplemented from TVirtualX. ◆ GetRegionBox(). void TGWin32VirtualXProxy::GetRegionBox ; (; Region_t ; reg, . Rectangle_t * ; rect . ). overridevirtual . Returns smallest enclosing rectangle. ; Reimplemented from TVirtualX. ◆ GetRGB(). void TGWin32VirtualXProxy::GetRGB ; (; Int_t ; index, . Float_t & ; r, . Float_t & ; g, . Float_t & ; b . ). overridevirtual . Returns RGB values for color ""index"". ; Reimplemented from TVirtualX. ◆ GetScreen(). Int_t TGWin32VirtualXProxy::GetScreen ; (; ); const. overridevirtual . Returns screen number. ; Might be useful in some cases where direct X11 manipulation outside of TVirtualX is needed, e.g. GL interface. ; Reimplemented from TVirtualX. ◆ GetTextAlign(). Short_t TGWin32VirtualXProxy::GetTextAlign ; (; ); const. overridevirtual . Return the text alignment. ; Reimplemented from TAttText. ◆ GetTextAngle(). Float_t TGWin32VirtualXProxy::GetTextAngle ; (; ); const. overridevirtual . Return the text angle. ; Reimplemented from TAttText. ◆ GetTextColor(). Color_t TGWin32VirtualXProxy::GetTextColor ; (; ); const. overridevirtual . Return the text color. ; Reimplemented from TAttText. ◆ GetTextExtent() [1/2]. void TGWin32VirtualXProxy::GetTextExtent ; (; UInt_t & ; w, . UInt_t & ; h, . wchar_t * ; mess . ). inlineoverridevirtual . Returns the size of the specified character string ""mess"". ; Parameters. [in]wthe text width ; [in]hthe text height ; [in]messthe string . Reimplemented from TVirtualX.; Definition at line 65 of file TGWin32VirtualXProxy.h. ◆ GetTextExtent() [2/2]. void TGWin32VirtualXProxy::GetTextExtent ; (; UInt_t & ; w, . UInt_t & ; h, . char * ; mess . ). overridevirtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:84875,interface,interface,84875,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['interface'],['interface']
Integrability,"_t ; h = 0, . TImagePalette * ; palette = gWebImagePalette . ). overridevirtual . In case of vectorized image return an associated array of doubles otherwise this method creates and returns a 2D array of doubles corresponding to palette. ; If palette is ZERO a color converted to double value [0, 1] according to formula Double_t((r << 16) + (g << 8) + b)/0xFFFFFF; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; The returned array must be deleted after usage. ; Reimplemented from TImage.; Definition at line 2501 of file TASImage.cxx. ◆ GetFileType(). TImage::EImageFileTypes TASImage::GetFileType ; (; const char * ; ext). protected . Return file type depending on specified extension. ; Protected method. ; Definition at line 827 of file TASImage.cxx. ◆ GetFillAreaSpans(). void TASImage::GetFillAreaSpans ; (; UInt_t ; npt, . TPoint * ; ppt, . UInt_t * ; nspans, . TPoint ** ; firstPoint, . UInt_t ** ; firstWidth . ). private . ◆ GetHeight(). UInt_t TASImage::GetHeight ; (; ); const. overridevirtual . Return height of original image not of the displayed image. ; (Number of image pixels) ; Reimplemented from TImage.; Definition at line 2163 of file TASImage.cxx. ◆ GetIconName(). const char * TASImage::GetIconName ; (; ); const. inlineoverridevirtual . Returns mime type name of object. ; Used by the TBrowser (via TGMimeTypes class). Override for class of which you would like to have different icons for objects of the same class. ; Reimplemented from TObject.; Definition at line 99 of file TASImage.h. ◆ GetImage(). ASImage * TASImage::GetImage ; (; ); const. inline . Definition at line 186 of file TASImage.h. ◆ GetImageBuffer(). void TASImage::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:56078,depend,depending,56078,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['depend'],['depending']
Integrability,"_t ; size, . bool ; skipEvenEntries = false . ). Make a RDF wrapping a RTrivialDS with the specified amount of entries. ; Constructing an RDataFrame as RDataFrame(nEntries) is a superior alternative. If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source: it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes). ; Definition at line 123 of file RTrivialDS.cxx. ◆ Not(). template<typename F , typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay, typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::ret_type> . auto ROOT::RDF::Not ; (; F && ; f); -> decltype(RDFInternal::NotHelper(Args(), std::forward<F>(f))). Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result. ; The callable must have one single non-template definition of operator(). This is a limitation with respect to std::not_fn, required for interoperability with RDataFrame. ; Definition at line 83 of file RDFHelpers.hxx. ◆ operator!=() [1/3]. template<class T1 , class T2 > . bool ROOT::RDF::operator!= ; (; const RResultPtr< T1 > & ; lhs, . const RResultPtr< T2 > & ; rhs . ). Definition at line 407 of file RResultPtr.hxx. ◆ operator!=() [2/3]. template<class T1 > . bool ROOT::RDF::operator!= ; (; const RResultPtr< T1 > & ; lhs, . std::nullptr_t ; rhs . ). Definition at line 425 of file RResultPtr.hxx. ◆ operator!=() [3/3]. template<class T1 > . bool ROOT::RDF::operator!= ; (; std::nullptr_t ; lhs, . const RResultPtr< T1 > & ; rhs . ). Definition at line 431 of file RResultPtr.hxx. ◆ operator<<(). std::ostream & ROOT::RDF::operator<< ; (; std::ostream & ; os, . const RDFDescription & ; description . ). Definition at line 34 of file RDFDescription.cxx. ◆ operator==() [1/3]. template<class T1 , class T2 > . bool ROOT::RDF::operator== ; (; const RResultPtr< T1 > & ; lhs, . const RResultPtr< T2 > & ; rhs . ). Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:11119,interoperab,interoperability,11119,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,1,['interoperab'],['interoperability']
Integrability,"_t ; size, . bool ; skipEvenEntries = false . ). Make a RDF wrapping a RTrivialDS with the specified amount of entries. ; Constructing an RDataFrame as RDataFrame(nEntries) is a superior alternative. If size is std::numeric_limits<ULong64_t>::max(), this acts as an infinite data-source: it returns entries from GetEntryRanges forever or until a Range stops the event loop (for test purposes). ; Definition at line 123 of file RTrivialDS.cxx. ◆ Not(). template<typename F , typename Args = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::arg_types_nodecay, typename Ret = typename ROOT::TypeTraits::CallableTraits<std::decay_t<F>>::ret_type> . auto ROOT::RDF::Not ; (; F && ; f); -> decltype(RDFInternal::NotHelper(Args(), std::forward<F>(f))). Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns the negated result. ; The callable must have one single non-template definition of operator(). This is a limitation with respect to std::not_fn, required for interoperability with RDataFrame. ; Definition at line 83 of file RDFHelpers.hxx. ◆ operator!=() [1/3]. template<class T1 , class T2 > . bool ROOT::RDF::operator!= ; (; const RResultPtr< T1 > & ; lhs, . const RResultPtr< T2 > & ; rhs . ). Definition at line 407 of file RResultPtr.hxx. ◆ operator!=() [2/3]. template<class T1 > . bool ROOT::RDF::operator!= ; (; const RResultPtr< T1 > & ; lhs, . std::nullptr_t ; rhs . ). Definition at line 425 of file RResultPtr.hxx. ◆ operator!=() [3/3]. template<class T1 > . bool ROOT::RDF::operator!= ; (; std::nullptr_t ; lhs, . const RResultPtr< T1 > & ; rhs . ). Definition at line 431 of file RResultPtr.hxx. ◆ operator<<(). std::ostream & ROOT::RDF::operator<< ; (; std::ostream & ; os, . const RDFDescription & ; description . ). Definition at line 37 of file RDFDescription.cxx. ◆ operator==() [1/3]. template<class T1 , class T2 > . bool ROOT::RDF::operator== ; (; const RResultPtr< T1 > & ; lhs, . const RResultPtr< T2 > & ; rhs . ). Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html:11118,interoperab,interoperability,11118,doc/v632/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1RDF.html,1,['interoperab'],['interoperability']
Integrability,_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; RooArgSet * allDependents ();  Return all observables. ;  ; bool binGenData ();  If true binning of data between generating and fitting is requested. ;  ; RooArgSet * dependents ();  Return fit model observables. ;  ; bool extendedGen ();  If true extended mode generation is requested. ;  ; RooArgSet * fitInitParams ();  Return initial value of parameters of fit model. ;  ; RooAbsPdf * fitModel ();  Return fit model. ;  ; RooLinkedList * fitOptList ();  Return list of fit options provided by user. ;  ; RooArgSet * fitParams ();  Return current value of parameters of fit model. ;  ; RooAbsGenContext * genContext ();  ; RooArgSet * genInitParams ();  Return initial value of generator model parameters. ;  ; RooAbsPdf * genModel ();  Return generator pdf. ;  ; RooArgSet * genParams ();  Return current value of generator model parameters. ;  ; const RooDataSet * genProtoData ();  Return generator prototype data provided by user. ;  ; RooAbsData * genSample ();  Return generate sample. ;  ; RooRealVar * nllVar ();  Return pointer to RooRealVar holding minimized -log(L) value. ;  ; double numExpGen ();  Return expected number of events from generator model. ;  ; RooArgS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMCStudyModule.html:11850,depend,dependents,11850,doc/master/classRooAbsMCStudyModule.html,https://root.cern,https://root.cern/doc/master/classRooAbsMCStudyModule.html,1,['depend'],['dependents']
Integrability,"_t GetRC (const char *RCenv, Int_t &env, const char *ord=""0"");  Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. ;  ; Int_t GetRC (const char *RCenv, TString &env, const char *ord=""0"");  Get into 'env' the value of string RC env variable 'rcenv' on node 'ord'. ;  ; Float_t GetRealTime () const;  ; Int_t GetRemoteProtocol () const;  ; ERunStatus GetRunStatus () const;  ; Int_t GetSeqNum () const;  ; Int_t GetSessionID () const;  ; const char * GetSessionTag () const;  ; virtual TFileCollection * GetStagingStatusDataSet (const char *dataset);  Obtains a TFileCollection showing the staging status of the specified dataset. ;  ; void GetStatistics (Bool_t verbose=kFALSE);  Get statistics about CPU time, real time and bytes read. ;  ; Int_t GetStatus () const;  ; virtual TTree * GetTreeHeader (TDSet *tdset);  Creates a tree header (a tree with nonexisting files) object for the DataSet. ;  ; const char * GetUrl ();  ; const char * GetUser () const;  ; const char * GetWorkDir () const;  ; void GoAsynchronous ();  Send GOASYNC message to the master. ;  ; Bool_t IsDataReady (Long64_t &totalbytes, Long64_t &bytesready);  See if the data is ready to be analyzed. ;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsIdle () const;  ; Bool_t IsLite () const;  ; Bool_t IsMaster () const;  ; Bool_t IsParallel () const;  ; Bool_t IsProofd () const;  ; Bool_t IsTty () const;  ; Bool_t IsValid () const;  ; Bool_t IsWaiting () const;  ; virtual Int_t Load (const char *macro, Bool_t notOnClient=kFALSE, Bool_t uniqueOnly=kTRUE, TList *wrks=0);  Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ;  ; void LogMessage (const char *msg, Bool_t all);  Log a message into the appropriate window by emitting a signal. ;  ; Int_t Ping ();  Ping PROOF. Returns 1 if master server responded. ;  ; void Print (Option_t *option="""") const o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:10592,message,message,10592,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,2,['message'],['message']
Integrability,"_t GetRC (const char *RCenv, Int_t &env, const char *ord=""0"");  Get into 'env' the value of integer RC env variable 'rcenv' on node 'ord'. ;  ; Int_t GetRC (const char *RCenv, TString &env, const char *ord=""0"");  Get into 'env' the value of string RC env variable 'rcenv' on node 'ord'. ;  ; Float_t GetRealTime () const;  ; Int_t GetRemoteProtocol () const;  ; ERunStatus GetRunStatus () const;  ; Int_t GetSeqNum () const;  ; Int_t GetSessionID () const;  ; const char * GetSessionTag () const;  ; virtual TFileCollection * GetStagingStatusDataSet (const char *dataset);  Obtains a TFileCollection showing the staging status of the specified dataset. ;  ; void GetStatistics (Bool_t verbose=kFALSE);  Get statistics about CPU time, real time and bytes read. ;  ; Int_t GetStatus () const;  ; virtual TTree * GetTreeHeader (TDSet *tdset);  Creates a tree header (a tree with nonexisting files) object for the DataSet. ;  ; const char * GetUrl ();  ; const char * GetUser () const;  ; const char * GetWorkDir () const;  ; void GoAsynchronous ();  Send GOASYNC message to the master. ;  ; TClass * IsA () const override;  ; Bool_t IsDataReady (Long64_t &totalbytes, Long64_t &bytesready);  See if the data is ready to be analyzed. ;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; Bool_t IsIdle () const;  ; Bool_t IsLite () const;  ; Bool_t IsMaster () const;  ; Bool_t IsParallel () const;  ; Bool_t IsProofd () const;  ; Bool_t IsTty () const;  ; Bool_t IsValid () const;  ; Bool_t IsWaiting () const;  ; virtual Int_t Load (const char *macro, Bool_t notOnClient=kFALSE, Bool_t uniqueOnly=kTRUE, TList *wrks=0);  Load the specified macro on master, workers and, if notOnClient is kFALSE, on the client. ;  ; void LogMessage (const char *msg, Bool_t all);  Log a message into the appropriate window by emitting a signal. ;  ; Int_t Ping ();  Ping PROOF. Returns 1 if master server responded. ;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:12105,message,message,12105,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['message']
Integrability,"_t IsActive () const;  ; Bool_t IsDNDSource () const;  ; Bool_t IsDNDTarget () const;  ; Bool_t IsEditable () const override;  ; void MapRaised () override;  map raised ;  ; void MapSubwindows () override;  map sub windows ;  ; void MapWindow () override;  map window ;  ; void Move (Int_t x, Int_t y) override;  Move frame. ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void ProcessedConfigure (Event_t *event);  ; virtual void ProcessedEvent (Event_t *event);  ; virtual void ReallyDelete ();  ; void RemoveInput (UInt_t emask);  Remove events specified in emask from the events the frame should handle. ;  ; void ReparentWindow (const TGWindow *p, Int_t x=0, Int_t y=0) override;  Reparent window, make p the new parent and position the window at position (x,y) in new parent. ;  ; void SaveUserColor (std::ostream &out, Option_t *);  Save a user color in a C++ macro file - used in SavePrimitive(). ;  ; virtual void SendMessage (const TGWindow *w, Longptr_t msg, Longptr_t parm1, Longptr_t parm2);  Send message (i.e. ;  ; void SetBackgroundColor (Pixel_t back) override;  Set background color (override from TGWindow base class). ;  ; void SetDNDSource (Bool_t onoff);  ; void SetDNDTarget (Bool_t onoff);  ; virtual void SetDragType (Int_t type);  SetDragType. ;  ; void SetDrawOption (Option_t *="""") override;  Set drawing option for object. ;  ; virtual void SetDropType (Int_t type);  SetDropType. ;  ; void SetEditable (Bool_t) override;  ; virtual void SetForegroundColor (Pixel_t);  ; void SetFrameElement (TGFrameElement *fe);  ; virtual void SetHeight (UInt_t h);  ; virtual void SetMaxHeight (UInt_t h);  ; virtual void SetMaxWidth (UInt_t w);  ; virtual void SetMinHeight (UInt_t h);  ; virtual void SetMinWidth (UInt_t w);  ; virtual void SetSize (const TGDimension &s);  ; virtual void SetWidth (UInt_t w);  ; virtual void SetX (Int_t x);  ; virtual void SetY (Int_t y);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListBox.html:12940,message,message,12940,doc/master/classTGListBox.html,https://root.cern,https://root.cern/doc/master/classTGListBox.html,1,['message'],['message']
Integrability,"_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:48501,message,messages,48501,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['message'],['messages']
Integrability,"_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:47186,message,messages,47186,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['message'],['messages']
Integrability,"_t fLineWidth;  Line width. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TView3D.h>. Inheritance diagram for TView3D:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkPerspective . Definition at line 66 of file TView3D.h. Constructor & Destructor Documentation. ◆ TView3D() [1/3]. TView3D::TView3D ; (; const TView3D & ; tv). protected . Set to TRUE after ExecuteRotateView. ; Copy constructor. ; Definition at line 197 of file TView3D.cxx. ◆ TView3D() [2/3]. TView3D::TView3D ; (; ). Default constructor. ; Definition at line 109 of file TView3D.cxx. ◆ TView3D() [3/3]. TView3D::TView3D ; (; Int_t ; system, . const Double_t * ; rmin, . const Double_t * ; rmax . ). TView3D constructor. ; Creates a 3-D view in the current pad rmin[3], rmax[3] are the limits of the object depending on the selected coordinate system; Before drawing a 3-D object in a pad, a 3-D view must be created. Note that a view is automatically created when drawing legos or surfaces.; The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi . Definition at line 153 of file TView3D.cxx. ◆ ~TView3D(). TView3D::~TView3D ; (; ). override . TView3D default destructor. ; Definition at line 276 of file TView3D.cxx. Member Function Documentation. ◆ AdjustPad(). void TView3D::AdjustPad ; (; TVirtualPad * ; pad = nullptr). static . Force the current pad to be updated. ; Definition at line 1539 of file TView3D.cxx. ◆ AdjustScales(). void TView3D::AdjustScales ; (; TVirtualPad * ; pad = nullptr). overridevirtual . Adjust all sides of view in respect of the biggest one. ; Implements TView.; Definition at line 1617 of file TView3D.cxx. ◆ AxisVertex(). void TView3D::AxisVertex ; (; Double_t ; ang, . Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTView3D.html:23918,depend,depending,23918,doc/master/classTView3D.html,https://root.cern,https://root.cern/doc/master/classTView3D.html,1,['depend'],['depending']
Integrability,"_t fgDby = 0;  ; static Pixel_t fgDefaultFrameBackground = 0;  ; static Pixel_t fgDefaultSelectedBackground = 0;  ; static const TGGC * fgHilightGC = nullptr;  ; static Bool_t fgInit = kFALSE;  ; static UInt_t fgLastButton = 0;  ; static Time_t fgLastClick = 0;  ; static const TGGC * fgShadowGC = nullptr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGTable.h>. Inheritance diagram for TGTable:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGTable(). TGTable::TGTable ; (; const TGWindow * ; p = nullptr, . Int_t ; id = 0, . TVirtualTableInterface * ; interface = nullptr, . UInt_t ; nrows = 50, . UInt_t ; ncolumns = 20 . ). TGTable constuctor. ; Definition at line 155 of file TGTable.cxx. ◆ ~TGTable(). TGTable::~TGTable ; (; ). override . TGTable destructor. ; Definition at line 190 of file TGTable.cxx. Member Function Documentation. ◆ Class(). static TClass * TGTable::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGTable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGTable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 232 of file TGTable.h. ◆ DeclFileName(). static const char * TGTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 232 of file TGTable.h. ◆ DoRedraw(). void TGTable::DoRedraw ; (; ). overrideprotectedvirtual . Redraw the TGTable. ; Reimplemented from TGFrame.; Definition at line 418 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:45520,interface,interface,45520,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['interface'],['interface']
Integrability,"_validIs integrator in valid state?; Bool_t_verboseVerbosity control; Double_t_wtd_int_sum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); This function registers class RooMCIntegrator, its configuration options; and its capabilities with RooNumIntFactory. RooMCIntegrator(); Default constructor. coverity[UNINIT_CTOR]. RooMCIntegrator(const RooAbsFunc& function, RooMCIntegrator::SamplingMode mode = Importance, RooMCIntegrator::GeneratorType genType = QuasiRandom, Bool_t verbose = kFALSE); Construct an integrator over 'function' with given sampling mode; and generator type. The sampling mode can be 'Importance'; (default), 'ImportanceOnly' and 'Stratified'. The generator type; can be 'QuasiRandom' (default) and 'PseudoRandom'. Consult the original; VEGAS documentation on details of the mode and type parameters. RooMCIntegrator(const RooAbsFunc& function, const RooNumIntConfig& config); Construct an integrator over 'function' where the configuration details; are taken from 'config'. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Return clone of this generator operating on given function with given configuration; Needed to support RooNumIntFactory. ~RooMCIntegrator(); Destructor. Bool_t checkLimits() const; Check if we can integrate over the current domain. If return value; is kTRUE we cannot handle the current limits (e.g. where the domain; of one or more observables is open ended. Double_t integral(const Double_t* yvec = 0); Evaluate the integral using a fixed number of calls to evaluate the integrand; equal to about 10k per dimension. Use the first 5k calls to refine the grid; over 5 iterations of 1k calls each, and the remaining 5k calls for a single; high statistics integration. Double_t vegas(RooMCIntegrator::Stage stage, UInt_t calls, UInt_t iterations, Double_t* absError = 0); Perform one step of Monte Carlo integration using th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCIntegrator.html:8848,integrat,integrator,8848,root/html528/RooMCIntegrator.html,https://root.cern,https://root.cern/root/html528/RooMCIntegrator.html,4,['integrat'],['integrator']
Integrability,"_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooGaussKronrodIntegrator1D, its parameters and capabilities with RooNumIntConfig. RooGaussKronrodIntegrator1D(); Default constructor. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object. The integration; range is taken from the definition in the function binding. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object in the given range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with given function and configuration. Needed for RooNumIntFactory. Bool_t initialize(); Perform one-time initialization of integrator. ~RooGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral. RooGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kTRUE ; }. Double_t* xvec(Double_t& xx); { _x[0] = xx ; return _x ; }. » Last changed: M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussKronrodIntegrator1D.html:8555,integrat,integrator,8555,root/html526/RooGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooGaussKronrodIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooGaussKronrodIntegrator1D, its parameters and capabilities with RooNumIntConfig. RooGaussKronrodIntegrator1D(); Default constructor. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object. The integration; range is taken from the definition in the function binding. RooGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integral on 'function' using given configuration object in the given range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with given function and configuration. Needed for RooNumIntFactory. Bool_t initialize(); Perform one-time initialization of integrator. ~RooGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral. RooGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kTRUE ; }. Double_t* xvec(Double_t& xx); { _x[0] = xx ; return _x ; }. » Last changed: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussKronrodIntegrator1D.html:8541,integrat,integrator,8541,root/html528/RooGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooGaussKronrodIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"` <td> Flag controls if HESSE is run after MIGRAD, on by default; 4088/// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; 4089/// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; 4090/// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; 4091/// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); 4092///; 4093/// <tr><th> <th> Options to control informational output; 4094/// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; 4095/// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; 4096/// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; 4097/// messages are suppressed as well; 4098/// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 4099/// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; 4100/// value suppress output completely, a zero value will only print the error count per p.d.f component,; 4101/// a positive value is will print details of each error up to numErr messages per p.d.f component.; 4102/// </table>; 4103///; 4104 ; 4105RooFit::OwningPtr<RooFitResult> RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2,; 4106 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 4107 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 4108{; 4109 RooLinkedList l ;; 4110 l.Add((TObject*)&arg1) ; l.Add((TObject*)&arg2) ;; 4111 l.Add((TObject*)&arg3) ; l.Add((TObject*)&arg4) ;; 4112 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4113 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4114 return chi2FitTo(data,l) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:178759,message,messages,178759,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['message'],['messages']
Integrability,"`, `tz` are the translation components; 72 - `sx`, `sy`, `sz` are arbitrary scale constants on each axis,; 73 ; 74 The disadvantage in using this approach is that computation for 4x4 matrices; 75is expensive. Even combining two translation would become a multiplication; 76of their corresponding matrices, which is quite an undesired effect. On the; 77other hand, it is not a good idea to store a translation as a block of 16; 78numbers. We have therefore chosen to implement each basic transformation type; 79as a class deriving from the same basic abstract class and handling its specific; 80data and point/vector transformation algorithms.; 81 ; 82\image html geom_transf.jpg; 83 ; 84### The base class TGeoMatrix defines abstract metods for:; 85 ; 86#### translation, rotation and scale getters. Every derived class stores only; 87 its specific data, e.g. a translation stores an array of 3 doubles and a; 88 rotation an array of 9. However, asking which is the rotation array of a; 89 TGeoTranslation through the base TGeoMatrix interface is a legal operation.; 90 The answer in this case is a pointer to a global constant array representing; 91 an identity rotation.; 92 ; 93~~~ {.cpp}; 94 Double_t *TGeoMatrix::GetTranslation(); 95 Double_t *TGeoMatrix::GetRotation(); 96 Double_t *TGeoMatrix::GetScale(); 97~~~; 98 ; 99#### MasterToLocal() and LocalToMaster() point and vector transformations :; 100 ; 101~~~ {.cpp}; 102 void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); 103 void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); 104 void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); 105 void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); 106~~~; 107 ; 108 These allow correct conversion also for reflections.; 109 ; 110#### Transformation type getters :; 111 ; 112~~~ {.cpp}; 113 Bool_t TGeoMatrix::IsIdentity(); 114 Bool_t TGeoMatrix::IsTranslation(); 115 Bool_t TGeoMatrix::IsRotation(); 116 Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:3818,interface,interface,3818,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['interface'],['interface']
Integrability,"`ParallelDescentOptions(bool enable=false, int splitStrategy=0, int numSplits=4)` <td> **Experimental** - Control settings related to the parallelization of likelihoods; 1053 * outside of the gradient calculation but in the minimization, most prominently; 1054 * in the linesearch step. The first argument this disables or enables likelihood; 1055 * parallelization. The second argument determines whether to split the task batches; 1056 * per event or per likelihood component. And the third argument how many events or; 1057 * respectively components to include in each batch.; 1058 * <tr><td> `TimingAnalysis(bool flag)` <td> **Experimental** - Log timings. This feature logs timings with NewStyle likelihoods on multiple processes simultaneously; 1059 * and outputs the timings at the end of a run to json log files, which can be analyzed with the; 1060 * `RooFit::MultiProcess::HeatmapAnalyzer`. Only works with simultaneous likelihoods.; 1061 * </table>; 1062 */; 1063 ; 1064 ; 1065/** @brief Protected implementation of the likelihood fitting routine.; 1066 *; 1067 * This virtual function can be overridden in case you want to change the likelihood fitting logic for custom PDFs.; 1068 *; 1069 * \note Never call this function directly. Instead, call RooAbsPdf::fitTo().; 1070 */; 1071 ; 1072std::unique_ptr<RooFitResult> RooAbsPdf::fitToImpl(RooAbsData& data, const RooLinkedList& cmdList); 1073{; 1074 return RooFit::FitHelpers::fitTo(*this, data, cmdList, false);; 1075}; 1076 ; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// Print value of p.d.f, also print normalization integral that was last used, if any; 1080 ; 1081void RooAbsPdf::printValue(ostream& os) const; 1082{; 1083 // silent warning messages coming when evaluating a RooAddPdf without a normalization set; 1084 RooHelpers::LocalChangeMsgLevel locmsg(RooFit::WARNING, 0u, RooFit::Eval, false);; 1085 ; 1086 getVal() ;; 1087 ; 1088 if (_norm) {; 1089 os << getVal() << ""/""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:52826,rout,routine,52826,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['rout'],['routine']
Integrability,"`b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167/// if nelem is a leaf name, it is used as the variable size of the array,; 168/// otherwise return 0.; 169/// The leaf referred to by nelem **MUST** be an int (/I),; 170/// - If leaf name has the form var[nelem], where nelem is a non-negative integers, then; 171/// it is used as the fixed size of the array.; 172/// - If leaf name has the form of a multi dimension array (e.g. var[nelem][nelem2]); 173/// where nelem and nelem2 are non-negative integers) then; 174/// it is used as a 2 dimensional array of fixed size.; 175/// - In case of the truncated floating point types (Float16_t and Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:5469,depend,dependent,5469,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['depend'],['dependent']
Integrability,"`std::vector<double>`), in which case the histogram; 1786 /// is filled with each one of the elements of the container. In case multiple columns of container type; 1787 /// are provided (e.g. values and weights) they must have the same length for each one of the events (but; 1788 /// possibly different lengths between events).; 1789 /// This action is *lazy*: upon invocation of this method the calculation is; 1790 /// booked but not executed. Also see RResultPtr.; 1791 ///; 1792 /// ### Example usage:; 1793 /// ~~~{.cpp}; 1794 /// // Deduce column type (this invocation needs jitting internally); 1795 /// auto myHist1 = myDf.Histo1D({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; 1796 /// // Explicit column type; 1797 /// auto myHist2 = myDf.Histo1D<float>({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; 1798 /// ~~~; 1799 ///; 1800 /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; 1801 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 1802 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 1803 template <typename V = RDFDetail::RInferredType>; 1804 RResultPtr<::TH1D> Histo1D(const TH1DModel &model = {"""", """", 128u, 0., 0.}, std::string_view vName = """"); 1805 {; 1806 const auto userColumns = vName.empty() ? ColumnNames_t() : ColumnNames_t({std::string(vName)});; 1807 ; 1808 const auto validatedColumns = GetValidatedColumnNames(1, userColumns);; 1809 ; 1810 std::shared_ptr<::TH1D> h(nullptr);; 1811 {; 1812 ROOT::Internal::RDF::RIgnoreErrorLevelRAII iel(kError);; 1813 h = model.GetHistogram();; 1814 h->SetDirectory(nullptr);; 1815 }; 1816 ; 1817 if (h->GetXaxis()->GetXmax() == h->GetXaxis()->GetXmin()); 1818 RDFInternal::HistoUtils<::TH1D>::SetCanExtendAllAxes(*h);; 1819 return CreateAction<RDFInternal::ActionTags::Histo1D, V>(validatedColumns, h, h, fProxiedPtr);; 1820 }; 1821 ; 1822 ////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:100743,interface,interfaces,100743,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['interface'],['interfaces']
Integrability,"a ; RooNDKeysPdf General N-dimensional non-parametric kernel estimation p.d.f; RooNLLVar Function representing (extended) -log(L) of p.d.f and dataset; RooNameReg String name registry; RooNameSet A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs; RooNonCPEigenDecay PDF to model CP-violating decays to final states which are not CP eigenstates; RooNormSetCache Management tool for tracking sets of similar integration/normalization sets; RooNovosibirsk Novosibirsk PDF; RooNumCdf Numeric calculator for CDF for a given PDF; RooNumConvPdf Operator PDF implementing numeric convolution of 2 input PDFs; RooNumConvolution Operator PDF implementing numeric convolution of 2 input functions; RooNumGenConfig Numeric (MC) Event generator configuration ; RooNumGenFactory Numeric Generator factory; RooNumIntConfig Numeric Integrator configuration ; RooNumIntFactory Numeric Integrator factory; RooNumRunningInt Numeric calculator for running integral of a given function; RooNumber wrapper class for portable numerics; RooObjCacheManager Cache manager for generic caches that contain RooAbsArg objects; RooParamBinning Binning specification with ranges parameterized by external RooAbsReal functions; RooParametricStepFunction Parametric Step Function Pdf; RooPlot Plot frame and container for graphics objects; RooPlotable Abstract interface for plotable objects in a RooPlot; RooPoisson A Poisson PDF; RooPolyVar Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurement w.r.t a truth value; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:38191,integrat,integration,38191,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,3,"['integrat', 'interface', 'wrap']","['integration', 'interface', 'wrapper']"
Integrability,"a = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(float val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:18708,rout,routine,18708,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,4,['rout'],['routine']
Integrability,"a PDF associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 1e-3, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:43334,integrat,integration,43334,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,1,['integrat'],['integration']
Integrability,"a RDefineReader or a RVariationReader, or nullptr if not available. ; No type checking is done on the requested reader. ; Definition at line 287 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [1/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::string & ; column); const. Get the names of all variations that directly or indirectly affect a given column. ; This list includes variations applied to the column as well as variations applied to other columns on which the value of this column depends (typically via a Define expression). ; Definition at line 130 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [2/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::vector< std::string > & ; columns); const. Get the names of all variations that directly or indirectly affect the specified columns. ; This list includes variations applied to the columns as well as variations applied to other columns on which the value of any of these columns depend (typically via Define expressions). ; Definition at line 140 of file RDFColumnRegister.cxx. ◆ GetVariationsFor(). std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationsFor ; (; const std::string & ; column); const. Get the names of the variations that directly provide alternative values for this column. ; Definition at line 114 of file RDFColumnRegister.cxx. ◆ IsAlias(). bool ROOT::Internal::RDF::RColumnRegister::IsAlias ; (; std::string_view ; name); const. Return true if the given column name is an existing alias. ; Definition at line 218 of file RDFColumnRegister.cxx. ◆ IsDefine(). bool ROOT::Internal::RDF::RColumnRegister::IsDefine ; (; std::string_view ; name); const. Return true if the given column name is an existing defined column. ; Definition at line 226 of file RDFColumnRegister.cxx. ◆ IsDefineOrAlias(). bool ROOT::Internal::RDF::RColumnRegister::IsDefineOrAlias ; (; std::string_view ; name); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:10251,depend,depend,10251,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['depend'],['depend']
Integrability,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. TObject* clone(const char* newname) const; { return new",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:42887,depend,dependents,42887,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,1,['depend'],['dependents']
Integrability,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Bool_t importWorkspaceHook(RooWorkspace& ws); Check if our datahist is already in the workspace. void Streamer(TBuffer& b); Stream an object of class Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistPdf.html:43103,depend,dependents,43103,root/html530/RooHistPdf.html,https://root.cern,https://root.cern/root/html530/RooHistPdf.html,1,['depend'],['dependents']
Integrability,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. TObject* clone(const char* newname) const; { return new RooHistPdf(*this,newname); }. RooDataHist& dataHist(); Return RooDataHist that is represented. c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:42052,depend,dependents,42052,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['depend'],['dependents']
Integrability,"a RooDataHist. The first list of observables are the p.d.f.; observables, which may any RooAbsReal (function or variable). The second list; are the corresponding observables in the RooDataHist which must be of type; RooRealVar or RooCategory This constructor thus allows to apply a coordinate transformation; on the histogram data to be applied. RooHistPdf(const RooHistPdf& other, const char* name = 0); Copy constructor. ~RooHistPdf(); Destructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the observables, normalized by the histograms contents. Interpolation; is applied if the RooHistPdf is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooHistPdf. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistPdf can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used on the integral over; all histogram observables is supported. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:44334,depend,dependents,44334,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,4,['depend'],['dependents']
Integrability,"a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments();; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4;; painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:18165,rout,rout,18165,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,3,['rout'],['rout']
Integrability,"a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. This technique is necessary as there is one stack per thread; and we can not rely on comparison with the current stack memory position. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStorage.html:4514,rout,routine,4514,root/html604/TStorage.html,https://root.cern,https://root.cern/root/html604/TStorage.html,1,['rout'],['routine']
Integrability,"a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStorage.html:4502,rout,routine,4502,root/html534/TStorage.html,https://root.cern,https://root.cern/root/html534/TStorage.html,2,['rout'],['routine']
Integrability,"a boost:; TLorentzRotation l; // l is initialized as identity TLorentzRotation m(l); // m = l TRotation r; TLorentzRotation lr(r); TLorentzRotation lb1(bx,by,bz); TVector3 b; TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; | 1+gamma'*bx*bx gamma'*bx*by gamma'*bx*bz gamma*bx |; | gamma'*by*bx 1+gamma'*by*by gamma'*by*bz gamma*by |; | gamma'*bz*bx gamma'*bz*by 1+gamma'*bz*bz gamma*bz |; | gamma*bx gamma*by gamma*bz gamma |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta) and gamma'=(gamma-1)/beta*beta. . Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions XX(), XY() .. TT(), through the operator (int,int):; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; ; if (l==m) {...} // test for equality; if (l !=m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; TLorentzRotation<div class=""legacybox""><h2>Legacy Code</h2> TLorentzRotation is a legacy interface: there will be no ...Definition TLorentzRotation.h:20; double; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. Transformations of a LorentzRotation; Compound transformations; There are four possibilities to find the product of two TLorentzRotation transformations:; TLorentzRotation a,b,c;; c = b*a;// product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b;// Attention: a=a*b; c = a.Transform(b)// a=b*a then c=a; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TLorentzRotation::MatrixMultiplicationTLorentzRotation MatrixMultiplication(const TLorentzRotation &) constDefinition TLorentzRotation.cxx:222; TLorentzRotation::TransformTLorentzRotation & Transform(const TLorentzRotation &)Definition TLorentzRotation.h:259; Lorentz boosts; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; TVe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLorentzRotation.html:2188,interface,interface,2188,doc/master/classTLorentzRotation.html,https://root.cern,https://root.cern/doc/master/classTLorentzRotation.html,1,['interface'],['interface']
Integrability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 113 of file TEnv.h. ◆ IsA(). TClass * TEnvRec::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 115 of file TEnv.h. ◆ Streamer(). void TEnvRec::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEnvRec::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 115 of file TEnv.h. Friends And Related Symbol Documentation. ◆ TEnv. friend class TEnv. friend . Definition at line 88 of file TEnv.h. ◆ TEnvParser. friend class TEnvParser. friend . Definition at line 89 of file TEnv.h. ◆ TReadEnvParser. friend class TReadEnvParser. friend . Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:14146,message,message,14146,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,1,['message'],['message']
Integrability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTNamed.html:19603,message,message,19603,doc/v632/classTNamed.html,https://root.cern,https://root.cern/doc/v632/classTNamed.html,1,['message'],['message']
Integrability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAnyPointer, TStreamerStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNamed.html:19526,message,message,19526,doc/master/classTNamed.html,https://root.cern,https://root.cern/doc/master/classTNamed.html,1,['message'],['message']
Integrability,"a double and returning a double in a 1D function interface For example, if you have a class like: struct X { double Eval(double x); }; you can wrapped in the following way: WrappedMemFunction<X, double ( X::* ) (double) > f; ;  CWrappedMemMultiFunction;  CWrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-dimensional function interface ;  CWrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm ;  CWrappedParamFunctionWrappedParamFunction class to wrap any multi-dimensional function pbject implementing the operator()(const double * x, const double * p) in an interface-like IParamFunction with a vector storing and caching internally the parameter values ;  CWrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(const double * ) in an interface-like IParamFunction, by fixing some of the variables and define them as parameters ;  CWrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime ;  NMathMore;  ►NMeta;  ►NSelection;  CClassAttributesUsed to specify attributes of classes in the ""DictSelection"" syntax ;  CKeepFirstTemplateArgumentsUsed to specify the number of arguments to be kept ;  CMemberAttributesUsed to specify attributes of data members in the ""DictSelection"" syntax ;  CSelectNoInstanceUsed to avoid to select all instances of a template ;  NMinuit;  ►NMinuit2;  CABObj;  CABObj< sym, LASymMatrix, double >;  CABObj< vec, LAVector, double >;  CABProd;  CABSum;  CAlgebraicProdType;  CAlgebraicProdType< gen, gen >;  CAlgebraicProdType< gen, sym >;  CAlgebraicProdType< gen, vec >;  CAlgebraicProdType< sym, gen >;  CAlge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:67131,interface,interface-like,67131,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['interface'],['interface-like']
Integrability,"a double and returning a double in a 1D function interface For example, if you have a class like: struct X { double Eval(double x); }; you can wrapped in the following way: WrappedMemFunction<X, double ( X::* ) (double) > f; ;  CWrappedMemMultiFunction;  CWrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-dimensional function interface ;  CWrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm ;  CWrappedParamFunctionWrappedParamFunction class to wrap any multi-dimensional function pbject implementing the operator()(const double * x, const double * p) in an interface-like IParamFunction with a vector storing and caching internally the parameter values ;  CWrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(const double * ) in an interface-like IParamFunction, by fixing some of the variables and define them as parameters ;  CWrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime ;  ►NMeta;  ►NSelection;  CClassAttributesUsed to specify attributes of classes in the ""DictSelection"" syntax ;  CKeepFirstTemplateArgumentsUsed to specify the number of arguments to be kept ;  CMemberAttributesUsed to specify attributes of data members in the ""DictSelection"" syntax ;  CSelectNoInstanceUsed to avoid to select all instances of a template ;  ►NMinuit2;  CABObj;  CABObj< sym, LASymMatrix, double >;  CABObj< vec, LAVector, double >;  CABProd;  CABSum;  CAlgebraicProdType;  CAlgebraicProdType< gen, gen >;  CAlgebraicProdType< gen, sym >;  CAlgebraicProdType< gen, vec >;  CAlgebraicProdType< sym, gen >;  CAlgebraicProdType< sym, sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:54147,interface,interface-like,54147,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['interface'],['interface-like']
Integrability,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer. » Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2010-11-19 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:12971,integrat,integration,12971,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,3,['integrat'],"['integration', 'integrations']"
Integrability,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer. » Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html:12973,integrat,integration,12973,root/html530/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLIntegrator.html,3,['integrat'],"['integration', 'integrations']"
Integrability,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer. » Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12973,integrat,integration,12973,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,3,['integrat'],"['integration', 'integrations']"
Integrability,"a genData().; When generating, data sets will be written out in ascii form if the pattern string is supplied The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat"" and should contain one integer field that encodes the sample serial number.; When fitting only, data sets may optionally be read from ascii files, using the same file pattern. ; Definition at line 321 of file RooMCStudy.cxx. ◆ Streamer(). void RooMCStudy::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMCStudy::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 152 of file RooMCStudy.h. Friends And Related Symbol Documentation. ◆ RooAbsMCStudyModule. friend class RooAbsMCStudyModule. friend . Definition at line 97 of file RooMCStudy.h. Member Data Documentation. ◆ _allDependents. RooArgSet RooMCStudy::_allDependents. protected . List of generate + prototype dependents. ; Definition at line 119 of file RooMCStudy.h. ◆ _binGenData. bool RooMCStudy::_binGenData. protected . Definition at line 132 of file RooMCStudy.h. ◆ _canAddFitResults. bool RooMCStudy::_canAddFitResults. protected . Allow adding of external fit results? ; Definition at line 136 of file RooMCStudy.h. ◆ _constrGenContext. std::unique_ptr<RooAbsGenContext> RooMCStudy::_constrGenContext. protected . Generator context for constraints p.d.f. ; Definition at line 116 of file RooMCStudy.h. ◆ _constrPdf. std::unique_ptr<RooAbsPdf> RooMCStudy::_constrPdf. protected . Constraints p.d.f. ; Definition at line 115 of file RooMCStudy.h. ◆ _dependents. RooArgSet RooMCStudy::_dependents. protected . List of dependents. ; Definition at line 118 of file RooMCStudy.h. ◆ _extendedGen. bool RooMCStudy::_extendedGen. protected . Definition at line 131 of file RooMCStudy.h. ◆ _fitInitParams. RooArgSet RooMCStudy::_fitInitParams. protected . List of initial values of fit parameters. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:41657,depend,dependents,41657,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['depend'],['dependents']
Integrability,"a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79this integration configuration. If no integration can be; 80performed, zero should be returned. Second,; 81 ; 82```; 83double analyticalIntegral(Int_t code); 84```; 85 ; 86implements the actual analytical integral(s) advertised by; 87`getAnalyticalIntegral()`. This function will only be called with; 88codes returned by `getAnalyticalIntegral()`, except code zero.; 89 ; 90The integration range for each dependent to be integrated can; 91be obtained from the dependent's proxy functions `min()` and; 92`max()`. Never call these proxy functions for any proxy not known to; 93be a dependent via the integration code. Doing so may be; 94ill-defined, e.g., in case the proxy holds a function, and will; 95trigger an assert. Integrated category dependents should always be; 96summed over all of their states.; 97 ; 98 ; 99 ; 100### Direct generation of observables; 101 ; 102Distributions for any PDF can be generated with the accept/reject method,; 103but for certain PDFs, more efficient methods may be implemented. To; 104implement direct generation of one or more",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:4062,integrat,integration,4062,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['integrat'],['integration']
Integrability,"a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::AbstractMethodvoid AbstractMethod(const char *method) constUse this method to implement an ""abstract"" method that you don't want to leave purely abstract.Definition TObject.cxx:1035; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::PutStatsvoid PutStats(Double_t *stats) overrideReplace current ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:213571,message,message,213571,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['message'],['message']
Integrability,"a list can be deletedDefinition TObject.h:62; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::GetBorderModeShort_t GetBorderMode() const overrideDefinition TPad.h:199; TPad::OpaqueMovingBool_t OpaqueMoving() const overrideIs pad moving in opaque mode ?Definition TPad.cxx:2879; TPad::PaintTextNDCvoid PaintTextNDC(Double_t u, Double_t v, const char *text) overridePaint text in CurrentPad NDC coordinates.Definition TPad.cxx:4613; TPad::GetTickyInt_t GetTicky() const overrideDefinition TPad.h:239; TPad::Clipvirtual Int_t Clip(Float_t *x, Float_t *y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt)Clipping routine: Cohen Sutherland algorithm.Definition TPad.cxx:768; TPad::HideToolTipvirtual void HideToolTip(Int_t event)Hide tool tip depending on the event type.Definition TPad.cxx:2847; TPad::fAbsYlowNDCDouble_t fAbsYlowNDCAbsolute Y top left corner of pad in NDC [0,1].Definition TPad.h:70; TPad::fXtoAbsPixelkDouble_t fXtoAbsPixelkConversion coefficient for X World to absolute pixel.Definition TPad.h:41; TPad::SetAttMarkerPSvoid SetAttMarkerPS(Color_t color, Style_t style, Size_t msize) overrideSet postscript marker attributes.Definition TPad.cxx:6227; TPad::DivideSquarevirtual void DivideSquare(Int_t n, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)""n"" is the total number of sub-pads.Definition TPad.cxx:1341; TPad::AbsCoordinatesvoid AbsCoordinates(Bool_t set) overrideDefinition TPad.h:167; TPad::AbsPixeltoYDouble_t AbsPixeltoY(Int_t py) overrideDefinition TPad.h:169; TPad::Classstatic TClass * Class(); TPad::IsBatchBool_t IsBatch() const overrideIs pad in batch mode ?Definition TPad.cxx:2856; TPad::GetUymaxDouble_t GetUymax() const overrideReturns the maximum y-coordinate value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:288241,depend,depending,288241,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['depend'],['depending']
Integrability,"a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC looks at $TEMP, $TEMP_DIR, $TEMPDIR, $TMP, $TMPDIR, $TMP_DIRor uses /tmp (or C:/). Also, a new interface TSystem::Get/SetBuildDir is introduced to let users select an alternative ‘root’ for building of the ACLiC libraries. For filename/full/path/name/macro.C, the library is created as fBuildDir/full/path/name/macro_C.so.; 7.4.3 Dictionary Generation; You can direct what is added to the dictionary generated by ACLiC in two ways. The simplest way is to add at the end of script (i.e. after the symbols have been defined) something like:; #if defined(__ROOTCLING__); #pragma link C++ class MyOtherClass;; #endif; You can also write this portion of code in a file name MyScript_linkdef.h where the suffix '_linkdef'is the prefix defined by the key ‘ACLiC.Linkdef‘ in the currently used resource file (usually .rootrcor$ROOTSYS/etc/system.rootrc) and the prefix is the name of your script.; The default behavior of rootcling is to not link in (i.e. generate the dictionary for) any of the symbols. In particular, this means that the following lines are, in the general case, unnecessary.; #pragma link off all globals;; #pragma link off all classes;; #p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:273456,interface,interface,273456,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 326 ; 327 /**; 328 Set the objective function (FCN) using a FitMethodGradFunction interface.; 329 Same as method above, but now extra information can be taken from the function class; 330 */; 331 bool SetFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter setti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:13333,interface,interface,13333,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['interface'],['interface']
Integrability,"a new canvas at a random position. ;  ; void Delete (Option_t *="""") override;  Delete this object. ;  ; void DeleteCanvasPainter ();  assert on IsBatch() == false? ;  ; void Destructor ();  Actual canvas destructor. ;  ; void DisconnectWidget ();  Used by friend class TCanvasImp. ;  ; void Draw (Option_t *option="""") override;  Draw a canvas. ;  ; TObject * DrawClone (Option_t *option="""") const override;  Draw a clone of this canvas A new canvas is created that is a clone of this canvas. ;  ; virtual TObject * DrawClonePad ();  Draw a clone of this canvas into the current pad In an interactive session, select the destination/current pad with the middle mouse button, then point to the canvas area to select the canvas context menu item DrawClonePad. ;  ; virtual void EditorBar ();  Get editor bar. ;  ; void EmbedInto (Int_t winid, Int_t ww, Int_t wh);  Embedded a canvas into a TRootEmbeddedCanvas. ;  ; void EnterLeave (TPad *prevSelPad, TObject *prevSelObj);  Generate kMouseEnter and kMouseLeave events depending on the previously selected object and the currently selected object. ;  ; void FeedbackMode (Bool_t set);  Turn rubberband feedback mode on or off. ;  ; void Flush ();  Flush canvas buffers. ;  ; void ForceUpdate ();  Force canvas update. ;  ; Bool_t GetAutoExec () const;  ; Int_t GetCanvasID () const override;  ; TCanvasImp * GetCanvasImp () const override;  ; TVirtualPadPainter * GetCanvasPainter ();  Access and (probably) creation of pad painter. ;  ; virtual void GetCanvasPar (Int_t &wtopx, Int_t &wtopy, UInt_t &ww, UInt_t &wh);  ; TObject * GetClickSelected () const;  ; TVirtualPad * GetClickSelectedPad () const;  ; TContextMenu * GetContextMenu () const;  ; const char * GetDISPLAY () const;  ; Int_t GetDoubleBuffer () const;  ; Int_t GetEvent () const override;  ; Int_t GetEventX () const override;  ; Int_t GetEventY () const override;  ; Color_t GetHighLightColor () const override;  ; TVirtualPad * GetPadSave () const override;  ; TObject * GetSelected (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:6285,depend,depending,6285,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,4,['depend'],['depending']
Integrability,"a pointer; to the pointer to our object. If we are *not* a top-level branch, return a pointer; to our object. If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. const char* GetIconName() const; -- Return icon name depending on type of branch element. Bool_t GetMakeClass() const; Return whether this branch is in a mode where the object are decomposed; or not (Also known as MakeClass mode). Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; -- Returns the branch value. If the leaf is an array, j is the index in the array. If leaf is an array inside a TClonesArray, len should be the length; of the array. If subarr is true, then len is actually the index within the sub-array. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchElement.html:22145,depend,depending,22145,root/html528/TBranchElement.html,https://root.cern,https://root.cern/root/html528/TBranchElement.html,1,['depend'],['depending']
Integrability,"a pointer; to the pointer to our object. If we are *not* a top-level branch, return a pointer; to our object. If we are owned by a MakeClass() tree:. Return a pointer to our object. void InitInfo(); -- Init the streamer info for the branch class, try to compensate for class code unload/reload and schema evolution. TVirtualCollectionProxy* GetCollectionProxy(); -- Return the collection proxy describing the branch content, if any. TClass* GetCurrentClass(); -- Return a pointer to the current type of the data member corresponding to branch element. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); -- Read all branches of a BranchElement and return total number of bytes. If entry = 0, then use current entry number + 1.; If entry < 0, then reset entry number to 0. Returns the number of bytes read from the input buffer.; If entry does not exist, then returns 0.; If an I/O error occurs, then returns -1. See IMPORTANT REMARKS in TTree::GetEntry. const char* GetIconName() const; -- Return icon name depending on type of branch element. Int_t GetMaximum() const; -- Return maximum count value of the branchcount if any. char* GetObject() const; -- Return a pointer to our object. TClass* GetParentClass(); -- Return a pointer to the parent class of the branch element. const char* GetTypeName() const; -- Return type name of element in the branch. Double_t GetValue(Int_t i, Int_t len, Bool_t subarr = kFALSE) const; -- Returns the branch value. If the leaf is an array, j is the index in the array. If leaf is an array inside a TClonesArray, len should be the length; of the array. If subarr is true, then len is actually the index within the sub-array. void* GetValuePointer() const; -- Returns pointer to first data element of this branch.; Currently used only for members of type character. void InitializeOffsets(); -- Initialize the base class subobjects offsets of our sub-branches and set fOffset if we are a container sub-branch. Note: The offsets are zero for data members so that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:20893,depend,depending,20893,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['depend'],['depending']
Integrability,"a previous call to SetAddress. ; Definition at line 4672 of file TBranchElement.cxx. ◆ Reset(). void TBranchElement::Reset ; (; Option_t * ; option = """"). overridevirtual . Reset a Branch. ; Existing i/o buffers are deleted. Entries, max and min are reset. ; Reimplemented from TBranch.; Definition at line 4752 of file TBranchElement.cxx. ◆ ResetAddress(). void TBranchElement::ResetAddress ; (; ). overridevirtual . Set branch address to zero and free all allocated memory. ; Reimplemented from TBranch.; Definition at line 4780 of file TBranchElement.cxx. ◆ ResetAfterMerge(). void TBranchElement::ResetAfterMerge ; (; TFileMergeInfo * ; info). overridevirtual . Reset a Branch after a Merge operation (drop data but keep customizations) ; Reimplemented from TBranch.; Definition at line 4767 of file TBranchElement.cxx. ◆ ResetDeleteObject(). void TBranchElement::ResetDeleteObject ; (; ). virtual . Release ownership of any allocated objects. ; Note: This interface was added so that clone trees could be told they do not own the allocated objects. ; Definition at line 4814 of file TBranchElement.cxx. ◆ ResetInitInfo(). void TBranchElement::ResetInitInfo ; (; bool ; recurse). virtual . Reset offset and StreamerInfo information from this branch. ; Parameters. [in]recurseWhen true call ResetInitInfo on all subbranches. . Definition at line 4831 of file TBranchElement.cxx. ◆ SetActionSequence(). void TBranchElement::SetActionSequence ; (; TClass * ; originalClass, . TStreamerInfo * ; localInfo, . TStreamerInfoActions::TActionSequence::SequenceGetter_t ; create, . TStreamerInfoActions::TActionSequence *& ; actionSequence . ). protected . Set the sequence of actions needed to read the data out of the buffer. ; Definition at line 5628 of file TBranchElement.cxx. ◆ SetAddress(). void TBranchElement::SetAddress ; (; void * ; addr). overridevirtual . Point this branch at an object. ; For a sub-branch, addr is a pointer to the branch object.; For a top-level branch the meaning of addr i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:65328,interface,interface,65328,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['interface'],['interface']
Integrability,"a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoMaterial.cxx:594; TGeoMaterial::ScreenFactorstatic Double_t ScreenFactor(Double_t z)static function Compute screening factor for pair production and Bremsstrahlung REFERENCE : EGS MANUA...Definition TGeoMaterial.cxx:1343; TGeoMaterial::GetConstPropertyRefconst char * GetConstPropertyRef(const char *property) constDefinition TGeoMaterial.cxx:384; TGeoMaterial::IsMixturevirtual Bool_t IsMixture() constDefinition TGeoMaterial.h:124; TGeoMaterial::fPressureDouble_t fPressureDefinition TGeoMaterial.h:47; TGeoMaterial::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the material.Definition TGeoMaterial.cxx:449; TGeoMaterial::AddConstPropertybool AddConstProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:430; TGeoMaterial::fTemperatureDouble_t fTemperatureDefinition TGeoMaterial.h:46; TGeoMaterial::GetElementPropvirtual void GetElementProp(Double_t &a, Double_t &z, Double_t &w, Int_t i=0)Single interface to get element properties.Definition TGeoMaterial.cxx:647; TGeoMaterial::DecayMaterialvirtual TGeoMaterial * DecayMaterial(Double_t time, Double_t precision=0.001)Create the material representing the decay product of this material at a given time.Definition TGeoMaterial.cxx:671; TGeoMaterial::fPropertiesTList fPropertiesDefinition TGeoMaterial.h:52; TGeoMaterial::AddPropertybool AddProperty(const char *property, const char *ref)Definition TGeoMaterial.cxx:418; TGeoMaterial::fZDouble_t fZDefinition TGeoMaterial.h:42; TGeoMaterial::SetRadLenvoid SetRadLen(Double_t radlen, Double_t intlen=0.)Set radiation/absorption lengths.Definition TGeoMaterial.cxx:496; TGeoMaterial::GetElementTGeoElement * GetElement() constGet a pointer to the element this material is made of.Definition TGeoMaterial.cxx:625; TGeoMaterial::fIndexInt_t fIndexDefinition TGeoMaterial.h:40; TGeoMaterial::kMatSavePrimitive@ kMatSavePrimitiveDefinition TGeoMaterial.h:36; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:57838,interface,interface,57838,doc/master/TGeoMaterial_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html,1,['interface'],['interface']
Integrability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPosixThread.html:7316,rout,routine,7316,root/html534/TPosixThread.html,https://root.cern,https://root.cern/root/html534/TPosixThread.html,1,['rout'],['routine']
Integrability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPosixThread.html:7777,rout,routine,7777,root/html604/TPosixThread.html,https://root.cern,https://root.cern/root/html604/TPosixThread.html,1,['rout'],['routine']
Integrability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPosixThread.html:7777,rout,routine,7777,root/html602/TPosixThread.html,https://root.cern,https://root.cern/root/html602/TPosixThread.html,1,['rout'],['routine']
Integrability,"a rotation of an angle phi (yaw) about the Z axis, followed by a rotation of an angle theta (pitch) about the new Y' axis, followed by a third rotation of an angle psi (roll) about the final X'' axis ;  CRowOffsetsStatic structure to keep the conversion from (i,j) to offsets in the storage data for a symmetric matrix ;  CSDeterminantDsfact ;  CSinVariableTransformationSin Transformation class for dealing with double bounded variables ;  CSInverterDsinv ;  CSkipFunction;  CSkipFunction< 0 >;  ►CSMatrixSMatrix: a generic fixed size D1 x D2 Matrix class ;  CSMatrixRow;  CSMatrixRow_const;  CSMatrixIdentity;  CSMatrixNoInit;  CSqrUnary Square Operation Class ;  CSqrtUnary Square Root Operation Class ;  CSqrtLowVariableTransformationSqrt Transformation class for dealing with lower bounded variables ;  CSqrtUpVariableTransformationSqrt Transformation class for dealing with upper bounded variables ;  CStdEngineClass to wrap engines fron the C++ standard random library in the ROOT Random interface ;  CStdEngineType;  CStdEngineType< std::knuth_b >;  CStdEngineType< std::minstd_rand >;  CStdEngineType< std::mt19937 >;  CStdEngineType< std::mt19937_64 >;  CStdEngineType< std::random_device >;  CStdEngineType< std::ranlux24 >;  CStdEngineType< std::ranlux48 >;  CStdRandomEngine;  CSVectorSVector: a generic fixed size Vector class ;  CTDataPoint;  CTDataPointN;  CTensorMulOpClass for Tensor Multiplication (outer product) of two vectors giving a matrix ;  CTRandomEngine;  CTransposeOpClass for Transpose Operations ;  CTranspPolicyMatrix transpose policy ;  CTranspPolicy< T, D1, D2, MatRepSym< T, D1 > >;  CUnaryOpUnaryOperation class A class representing unary operators in the parse tree ;  CVavilovBase class describing a Vavilov distribution ;  CVavilovAccurateClass describing a Vavilov distribution ;  CVavilovAccurateCdfClass describing the Vavilov cdf ;  CVavilovAccuratePdfClass describing the Vavilov pdf ;  CVavilovAccurateQuantileClass describing the Vavilov quantile functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:56320,interface,interface,56320,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['interface'],['interface']
Integrability,"a state with given name, the lowest available; positive integer is assigned as index. Category; state labels may not contain semicolons.; Error status is return if state with given name; is already defined. Bool_t defineType(const char* label, Int_t index); Define a state with given name and index. Category; state labels may not contain semicolons; Error status is return if state with given name; or index is already defined. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; compact only at the moment. void clearRange(const char* name, Bool_t silent); Check that both input arguments are not null pointers. void setRange(const char* rangeName, const char* stateNameList). void addToRange(const char* rangeName, const char* stateNameList); Check that both input arguments are not null pointers. Bool_t isStateInRange(const char* rangeName, const char* stateName) const; If no range is specified [ i.e. the default range ] all category states are in range. void Streamer(TBuffer& ). TObject* clone(const char* newname) const; { return new RooCategory(*this,newname); }. Int_t getIndex() const; Value modifiers. const char* getLabel() const. Bool_t isFundamental() const; We implement a fundamental type of AbsArg that can be stored in a dataset. Bool_t isDerived() const; Does value or shape of this arg depend on any other arg?. void clearTypes(); { RooAbsCategory::clearTypes() ; }. Bool_t inRange(const char* rangeName) const; Returns true of current value of category is inside given range. Bool_t hasRange(const char* rangeName) const; Returns true if category has range with given name. RooCatType evaluate() const; Dummy implementation. » Last changed: Tue Jun 2 15:29:49 2015 » Last generated: 2015-06-02 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCategory.html:27481,depend,depend,27481,root/html604/RooCategory.html,https://root.cern,https://root.cern/root/html604/RooCategory.html,1,['depend'],['depend']
Integrability,"a stored in TTrees with a high level interface ;  Tree LibraryTo store large quantities of same-class objects, ROOT provides the TTree and TNtuple classes ;  ▼TutorialsA collection of macros helping to learn ROOT by example ;  Tutorials specific to Mac/CocoaVarious examples showing graphics done with the Mac graphics system Cocoa. These examples run only on Mac/Os ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Data Frame tutorialsThese examples show the functionalities of the RDataFrame class ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files interface tutorialsExamples showing the FITS file interface ;  FOAM tutorialsExamples showing how to use FOAM ;  Geometry tutorialsVarious ROOT geometry package examples ;  OpenGL tutorialsVarious examples showing the OpenGL graphics in ROOT ;  Graphics tutorialsVarious examples showing the basic ROOT graphics ;  Graphs tutorialsExamples showing the ""graphs classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/modules.html:9620,interface,interface,9620,doc/v614/modules.html,https://root.cern,https://root.cern/doc/v614/modules.html,2,['interface'],['interface']
Integrability,"a the RooNumIntConfig object reference returned by the convIntConfig() member function By default the numeric convolution is integrated from -infinity to +infinity through a x -> 1/x coordinate transformation of the tails. For convolution with a very small bandwidth it may be advantageous (for both CPU consumption and stability) if the integration domain is limited to a finite range. The function setConvolutionWindow(mean,width,scale) allows to set a sliding window around the x value to be calculated taking a RooAbsReal expression for an offset and a width to be taken around the x value. These input expression can be RooFormulaVars or other function objects although the 3d 'scale' argument 'scale' multiplies the width RooAbsReal expression given in the 2nd argument, allowing for an appropriate window definition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The default numeric precision is 1e-7, i.e. the global default for numeric integration but you should experiment with this value to see if it is sufficient for example by studying the number of function calls that MINUIT needs to fit your function as function of the convolution precision. ; Definition at line 26 of file RooNumConvPdf.h. Public Member Functions;  RooNumConvPdf ();  ;  RooNumConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf, RooAbsPdf &resmodel);  ;  RooNumConvPdf (const RooNumConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvPdf () override;  Destructor. ;  ; void clearConvolutionWindow ();  ; TObject * clone (const char *newname) const override;  ; RooNumIntConfig & convIntConfig ();  ; double evaluate () const override;  Calculate and return value of p.d.f. ;  ; TClass * IsA () const override;  ; RooAbsReal & model () const;  ; RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:2235,integrat,integration,2235,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['integrat'],['integration']
Integrability,"a the RooNumIntConfig object reference returned by the convIntConfig() member function By default the numeric convolution is integrated from -infinity to +infinity through a x -> 1/x coordinate transformation of the tails. For convolution with a very small bandwidth it may be advantageous (for both CPU consumption and stability) if the integration domain is limited to a finite range. The function setConvolutionWindow(mean,width,scale) allows to set a sliding window around the x value to be calculated taking a RooAbsReal expression for an offset and a width to be taken around the x value. These input expression can be RooFormulaVars or other function objects although the 3d 'scale' argument 'scale' multiplies the width RooAbsReal expression given in the 2nd argument, allowing for an appropriate window definition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The default numeric precision is 1e-7, i.e. the global default for numeric integration but you should experiment with this value to see if it is sufficient for example by studying the number of function calls that MINUIT needs to fit your function as function of the convolution precision. ; Definition at line 29 of file RooNumConvolution.h. Public Member Functions;  RooNumConvolution ();  ;  RooNumConvolution (const char *name, const char *title, RooRealVar &convVar, RooAbsReal &pdf, RooAbsReal &resmodel, const RooNumConvolution *proto=nullptr);  Constructor of convolution operator PDF. ;  ;  RooNumConvolution (const RooNumConvolution &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvolution () override;  Destructor. ;  ; void clearConvolutionWindow ();  Removes previously defined convolution window, reverting to convolution from -inf to +inf. ;  ; TObject * clone (const char *newname) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:2085,integrat,integration,2085,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['integrat'],['integration']
Integrability,"a to SQL statements or read data from SQL tables; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TCivetweb http server implementation, based on civetweb embedded server; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray An array of clone objects; TCollection Collection abstract base class; TCollectionClassStreamer ; TCollectionMemberStreamer ; TCollectionMethodBrowsable Helper object to browse a collection's methods; TCollectionPropertyBrowsable Helper object to add browsable collection properties; TCollectionProxyFactory ; TCollectionStreamer ; TColor Color defined by RGB or HLS; TColorGradient Gradient fill.; TColorGradient::Point ; TColorWheel The ROOT Color Wheel; TColumnView Helper to represent one TTable column; TComplex Complex Class; TCondition Condition variable class; TConditionImp Condition variable implementation ABC; TCondor Interface to the Condor System; TCondorSlave Describes a claimed slave; TConfidenceLevel output for TLimit functions; TContextMenu Context sensitive popup menu; TContextMenuImp Context sensitive popup menu implementation; TControlBar Contro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:56540,interface,interface,56540,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['interface'],['interface']
Integrability,"a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset, 				 const RooNumIntConfig* cfg, const char* rangeName); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:35189,integrat,integrates,35189,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,2,['integrat'],['integrates']
Integrability,"a way to release a lock used to protect ...Definition TCling.cxx:7546; TCling::fLookedUpClassesstd::set< size_t > fLookedUpClassesDefinition TCling.h:121; TCling::TClingTCling(const TCling &)=delete; TCling::AddAvailableIndentifiersvirtual void AddAvailableIndentifiers(TSeqCollection &Idents) finalDefinition TCling.cxx:2358; TCling::TypedefInfo_Deletevoid TypedefInfo_Delete(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9442; TCling::Resetvoid Reset() finalPressing Ctrl+C should forward here.Definition TCling.cxx:3708; TCling::TypedefInfo_TrueNameconst char * TypedefInfo_TrueName(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9514; TCling::SetClassAutoLoadingint SetClassAutoLoading(int) const finalEnable/Disable the AutoLoading of libraries.Definition TCling.cxx:7567; TCling::ClassInfo_FullNameconst char * ClassInfo_FullName(ClassInfo_t *info) const finalDefinition TCling.cxx:8424; TCling::AutoParseImplRecurseUInt_t AutoParseImplRecurse(const char *cls, bool topLevel)Helper routine for TCling::AutoParse implementing the actual call to the parser and looping over temp...Definition TCling.cxx:6381; TCling::MethodInfo_TypeNameconst char * MethodInfo_TypeName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9147; TCling::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Long_t param) const finalDefinition TCling.cxx:7974; TCling::GetIncludePathconst char * GetIncludePath() finalRefresh the list of include paths known to the interpreter and return it with -I prepended.Definition TCling.cxx:7370; TCling::UpdateListsOnUnloadedvoid UpdateListsOnUnloaded(const cling::Transaction &T)Invalidate stored TCling state for declarations included in transaction ‘T’.Definition TCling.cxx:6849; TCling::UpdateClassInfoWithDeclvoid UpdateClassInfoWithDecl(const clang::NamedDecl *ND)Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.Definition TCling.cxx:6681; TCling::IsSameTypebool IsSameType(const void *QualTypePtr1, const void *QualTypePtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:86240,rout,routine,86240,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['rout'],['routine']
Integrability,"a wrapper class for the MIXMAX Random number generator.Definition MixMaxEngine.h:102; ROOT::Math::MixMaxEngine::StateInt_tuint64_t StateInt_tDefinition MixMaxEngine.h:110; ROOT::Math::MixMaxEngine::IntRndmResult_t IntRndm()generate a 64 bit integer numberDefinition MixMaxEngine.icc:103; ROOT::Math::MixMaxEngine::GetStatevoid GetState(std::vector< StateInt_t > &state) constget the state of the generatorDefinition MixMaxEngine.icc:141; ROOT::Math::MixMaxEngine::~MixMaxEngine~MixMaxEngine() overrideDefinition MixMaxEngine.icc:42; ROOT::Math::MixMaxEngine::SetSeedvoid SetSeed(Result_t seed)set the generator seedDefinition MixMaxEngine.icc:53; ROOT::Math::MixMaxEngine::BaseTypeTRandomEngine BaseTypeDefinition MixMaxEngine.h:106; ROOT::Math::MixMaxEngine::Rndmdouble Rndm() overrideDefinition MixMaxEngine.h:135; ROOT::Math::MixMaxEngine::Counterint Counter() constGet the counter (between 0 and Size-1)Definition MixMaxEngine.icc:152; ROOT::Math::MixMaxEngine::operator()double operator()()generate a double random number (faster interface)Definition MixMaxEngine.h:138; ROOT::Math::MixMaxEngine::Rndm_impldouble Rndm_impl()implementation function to generate the random numberDefinition MixMaxEngine.icc:92; ROOT::Math::MixMaxEngine::Namestatic const char * Name()get name of the generatorDefinition MixMaxEngine.icc:157; ROOT::Math::MixMaxEngine::fRngMixMaxEngineImpl< N > * fRngmixmax internal engine classDefinition MixMaxEngine.h:170; ROOT::Math::MixMaxEngine::RndmArrayvoid RndmArray(int n, double *array)generate an array of random numbersDefinition MixMaxEngine.icc:123; ROOT::Math::MixMaxEngine::SetStatevoid SetState(const std::vector< StateInt_t > &state)set the full initial generator stateDefinition MixMaxEngine.icc:130; ROOT::Math::MixMaxEngine::Sizestatic int Size()Get the size of the generator.Definition MixMaxEngine.icc:147; ROOT::Math::MixMaxEngine::Result_tuint64_t Result_tDefinition MixMaxEngine.h:114; ROOT::Math::MixMaxEngine::MaxIntstatic uint64_t MaxInt()maximum inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MixMaxEngine_8h_source.html:8280,interface,interface,8280,doc/master/MixMaxEngine_8h_source.html,https://root.cern,https://root.cern/doc/master/MixMaxEngine_8h_source.html,1,['interface'],['interface']
Integrability,"a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:7887,wrap,wrapper,7887,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,1,['wrap'],['wrapper']
Integrability,"a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootCanvas.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQRootCanvas.html:7887,wrap,wrapper,7887,root/html532/TQRootCanvas.html,https://root.cern,https://root.cern/root/html532/TQRootCanvas.html,1,['wrap'],['wrapper']
Integrability,"a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTitle(const char* title = """"); just a wrapper. void ToggleEventStatus(); just a wrapper. void ToggleAutoExec(); just a wrapper. void Update(); just a wrapper. void closeEvent(QCloseEvent* e); Close. ~TQRootCanvas(); dtor. TQRootCanvas(const TQRootCanvas& ). TQRootCanvas& operator=(const TQRootCanvas& ). TCanvas* GetCanvas(); { return fCanvas;}. Int_t GetRootWid(); { return fWid;}. Bool_t GetCanvasOwner(); { return fIsCanvasOwned; }. QWidget* GetParent(); { return fParent;}. QWidget* GetTabWin(); { return fTabWin;}. Bool_t NeedsResize(). {return fNeedResize;}. void SetNeedsResize(Bool_t yes); {fNeedResize=yes;}. bool eventFilter(QObject* , QEvent* ). » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:7647,wrap,wrapper,7647,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"a());; 2292 gdbscript = """";; 2293 }; 2294 }; 2295 if (gdbscript == """") {; 2296 gdbscript = ""gdb-backtrace.sh"";; 2297 gSystem->PrependPathName(TROOT::GetEtcDir(), gdbscript);; 2298 if (AccessPathName(gdbscript, kReadPermission)) {; 2299 fprintf(stderr, ""Error in <TUnixSystem::StackTrace> script %s is missing\n"", gdbscript.Data());; 2300 return;; 2301 }; 2302 }; 2303 gdbscript += "" "";; 2304 ; 2305 TString gdbmess = gEnv->GetValue(""Root.StacktraceMessage"", """");; 2306 gdbmess = gdbmess.Strip();; 2307 ; 2308 std::cout.flush();; 2309 fflush(stdout);; 2310 ; 2311 std::cerr.flush();; 2312 fflush(stderr);; 2313 ; 2314 int fd = STDERR_FILENO;; 2315 ; 2316 const char *message = "" Generating stack trace...\n"";; 2317 ; 2318 if (fd && message) { } // remove unused warning (remove later); 2319 ; 2320 if (gApplication && !strcmp(gApplication->GetName(), ""TRint"")); 2321 Getlinem(kCleanUp, nullptr);; 2322 ; 2323#if defined(USE_GDB_STACK_TRACE); 2324 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2325 if (!gdb) {; 2326 fprintf(stderr, ""gdb not found, need it for stack trace\n"");; 2327 return;; 2328 }; 2329 ; 2330 // write custom message file; 2331 TString gdbmessf = ""gdb-message"";; 2332 if (gdbmess != """") {; 2333 FILE *f = TempFileName(gdbmessf);; 2334 fprintf(f, ""%s\n"", gdbmess.Data());; 2335 fclose(f);; 2336 }; 2337 ; 2338 // use gdb to get stack trace; 2339 gdbscript += GetExePath();; 2340 gdbscript += "" "";; 2341 gdbscript += GetPid();; 2342 if (gdbmess != """") {; 2343 gdbscript += "" "";; 2344 gdbscript += gdbmessf;; 2345 }; 2346 gdbscript += "" 1>&2"";; 2347 Exec(gdbscript);; 2348 delete [] gdb;; 2349 return;; 2350 ; 2351#elif defined(R__AIX); 2352 TString script = ""procstack "";; 2353 script += GetPid();; 2354 Exec(script);; 2355 return;; 2356#elif defined(R__SOLARIS); 2357 char *cppfilt = Which(Getenv(""PATH""), ""c++filt"", kExecutePermission);; 2358 TString script = ""pstack "";; 2359 script += GetPid();; 2360 if (cppfilt) {; 2361 script += "" | "";; 2362 script += cppfilt;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:71985,message,message,71985,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,3,['message'],['message']
Integrability,"a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const float* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:15352,depend,depends,15352,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,6,['depend'],['depends']
Integrability,"a, double precision);  Creates a wrapping RooBinSamplingPdf if appropriate. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:60071,integrat,integration,60071,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integration']
Integrability,"a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6483,integrat,integration,6483,root/html534/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html,1,['integrat'],['integration']
Integrability,"a.; Sources; http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon. Int_t IsInside(Double_t x, Double_t y) const; Return 1 if the point (x,y) is inside the polygon defined by; the graph vertices 0 otherwise. Algorithm:; The loop is executed with the end-point coordinates of a line segment; (X1,Y1)-(X2,Y2) and the Y-coordinate of a horizontal line.; The counter inter is incremented if the line (X1,Y1)-(X2,Y2) intersects; the horizontal line. In this case XINT is set to the X-coordinate of the; intersection point. If inter is an odd number, then the point x,y is within; the polygon. void LeastSquareFit(Int_t m, Double_t* a, Double_t xmin = 0, Double_t xmax = 0); Least squares polynomial fitting without weights. m number of parameters; a array of parameters; first 1st point number to fit (default =0); last last point number to fit (default=fNpoints-1). based on CERNLIB routine LSQ: Translated to C++ by Rene Brun. void LeastSquareLinearFit(Int_t n, Double_t& a0, Double_t& a1, Int_t& ifail, Double_t xmin = 0, Double_t xmax = 0); Least square linear fit without weights. Fit a straight line (a0 + a1*x) to the data in this graph.; ndata: if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; the initial parameter values for a fit with exponential function.; a0: constant; a1: slope; ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); xmin, xmax: fitting range. extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun. void Paint(Option_t* chopt = """"); Draw this graph with its current attributes. void PaintGraph(Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); Draw the (x,y) as a graph. void PaintGrapHist(Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); Draw the (x,y) as a histogram. void PaintStats(TF1* fit); Draw the stats. void Print(Option_t* chopt = """") const; Print graph valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:36202,rout,routine,36202,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,6,['rout'],['routine']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,2>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:4790,interface,interface,4790,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,4,['interface'],['interface']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,3>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_3_.html:4880,interface,interface,4880,root/html528/ROOT__Math__SVector_float_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_3_.html,4,['interface'],['interface']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,4>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_4_.html:4790,interface,interface,4790,root/html528/ROOT__Math__SVector_float_4_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_4_.html,4,['interface'],['interface']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,5>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_5_.html:4790,interface,interface,4790,root/html528/ROOT__Math__SVector_float_5_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_5_.html,4,['interface'],['interface']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,6>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_6_.html:4880,interface,interface,4880,root/html528/ROOT__Math__SVector_float_6_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_6_.html,4,['interface'],['interface']
Integrability,"a1, const float& a2, const float& a3, const float& a4, const float& a5, const float& a6, const float& a7, const float& a8, const float& a9, const float& a10); ROOT::Math::SVector<float,7>&Unit(). Data Members; public:. enum { kSize; };. private:. floatfArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_7_.html:4880,interface,interface,4880,root/html528/ROOT__Math__SVector_float_7_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_7_.html,4,['interface'],['interface']
Integrability,"a1=-1.484, ; prevFCN = 1899.958577 a1=-1.485, ; prevFCN = 1899.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf315_projectpdf.py. tutorialsroofitrf315_projectpdf.py. ROOT master - Reference Guide Generated on T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:4899,synchroniz,synchronize,4899,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,1,['synchroniz'],['synchronize']
Integrability,"a1=-1.484, ; prevFCN = 1899.958577 a1=-1.485, ; prevFCN = 1899.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf315_projectpdf.C. tutorialsroofitrf315_projectpdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:9326,synchroniz,synchronize,9326,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['synchroniz'],['synchronize']
Integrability,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html:5027,interface,interface,5027,root/html602/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html,2,['interface'],['interface']
Integrability,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html:5027,interface,interface,5027,root/html602/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html,2,['interface'],['interface']
Integrability,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html:5027,interface,interface,5027,root/html602/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html,2,['interface'],['interface']
Integrability,"a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html:5027,interface,interface,5027,root/html602/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html,2,['interface'],['interface']
Integrability,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:1632,protocol,protocol,1632,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['protocol'],['protocol']
Integrability,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:1640,protocol,protocol,1640,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,4,['protocol'],['protocol']
Integrability,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:1632,protocol,protocol,1632,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,2,['protocol'],['protocol']
Integrability,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:1640,protocol,protocol,1640,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['protocol'],['protocol']
Integrability,"a6, const T &a7, const T &a8);  construct a vector of size 8 from 8 scalar values ;  ;  SVector (const T &a1, const T &a2, const T &a3, const T &a4, const T &a5, const T &a6, const T &a7, const T &a8, const T &a9);  construct a vector of size 9 from 9 scalar values ;  ;  SVector (const T &a1, const T &a2, const T &a3, const T &a4, const T &a5, const T &a6, const T &a7, const T &a8, const T &a9, const T &a10);  construct a vector of size 10 from 10 scalar values ;  ; SVector< T, D > & operator= (const T &a1);  assignment from a scalar (only for size 1 vector) ;  ; SVector< T, D > & operator= (const SVector< T, D > &rhs);  assignment from another vector ;  ; template<class A > ; SVector< T, D > & operator= (const VecExpr< A, T, D > &rhs);  assignment from Vector Expression ;  ; — STL-like interface —; iterator begin ();  STL iterator interface. ;  ; iterator end ();  STL iterator interface. ;  ; const_iterator begin () const;  STL const_iterator interface. ;  ; const_iterator end () const;  STL const_iterator interface. ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, InputIterator end);  set vector elements copying the values iterator size must match vector size ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, unsigned int size);  set vector elements copying the values size must be <= vector size ;  ; — Operators —; bool operator== (const T &rhs) const;  element wise comparison ;  ; bool operator!= (const T &rhs) const;  element wise comparison ;  ; bool operator== (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator!= (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator== (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator!= (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:3337,interface,interface,3337,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['interface'],['interface']
Integrability,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html:4834,interface,interface,4834,root/html602/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html,4,['interface'],['interface']
Integrability,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html:4834,interface,interface,4834,root/html602/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html,4,['interface'],['interface']
Integrability,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html:4834,interface,interface,4834,root/html602/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html,4,['interface'],['interface']
Integrability,"a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html:4834,interface,interface,4834,root/html602/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,2>SVector<double,2>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,2>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[2]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html:4798,interface,interface,4798,root/html528/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_3_.html:4889,interface,interface,4889,root/html528/ROOT__Math__SVector_double_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_3_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_4_.html:4798,interface,interface,4798,root/html528/ROOT__Math__SVector_double_4_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_4_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_5_.html:4798,interface,interface,4798,root/html528/ROOT__Math__SVector_double_5_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_5_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_6_.html:4889,interface,interface,4889,root/html528/ROOT__Math__SVector_double_6_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_6_.html,4,['interface'],['interface']
Integrability,"a7, const double& a8, const double& a9); ROOT::Math::SVector<double,7>SVector<double,7>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,7>&Unit(). Data Members; public:. enum { kSize; };. private:. doublefArray[7]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_7_.html:4889,interface,interface,4889,root/html528/ROOT__Math__SVector_double_7_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_7_.html,4,['interface'],['interface']
Integrability,"a; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf704__amplitudefit_8C.html:8331,integrat,integrator,8331,doc/master/rf704__amplitudefit_8C.html,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html,2,['integrat'],['integrator']
Integrability,"a=1. void ReadRandom(const char* filename). Reads saved random generator status from filename. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Based on the BSD Unix (Rand) Linear congrential generator; Produces uniformly-distributed floating points between 0 and 1.; Identical sequence on all machines of >= 32 bits.; Periodicity = 2**31; generates a number in ]0,1]; Note that this is a generator which is known to have defects; (the lower random bits are correlated) and therefore should NOT be; used in any statistical study. void RndmArray(Int_t n, Double_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void RndmArray(Int_t n, Float_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void SetSeed(UInt_t seed = 0); Set the random generator seed. Note that default value is zero, which is different than the; default value used when constructing the class.; If the seed is zero the seed is set to a random value; which in case of TRandom depends on the machine clock.; Note that the machine clock is returned with a precision of 1 second.; If one calls SetSeed(0) within a loop and the loop time is less than 1s,; all generated numbers will be identical!; Instead if a different generator implementation is used (TRandom1 , 2 or 3) the seed is generated using; a 128 bit UUID. This results in different seeds and then random sequence for every SetSeed(0) call. void Sphere(Double_t& x, Double_t& y, Double_t& z, Double_t r); generates random vectors, uniformly distributed over the surface; of a sphere of given radius.; Input : r = sphere radius; Output: x,y,z a random 3-d vector of length r; Method: (based on algorithm suggested by Knuth and attributed to Robert E Knop); which uses less random numbers than the CERNLIB RN23DIM algorithm. Double_t Uniform(Double_t x1 = 1); returns a uniform deviate on the interval ]0, x1]. Double_t Uniform(Double_t x1, Double_t x2); returns a uniform deviate on the interv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom.html:15332,depend,depends,15332,root/html528/TRandom.html,https://root.cern,https://root.cern/root/html528/TRandom.html,3,['depend'],['depends']
Integrability,"aFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all RDataFrame operations currently work with this package. The subset that is currently available is:. AsNumpy; Count; Define; Fill; Filter; Graph; Histo[1,2,3]D; Max; Mean; Min; Profile[1,2,3]D; Snapshot; Sum. with support for more operations coming in the future.; Any distributed RDataFrame backend inherits the dependencies of the underlying software needed to distribute the applications. The Spark backend for example has the following runtime dependencies (ROOT will build just fine without, but the feature will be unavailable without these packages):. pyspark, that in turn has its own set of dependencies:; Java; py4j. Tests for the Spark backend can be turned ON/OFF with the new build option test_distrdf_pyspark (OFF by default).; Histogram Libraries. Add a new THistRange class for defining a generic bin range and iteration in a 1d and multi-dimensional histogram; Fix a memory leak in TF1::Copy and TFormula::Copy; Enable using automatic differentiation when computing parameter gradient in formula based TF1; Add several fixes and improvements to the TKDE class using kernel estimation for estimating a density from data.; Improve TF1::GetRandom, TH1::GetRandom and TH1::FillRandom (and same for TF2,TF3, TH2 and TH3 functions) to pass optionally a random number generator instance. This allows to use these function with a user provided random number generator instead of using the default gRandom. Math Libraries. Update the definitions of the physical constants using the recommended 2018 values from NIST.; Use also the new SI definition of base units from 2019, where the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:12175,depend,dependencies,12175,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['depend'],['dependencies']
Integrability,"aFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  Nroot-argparse;  Nrootmarks;  ►NROOTwriter;  CROOTwriter;  Nshapes;  Nsqlcreatedb;  Nsqlfilldb;  Nsqlio;  Nsqlselect;  Nstaff;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  Nsurfaces;  Ntbb;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declaration in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:83234,interface,interface,83234,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['interface'],['interface']
Integrability,"aFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declaration into fReturnType fScopeName::fFunctionName<fFunctionTemplateArguments>(fFunctionParameters) ;  CTInterpreterLookupHelper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:79554,interface,interface,79554,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['interface'],['interface']
Integrability,"aHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const char* name, const char* title, const RooArgList& funcObs, const RooArgList& histObs, const RooDataHist& dhist, Int_t intOrder = 0); Constructor from a RooDataHist. The variable listed in 'vars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. ~RooHistFunc(). Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the his",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:38048,depend,dependents,38048,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['depend'],['dependents']
Integrability,"aUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationUnitDecl();; 742 method = ROOT::TMetaUtils::GetFuncWithProto(TU, what, proto, interp,; 743 false /*diags*/);; 744 }; 745 bool has_input_error = false;; 746 if (method != nullptr && (method->getAccess() == clang::AS_public || method->getAccess() == clang::AS_none)) {; 747 std::string filename = ROOT::TMetaUtils::GetFileName(*method, interp);; 748 if (strstr(filename.c_str(), ""TBuffer.h"") != nullptr ||; 749 strstr(filename.c_str(), ""Rtypes.h"") != nullptr) {; 750 ; 751 has_input_error = true;; 752 }; 753 } else {; 754 has_input_error = true;; 755 }; 756 if (has_input_error) {; 757 // We don't want to generate duplicated error messages in several dictionaries (when generating temporaries); 758 const char *maybeconst = """";; 759 const char *mayberef = ""&"";; 760 if (what[strlen(what) - 1] == '<') {; 761 maybeconst = ""const "";; 762 mayberef = """";; 763 }; 764 ROOT::TMetaUtils::Error(nullptr,; 765 ""in this version of ROOT, the option '!' used in a linkdef file\n""; 766 "" implies the actual existence of customized operators.\n""; 767 "" The following declaration is now required:\n""; 768 "" TBuffer &%s(TBuffer &,%s%s *%s);\n"", what, maybeconst, fullname.c_str(), mayberef);; 769 }; 770 return has_input_error;; 771 ; 772}; 773 ; 774////////////////////////////////////////////////////////////////////////////////; 775/// Check if the operator>> has been properly declared if the user has; 776/// requested a custom version.; 777 ; 778bool CheckInputOperator(const clang::RecordDecl *cl, cling::Interpreter &interp); 779{; 780 string fullname;; 781 ROOT::TMetaUtils::GetQualifiedName(fullname, *cl);; 782 int ncha = fullname.length() + 13;; 783 char *proto = new char[ncha];; 784 snprintf(proto, ncha, ""TBuffer&,%s*&"", fullname.c_str(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:25971,message,messages,25971,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['message'],['messages']
Integrability,"abel for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; RooRealProxy_true; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooPullVar(); Default constructor. RooPullVar(const char* name, const char* title, RooRealVar& measurement, RooAbsReal& truth); Construct RooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:36594,integrat,integrator,36594,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,2,['integrat'],['integrator']
Integrability,"abel to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. RooAbsCategory(); Constructors, assignment etc. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Tue Jun 2 15:26:57 2015 » Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCategory.html:28387,integrat,integration,28387,root/html604/RooAbsCategory.html,https://root.cern,https://root.cern/root/html604/RooAbsCategory.html,1,['integrat'],['integration']
Integrability,"abelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooSetProxy_varSetNot used anymore?; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvCoefVar(const char* name, const char* title, const RooAbsAnaConvPdf& input, Int_t coefIdx, const RooArgSet* varList = 0); Constuctor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:36637,integrat,integrator,36637,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,2,['integrat'],['integrator']
Integrability,able ;  CVariableNormalizeTransformLinear interpolation class ;  CVariablePCATransformLinear interpolation class ;  CVariableRearrangeTransformRearrangement of input variables ;  CVariableTransformBaseLinear interpolation class ;  CVarTransformHandler;  CVolumeVolume for BinarySearchTree ;  ►NTStreamerInfoActions;  CTActionSequence;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CApplicationWindowMain Qt&Root Application Window: ;  CBalancerInfo;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClusterD;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CData;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CDUMMY;  CEditor;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  CFUMILI2;  Cfuncptr_and_voidptr_t;  CGaussFunction;  CGcCache_t;  CGCValues_t;  Cgroup;  CGSL_BFGS;  CGSL_BFGS2;  CGSL_FR;  CGSL_NLS;  CGSL_PR;  Ch1analysis;  Ch1analysisTreeReader;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CLI,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:81000,adapter,adapter,81000,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['adapter'],['adapter']
Integrability,able Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSelector for TTree::GetEntries(selection); TSelectorList Special TList used in the TSelector; TSelectorScalar Mergable scalar; TSemaphore ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:120267,interface,interface,120267,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['interface'],['interface']
Integrability,"able The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class ;  CMinOpSubtraction Operation Class ;  CMinusUnary Minus Operation Class ;  CMinusEqualsEvaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) ;  CMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix -= general : NOT Allowed operation ;  CMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices ;  CMiserParametersStructures collecting parameters for MISER multidimensional integration ;  CMixMaxEngineMixMaxEngine is a wrapper class for the MIXMAX Random number generator ;  CMixMaxEngineImpl;  CMixMaxEngineImpl< ROOT_MM_N >;  CMulOpMultiplication (element-wise) Operation Class ;  CMultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimensional parameteric function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a multi dimensional parameteric gradient function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiNumGradFunctionMultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CPar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:49962,wrap,wrap,49962,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['wrap'],['wrap']
Integrability,"able at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Minuit.html:1267,wrap,wrapped,1267,doc/master/group__Minuit.html,https://root.cern,https://root.cern/doc/master/group__Minuit.html,1,['wrap'],['wrapped']
Integrability,"able gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint codes for TPad::Clip. Int_t ClipPolygon(Int_t n, Double_t* x, Double_t* y, Int_t nn, Double_t* xc, Double_t* yc, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clip polygon using the Sutherland-Hodgman algorithm. Input parameters:. n: Number of points in the polygon to be clipped; x[n], y[n] : Polygon do be clipped vertices; xclipl, yclipb, xclipr, yclipt : Clipping boundary. Output parameters:. nn: number of points in xc and yc; xc, yc: clipped po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:32938,rout,routine,32938,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,6,['rout'],['routine']
Integrability,"able named R__ZipMode which can be modified by a global function named R__SetZipMode ;  CEAlgorithm;  CEDefaults;  CELevel;  CRDataFrameROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  Nroot-argparse;  Nrootmarks;  ►NROOTwriter;  CROOTwriter;  Nshapes;  Nsqlcreatedb;  Nsqlfilldb;  Nsqlio;  Nsqlselect;  Nstaff;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:83087,interface,interface,83087,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['interface'],['interface']
Integrability,"able named R__ZipMode which can be modified by a global function named R__SetZipMode ;  CEAlgorithm;  CEDefaults;  CELevel;  CRDataFrameROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Ccheck_bound_t;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  ►NTClassEdit;  CFunctionSplitInfoResult of splitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:79407,interface,interface,79407,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['interface'],['interface']
Integrability,"able->FindElement(""Copper"");; Materials made of single elements can be defined by their atomic mass (A), charge (Z) and density (rho). One can also create a material by specifying the element that it is made of. Optionally the radiation and absorption lengths can be also provided; otherwise they can be computed on-demand [G3]. The class representing them is TGeoMaterial:; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); Any material or derived class is automatically indexed after creation. The assigned index is corresponding to the last entry in the list of materials owned by TGeoManager class. This can be changed using the TGeoMaterial::SetIndex() method, however it is not recommended while using the geometry package interfaced with a transport MC. Radiation and absorption lengths can be set using:; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);. radlen: radiation length. If radlen<=0 the value is computed using GSMATE algorithm in GEANT3; intlen: absorption length. Material state, temperature and pressure can be changed via setters. Another material property is transparency. It can be defined and used while viewing the geometry with OpenGL.; void SetTransparency (Char_t transparency = 0). transparency: between 0 (opaque default) to 100 (fully transparent). One can attach to a material a user-defined object storing Cerenkov properties. Another hook for material shading properties is currently not in use. Mixtures are materials made of several elements. They are represented by the class TGeoMixture, deriving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:889058,interface,interfaced,889058,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interfaced']
Integrability,"able. ;  . Protected Member Functions; Window_t FindWindow (Window_t root, Int_t x, Int_t y, Int_t maxd);  Search for DND aware window at position x,y. ;  ; Window_t GetRootProxy ();  Get root window proxy. ;  ; Bool_t HandleDNDDrop (Window_t src, Time_t timestamp);  Handle DND drop event. ;  ; Bool_t HandleDNDEnter (Window_t src, long vers, Atom_t dataTypes[3]);  Handle DND enter event. ;  ; Bool_t HandleDNDFinished (Window_t target);  Handle DND finished event. ;  ; Bool_t HandleDNDLeave (Window_t src);  Handle DND leave event. ;  ; Bool_t HandleDNDPosition (Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp);  Handle DND position event. ;  ; Bool_t HandleDNDStatus (Window_t from, int accepted, Rectangle_t skip, Atom_t action);  Handle DND status event. ;  ; void InitAtoms ();  Initialize drag and drop atoms. ;  ; Bool_t IsDNDAware (Window_t win, Atom_t *typelist=nullptr);  Check if window win is DND aware. ;  ; Bool_t IsTopLevel (Window_t win);  ; void SendDNDDrop (Window_t target);  Send DND drop message to target window. ;  ; void SendDNDEnter (Window_t target);  Send DND enter message to target window. ;  ; void SendDNDFinished (Window_t src);  Send DND finished message to source window. ;  ; void SendDNDLeave (Window_t target);  Send DND leave message to target window. ;  ; void SendDNDPosition (Window_t target, int x, int y, Atom_t action, Time_t timestamp);  Send DND position message to target window. ;  ; void SendDNDStatus (Window_t target, Atom_t action);  Send DND status message to source window. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Atom_t fAcceptedAction;  ; Cursor_t fDNDNoDropCursor;  no drop cursor type ;  ; Atom_t * fDraggerTypes;  lists of DND types ;  ; Bool_t fDragging;  kTRUE while dragging ;  ; TGDragWindow * fDragWin;  drag wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:11648,message,message,11648,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['message'],['message']
Integrability,"able::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__FitterBase.html:6974,interface,interface,6974,root/html528/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html,2,['interface'],['interface']
Integrability,"able; RooAbsData*fPOIToTestvalue of POI points to perform the construction; RooAbsData*fPointsToTestpoints to perform the construction; Bool_tfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); standard constructor. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. TestStatSampler* GetTestStatSampler() const. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(RooAbsData& data, RooStats::ModelConfig& model); FeldmanCousins();; Common constructor. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void SetData(RooAbsData& ); Set the DataSet. void SetPdf(RooAbsPdf& ); Set the Pdf. void SetParameters(const RooArgSet& ); specify the parameters of interest in the interval. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). void SetParameterPointsToTest(RooAbsData& pointsToTest); User-defined set of points to test. void SetPOIPointsToTest(RooAbsData& poiToTest); User-defined set of points to test. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfiden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__FeldmanCousins.html:4645,interface,interface,4645,root/html530/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html530/RooStats__FeldmanCousins.html,5,['interface'],['interface']
Integrability,"able; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; TMVA::DataSetInfo & CreateCategoryDSI (const TCut &, const TString &, const TString &);  create a DataSetInfo object for a sub-classifier ;  ; void GetHelpMessage () const;  Get help message text. ;  ; virtual std::vector< Double_t > GetMvaValues (Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  returns the mva values of the right sub-classifier ;  ;  Protected Member Functions inherited from TMVA::MethodCompositeBase; MethodBase * GetCurrentMethod ();  ; MethodBase * GetCurrentMethod (UInt_t idx);  ; UInt_t GetCurrentMethodIndex ();  ; IMethod * GetLastMethod ();  ; IMethod * GetMethod (const Int_t index) const;  accessor by index in vector ;  ; IMethod * GetMethod (const TString &title) const;  accessor by name ;  ; IMethod * GetPreviousMethod ();  ;  Protected Member Functions inherited from TMVA::MethodBase; virtual std::vector< Double_t > GetDataMvaValues (DataSet *data=nullptr, Long64_t firstEvt=0, Long64_t lastEvt=-1, Bool_t logProgress=false);  get all the MVA values for the events of the given Data type ;  ; const TString & GetInternalVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCategory.html:25119,message,message,25119,doc/master/classTMVA_1_1MethodCategory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCategory.html,1,['message'],['message']
Integrability,"ables (bool stripDisconnected=true) const;  Return RooArgSet with all variables (tree leaf nodes of expression tree) ;  ; void graphVizTree (const char *fileName, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Create a GraphViz .dot file visualizing the expression tree headed by this RooAbsArg object. ;  ; void graphVizTree (std::ostream &os, const char *delimiter=""\n"", bool useTitle=false, bool useLatex=false);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolynomial.html:36302,depend,depend,36302,doc/master/classRooPolynomial.html,https://root.cern,https://root.cern/doc/master/classRooPolynomial.html,1,['depend'],['depend']
Integrability,"ables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(); RooStats::TestStatSamplerRooStats::TestStatSampler::TestStatSampler(const RooStats::TestStatSampler&). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DebuggingSampler(). virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__DebuggingSampler.html:2591,interface,interface,2591,root/html602/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__DebuggingSampler.html,2,['interface'],['interface']
Integrability,"ables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs that have one or more dependents in; 67common, etc).; 68 ; 69#### Implementing analytical integrals; 70To implement analytical integrals, two functions must be implemented. First,; 71 ; 72```; 73Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet); 74```; 75should return the analytical integrals that are supported. `integSet`; 76is the set of dependents for which integration is requested. The; 77function should copy the subset of dependents it can analytically; 78integrate to `anaIntSet`, and return a unique identification code for; 79t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:3069,integrat,integration,3069,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['integrat'],['integration']
Integrability,"ables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKernel ker) const; { return UInt_t(ker); }. EKernel UIntToKernel(UInt_t iker). UInt_t TargetSelectionToUInt(TMVA::ETargetSelection ts) const; { return UInt_t(ts); }. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodPDEFoam.html:26954,message,message,26954,root/html604/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodPDEFoam.html,1,['message'],['message']
Integrability,"ables. void WriteFoamsToFile() const; Write PDEFoams to file. void ReadWeightsFromStream(istream& i); read options and internal parameters. void ReadWeightsFromXML(void* wghtnode); read PDEFoam variables from xml weight file. TMVA::PDEFoam* ReadClonedFoamFromFile(TFile* , const TString& ); Reads a foam with name 'foamname' from file, and returns a clone; of the foam. The given ROOT file must be open. (The ROOT file; will not be closed in this function.). Parameters:. - file - an open ROOT file. - foamname - name of foam to load from the file. Returns:. If a foam with name 'foamname' exists in the file, then it is; read from the file, cloned and returned. If a foam with name; 'foamname' does not exist in the file or the clone operation; does not succeed, then NULL is returned. void ReadFoamsFromFile(); read foams from file. TMVA::ETargetSelection UIntToTargetSelection(UInt_t its); convert UInt_t to ETargetSelection (used for reading weight files). void FillVariableNamesToFoam() const; store the variable names in all foams. void MakeClassSpecific(ostream& , const TString& ) const; write PDEFoam-specific classifier response; NOT IMPLEMENTED YET!. void GetHelpMessage() const; provide help message. MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0). EKernel GetKernel( void ); helper functions to convert enum types to UInt_t and back. { return fKernel; }. UInt_t KernelToUInt(TMVA::MethodPDEFoam::EKernel ker) const; { return UInt_t(ker); }. EKernel UIntToKernel(UInt_t iker). UInt_t TargetSelectionToUInt(TMVA::ETargetSelection ts) const; { return UInt_t(ts); }. » Author: Tancredi Carli, Dominik Dannheim, Alexander Voigt » Copyright (c) 2008, 2010: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDEFoam.html:26946,message,message,26946,root/html602/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDEFoam.html,1,['message'],['message']
Integrability,"ablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooListProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUniform.html:38231,integrat,integrator,38231,root/html526/RooUniform.html,https://root.cern,https://root.cern/root/html526/RooUniform.html,1,['integrat'],['integrator']
Integrability,"above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction2PdfBinding_double_double_double_.html:40083,integrat,integrator,40083,root/html532/RooCFunction2PdfBinding_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction2PdfBinding_double_double_double_.html,1,['integrat'],['integrator']
Integrability,"above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:42325,integrat,integrator,42325,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['integrat'],['integrator']
Integrability,"abs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711505,integrat,integration,711505,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['integrat'],['integration']
Integrability,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(a,b). double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:7306,interface,interface,7306,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:7660,interface,interface,7660,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,15,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"abstract class) for parametric one-dimensional gradient functions providing in addition to function evaluation with respect the coordinates also the gradient with respect to the parameters, via the method ParameterGradient ;  CIRootFinderMethodInterface for finding function roots of one-dimensional functions ;  ►CKDTree;  CBaseNode;  CBinNode;  CComparePoints;  CCut;  CHeadNode;  Citerator;  CSplitNode;  CTerminalNode;  CKelvinFunctionsThis class calculates the Kelvin functions Ber(x), Bei(x), Ker(x), Kei(x), and their first derivatives ;  CLCGEngine;  CLocalCoordinateSystemTagTag for identifying vectors based on a local coordinate system ;  CLorentzRotationLorentz transformation class with the (4D) transformation represented by a 4x4 orthosymplectic matrix ;  CLorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system for the spatial vector part ;  CLSResidualFuncLSResidualFunc class description ;  CMathMoreLibrary;  CMatRepStdExpression wrapper class for Matrix objects ;  CMatRepSymMatRepSym Matrix storage representation for a symmetric matrix of dimension NxN This class is a template on the contained type and on the symmetric matrix size, N ;  CMatrixMulOpClass for Matrix-Matrix multiplication ;  CMemFunHandlerFunctor Handler to Wrap pointers to member functions The member function type must be (XXX means any name is allowed) : double XXX ( double x) for 1D functions and double XXXX (const double *x) for multi-dimensional functions ;  CMemGradFunHandlerFunctor Handler to Wrap pointers to member functions for the evaluation of the function and the gradient ;  CMersenneTwisterEngineRandom number generator class based on M ;  Cmeta_col_dot;  Cmeta_col_dot< 0 >;  Cmeta_dot;  Cmeta_dot< 0 >;  Cmeta_mag;  Cmeta_mag< 0 >;  Cmeta_matrix_dot;  Cmeta_matrix_dot< 0 >;  Cmeta_row_dot;  Cmeta_row_dot< 0 >;  CMinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:40074,wrap,wrapper,40074,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"ac[0.5,0.,1.]*bkg,sig)"");; ; } else {; ; // Use object factory to build pdf of tutorial rs502_wspacewrite but; // - Contracted to a single line recursive expression,; // - Omitting explicit names for components that are not referred to explicitly later; ; w->factory(""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[0.2,0.,1.]}),""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))"");; }; ; // A d v a n c e d p . d . f . c o n s t r u c t o r a r g u m e n t s; // ----------------------------------------------------------------; //; // P.d.f. constructor arguments may by any type of RooAbsArg, but also; //; // double --> converted to RooConst(...); // {a,b,c} --> converted to RooArgSet() or RooArgList() depending on required ctor arg; // dataset name --> converted to RooAbsData reference for any dataset residing in the workspace; // enum --> Any enum label that belongs to an enum defined in the (base) class; ; // Make a dummy dataset pdf 'model' and import it in the workspace; std::unique_ptr<RooDataSet> data{w->pdf(""model"")->generate(*w->var(""x""), 1000)};; w->import(*data, Rename(""data""));; ; // Construct a KEYS pdf passing a dataset name and an enum type defining the; // mirroring strategy; w->factory(""KeysPdf::k(x,data,NoMirror,0.2)"");; ; // Print workspace contents; w->Print();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFit::RenameRooCmdArg Rename(const char *suffix)Definition RooGlobalFunc.cxx:1055; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html:2253,depend,depending,2253,doc/master/rf511__wsfactory__basic_8C.html,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html,1,['depend'],['depending']
Integrability,"ace and fills the base-class visualization structures from pad contents. ; Definition at line 26 of file TGLScenePad.h. Public Member Functions;  TGLScenePad (TVirtualPad *pad);  cache logicals during scene rebuilds ;  ;  ~TGLScenePad () override;  ; void AddCompositeOp (UInt_t operation) override;  Add composite operation used to combine objects added via AddObject TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ;  ; void AddHistoPhysical (TGLLogicalShape *log, const Float_t *histColor=nullptr);  Scale and rotate a histo object to mimic placement in canvas. ;  ; Int_t AddObject (const TBuffer3D &buffer, Bool_t *addChildren=nullptr) override;  Add an object to the viewer, using internal physical IDs TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ;  ; Int_t AddObject (UInt_t physicalID, const TBuffer3D &buffer, Bool_t *addChildren=nullptr) override;  Add an object to the scene, using an external physical ID TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ;  ; void BeginScene () override;  Start building of the scene. ;  ; Bool_t BuildingScene () const override;  ; Bool_t CanLoopOnPrimitives () const override;  ; void CloseComposite () override;  Close composite container TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ;  ; Int_t DistancetoPrimitive (Int_t, Int_t) override;  Computes distance from point (px,py) to the object. ;  ; void EndScene () override;  End building of the scene. ;  ; void ExecuteEvent (Int_t, Int_t, Int_t) override;  Execute action corresponding to an event at (px,py). ;  ; TVirtualPad * GetPad () const;  ; Bool_t GetSmartRefresh () const;  ; TClass * IsA () const override;  ; void ObjectPaint (TObject *obj, Option_t *opt="""") override;  Override of virtual TVirtualViewer3D::ObjectPaint(). ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:1496,interface,interface,1496,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['interface'],['interface']
Integrability,"ace for new ROOT classes and functions. ; More... Namespaces; namespace  CocoaTutorials;  ; namespace  Detail;  ; namespace  ExecutorUtils;  This namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce. ;  ; namespace  Experimental;  ; namespace  Fit;  Namespace for the fitting classes. ;  ; namespace  GLTutorials;  ; namespace  Internal;  ; namespace  MacOSX;  ; namespace  Math;  ; namespace  MathMore;  ; namespace  Meta;  ; namespace  Minuit;  ; namespace  Minuit2;  ; namespace  option;  The namespace of The Lean Mean C++ Option Parser. ;  ; namespace  Quartz;  ; namespace  R;  namespace associated R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:1214,depend,depend,1214,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,1,['depend'],['depend']
Integrability,"ace should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNullModel(const RooStats::ModelConfig& model). SetAlternateModel(const RooStats::ModelConfig& model). void SetData(RooAbsData& data); Set the DataSet. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestCalculator.h 30462 2009-09-25 16:05:55Z moneta $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestCalculator.html:2342,interface,interface,2342,root/html528/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestCalculator.html,1,['interface'],['interface']
Integrability,"ace should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNullModel(const RooStats::ModelConfig& model). SetAlternateModel(const RooStats::ModelConfig& model). void SetData(RooAbsData& data); Set the DataSet. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestCalculator.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestCalculator.html:2344,interface,interface,2344,root/html530/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestCalculator.html,1,['interface'],['interface']
Integrability,"ace should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNullModel(const RooStats::ModelConfig& model). SetAlternateModel(const RooStats::ModelConfig& model). void SetData(RooAbsData& data); Set the DataSet. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestCalculator.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestCalculator.html:2344,interface,interface,2344,root/html532/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestCalculator.html,1,['interface'],['interface']
Integrability,"ace to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _useStandardParametrization = false;  ; RooRealProxy k;  the shape parameter, exp(sigma) ;  ; RooRealProxy m0;  the median, exp(mu) ;  ; RooRealProxy x;  the variable ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:68908,integrat,integration,68908,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['integrat'],['integration']
Integrability,"ace to TSpectrum::Search. ; The function finds peaks in this histogram where the width is > sigma and the peak maximum greater than threshold*maximum bin content of this. For more details see TSpectrum::Search. Note the difference in the default value for option compared to TSpectrum::Search option="""" by default (instead of ""goff""). ; Reimplemented in TH2.; Definition at line 9301 of file TH1.cxx. ◆ Smooth(). void TH1::Smooth ; (; Int_t ; ntimes = 1, . Option_t * ; option = """" . ). virtual . Smooth bin contents of this histogram. ; if option contains ""R"" smoothing is applied only to the bins defined in the X axis range (default is to smooth all bins) Bin contents are replaced by their smooth values. Errors (if any) are not modified. the smoothing procedure is repeated ntimes (default=1) ; Reimplemented in TH2.; Definition at line 6879 of file TH1.cxx. ◆ SmoothArray(). void TH1::SmoothArray ; (; Int_t ; nn, . Double_t * ; xx, . Int_t ; ntimes = 1 . ). static . Smooth array xx, translation of Hbook routine hsmoof.F. ; Based on algorithm 353QH twice presented by J. Friedman in Proc. of the 1974 CERN School of Computing, Norway, 11-24 August, 1974. See also Section 4.2 in J. Friedman, Data Analysis Techniques for High Energy Physics. ; Definition at line 6768 of file TH1.cxx. ◆ StatOverflows(). void TH1::StatOverflows ; (; Bool_t ; flag = kTRUE). static . if flag=kTRUE, underflows and overflows are used by the Fill functions in the computation of statistics (mean value, StdDev). ; By default, underflows or overflows are not used. ; Definition at line 6925 of file TH1.cxx. ◆ Streamer(). void TH1::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TObject.; Reimplemented in TH1C, TH1S, TH1I, TH1L, TH1F, TH1D, TH1K, TH2, TH2C, TH2S, TH2I, TH2L, TH2F, TH2D, TH2Poly, TH3, TH3C, TH3S, TH3I, TH3L, TH3F, TH3D, TProfile, TProfile2D, TProfile2Poly, and TProfile3D.; Definition at line 6933 of file TH1.cxx. ◆ StreamerNVirtual(). void TH1::St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:221104,rout,routine,221104,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['rout'],['routine']
Integrability,"ace)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:118; ROOT::Math::WrappedMemFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:124; ROOT::Math::WrappedMemFunction::WrappedMemFunctionWrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:103; ROOT::Math::WrappedMemFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:123; ROOT::Math::WrappedMemFunction::CloneWrappedMemFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:111; ROOT::Math::WrappedMemMultiFunctionDefinition WrappedFunction.h:182; ROOT::Math::WrappedMemMultiFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:214; ROOT::Math::WrappedMemMultiFunction::CloneWrappedMemMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:199; ROOT::Math::WrappedMemMultiFunction::WrappedMemMultiFunctionWrappedMemMultiFunction(FuncObj &obj, MemFuncPtr memFn, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:190; ROOT::Math::WrappedMemMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:208; ROOT::Math::WrappedMemMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:215; ROOT::Math::WrappedMemMultiFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:213; ROOT::Math::WrappedMemMultiFunction::NDimunsigned int NDim()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedFunction_8h_source.html:7646,interface,interface,7646,doc/master/WrappedFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html,1,['interface'],['interface']
Integrability,"ace: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5675 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6244 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6269 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 6945 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current TVirtualStreamerInfo. ; Definition at line 5696 of file TClass.cxx. ◆ SetDeclFile(). void TClass::SetDeclFile ; (; const char * ; name, . Short_t ; line . ). inline . Definition at line 555 of file TClass.h. ◆ SetDelete(). void TClass::SetDelete ; (; ROOT::DelFunc_t ; deleteFunc). Install a new wrapper around 'delete'. ; Definition at line 7001 of file TClass.cxx. ◆ SetDeleteArray(). void TClass::SetDeleteArray ; (; ROOT::DelArrFunc_t ; deleteArrayFunc). Install a new wrapper around 'delete []'. ; Definition at line 7009 of file TClass.cxx. ◆ SetDestructor(). void TClass::SetDestructor ; (; ROOT::DesFunc_t ; destructorFunc). Install a new wrapper around the destructor. ; Definition at line 7017 of file TClass.cxx. ◆ SetDirectoryAutoAdd(). void TClass::SetDirectoryAutoAdd ; (; ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:115162,wrap,wrapper,115162,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['wrap'],['wrapper']
Integrability,"ace: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5742 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6311 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6336 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 7012 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current TVirtualStreamerInfo. ; Definition at line 5763 of file TClass.cxx. ◆ SetDeclFile(). void TClass::SetDeclFile ; (; const char * ; name, . Short_t ; line . ). inline . Definition at line 555 of file TClass.h. ◆ SetDelete(). void TClass::SetDelete ; (; ROOT::DelFunc_t ; deleteFunc). Install a new wrapper around 'delete'. ; Definition at line 7068 of file TClass.cxx. ◆ SetDeleteArray(). void TClass::SetDeleteArray ; (; ROOT::DelArrFunc_t ; deleteArrayFunc). Install a new wrapper around 'delete []'. ; Definition at line 7076 of file TClass.cxx. ◆ SetDestructor(). void TClass::SetDestructor ; (; ROOT::DesFunc_t ; destructorFunc). Install a new wrapper around the destructor. ; Definition at line 7084 of file TClass.cxx. ◆ SetDirectoryAutoAdd(). void TClass::SetDirectoryAutoAdd ; (; ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:115163,wrap,wrapper,115163,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['wrap'],['wrapper']
Integrability,"ace::GraphAsymmErrorsRResultPtr<::TGraphAsymmErrors > GraphAsymmErrors(std::string_view x="""", std::string_view y="""", std::string_view exl="""", std::string_view exh="""", std::string_view eyl="""", std::string_view eyh="""")Fill and return a TGraphAsymmErrors object (lazy action).Definition RInterface.hxx:2278; ROOT::RDF::RInterface::SnapshotRResultPtr< RInterface< RLoopManager > > Snapshot(std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions())Save selected columns to disk, in a new TTree treename in file filename.Definition RInterface.hxx:1317; ROOT::RDF::RInterface::AggregateRResultPtr< U > Aggregate(AccFun aggregator, MergeFun merger, std::string_view columnName="""")Execute a user-defined accumulation operation on the processed column values in each processing slot.Definition RInterface.hxx:2913; ROOT::RDF::RInterface::DefineSlotEntryRInterface< Proxied, DS_t > DefineSlotEntry(std::string_view name, F expression, const ColumnNames_t &columns={})Define a new column with a value dependent on the processing slot and the current entry.Definition RInterface.hxx:500; ROOT::RDF::RInterface::MinRResultPtr< RDFDetail::MinReturnType_t< T > > Min(std::string_view columnName="""")Return the minimum of processed column values (lazy action).Definition RInterface.hxx:2640; ROOT::RDF::RInterface::ReduceRResultPtr< T > Reduce(F f, std::string_view columnName="""")Execute a user-defined reduce operation on the values of a column.Definition RInterface.hxx:1688; ROOT::RDF::RInterface::Foreachvoid Foreach(F f, const ColumnNames_t &columns={})Execute a user-defined function on each entry (instant action).Definition RInterface.hxx:1611; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RJittedFilter, DS_t > Filter(std::string_view expression, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:288; ROOT::RDF::RInterface::Profile2DRResultPtr<::TProfile2D > Profile2D(const TProfile2DM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:213162,depend,dependent,213162,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['depend'],['dependent']
Integrability,"aced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022 // We need the dictionary initialization but we don't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:76217,inject,injected,76217,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['inject'],['injected']
Integrability,"ach case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times - i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:. Orthographic (XOY); Orthographic (XOZ); Orthographic (ZOY). Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab - see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button. GL Viewer camera interactions. For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:. Shiftx 10; Ctrlx 0.1; Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right mouse button is down).; Note for orthographic cameras:. There is no field of view of view/focal length - dollying and zooming producing an identical scaling action.; There is a fixed eye direction - so the ‘Orbit’ action is disabled. Note for perspective cameras:. Dol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:390056,interface,interface,390056,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Mon Jul 4 15:23:02 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenProdProj.html:34780,integrat,integration,34780,root/html530/RooGenProdProj.html,https://root.cern,https://root.cern/root/html530/RooGenProdProj.html,1,['integrat'],['integration']
Integrability,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Thu Nov 3 20:08:19 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenProdProj.html:35159,integrat,integration,35159,root/html532/RooGenProdProj.html,https://root.cern,https://root.cern/root/html532/RooGenProdProj.html,1,['integrat'],['integration']
Integrability,"ache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Tue Jun 2 15:31:20 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooGenProdProj.html:38835,integrat,integration,38835,root/html604/RooGenProdProj.html,https://root.cern,https://root.cern/root/html604/RooGenProdProj.html,1,['integrat'],['integration']
Integrability,"ache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; Bool_t_protectNegative; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPoisson.html:42290,integrat,integrator,42290,root/html534/RooPoisson.html,https://root.cern,https://root.cern/root/html534/RooPoisson.html,1,['integrat'],['integrator']
Integrability,"ache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 407",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:147563,depend,depends,147563,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['depend'],['depends']
Integrability,ache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgrThe cache manager; RooSetProxy_cacheObsVariables to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:31612,integrat,integration,31612,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,2,['integrat'],['integration']
Integrability,ache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgrThe cache manager; RooSetProxy_cacheObsVariables to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:32327,integrat,integration,32327,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,1,['integrat'],['integration']
Integrability,ache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgrThe cache manager; RooSetProxy_cacheObsVariables to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree bran,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedReal.html:32702,integrat,integration,32702,root/html532/RooCachedReal.html,https://root.cern,https://root.cern/root/html532/RooCachedReal.html,1,['integrat'],['integration']
Integrability,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:61594,rout,routed,61594,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,21,"['message', 'protocol', 'rout']","['message', 'protocol', 'routed']"
Integrability,"acheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExponential.html:38762,integrat,integrator,38762,root/html528/RooExponential.html,https://root.cern,https://root.cern/root/html528/RooExponential.html,1,['integrat'],['integrator']
Integrability,"achedReal, and RooGenProdProj.; Definition at line 562 of file RooAbsArg.h. ◆ optimizeCacheMode() [1/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definition at line 519 of file RooAbsArg.h. ◆ Print(). void RooAbsArg::Print ; (; Option_t * ; options = nullptr); const. inlineoverridevirtual . Print the object to the defaultPrintStream(). ; Parameters. [in]optionsV print verbose. T print a tree structure ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:78840,depend,depend,78840,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['depend'],['depend']
Integrability,"achine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(Int_t maxiter = 500); {fMaxIterations = maxiter;}. void SetObjectFit(TObject* obj); {fO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:56304,rout,routine,56304,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,12,"['message', 'rout']","['message', 'routine']"
Integrability,"ackBox && Hoption.FrontBox) ol->Paint(option);; 7041 Hoption.System = kCARTESIAN;; 7042 ; 7043 if (!Hoption.Axis && !Hoption.Same) {; 7044 TGaxis axis;; 7045 PaintLegoAxis(&axis, 90);; 7046 }; 7047 ; 7048 // Draw palette. In case of 4D plot with TTree::Draw() the palette should; 7049 // be painted with the option colz.; 7050 if (fH->GetDrawOption() && strstr(opt,""colz"")) {; 7051 Int_t ndiv = fH->GetContour();; 7052 if (ndiv == 0 ) {; 7053 ndiv = gStyle->GetNumberContours();; 7054 fH->SetContour(ndiv);; 7055 }; 7056 PaintPalette();; 7057 }; 7058 ; 7059 // Draw title; 7060 PaintTitle();; 7061 ; 7062 //Draw stats and fit results; 7063 TF1 *fit = nullptr;; 7064 TIter next(fFunctions);; 7065 while (auto obj = next()) {; 7066 if (obj->InheritsFrom(TF1::Class())) {; 7067 fit = (TF1*)obj;; 7068 break;; 7069 }; 7070 }; 7071 if ((Hoption.Same%10) != 1) {; 7072 if (!fH->TestBit(TH1::kNoStats)) { // bit set via TH1::SetStats; 7073 PaintStat3(gStyle->GetOptStat(),fit);; 7074 }; 7075 }; 7076 ; 7077}; 7078 ; 7079////////////////////////////////////////////////////////////////////////////////; 7080/// Compute histogram parameters used by the drawing routines.; 7081 ; 7082Int_t THistPainter::PaintInit(); 7083{; 7084 ; 7085 if (fH->GetDimension() > 1 || Hoption.Lego || Hoption.Surf) return 1;; 7086 ; 7087 Int_t i;; 7088 static const char *where = ""PaintInit"";; 7089 Double_t yMARGIN = gStyle->GetHistTopMargin();; 7090 Int_t maximum = 0;; 7091 Int_t minimum = 0;; 7092 if (fH->GetMaximumStored() != -1111) maximum = 1;; 7093 if (fH->GetMinimumStored() != -1111) minimum = 1;; 7094 ; 7095 // Compute X axis parameters; 7096 ; 7097 Int_t last = fXaxis->GetLast();; 7098 Int_t first = fXaxis->GetFirst();; 7099 Hparam.xlowedge = fXaxis->GetBinLowEdge(first);; 7100 Hparam.xbinsize = fXaxis->GetBinWidth(first);; 7101 Hparam.xlast = last;; 7102 Hparam.xfirst = first;; 7103 Hparam.xmin = Hparam.xlowedge;; 7104 Hparam.xmax = fXaxis->GetBinLowEdge(last)+fXaxis->GetBinWidth(last);; 7105 ; 7106 // if lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:256936,rout,routines,256936,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['rout'],['routines']
Integrability,"ackground color of headers. void SetOddRowBackground(Pixel_t pixel); Set the background color for all odd numbered rows. void SetEvenRowBackground(Pixel_t pixel); Set the background color for all even numbered rows. void SetHeaderBackground(Pixel_t pixel); Set the background color for the headers. void SetDefaultColors(); Set the background color for all rows and headers to their defaults. void MoveTable(Int_t rows, Int_t columns); Move and layout the table to the specified range. void GotoTableRange(Int_t xtl, Int_t ytl, Int_t xbr, Int_t ybr); Move and resize the table to the specified range. TGTableCell * operator()(UInt_t row, UInt_t column); Operator for easy cell acces. void ScrollCHeaders(Int_t xpos); Scroll the column headers horizontally. void ScrollRHeaders(Int_t ypos); Scroll the row headers vertically. void NextChunk(); Move the table to the next chunk of the data set with the same size. void PreviousChunk(); Move the table to the previous chunk of the data set with the same size. void Goto(); Slot used by the Goto button and whenever return is pressed in; on of the text entries in the range frame. void UserRangeChange(); Slot used when the text in one of the range frame text entries changes. void Update(); Update the range of the available data and refresh the current view. TGTable(const TGWindow* p = 0, Int_t id = 0, TVirtualTableInterface* interface = 0, UInt_t nrows = 50, UInt_t ncolumns = 20). TVirtualTableInterface * GetInterface(); { return fInterface; }. TGCanvas * GetCanvas(); { return fCanvas; }. const TGTableHeaderFrame * GetRHdrFrame(); { return fRHdrFrame; }. const TGTableHeaderFrame * GetCHdrFrame(); { return fCHdrFrame; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 15:57:29 2015 » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTable.html:32358,interface,interface,32358,root/html604/TGTable.html,https://root.cern,https://root.cern/root/html604/TGTable.html,1,['interface'],['interface']
Integrability,"ackground, tile, stipple,; tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list.; (see also the GCValues_t structure). void ClearArea(Window_t id, Int_t x, Int_t y, UInt_t w, UInt_t h); Paints a rectangular area in the specified window ""id"" according to; the specified dimensions with the window's background pixel or pixmap. id - specifies the window; x, y - coordinates, which are relative to the origin; w, h - the width and height which define the rectangle dimensions. Bool_t CheckEvent(Window_t id, EGEventType type, Event_t& ev); Check if there is for window ""id"" an event of type ""type"". If there; is it fills in the event structure and return true. If no such event; return false. void SendEvent(Window_t id, Event_t* ev); Specifies the event ""ev"" is to be sent to the window ""id"".; This function requires you to pass an event mask. void DispatchClientMessage(UInt_t messageID); Force processing of event, sent by SendEvent before. void WMDeleteNotify(Window_t id); Tells WM to send message when window is closed via WM. void SetKeyAutoRepeat(Bool_t on = kTRUE); Turns key auto repeat on (kTRUE) or off (kFALSE). void GrabKey(Window_t id, Int_t keycode, UInt_t modifier, Bool_t grab = kTRUE); Establishes a passive grab on the keyboard. In the future, the; keyboard is actively grabbed, the last-keyboard-grab time is set; to the time at which the key was pressed (as transmitted in the; KeyPress event), and the KeyPress event is reported if all of the; following conditions are true:; - the keyboard is not grabbed and the specified key (which can; itself be a modifier key) is logically pressed when the; specified modifier keys are logically down, and no other; modifier keys are logically down;; - either the grab window ""id"" is an ancestor of (or is) the focus; window, or ""id"" is a descendant of the focus window and contains; the pointer;; - a passive grab on the same key combination does not exist on any; ancestor of grab_window. id - window id; keycode - specifies",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualX.html:51249,message,message,51249,root/html534/TVirtualX.html,https://root.cern,https://root.cern/root/html534/TVirtualX.html,3,['message'],['message']
Integrability,"acks class; TGeoTransientPanel List-Tree based dialog; TGeoTranslation translation class; TGeoTranslationEditor TGeoTranslation editor; TGeoTrap G3 TRAP shape; TGeoTrapEditor TGeoTrap editor; TGeoTrd1 TRD1 shape class; TGeoTrd1Editor TGeoTrd1 editor; TGeoTrd2 TRD2 shape class; TGeoTrd2Editor TGeoTrd2 editor; TGeoTreeDialog List-Tree based dialog; TGeoTube cylindrical tube class; TGeoTubeEditor TGeoTube editor; TGeoTubeSeg cylindrical tube segment class ; TGeoTubeSegEditor TGeoTubeSeg editor; TGeoUniformMagField Uniform magnetic field ; TGeoUnion union node; TGeoVolume geometry volume descriptor; TGeoVolumeAssembly an assembly of volumes; TGeoVolumeDialog List-Tree based volume dialog; TGeoVolumeEditor TGeoVolume editor; TGeoVolumeMulti class to handle multiple volumes in one step; TGeoVoxelFinder voxel finder class; TGeoXtru extruded polygon class ; TGeometry Structure for Matrices, Shapes and Nodes; TGlobal Global variable class; TGondzioSolver Gondzio Qp Solver class; TGraph Graph graphics class; TGraph2D Set of n x[i],y[i],z[i] points with 3-d graphics including Delaunay triangulation; TGraph2DErrors A 2D graph with error bars; TGraph2DPainter TGraph2D painter; TGraphAsymmErrors A graph with asymmetric error bars; TGraphBentErrors A graph with bent, asymmetric error bars; TGraphDelaunay Delaunay triangulation; TGraphEditor graph editor; TGraphErrors A graph with error bars; TGraphPainter TGraph painter; TGraphPolar Polar graph; TGraphPolargram Polar axis; TGraphQQ to create and to draw quantile-quantile plots; TGraphSmooth Graph Smoother; TGrid ABC defining interface to GRID services; TGridCollection ABC managing collection of files on the Grid; TGridJDL ABC defining interface JDL generator; TGridJob ABC defining interface to a GRID job; TGridJobStatus ABC defining status of a Grid job; TGridJobStatusList ABC defining interface to a list of GRID jobs; TGridResult ABC defining interface to GRID result set; TGroupButton A user interface button in a group of buttons.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:86897,interface,interface,86897,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,6,['interface'],['interface']
Integrability,"acks(new TClingCallbacks(GetInterpreterImpl(), /*hasCodeGen*/ !fromRootCling));; 1595 fClingCallbacks = clingCallbacks.get();; 1596 fClingCallbacks->SetAutoParsingSuspended(fIsAutoParsingSuspended);; 1597 fInterpreter->setCallbacks(std::move(clingCallbacks));; 1598 ; 1599 if (!fromRootCling) {; 1600 cling::DynamicLibraryManager& DLM = *fInterpreter->getDynamicLibraryManager();; 1601 // Make sure cling looks into ROOT's libdir, even if not part of LD_LIBRARY_PATH; 1602 // e.g. because of an RPATH build.; 1603 DLM.addSearchPath(TROOT::GetSharedLibDir().Data(), /*isUser=*/true,; 1604 /*prepend=*/true);; 1605 auto ShouldPermanentlyIgnore = [](llvm::StringRef FileName) -> bool{; 1606 llvm::StringRef stem = llvm::sys::path::stem(FileName);; 1607 return stem.startswith(""libNew"") || stem.startswith(""libcppyy_backend"");; 1608 };; 1609 // Initialize the dyld for AutoloadLibraryGenerator.; 1610 DLM.initializeDyld(ShouldPermanentlyIgnore);; 1611 }; 1612}; 1613 ; 1614 ; 1615////////////////////////////////////////////////////////////////////////////////; 1616/// Destroy the interpreter interface.; 1617 ; 1618TCling::~TCling(); 1619{; 1620 // ROOT's atexit functions require the interepreter to be available.; 1621 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:60704,interface,interface,60704,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['interface'],['interface']
Integrability,"acobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_tRooPrintable::_nameLength; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:33038,integrat,integrator,33038,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['integrat'],['integrator']
Integrability,"acter string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUrl.html:8793,protocol,protocol,8793,root/html528/TUrl.html,https://root.cern,https://root.cern/root/html528/TUrl.html,3,['protocol'],['protocol']
Integrability,"acter string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUrl.html:8921,protocol,protocol,8921,root/html534/TUrl.html,https://root.cern,https://root.cern/root/html534/TUrl.html,3,['protocol'],['protocol']
Integrability,"acters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  . Protected Attributes; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr};  ; Bool_t fDone {kFALSE};  ; TSeqCollection * fFileHandler {nullptr};  ; TString fFlagsDebug;  ; TString fFlagsOpt;  ; TSeqCollection * fHelpers {nullptr};  ; TString fHostname;  ; TString fIncludePath;  ; Bool_t fInControl {kFALSE};  ; std::atomic< Bool_t > fInsideNotify {kFALSE};  ; Int_t fLevel {0};  ; TString fLinkdefSuffix;  ; TString fLinkedLibs;  ; TString fListLibs;  ; TString fListPaths;  ; TString fMakeExe;  ; TString fMakeSharedLib;  ; Int_t fMaxrfd {-1};  ; Int_t fMaxwfd {-1};  ; Int_t fNfd {0};  Signals that were trapped. ;  ; TString fObjExt;  ; TSeq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:31463,protocol,protocol,31463,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['protocol'],['protocol']
Integrability,"actions, r and helperArg will refer to the same object, because the only argument to forward to the action helper is the result value itself. We need the distinction for actions such as Snapshot or Cache, for which the constructor arguments of the action helper are different from the returned value. ; Definition at line 150 of file RInterfaceBase.hxx. ◆ Describe(). ROOT::RDF::RDFDescription ROOT::RDF::RInterfaceBase::Describe ; (; ). Return information about the dataframe. ; Returnsinformation about the dataframe as RDFDescription object; This convenience function describes the dataframe and combines the following information:; Number of event loops run, see GetNRuns(); Number of total and defined columns, see GetColumnNames() and GetDefinedColumnNames(); Column names, see GetColumnNames(); Column types, see GetColumnType(); Number of processing slots, see GetNSlots(). This is not an action nor a transformation, just a query to the RDataFrame object. The result is dependent on the node from which this method is called, e.g. the list of defined columns returned by GetDefinedColumnNames().; Please note that this is a convenience feature and the layout of the output can be subject to change and should be parsed via RDFDescription methods. Example usage:; RDataFrame df(10);; auto df2 = df.Define(""x"", ""1.f"").Define(""s"", ""\""myStr\"""");; // Describe the dataframe; df2.Describe().Print(); df2.Describe().Print(/*shortFormat=*&zwj;/true); std::cout << df2.Describe().AsString() << std::endl;; std::cout << df2.Describe().AsString(/*shortFormat=*&zwj;/true) << std::endl;; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. Definition at line 237 of file RInterfaceBase.cxx. ◆ DescribeDataset(). std::string ROOT::RDF::RInterfaceBase::DescribeDataset ; (; ); const. protected . Definition at line 44 of file RInterfaceBase.cxx. ◆ GetColumnNames(). ROOT::RDF::ColumnNames_t ROOT::RDF::RInterfaceBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html:7598,depend,dependent,7598,doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterfaceBase.html,1,['depend'],['dependent']
Integrability,"activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:41364,integrat,integrator,41364,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['integrat'],['integrator']
Integrability,"actory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:42509,interface,interfaced,42509,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['interface'],['interfaced']
Integrability,"actory.h. ◆ init(). void RooNumIntFactory::init ; (; ). private . Register all known integrators by calling their static registration functions. ; Definition at line 54 of file RooNumIntFactory.cxx. ◆ instance(). RooNumIntFactory & RooNumIntFactory::instance ; (; ). static . Static method returning reference to singleton instance of factory. ; Definition at line 82 of file RooNumIntFactory.cxx. ◆ IsA(). TClass * RooNumIntFactory::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 75 of file RooNumIntFactory.h. ◆ registerPlugin(). bool RooNumIntFactory::registerPlugin ; (; std::string const & ; name, . Creator const & ; creator, . const RooArgSet & ; defConfig, . bool ; canIntegrate1D, . bool ; canIntegrate2D, . bool ; canIntegrateND, . bool ; canIntegrateOpenEnded, . const char * ; depName = """" . ). Method accepting registration of a prototype numeric integrator along with a RooArgSet of its default configuration options and an optional list of names of other numeric integrators on which this integrator depends. ; Returns true if integrator was previously registered ; Definition at line 105 of file RooNumIntFactory.cxx. ◆ Streamer(). void RooNumIntFactory::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooNumIntFactory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 75 of file RooNumIntFactory.h. Friends And Related Symbol Documentation. ◆ RooNumIntConfig. friend class RooNumIntConfig. friend . Definition at line 51 of file RooNumIntFactory.h. Member Data Documentation. ◆ _map. std::map<std::string,PluginInfo> RooNumIntFactory::_map. private . Definition at line 68 of file RooNumIntFactory.h. Libraries for RooNumIntFactory:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumIntFactory.h;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumIntFactory.html:15306,integrat,integrator,15306,doc/master/classRooNumIntFactory.html,https://root.cern,https://root.cern/doc/master/classRooNumIntFactory.html,4,"['depend', 'integrat']","['depends', 'integrator', 'integrators']"
Integrability,"ad = 1; , kWrite = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofServLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TProofServLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ;  ~TProofServLogHandler () override;  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady () const;  ; virtual Bool_t IsWriteReady () const;  ; void Remove () override;  Remove file event handler from system file handler list. ;  ; virtual void ResetReadyMask ();  ; void SetFd (int fd);  ; virtual void SetInterest (In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:1529,message,message,1529,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['message'],['message']
Integrability,"ad(subpadnumber); ; Implements TVirtualPad.; Definition at line 693 of file TPad.cxx. ◆ Class(). static TClass * TPad::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TPad::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TPad::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 419 of file TPad.h. ◆ Clear(). void TPad::Clear ; (; Option_t * ; option = """"). overridevirtual . Delete all pad primitives. ; If the bit kClearAfterCR has been set for this pad, the Clear function will execute only after having pressed a CarriageReturn Set the bit with mypad->SetBit(TPad::kClearAfterCR) ; Implements TVirtualPad.; Definition at line 722 of file TPad.cxx. ◆ Clip() [1/2]. Int_t TPad::Clip ; (; Double_t * ; x, . Double_t * ; y, . Double_t ; xclipl, . Double_t ; yclipb, . Double_t ; xclipr, . Double_t ; yclipt . ). overridevirtual . Clipping routine: Cohen Sutherland algorithm. ; - If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. Parameters. [in,out]x[],y[]Segment coordinates (2 points) ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary . Implements TVirtualPad.; Definition at line 830 of file TPad.cxx. ◆ Clip() [2/2]. Int_t TPad::Clip ; (; Float_t * ; x, . Float_t * ; y, . Float_t ; xclipl, . Float_t ; yclipb, . Float_t ; xclipr, . Float_t ; yclipt . ). virtual . Clipping routine: Cohen Sutherland algorithm. . If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. Parameters. [in,out]x[],y[]Segment coordinates (2 points) ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary . Definition at line 768 of file TPad.cxx. ◆ ClippingCode(). Int_t TPad::ClippingCode ; (; Double_t ; x, . Double_t ; y, . Double_t ; xcl1, . Double_t ; ycl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:61421,rout,routine,61421,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['rout'],['routine']
Integrability,"ad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:6197,wrap,wrapper,6197,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"ad->SetLogy(true);; }; The problem was reported here. TGraph2D; Add a new implementation for Delauney interpolation using the triangle code from Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. A new class for Delauney triangulator and interpolation has been added in the MathCore library ( ROOT::Math::Delauney2D ).; Fitting. Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes ROOT-7791.; Fix some bugs in TF1NormSum (to fit normalized sum of functions) and in TF1Convolution; Add a new histogram fitting option, WIDTH to fit directly density. The bin content in this case is scaled by the histogram bin width. TFormula. Fix several bugs in the new TFormula class.; Add as new pre-defined functions: crystalball, breitwigner and cheb0,cheb1,...cheb10 for the Chebyshev polynomials. Math Libraries; Random numbers. Move from MathMore to MathCore the class ROOT::Math::Random. Make it a new interface class for random number generation. Add interfaces for standard ROOT random engines, GSL random engines and random engines provided by the C++ standard library (std::random).; Add a new randomengine, MIXMAX based on matrix-recursive random number generator from Kostas and George Savvidy. See this paper. R Interface; Apply several improvements in the interface to R, allowing to use R functions within ROOT. See more at the ROOT-R User Guide.; TMVA; Add new TMVA plug-in based on R and Python (using Scikit-Learn) * See the RMVA Web page for a detailed description of the new TMVA method based on R * See the PyMVA Web page for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package.; RooFit Libraries; 2D Graphics Libraries; THistPainter; Improve the algorithm to compute the lower limit of an axis in log scale when its real lower limit is 0. The problem was reported in ROOT-7414.; Using the COL option with histograms having some negative bins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:13654,interface,interface,13654,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['interface'],['interface']
Integrability,"ad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:32462,rout,routine,32462,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,6,['rout'],['routine']
Integrability,"adEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 }; 413 return len * fLen;; 414 } else {; 415 // -- We are a fixed size thing.; 416 return fLen;; 417 }; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Helper routine for TLeafX::SetAddress.; 422///; 423/// The return value is non-zero if we owned the old; 424/// value buffer and must delete it now. The size; 425/// of the value buffer is recalculated and stored,; 426/// and a decision is made whether or not we own the; 427/// new value buffer.; 428 ; 429Int_t TLeaf::ResetAddress(void* addr, bool calledFromDestructor); 430{; 431 // The kNewValue bit records whether or not we own; 432 // the current value buffer or not. If we own it,; 433 // then we are responsible for deleting it.; 434 bool deleteValue = false;; 435 if (TestBit(kNewValue)) {; 436 deleteValue = true;; 437 }; 438 // If we are not being called from a destructor,; 439 // recalculate the value buffer size and decide; 440 // whether or not we own the new value buffer.; 441 if (!calledFromDestructor) {; 442 // -- Recalculate value buffer size and decide ownership of value.; 443 if (fLeafCount) {; 444 // -- Varying length array da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:13601,rout,routine,13601,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['rout'],['routine']
Integrability,"adPos;  A position (horizontal and vertical) in a RPad. More...;  ; class  RPairField;  The generic field for std::pair<T1, T2> types. More...;  ; class  RPalette;  A set of colors. More...;  ; class  RPaletteDrawable;  A color palette draw near the frame. More...;  ; class  RPave;  Base class for paves with text, statistic, legends, placed relative to RFrame position and adjustable height. More...;  ; class  RPrepareVisitor;  Visitor used for a pre-processing run to collect information needed by another visitor class. More...;  ; class  RPrintSchemaVisitor;  Contains settings for printing and prints a summary of an RField instance. More...;  ; class  RPrintValueVisitor;  Renders a JSON value corresponding to the field. More...;  ; class  RProxiedCollectionField;  The field for a class representing a collection of elements via TVirtualCollectionProxy. More...;  ; class  RRecordField;  The field for an untyped record. More...;  ; class  RResult;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  RResult< void >;  RResult<void> has no data member and no Inspect() method but instead a Success() factory method. More...;  ; class  RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  RRVecField;  The type-erased field for a RVec<Type> More...;  ; class  RSetField;  The generic field for a std::set<Type> and std::unordered_set<Type> More...;  ; class  RStyle;  A set of defaults for graphics attributes, e.g. More...;  ; class  RTupleField;  The generic field for std::tuple<Ts...> types. More...;  ; class  RUniquePtrField;  ; class  RVariantField;  The generic field for std::variant types. More...;  ; class  RVectorField;  The generic field for a (nested) std::vector<Type> except for std::vector<bool> More...;  ; class  TObjectDisplayItem;  Display item for TObject with drawing options. More...;  ; class  TObjectDrawable;  Provides v7 drawing fac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:20968,wrap,wraps,20968,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['wrap'],['wraps']
Integrability,"adResults.end(), 0);; 1259 }; 1260 ; 1261 // Called by RDataFrame to retrieve the name of this action.; 1262 std::string GetActionName() const { return ""MyCounter""; }; 1263};; 1264 ; 1265int main() {; 1266 ROOT::RDataFrame df(10);; 1267 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1268 // The GetValue call triggers the event loop; 1269 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1270}; 1271~~~; 1272 ; 1273See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1274for a more complete example.; 1275 ; 1276#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74256,interface,interface,74256,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['interface'],['interface']
Integrability,"adResults.end(), 0);; 1299 }; 1300 ; 1301 // Called by RDataFrame to retrieve the name of this action.; 1302 std::string GetActionName() const { return ""MyCounter""; }; 1303};; 1304 ; 1305int main() {; 1306 ROOT::RDataFrame df(10);; 1307 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1308 // The GetValue call triggers the event loop; 1309 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1310}; 1311~~~; 1312 ; 1313See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1314for a more complete example.; 1315 ; 1316#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:75936,interface,interface,75936,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['interface'],['interface']
Integrability,"added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the members of a collection is generic, i.e. independent of any specific representation of a collection. To process each object in a collection one needs some type of cursor that is initialized and then steps over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TList TListIter; TMap TMapIter. 16.3 Foundation Classes; All collections are based on the fundamental classes: TCollection and TIterator. They are so generic that it is not possible to create objects from them; they are only used as base classes for other classes (i.e. they are abstract base classes).; The TCollection class provides the basic protocol (i.e. the minimum set of member functions) that all collection classes have to implement. These include:. Add Adds another object to the collection.; GetSize Returns the number of objects in the collection.; Clear Clears out the collection, but does not delete the removed objects.; Delete Clears out the collection and deletes the removed objects. This should only be used if the collection owns its objects (which are not normally the case).; FindObject Finds an object given either its name or address.; MakeIterator Returns an iterator associated with the collection.; Remove Removes an object fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:844822,wrap,wrapper,844822,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['wrap'],['wrapper']
Integrability,"addition all resulting classifiers are saved and can be applied to new data using MethodCrossValidation. One requirement for this to work is a splitting function that is evaluated for each event to determine into what fold it goes (for training/evaluation) or to what classifier (for application). Split Expression; Cross evaluation uses a deterministic split to partition the data into folds called the split expression. The expression can be any valid TFormula as long as all parts used are defined.; For each event the split expression is evaluated to a number and the event is put in the fold corresponding to that number.; It is recommended to always use int([NumFolds]) at the end of the expression.; The split expression has access to all spectators and variables defined in the dataloader. Additionally, the number of folds in the split can be accessed with NumFolds (or numFolds). Example; ""int(fabs([eventID]))%int([NumFolds])"". Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVACrossValidation. ; DataSetInfo : [datasetcv] : Added class ""Signal""; : Add Tree of type Signal with 1000 events; DataSetInfo : [datasetcv] : Added class ""Background""; : Add Tree of type Background with 1000 events; <HEADER> Factory : You are running ROOT Version: 6.33.01, Oct 10, 2023; : ; : _/_/_/_/_/ _| _| _| _| _|_| ; : _/ _|_| _|_| _| _| _| _| ; : _/ _| _| _| _| _| _|_|_|_| ; : _/ _| _| _| _| _| _| ; : _/ _| _| _| _| _| ; : ; : ___________TMVA Version 4.2.1, Feb 5, 2015; : ; : Rebuilding Dataset datasetcv; : Building event vectors for type 2 Signal; : Dataset[datasetcv] : create input formulas for tree ; : Building event vectors for type 2 Background; : Dataset[datasetcv] : create input formulas for tree ; <HEADER> DataSetFactory : [datasetcv] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 999",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:1941,integrat,integrated,1941,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['integrat'],['integrated']
Integrability,"address of local host to which the socket is bound. ;  ; Int_t GetOption (ESockOptions opt, Int_t &val) override;  Get socket options. Returns -1 in case of error. ;  ; Int_t GetSize () const;  ; TClass * IsA () const override;  ; Bool_t IsValid () const override;  ; Int_t Recv (char *mess, Int_t max) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *mess, Int_t max, Int_t &kind) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &status, Int_t &kind) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&mess) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Send a raw buffer of specified length. ;  ; Int_t Send (const char *mess, Int_t kind=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Send (const TMessage &mess) override;  Send a TMessage object. ;  ; Int_t Send (Int_t kind) override;  Send a single message opcode. ;  ; Int_t Send (Int_t status, Int_t kind) override;  Send a status and a single message opcode. ;  ; Int_t SendRaw (const void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Send a raw buffer of specified length. ;  ; Int_t SetOption (ESockOptions opt, Int_t val) override;  Set socket options. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSocket;  TSocket (const char *host, const char *service, Int_t tcpwindowsize=-1);  Create a socket. ;  ;  TSocket (const char *host, Int_t port, Int_t tcpwindowsize=-1);  Create a socket; see CreateAuthSocket for the form of url. ;  ;  TSocket (const char *sockpath);  Create a socket in the Unix domain on 'sockpath'. ;  ;  TSocket (const TSocket &s);  TSocket copy ctor. ;  ;  TSocket (Int_t descriptor);  Create a socket. ;  ;  TSocket (Int_t descriptor, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:2329,message,message,2329,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['message'],['message']
Integrability,"ader file Math/ProbFuncInv.h.; The following picture illustrates the available statistical functions (PDF, CDF and quantiles) in the case of the normal distribution. PDF, CDF and quantiles in the case of the normal distribution. 13.6 Numerical Algorithms; ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. Evaluation of function derivatives.; Evaluation of integrals.; Finding the roots of a function; Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function. ROOT provides a common way of specifying them via some interfaces; 13.7 ROOT::Math Function interfaces; To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function. In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ROOT::Math Function interface structure. 13.7.1 One-dimensional Function Interfaces; These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions. For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. ROOT::Math::IBaseFunctionOneDim: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing double operator() (const double ). The user class defined only needs to reimplement the pure abstract method double DoEval(double x), that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from IBaseFunctionOneDim:; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:686965,interface,interface,686965,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"ader.C script:// File loader.C; #include ; #include ; #ifdef __MAKECINT__; #pragma link C++ class vector<Track>+;; #endifI am defining a vector for my custom type (for example Track) in a root macro but when I push_back a Track object in the vector, CINT complains. e.g.; vector testVector;; Track obj;; ...; testVector.push_back(obj);; gives:Error: Can't call vector::push_back(timeStamp) in current scope MyAnalysisMasterTreeMaker.C:358:; Possible candidates are...; (in vector); *** Interpreter error recovered ***. Although, if I use a vector or vector or vector push_back works fine.; ; . What is the difference between a TFolder and a TDirectory? . TFolder manages a hierrachy of objects in memory.; TDirectory is doing it for a file.; One can save the TFolder structure to a directory in a file.; ; . Ubuntu: No backtrace (stacktrace) when ROOT crashes . Enable /proc/sys/kernel/yama/ptrace_scope or edit /etc/sysctl.d/10-ptrace.conf. See this blog entry for details. ; . Can I integrate ROOT into my CMake build? . Absolutely. The CMake command find_package() will set all needed ROOT related variables, which can be used to compile and link one's own code. An example from the ROOT Event example (found in root/test) can be downloaded here. Just un-tar the attached file and run:. cd event/build; cmake ..; make. I use CMake to build my own code, and I would like to use ROOT in that code. Is there a way to wire ROOT into the CMake build files? Something like FindROOT.cmake? ; . Windows: Why must debug (non-debug) compiled code be linked against debug (non-debug) ROOT? . Microsoft's STL classes (std::string, std::vector,...) are different for debug and optimized mode. When calling a ROOT function that expects a STL object as an argument, the caller (e.g. your code) and ROOT must agree on what the object looks like. Thus if you link against ROOT libraries built as debug (non-debug) you must also compile your code as debug (non-debug). ACLiC does that automatically for you. ; . Cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/faq-page.html:4680,integrat,integrate,4680,d/faq-page.html,https://root.cern,https://root.cern/d/faq-page.html,1,['integrat'],['integrate']
Integrability,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:364098,message,message,364098,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['message']
Integrability,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:364131,message,message,364131,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['message']
Integrability,"adientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4396,interface,interface,4396,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,1,['interface'],['interface']
Integrability,"adientFunctionMultiDim>::UpdateNCalls() const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>& rhs). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 30539 2009-10-01 13:13:09Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3986,interface,interface,3986,root/html526/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,1,['interface'],['interface']
Integrability,"ading the buffer; TBufferFile::InfoList_tTBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMessage.html:22592,message,message,22592,root/html602/TMessage.html,https://root.cern,https://root.cern/root/html602/TMessage.html,6,['message'],['message']
Integrability,"ading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:21167,message,message,21167,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,6,['message'],['message']
Integrability,"adlener, DESY,; Lorenzo Moneta, CERN/EP-SFT,; Alja Mrak Tadel, UCSD/CMS,; Axel Naumann, CERN/EP-SFT,; Dante Niewenhuis, VU Amsterdam; Luis Antonio Obis Aparicio, University of Zaragoza, Ianna Osborne, Princeton University,; Vincenzo Eduardo Padulano, CERN/EP-SFT,; Danilo Piparo, CERN/EP-SFT,; Fons Rademakers, CERN/IT,; Jonas Rembser, CERN/EP-SFT,; Andrea Rizzi, University of Pisa,; Andre Sailer, CERN/EP-SFT,; Garima Singh, ETH,; Juraj Smiesko, CERN/RCS-PRJ-FC, Pavlo Svirin, National Technical University of Ukraine,; Maciej Szymanski, Argonne,; Christian Tacke, Darmstadt University,; Matevz Tadel, UCSD/CMS,; Alvaro Tolosa Delgado, CERN/RCS-PRJ-FC,; Devajith Valaparambil Sreeramaswamy, CERN/EP-SFT,; Peter Van Gemmeren, Argonne,; Vassil Vassilev, Princeton/CMS,; Wouter Verkerke, NIKHEF/ATLAS, Stefan Wunsch; Deprecation and Removal. The RooFit legacy iterators are deprecated and will be removed in ROOT 6.34 (see section “RooFit libraries”); Some memory-unsafe RooFit interfaces were removed; Some redundant RooDataSet constructors are deprecated and will be removed in ROOT 6.34. Please use the RooDataSet constructors that take RooFit command arguments instead; ROOT does not longer support Python 2. The minimum required Python version to build ROOT is 3.8.; Support for wildcard imports like from ROOT import * is dropped from PyROOT; Support for external (ie. non-builtin) libAfterImage is now deprecated and it will be removed in next release 6.34.; The TList::TList(TObject*) constructor is deprecated and will be removed in ROOT 6.34; The deprecated TProofOutputList::TProofOutputList(TObject *o) constructor was removed. Core Libraries; The Cling interpreter now relies on LLVM version 16.; I/O Libraries; hadd respects compression settings; Fixed a bug that was previously changing the compression settings to a single digit number instead of the full value (by default 101).; TTree Libraries; Add files from subdirectories with TChain::Add globbing; It is now possible to add file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:3574,interface,interfaces,3574,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['interface'],['interfaces']
Integrability,"af::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDouble_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:179; TLeaf::GetValueHelper< ULong64_t >::Execstatic ULong64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:176; TLeaf::GetValueHelperDefinition TLeaf.h:84; TLeaf::GetValueHelper::Execstatic T Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:85; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:68. treetreeincTLeaf.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:18811,message,message,18811,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['message'],['message']
Integrability,"after each packet (to reduce the loss in case of crash).; Setting 'ds' automatically sets 'mvf=1'; it is still possible to set 'mvf=11' to save results after each packet.; The separator from the next option is either a ' ' or a ';'; All recognized settings are removed from the input string opt. If action == 0, set up the output file accordingly, if action == 1 clean related output file settings. If the final target file is local then 'target' is set to the final local path when action == 0 and used to retrieve the file with TFile::Cp when action == 1.; Output file settings are in the form `<previous_option>`of=name `<next_option>`; `<previous_option>`outfile=name,...;`<next_option>`; The separator from the next option is either a ' ' or a ';' Called interanally by TProof::Process.; Returns 0 on success, -1 on error. ; Definition at line 4937 of file TProof.cxx. ◆ HandleSubmerger(). void TProof::HandleSubmerger ; (; TMessage * ; mess, . TSlave * ; sl . ). private . Process a message of type kPROOF_SUBMERGER. ; Definition at line 4014 of file TProof.cxx. ◆ Init(). Int_t TProof::Init ; (; const char * ; masterurl, . const char * ; conffile, . const char * ; confdir, . Int_t ; loglevel, . const char * ; alias = 0 . ). protected . Start the PROOF environment. ; Starting PROOF involves either connecting to a master server, which in turn will start a set of slave servers, or directly starting as master server (if master = """"). For a description of the arguments see the TProof ctor. Returns the number of started master or slave servers, returns 0 in case of error, in which case fValid remains false. ; Definition at line 757 of file TProof.cxx. ◆ InitMembers(). void TProof::InitMembers ; (; ). protected . Default initializations. ; Definition at line 527 of file TProof.cxx. ◆ Interrupt(). void TProof::Interrupt ; (; EUrgent ; type, . ESlaves ; list = kActive . ). private . Send interrupt to master or slave servers. ; Definition at line 2276 of file TProof.cxx. ◆ InterruptCur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:110900,message,message,110900,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['message']
Integrability,"ag (Int_t ix, Int_t iy);  ; static void InitPivot (const Int_t n, const Int_t nz, TArrayI &Airn, TArrayI &Aicn, TArrayI &Aiw, TArrayI &Aikeep, TArrayI &Aiw1, Int_t &nsteps, const Int_t iflag, Int_t *icntl, Double_t *cntl, Int_t *info, Double_t &ops);  Setup Pivoting variables. ;  ; static void InitPivot_sub1 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *nv, Int_t *nxt, Int_t *lst, Int_t *ipd, Int_t *flag, const Int_t iovflo, Int_t &ncmpa, const Double_t fratio);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2a (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub3 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub4 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *ips, Int_t *ipv, Int_t *nv, Int_t *flag, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub5 (const Int_t n, Int_t *ipe, Int_t *nv, Int_t *ips, Int_t *ne, Int_t *na, Int_t *nd, Int_t &nsteps, const Int_t nemin);  Help routine for pivoting setup. ;  ; static void InitPivot_sub6 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *na, Int_t *ne, Int_t *nd, const Int_t nsteps, Int_t *lstki, Int_t *lstkr, Int_t *iw, Int_t *info, Double_t &ops);  Help routine for pivoting setup. ;  ; static Int_t NonZerosUpperTriang (const TMatrixDSparse &a);  Static function, returning the number of non-zero entries in the upper triangular matrix . ;  ; static void Solve (const Int_t n, TArrayD &Aa, TArrayI &Aiw, TArrayD &Aw, const Int_t ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:14330,rout,routine,14330,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['rout'],['routine']
Integrability,"ag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction2Binding_double_unsigned_int_double_.html:33110,integrat,integrator,33110,root/html530/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction2Binding_double_unsigned_int_double_.html,1,['integrat'],['integrator']
Integrability,"ag specifying if it is a chi2 (least-square fit). In the last two parameters are given, the chi2/ndf can be computed after fitting the data. template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::IBaseFunctionMultiDim interface:. bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::FitMethodFunction interface. This is an interface class extending the ROOT::Math::IBaseFunctionMultiDim with some extra functionality which can be used when fitting. This extra functionality is required by dedicated fitting algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result; The result of the fit is contained in the ROOT::Fit::Result object. A reference to the result object is obtained with the function Fitter::Result(). The ROOT::Fit::FitResult class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit, minimum chi2/likelihood values, etc…; A FitResult::Print method is also available to print the result of the fit.; The class has a self-explanatory API so, see its reference documentation for the possible information available after the fit.; One extra functionality offered by ROOT::Fit::FitResult is the possibility to compute the confidence intervals of the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:210201,interface,interface,210201,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"agation mask for specified server. void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all leaf nodes of the arg tree, starting with; ourself as top node. A leaf node is node that has no servers declared. void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with all branch nodes of the arg tree starting with; ourself as top node. A branch node is node that has one or more servers declared. void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; Fill supplied list with nodes of the arg tree, following all server links,; starting with ourself as top node. RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names of the variable list; of the supplied data set (the dependents). The caller of this; function is responsible for deleting the returned argset.; The complement of this function is getObservables(). void addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; INTERNAL helper function for getParameters(). RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that don't match any of the names the args in the; supplied argset. The caller of this function is responsible; for deleting the returned argset. The complement of this function; is getObservables(). RooArgSet* getObservables(const RooAbsData* data) const; Create a list of leaf nodes in the arg tree starting with; ourself as top node that match any of the names of the variable list; of the supplied data set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:20919,depend,dependents,20919,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,6,['depend'],['dependents']
Integrability,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:3101,rout,routines,3101,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,12,['rout'],['routines']
Integrability,"age for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:1897,interface,interface,1897,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,2,['interface'],['interface']
Integrability,"age(TCollection* pathlist, Option_t* opt = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static voidGetPrefix(const char* url, TString& pfx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfPrefixprefix to prepend to requests; TNetSystem*fSysteminstance of the admin interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void GetPrefix(const char* url, TString& pfx). TNetFileStager(const char* stager = """"). virtual ~TNetFileStager(). Bool_t IsStaged(const char* path). Int_t Locate(const char* path, TString& endpath). Bool_t Matches(const char* s). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. void Print(Option_t* option = """") const. » Author: G. Ganis Feb 2011 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFileStager.html:6244,interface,interface,6244,root/html534/TNetFileStager.html,https://root.cern,https://root.cern/root/html534/TNetFileStager.html,1,['interface'],['interface']
Integrability,"age.h. ◆ TagStreamerInfo(). void TMessage::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Remember that the StreamerInfo is being used in writing. ; When support for schema evolution is enabled the list of TStreamerInfo used to stream this object is kept in fInfos. This information is used by TSocket::Send that sends this list through the socket. This list is in turn used by TSocket::Recv to store the TStreamerInfo objects in the relevant TClass in case the TClass does not know yet about a particular class version. This feature is implemented to support clients and servers with either different ROOT versions or different user classes versions. ; Reimplemented from TBufferIO.; Definition at line 168 of file TMessage.cxx. ◆ TestBitNumber(). Bool_t TMessage::TestBitNumber ; (; UInt_t ; bitnumber); const. inlineprivate . Definition at line 59 of file TMessage.h. ◆ Uncompress(). Int_t TMessage::Uncompress ; (; ). Uncompress the message. ; The message will only be uncompressed when kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. ; Definition at line 389 of file TMessage.cxx. ◆ UsesSchemaEvolution(). Bool_t TMessage::UsesSchemaEvolution ; (; ); const. inline . Definition at line 79 of file TMessage.h. ◆ UsesSchemaEvolutionForAll(). Bool_t TMessage::UsesSchemaEvolutionForAll ; (; ). static . Static function returning status of global schema evolution. ; Definition at line 124 of file TMessage.cxx. ◆ What(). UInt_t TMessage::What ; (; ); const. inline . Definition at line 75 of file TMessage.h. ◆ WriteProcessID(). UShort_t TMessage::WriteProcessID ; (; TProcessID * ; pid). overridevirtual . Check if the ProcessID pid is already in the message. ; If not, then:; mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; mark bit uid+1 where uid id the uid of the ProcessID . Reimplemented from TBufferIO.; Definition at line 438 of file TMessage.cxx. Friends And Related Symbol Documentation. ◆ TAuthenticate. friend class TAuthenticate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:47249,message,message,47249,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,1,['message'],['message']
Integrability,"age/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:53480,depend,dependent,53480,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['depend'],['dependent']
Integrability,"age/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:50693,depend,dependent,50693,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['depend'],['dependent']
Integrability,"age/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:52123,depend,dependent,52123,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,1,['depend'],['dependent']
Integrability,"ager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigmaL; RooRealProxysigmaR; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBifurGauss.html:38870,integrat,integrator,38870,root/html528/RooBifurGauss.html,https://root.cern,https://root.cern/root/html528/RooBifurGauss.html,1,['integrat'],['integrator']
Integrability,"ager;  Central instance to create and show web-based windows like Canvas or FitPanel. More...;  ; class  RWebWindowWSHandler;  just wrapper to deliver websockets call-backs to the RWebWindow class More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:6480,interface,interfaces,6480,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['interface'],['interfaces']
Integrability,ager _cacheMgr;  ; RooArgSet * _curNormSet = nullptr;  The cache manager. ;  ; TMatrixD * _M = nullptr;  ; TVectorD * _mref = nullptr;  ; RooListProxy _pdfList;  ; Setting _setting;  ; bool _useHorizMorph = true;  ; RooSetProxy _varList;  ; RooRealProxy m;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMomentMorph.html:70778,integrat,integration,70778,doc/master/classRooMomentMorph.html,https://root.cern,https://root.cern/doc/master/classRooMomentMorph.html,1,['integrat'],['integration']
Integrability,"ages from the related file. ; Definition at line 240 of file TProofServ.cxx. ◆ TProofServLogHandler() [2/2]. TProofServLogHandler::TProofServLogHandler ; (; FILE * ; f, . TSocket * ; s, . const char * ; pfx = """" . ). Handle available message from the open file 'f'. ; Definition at line 268 of file TProofServ.cxx. ◆ ~TProofServLogHandler(). TProofServLogHandler::~TProofServLogHandler ; (; ). override . Handle available message in the open file. ; Definition at line 286 of file TProofServ.cxx. Member Function Documentation. ◆ GetCmdRtn(). Int_t TProofServLogHandler::GetCmdRtn ; (; ). static . Static method to get the return code from the execution of a command via the pipe. ; This is always 0 when the log handler is not used with a pipe ; Definition at line 344 of file TProofServ.cxx. ◆ IsValid(). Bool_t TProofServLogHandler::IsValid ; (; ). inline . Definition at line 390 of file TProofServ.h. ◆ Notify(). Bool_t TProofServLogHandler::Notify ; (; ). overridevirtual . Handle available message in the open file. ; Reimplemented from TFileHandler.; Definition at line 303 of file TProofServ.cxx. ◆ ReadNotify(). Bool_t TProofServLogHandler::ReadNotify ; (; ). inlineoverridevirtual . Notify when something can be read from the descriptor associated with this handler. ; Reimplemented from TFileHandler.; Definition at line 393 of file TProofServ.h. ◆ SetDefaultPrefix(). void TProofServLogHandler::SetDefaultPrefix ; (; const char * ; pfx). static . Static method to set the default prefix. ; Definition at line 336 of file TProofServ.cxx. Member Data Documentation. ◆ fFile. FILE* TProofServLogHandler::fFile. private . Definition at line 378 of file TProofServ.h. ◆ fgCmdRtn. Int_t TProofServLogHandler::fgCmdRtn = 0. staticprivate . Definition at line 382 of file TProofServ.h. ◆ fgPfx. TString TProofServLogHandler::fgPfx = """". staticprivate . Definition at line 381 of file TProofServ.h. ◆ fPfx. TString TProofServLogHandler::fPfx. private . Definition at line 379 of file TProofServ.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:18773,message,message,18773,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['message'],['message']
Integrability,"ahanSum< T, N >The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors when adding a sequence of finite-precision floating point numbers. ; This is done by keeping a separate running compensation (a variable to accumulate small errors). Auto-vectorisable accumulation; This class can internally use multiple accumulators (template parameter N). When filled from a collection that supports index access from a contiguous block of memory, compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling through the internal accumulators based on the value of ""`index % N`"", so N accumulators can be filled from a block of N numbers in a single instruction.; The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version with N = 1. This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation result can change in dependence of N, even when the data are identical. The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to speed up the accumulation, but not to increase precision.; Parameters. TThe type of the values to be accumulated. ; NNumber of accumulators. Defaults to 1. Ideal values are the widths of a vector register on the relevant architecture. Depending on the instruction set, good values are:; AVX2-float: 8; AVX2-double: 4; AVX512-float: 16; AVX512-double: 8. Examples; std::vector<double> numbers(1000);; for (std::size_t i=0; i<1000; ++i) {; numbers[i] = rand();; }; ; ROOT::Math::KahanSum<double, 4> k;; k.Add(numbers.begin(), numbers.end());; // or; k.Add(numbers);; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html:1407,depend,dependence,1407,doc/master/classROOT_1_1Math_1_1KahanSum.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1KahanSum.html,1,['depend'],['dependence']
Integrability,"ail::RDF::GetMergeableValuestd::unique_ptr< RMergeableVariations< T > > GetMergeableValue(ROOT::RDF::Experimental::RResultMap< T > &rmap)Retrieve mergeable values after calling ROOT::RDF::VariationsFor .Definition RResultMap.hxx:211; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; mTMarker mDefinition textangle.C:8. Definition at line 211 of file RResultMap.hxx. ◆ GetMergeableValue() [2/2]. template<typename T > . std::unique_ptr< RMergeableValue< T > > ROOT::Detail::RDF::GetMergeableValue ; (; RResultPtr< T > & ; rptr). Retrieve a mergeable value from an RDataFrame action. ; Parameters. [in]rptrlvalue reference of an RResultPtr object. . ReturnsAn RMergeableValue holding the result of the action, wrapped in an std::unique_ptr.; This function triggers the execution of the RDataFrame computation graph. Then retrieves an RMergeableValue object created with the result wrapped by the RResultPtr argument. The user obtains ownership of the mergeable, which in turn holds a copy of the result of the action. The RResultPtr is not destroyed in the process and will still retain (shared) ownership of the original result.; Example usage: using namespace ROOT::Detail::RDF;; ROOT::RDataFrame d(""myTree"", ""file_*.root"");; auto h = d.Histo1D(""Branch_A"");; auto mergeablehisto = GetMergeableValue(h);; d#define d(i)Definition RSha256.hxx:102; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80. Definition at line 470 of file RResultPtr.hxx. ◆ MakeResultPtr(). template<typename T > . RResultPtr< T > ROOT::Detail::RDF::MakeResultPtr ; (; const std::shared_ptr< T > & ; r, . RLoopManager & ; df, . std::shared_ptr< ROOT::Internal::RDF::RActionBase > ; actionPtr . ). Create a RResultPtr and set its pointer to the corresponding RAction This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr. ; Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html:8198,wrap,wrapped,8198,doc/master/namespaceROOT_1_1Detail_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html,1,['wrap'],['wrapped']
Integrability,"ail::RInferredType, typename V2 = RDFDetail::RInferredType, typename V3 = RDFDetail::RInferredType> . RResultPtr<::TProfile2D > ROOT::RDF::RInterface< Proxied, DataSource >::Profile2D ; (; const TProfile2DModel & ; model, . std::string_view ; v1Name = """", . std::string_view ; v2Name = """", . std::string_view ; v3Name = """" . ). inline . Fill and return a two-dimensional profile (lazy action). ; Template Parameters. V1The type of the column used to fill the x axis of the histogram. Inferred if not present. ; V2The type of the column used to fill the y axis of the histogram. Inferred if not present. ; V3The type of the column used to fill the z axis of the histogram. Inferred if not present. . Parameters. [in]modelThe returned profile will be constructed using this as a model. ; [in]v1NameThe name of the column that will fill the x axis. ; [in]v2NameThe name of the column that will fill the y axis. ; [in]v3NameThe name of the column that will fill the z axis. . Returnsthe bidimensional profile wrapped in a RResultPtr.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column types (this invocation needs jitting internally); auto myProf1 = myDf.Profile2D({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; ""xValues"", ""yValues"", ""zValues"");; // Explicit column types; auto myProf2 = myDf.Profile2D<int, float, double>({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; ""xValues"", ""yValues"", ""zValues"");; NoteDifferently from other ROOT interfaces, the returned profile is not associated to gDirectory and the caller is responsible for its lifetime (in particular, a typical source of confusion is that if result histograms go out of scope before the end of the program, ROOT might display a blank canvas). ; Definition at line 2426 of file RInterface.hxx. ◆ Range() [1/2]. template<typename Proxied , typename DataSource = void> . RInterface< RDFDetail::RRange< Proxied >, DS_t > ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:112226,wrap,wrapped,112226,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wrapped']
Integrability,"ain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 551 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the returned object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over.; NoteThe integral over a PDF is usually not normalised (i.e., it is usually not 1 when integrating the PDF over the full range). In fact, this integral is used to compute the normalisation of each PDF. See the rf110 tutorial for details on PDF normalisation.; The following named arguments are accepted . Effect on integral creation . NormSet(const RooArgSet&) Specify normalization set, mostly useful when working with PDFs . NumIntConfig(const RooNumIntConfig&) Use given configuration for any numeric integration, if necessary . Range(const char* name) Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments . PyROOT; The RooAbsReal::createIntegral() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 512 of file RooAbsReal.cxx. ◆ createIntegral() [6/6]. RooFit::OwningPtr<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:89772,integrat,integrates,89772,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['integrat'],['integrates']
Integrability,"ain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 553 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the returned object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over.; NoteThe integral over a PDF is usually not normalised (i.e., it is usually not 1 when integrating the PDF over the full range). In fact, this integral is used to compute the normalisation of each PDF. See the rf110 tutorial for details on PDF normalisation.; The following named arguments are accepted . Effect on integral creation . NormSet(const RooArgSet&) Specify normalization set, mostly useful when working with PDFs . NumIntConfig(const RooNumIntConfig&) Use given configuration for any numeric integration, if necessary . Range(const char* name) Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments . PyROOT; The RooAbsReal::createIntegral() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 514 of file RooAbsReal.cxx. ◆ createIntegral() [6/6]. RooFit::OwningPtr<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:88504,integrat,integrates,88504,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,['integrat'],['integrates']
Integrability,"ain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Fri Jun 19 21:36:03 2015 » Last generated: 2015-06-19 21:36; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:4658,integrat,integration,4658,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,1,['integrat'],['integration']
Integrability,"ain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Sat Jun 20 17:30:05 2015 » Last generated: 2015-06-20 17:30; This page h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCacheManager_RooAbsCacheElement_.html:4658,integrat,integration,4658,root/html604/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html604/RooCacheManager_RooAbsCacheElement_.html,1,['integrat'],['integration']
Integrability,"ain window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information about column from SQL table; TSQLFile ROOT TFile interface to SQL database; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLObjectData Keeps the data requested from the SQL server for an object.; TSQLObjectDataPool XML object keeper class ; TSQLObjectInfo Info (classname, version) about object in database ; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLStructure Table/structure description used internally by YBufferSQL.; TSQLTableData Collection of columns data for single SQL table; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:122664,interface,interface,122664,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['interface'],['interface']
Integrability,"ain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodDT.html:3021,depend,depending,3021,root/html528/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html,6,['depend'],['depending']
Integrability,"ain_id);  Tells window manager that the window ""id"" is a transient window of the window ""main_id"". ;  ; virtual void ShapeCombineMask (Window_t id, Int_t x, Int_t y, Pixmap_t mask);  The Non-rectangular Window Shape Extension adds non-rectangular windows to the System. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SubtractRegion (Region_t rega, Region_t regb, Region_t result);  Subtracts regb from rega and stores the results in result. ;  ; virtual Int_t SupportsExtension (const char *ext) const;  Returns 1 if window system server supports extension given by the argument, returns 0 in case extension is not supported and returns -1 in case of error (like server not initialized). ;  ; virtual void Sync (Int_t mode);  Set synchronisation on or off. ;  ; virtual Int_t TextWidth (FontStruct_t font, const char *s, Int_t len);  Return length of the string ""s"" in pixels. Size depends on font. ;  ; virtual void TranslateCoordinates (Window_t src, Window_t dest, Int_t src_x, Int_t src_y, Int_t &dest_x, Int_t &dest_y, Window_t &child);  Translates coordinates in one window to the coordinate space of another window. ;  ; virtual void UnionRectWithRegion (Rectangle_t *rect, Region_t src, Region_t dest);  Updates the destination region from a union of the specified rectangle and the specified source region. ;  ; virtual void UnionRegion (Region_t rega, Region_t regb, Region_t result);  Computes the union of two regions. ;  ; virtual void UnmapWindow (Window_t id);  Unmaps the specified window ""id"". ;  ; virtual void Update (Int_t mode=0);  Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer. ;  ; virtual void UpdateWindow (Int_t mode);  Updates or synchronises client and server once (not permanent). ;  ; virtual void Warp (Int_t ix, Int_t iy, Window_t id=0);  Sets the pointer position. ;  ; virtual void WMDeleteNotify (Window_t id);  Tells WM to sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:30069,depend,depends,30069,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['depend'],['depends']
Integrability,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:108525,integrat,integrators,108525,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,3,['integrat'],"['integration', 'integrators']"
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf__GenSpec.html:4007,depend,dependent,4007,root/html602/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf__GenSpec.html,2,['depend'],['dependent']
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4007,depend,dependent,4007,root/html530/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html,1,['depend'],['dependent']
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init; Int_t_nGen; RooDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf__GenSpec.html:4007,depend,dependent,4007,root/html532/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf__GenSpec.html,1,['depend'],['dependent']
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init = kFALSE). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Bool_t_init",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf__GenSpec.html:4007,depend,dependent,4007,root/html534/RooAbsPdf__GenSpec.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf__GenSpec.html,1,['depend'],['dependent']
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:3999,depend,dependent,3999,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['depend'],['dependent']
Integrability,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:3999,depend,dependent,3999,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['depend'],['dependent']
Integrability,"aining events; vector<const TMVA::Event*>fTrainingEventsRndmidem, but randomly shuffled; Bool_tfVisHistsUseImpif true, use importance as weight; else coef in vis hists; static const Int_trandSEEDset to 1 for debugging purposes or to zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFit( const MethodBase *rfbase ); constructor. RuleFit(); default constructor. ~RuleFit(); destructor. void InitNEveEff(); init effective number of events (using event weights). void InitPtrs(const TMVA::MethodBase* rfbase); initialize pointers. void Initialize(const TMVA::MethodBase* rfbase); initialize the parameters of the RuleFit method and make rules. void SetMethodBase(const TMVA::MethodBase* rfbase); set MethodBase. void Copy(const TMVA::RuleFit& other); copy method. Double_t CalcWeightSum(const vector<const TMVA::Event*>* events, UInt_t neve = 0); calculate the sum of weights. void SetMsgType(TMVA::EMsgType t); set the current message type to that of mlog for this class and all other subtools. void BuildTree(TMVA::DecisionTree* dt); build the decision tree using fNTreeSample events from fTrainingEventsRndm. void MakeForest(); make a forest of decisiontrees. void SaveEventWeights(); save event weights - must be done before making the forest. void RestoreEventWeights(); save event weights - must be done before making the forest. void Boost(TMVA::DecisionTree* dt); Boost the events. The algorithm below is the called AdaBoost.; See MethodBDT for details.; Actually, this is a more or less copy of MethodBDT::AdaBoost(). void ForestStatistics(); summary of statistics of all trees; * end-nodes: average and spread. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<const TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__RuleFit.html:4453,message,message,4453,root/html534/TMVA__RuleFit.html,https://root.cern,https://root.cern/root/html534/TMVA__RuleFit.html,3,['message'],['message']
Integrability,"aining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:40083,integrat,integrator,40083,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,1,['integrat'],['integrator']
Integrability,"aint (Option_t *option="""") override;  Paint image. ;  ; void PaintImage (Drawable_t wid, Int_t x, Int_t y, Int_t xsrc=0, Int_t ysrc=0, UInt_t wsrc=0, UInt_t hsrc=0, Option_t *opt="""") override;  Draw image on the drawable wid (pixmap, window) at x,y position. ;  ; void PolyPoint (UInt_t npt, TPoint *ppt, const char *col=""#000000"", TImage::ECoordMode mode=kCoordModeOrigin) override;  Draw a poly point. ;  ; void PutPixel (Int_t x, Int_t y, const char *col=""#000000"") override;  Draw a point at the specified position. ;  ; void ReadImage (const char *file, EImageFileTypes type=TImage::kUnknown) override;  Read specified image file. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Scale (UInt_t width, UInt_t height) override;  Scale the original image. ;  ; void SetEditable (Bool_t on=kTRUE) override;  ; void SetImage (ASImage *image);  ; void SetImage (const Double_t *imageData, UInt_t width, UInt_t height, TImagePalette *palette=nullptr) override;  Deletes the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (const TArrayD &imageData, UInt_t width, TImagePalette *palette=nullptr) override;  Delete the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (const TVectorD &imageData, UInt_t width, TImagePalette *palette=nullptr) override;  Delete the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (Pixmap_t pxm, Pixmap_t mask=0) override;  Create image from pixmap. ;  ; Bool_t SetImageBuffer (char **buffer, EImageFileTypes type=TImage::kPng) override;  Create image from compressed buffer. ;  ; Bool_t SetJpegDpi (const char *name, UInt_t dpi=72);  Set an image printing resolution in Dots Per Inch units. ;  ; void SetPalette (const TImagePalette *palette) override;  Set a new palette to an image. ;  ; void SetPaletteEnabled (Bool_t on=kTRUE) override;  Sw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:12325,depend,depending,12325,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['depend'],['depending']
Integrability,"ainter::PaintH3 ; (; Option_t * ; option = """"). virtual . Control function to draw a 3D histograms. ; Definition at line 6974 of file THistPainter.cxx. ◆ PaintH3Box(). void THistPainter::PaintH3Box ; (; Int_t ; iopt). virtual . Control function to draw a 3D histogram with boxes. ; Definition at line 7499 of file THistPainter.cxx. ◆ PaintH3BoxRaster(). void THistPainter::PaintH3BoxRaster ; (; ). virtual . Control function to draw a 3D histogram with boxes. ; Definition at line 7690 of file THistPainter.cxx. ◆ PaintH3Iso(). void THistPainter::PaintH3Iso ; (; ). virtual . Control function to draw a 3D histogram with Iso Surfaces. ; Definition at line 7892 of file THistPainter.cxx. ◆ PaintHighlightBin(). void THistPainter::PaintHighlightBin ; (; Option_t * ; option = """"). virtual . Paint highlight bin as TBox object. ; Definition at line 3908 of file THistPainter.cxx. ◆ PaintHist(). void THistPainter::PaintHist ; (; Option_t * ; option). virtual . Control routine to draw 1D histograms ; Definition at line 6837 of file THistPainter.cxx. ◆ PaintInit(). Int_t THistPainter::PaintInit ; (; ). virtual . Compute histogram parameters used by the drawing routines. ; Definition at line 7082 of file THistPainter.cxx. ◆ PaintInitH(). Int_t THistPainter::PaintInitH ; (; ). virtual . Compute histogram parameters used by the drawing routines for a rotated pad. ; Definition at line 7334 of file THistPainter.cxx. ◆ PaintLego(). void THistPainter::PaintLego ; (; Option_t * ; option). virtual . Control function to draw a 2D histogram as a lego plot. ; Definition at line 8017 of file THistPainter.cxx. ◆ PaintLegoAxis(). void THistPainter::PaintLegoAxis ; (; TGaxis * ; axis, . Double_t ; ang . ). virtual . Draw the axis for legos and surface plots. ; Definition at line 8232 of file THistPainter.cxx. ◆ PaintPalette(). void THistPainter::PaintPalette ; (; ). virtual . Paint the color palette on the right side of the pad. ; Definition at line 8421 of file THistPainter.cxx. ◆ PaintScatterPlot()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:160891,rout,routine,160891,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['rout'],['routine']
Integrability,"airs ;  CGeneralLinearFunctionDerivationAuxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar ;  CGeneralLinearFunctionDerivation< double >;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ) ;  CGSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by GSL ;  CGSLFunctionDerivWrapperClass to wrap a gsl_function_fdf (with derivatives) ;  CGSLFunctionWrapperWrapper class to the gsl_function C structure ;  CGSLIntegrationWorkspace;  CGSLIntegratorClass for performing numerical integration of a function in one dimension ;  CGSLInterpolatorInterpolation class based on GSL interpolation functions ;  CGSLMCIntegrationWorkspace;  CGSLMCIntegrator;  CGSLMinimizerGSLMinimizer class ;  CGSLMinimizer1DMinimizer for arbitrary one dimensional functions ;  CGSLMiserIntegrationWorkspaceWorkspace for MISER ;  CGSLMonteFunctionAdapter;  CGSLMonteFunctionWrapperWrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm ;  CGSLMultiFitGSLMultiFit, internal class for implementing GSL non linear least square GSL fitting ;  CGSLMultiFitFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: ;  CGSLMultiFitFunctionWrapperWrapper to a multi-dim functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:37835,wrap,wrap,37835,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['wrap'],['wrap']
Integrability,"ait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110562,depend,depends,1110562,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['depend'],['depends']
Integrability,"aits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, required only to build hierarchy. More...;  ; class  RGeomNodeInfo;  Node information including rendering data. More...;  ; class  RGeomNodeVisibility;  Custom settings for physical Node visib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:2468,interface,interface,2468,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['interface'],['interface']
Integrability,"aits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; class  RBrowser;  Web-based ROOT files and objects browser. More...;  ; class  RBrowserCatchedWidget;  ; class  RBrowserData;  Way to browse (hopefully) everything in ROOT. More...;  ; class  RBrowserDataCleanup;  ; class  RBrowserEditorWidget;  ; class  RBrowserInfoWidget;  ; class  RBrowserReply;  Reply on browser request. More...;  ; class  RBrowserRequest;  Request send from client to get content of path element. More...;  ; class  RBrowserTimer;  ; class  RBrowserWidget;  Abstract Web-based widget, which can be used in the RBrowser Used to embed canvas, geometry viewer and potentially any other widgets. More...;  ; class  RBrowserWidgetProvider;  ; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  RFileDialog;  Web-based FileDialog. More...;  ; class  RGeoItem;  Representation of single item in the geometry browser. More...;  ; class  RGeomBrowserIter;  Iterator of hierarchical geometry structures. More...;  ; class  RGeomConfig;  Configuration parameters which can be configured on the client Send as is to-from client. More...;  ; class  RGeomDescription;  ; class  RGeomDrawing;  Object with full description for drawing geometry It includes list of visible items and list of nodes required to build them. More...;  ; class  RGeomHierarchy;  Web-based ROOT geometry hierarchy viewer. More...;  ; class  RGeomNode;  Full node description including matrices and other attributes. More...;  ; class  RGeomNodeBase;  Base description of geometry node, required only to build hierarchy. More...;  ; class  RGeomNodeInfo;  Node information including rendering data. More...;  ; class  RGeomNode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:2507,interface,interface,2507,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['interface'],['interface']
Integrability,"al (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetRelTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 28946 2009-06-11 15:39:14Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:9424,integrat,integrator,9424,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,1,['integrat'],['integrator']
Integrability,"al (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:18125,message,message,18125,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,4,['message'],['message']
Integrability,"al (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction1PdfBinding_double_int_.html:38520,integrat,integrator,38520,root/html526/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction1PdfBinding_double_int_.html,1,['integrat'],['integrator']
Integrability,"al . Reimplemented in RooCachedReal, and RooNumRunningInt.; Definition at line 93 of file RooAbsCachedReal.h. ◆ selfNormalized(). virtual bool RooAbsCachedReal::selfNormalized ; (; ); const. inlinevirtual . Definition at line 32 of file RooAbsCachedReal.h. ◆ setInterpolationOrder(). void RooAbsCachedReal::setInterpolationOrder ; (; Int_t ; order). Set interpolation order of RooHistFunct representing cache histogram. ; Definition at line 254 of file RooAbsCachedReal.cxx. ◆ Streamer(). void RooAbsCachedReal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in RooCachedReal, RooNumCdf, and RooNumRunningInt. ◆ StreamerNVirtual(). void RooAbsCachedReal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file RooAbsCachedReal.h. Friends And Related Symbol Documentation. ◆ FuncCacheElem. friend class FuncCacheElem. friend . Definition at line 95 of file RooAbsCachedReal.h. Member Data Documentation. ◆ _anaIntMap. std::map<Int_t,std::pair<const RooArgSet*,const RooArgSet*> > RooAbsCachedReal::_anaIntMap. mutableprotected . ! Map for analytical integration codes ; Definition at line 113 of file RooAbsCachedReal.h. ◆ _cacheMgr. RooObjCacheManager RooAbsCachedReal::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 106 of file RooAbsCachedReal.h. ◆ _disableCache. bool RooAbsCachedReal::_disableCache. private . Definition at line 118 of file RooAbsCachedReal.h. ◆ _ipOrder. Int_t RooAbsCachedReal::_ipOrder. protected . Interpolation order for cache histograms. ; Definition at line 109 of file RooAbsCachedReal.h. Libraries for RooAbsCachedReal:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsCachedReal.h; roofit/roofitcore/src/RooAbsCachedReal.cxx. RooAbsCachedReal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:68697,integrat,integration,68697,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['integrat'],['integration']
Integrability,"al ; (; RooFit::EvalContext & ; ctx); const. overrideprotectedvirtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented from RooAbsReal.; Definition at line 374 of file RooProduct.cxx. ◆ evaluate(). double RooProduct::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate product of input functions. ; Implements RooAbsReal.; Definition at line 353 of file RooProduct.cxx. ◆ forceAnalyticalInt(). bool RooProduct::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . Force internal handling of integration of given observable if any of the product terms depend on it. ; Reimplemented from RooAbsReal.; Definition at line 119 of file RooProduct.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooProduct::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Declare that we handle all integrations internally. ; Reimplemented from RooAbsReal.; Definition at line 280 of file RooProduct.cxx. ◆ getPartIntList(). Int_t RooProduct::getPartIntList ; (; const RooArgSet * ; iset, . const char * ; isetRange = nullptr . ); const. protected . Return list of (partial) integrals whose product defines the integral of this RooProduct over the observables in iset in range isetRange. ; If no such list exists, create it now and store it in the cache for future use. ; Definition at line 209 of file RooProduct.cxx. ◆ groupProductTerms(). RooProduct::ProdMap * RooProduct::groupProductTerms ; (; const RooArgSet & ; allVars); const. protected . Group observables into subsets in which the product factorizes and that can thus be integrated separately. ; Definition at line 138 of file RooProduct.cxx. ◆ ioStreamerPass2(). void RooProduct::ioStreamerPass2 ; (; ). overrideprotectedvirtual . Method called by workspace container to finalize schema evolution issues that cannot be handled in a sin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProduct.html:65120,integrat,integrations,65120,doc/master/classRooProduct.html,https://root.cern,https://root.cern/doc/master/classRooProduct.html,1,['integrat'],['integrations']
Integrability,"al Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; const RooAbsReal&ixF(); voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*RooAbsMoment::mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:17881,message,message,17881,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,9,['message'],['message']
Integrability,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheSystem.html:9437,protocol,protocol,9437,root/html532/TDCacheSystem.html,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html,4,['protocol'],['protocol']
Integrability,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetSystem.html:11479,protocol,protocol,11479,root/html532/TNetSystem.html,https://root.cern,https://root.cern/root/html532/TNetSystem.html,2,['protocol'],['protocol']
Integrability,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TWebSystem&operator=(const TWebSystem&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebSystem.html:9559,protocol,protocol,9559,root/html602/TWebSystem.html,https://root.cern,https://root.cern/root/html602/TWebSystem.html,2,['protocol'],['protocol']
Integrability,"al Bool_tTSystem::IsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intTSystem::Link(const char* from, const char* to); virtual voidTSystem::ListLibraries(const char* regexp = """"); virtual voidTSystem::ListSymbols(const char* module, const char* re = """"); virtual intTSystem::Load(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeTSystem::Now(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intTSystem::OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidTSystem::Openlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*TSystem::OpenPipe(const char* command, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*TSystem::PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intTSystem::RecvBuf(int sock, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:11465,protocol,protocol,11465,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['protocol'],['protocol']
Integrability,"al Bool_tisFundamental() const; virtual Bool_tRooAbsRealLValue::isJacobianOK(const RooArgSet& depList) const; virtual Bool_tRooAbsRealLValue::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tRooAbsRealLValue::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; virtual Double_tRooAbsRealLValue::jacobian() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); virtual Int_tRooAbsRealLValue::numBins(const char* rangeName = 0) const; virtual Int_tRooAbsRealLValue::numBins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:20071,message,message,20071,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,['message'],['message']
Integrability,"al Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:3528,depend,dependsOn,3528,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['depend'],['dependsOn']
Integrability,"al and background PDEFoam cells.; If fSigBgSeparated == false, the error is taken directly from the PDEFoam cell. ; Definition at line 755 of file MethodPDEFoam.cxx. ◆ CalcXminXmax(). void TMVA::MethodPDEFoam::CalcXminXmax ; (; ). protected . Determine foam range [fXmin, fXmax] for all dimensions, such that a fraction of 'fFrac' events lie outside the foam. ; Definition at line 322 of file MethodPDEFoam.cxx. ◆ Class(). static TClass * TMVA::MethodPDEFoam::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodPDEFoam::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodPDEFoam::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 212 of file MethodPDEFoam.h. ◆ CreatePDEFoamKernel(). TMVA::PDEFoamKernelBase * TMVA::MethodPDEFoam::CreatePDEFoamKernel ; (; ). protected . create a pdefoam kernel estimator, depending on the current value of fKernel ; Definition at line 1102 of file MethodPDEFoam.cxx. ◆ CreateRanking(). const TMVA::Ranking * TMVA::MethodPDEFoam::CreateRanking ; (; ). virtual . Compute ranking of input variables from the number of cuts made in each PDEFoam dimension. ; The PDEFoam dimension (the variable) for which the most cuts were done is ranked highest. ; Implements TMVA::MethodBase.; Definition at line 823 of file MethodPDEFoam.cxx. ◆ DeclareCompatibilityOptions(). void TMVA::MethodPDEFoam::DeclareCompatibilityOptions ; (; ). privatevirtual . options that are used ONLY for the READER to ensure backward compatibility ; Reimplemented from TMVA::MethodBase.; Definition at line 243 of file MethodPDEFoam.cxx. ◆ DeclareOptions(). void TMVA::MethodPDEFoam::DeclareOptions ; (; ). privatevirtual . Declare MethodPDEFoam options. ; Implements TMVA::MethodBase.; Definition at line 208 of file MethodPDEFoam.cxx. ◆ DeclFileName(). static const char * TMVA::MethodPDEFoam::DeclFileName ; (; ). inlinestatic . Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDEFoam.html:35563,depend,depending,35563,doc/master/classTMVA_1_1MethodPDEFoam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDEFoam.html,1,['depend'],['depending']
Integrability,"al calculation. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetGenerator(ROOT::Math::GSLRngWrapper* r). 	 to be added later as options for basic MC methods; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetIntegrationRule(Integration::GKRule );. 	 set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). 	 set integration method. void SetMode(ROOT::Math::MCIntegration::Mode mode). 	 set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). 	 set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). 	 set default parameters for MISER method. double Sigma(). 	 set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. 	 returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). 	 returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method. » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMCIntegrator.h 26307 2008-11-20 09:51:19Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html:6816,integrat,integration,6816,root/html526/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html,1,['integrat'],['integration']
Integrability,"al data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)), the corresponding names of the classes are written using sans-serif font type (MnMigrad, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:7625,interface,interface,7625,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['interface'],['interface']
Integrability,"al functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  CTBranchProxy;  ►CTCollectionProxyInfo;  CAddress;  CEnviron;  CEnvironBase;  CInsert;  CIterators;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValue;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsert;  CPairHolder;  CPushback;  CPushb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:9761,interface,interface,9761,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['interface'],['interface']
Integrability,al functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall hel,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:9412,interface,interface,9412,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['interface'],['interface']
Integrability,"al implementation of a PDF class derived from RooAbsPdf; 32should override the `evaluate()` function. This function should; 33return the PDF's value (which does not need to be normalised).; 34 ; 35 ; 36#### Normalization/Integration; 37 ; 38Although the normalization of a PDF is an integral part of a; 39probability density function, normalization is treated separately; 40in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; 41PDF: it can be a building block for a more complex composite PDF; 42if any of its variables are functions instead of variables. In; 43such cases, the normalization of the composite PDF may not simply be; 44integral over the dependents of the top-level PDF: these are; 45functions with potentially non-trivial Jacobian terms themselves.; 46\note Therefore, no explicit attempt should be made to normalize the; 47function output in evaluate(). In particular, normalisation constants; 48can be omitted to speed up the function evaluations, and included later; 49in the integration of the PDF (see below), which is rarely called in; 50comparison to the `evaluate()` function.; 51 ; 52In addition, RooAbsPdf objects do not have a static concept of what; 53variables are parameters, and what variables are dependents (which; 54need to be integrated over for a correct PDF normalization).; 55Instead, the choice of normalization is always specified each time a; 56normalized value is requested from the PDF via the getVal(); 57method.; 58 ; 59RooAbsPdf manages the entire normalization logic of each PDF with; 60the help of a RooRealIntegral object, which coordinates the integration; 61of a given choice of normalization. By default, RooRealIntegral will; 62perform an entirely numeric integration of all dependents. However,; 63PDFs can advertise one or more (partial) analytical integrals of; 64their function, and these will be used by RooRealIntegral, if it; 65determines that this is safe (i.e., no hidden Jacobian terms,; 66multiplication with other PDFs t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:2470,integrat,integration,2470,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['integrat'],['integration']
Integrability,"al integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_int_.html:32446,integrat,integrator,32446,root/html526/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction4Binding_double_double_double_double_int_.html,2,['integrat'],['integrator']
Integrability,"al integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinearVar.html:37414,integrat,integrator,37414,root/html530/RooLinearVar.html,https://root.cern,https://root.cern/root/html530/RooLinearVar.html,1,['integrat'],['integrator']
Integrability,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2903 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:121221,message,messages,121221,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['message'],['messages']
Integrability,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2988 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:122551,message,messages,122551,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['message'],['messages']
Integrability,"al of bin contents. ;  ; virtual Double_t IntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") const;  Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram. ;  ; Double_t Interpolate (Double_t x, Double_t y, Double_t z) const override;  Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation based on the 8 nearest bin center points (corner of the cube surrounding the points) The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation The given values (x,y,z) must be between first bin center and last bin center for each coordinate: ;  ; Double_t KolmogorovTest (const TH1 *h2, Option_t *option="""") const override;  Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ;  ; virtual TH1 * Project3D (Option_t *option=""x"") const;  Project a 3-d histogram into 1 or 2-d histograms depending on the option parameter, which may contain a combination of the characters x,y,z,e. ;  ; virtual TH1D * ProjectionX (const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") const;  Project a 3-D histogram into a 1-D histogram along X. ;  ; virtual TH1D * ProjectionY (const char *name=""_py"", Int_t ixmin=0, Int_t ixmax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") const;  Project a 3-D histogram into a 1-D histogram along Y. ;  ; virtual TH1D * ProjectionZ (const char *name=""_pz"", Int_t ixmin=0, Int_t ixmax=-1, Int_t iymin=0, Int_t iymax=-1, Option_t *option="""") const;  Project a 3-D histogram into a 1-D histogram along Z. ;  ; virtual TH3 * Rebin3D (Int_t nxgroup=2, Int_t nygroup=2, Int_t nzgroup=2, const char *newname="""");  Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together. ;  ; TH3 * RebinX (Int_t ngroup=2, const char *newname="""") override;  Rebin only the X axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:13832,depend,depending,13832,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['depend'],['depending']
Integrability,"al of bin contents. ;  ; virtual Double_t IntegralAndError (Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t &err, Option_t *option="""") const;  Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2] for a 3-D histogram. ;  ; Double_t Interpolate (Double_t x, Double_t y, Double_t z) const override;  Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation based on the 8 nearest bin center points (corner of the cube surrounding the points) The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation The given values (x,y,z) must be between first bin center and last bin center for each coordinate: ;  ; Double_t KolmogorovTest (const TH1 *h2, Option_t *option="""") const override;  Statistical test of compatibility in shape between THIS histogram and h2, using Kolmogorov test. ;  ; virtual TH1 * Project3D (Option_t *option=""x"") const;  Project a 3-d histogram into 1 or 2-d histograms depending on the option parameter, which may contain a combination of the characters x,y,z,e. ;  ; virtual TProfile2D * Project3DProfile (Option_t *option=""xy"") const;  Project a 3-d histogram into a 2-d profile histograms depending on the option parameter option may contain a combination of the characters x,y,z option = ""xy"" return the x versus y projection into a TProfile2D histogram option = ""yx"" return the y versus x projection into a TProfile2D histogram option = ""xz"" return the x versus z projection into a TProfile2D histogram option = ""zx"" return the z versus x projection into a TProfile2D histogram option = ""yz"" return the y versus z projection into a TProfile2D histogram option = ""zy"" return the z versus y projection into a TProfile2D histogram NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. ;  ; virtual TH1D * ProjectionX (const char *name=""_px"", Int_t iymin=0, Int_t iymax=-1, Int_t izmin=0, Int_t izmax=-1, Option_t *option="""") const;  Project a 3-D h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:10037,depend,depending,10037,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,7,['depend'],['depending']
Integrability,"al of function landau over observables(x) with normalization () with range identifier <none>; [#3] DEBUG:Integration -- landau: Adding observable x as shape dependent; [#3] DEBUG:Integration -- landau: Adding parameter 0 as value dependent; [#3] DEBUG:Integration -- landau: Adding parameter 0.1 as value dependent; [#3] INFO:Integration -- landau: Observable x is suitable for analytical integration (if supported by p.d.f); [#3] INFO:Integration -- landau: Observables (x) are numerically integrated; [#1] INFO:NumericIntegration -- RooRealIntegral::init(landau_Int[x]) using numeric integrator RooAdaptiveGaussKronrodIntegrator1D to calculate Int(x); [2] int_dx landau(x) = 0.098957102921895; [#3] INFO:Integration -- RooRealIntegral::ctor(landau_Int[x]) Constructing integral of function landau over observables(x) with normalization () with range identifier <none>; [#3] DEBUG:Integration -- landau: Adding observable x as shape dependent; [#3] DEBUG:Integration -- landau: Adding parameter 0 as value dependent; [#3] DEBUG:Integration -- landau: Adding parameter 0.1 as value dependent; [#3] INFO:Integration -- landau: Observable x is suitable for analytical integration (if supported by p.d.f); [#3] INFO:Integration -- landau: Observables (x) are numerically integrated; [#1] INFO:NumericIntegration -- RooRealIntegral::init(landau_Int[x]) using numeric integrator RooAdaptiveGaussKronrodIntegrator1D to calculate Int(x); [3] int_dx landau(x) = 0.098957102921895; --- RooAbsArg ---; Value State: clean; Shape State: clean; Attributes: [SnapShot_ExtRefClone] ; Address: 0x55cdf7163a10; Clients: ; Servers: ; Proxies: ; --- RooAbsCategory ---; Value = 1 ""15Points); Possible states:; 15Points 1; 21Points 2; 31Points 3; 41Points 4; 51Points 5; 61Points 6; WynnEpsilon 0; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf901_numintconfig.C. tutorialsroofitrf901_numintconfig.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8C.html:11509,depend,dependent,11509,doc/master/rf901__numintconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html,4,"['depend', 'integrat']","['dependent', 'integrated', 'integration', 'integrator']"
Integrability,"al of function on an infinite interval. ; This function computes, to an attempted specified accuracy, the value of the integral: ; \[; I = \int^{\infty}_{-\infty} f(x)dx; \]. Usage: In any arithmetic expression, this function has the approximate value of the integral I.; The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. ; Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 56 of file GaussIntegrator.cxx. ◆ Integral() [2/3]. double ROOT::Math::GaussIntegrator::Integral ; (; const std::vector< double > & ; pts). overridevirtual . This method is not implemented. ; Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 190 of file GaussIntegrator.cxx. ◆ Integral() [3/3]. double ROOT::Math::GaussIntegrator::Integral ; (; double ; a, . double ; b . ). overridevirtual . Returns Integral of function between a and b. ; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig converted to C++ by Rene Brun; This function computes, to an attempted specified accuracy, the value of the integral.; Method: For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point and 16-point Gaussian quadrature approximations to ; \[; I = \int^{b}_{a} f(x)dx; \]. and define ; \[; r(a,b) = \frac{\left|g_{16}(a,b)-g_{8}(a,b)\right|}{1+\left|g_{16}(a,b)\right|}; \]. Then, ; \[; G = \sum_{i=1}^{k}g_{16}(x_{i-1},x_{i}); \]. where, starting with \(x_{0} = A\) and finishing with \(x_{k} = B\), the subdivision points \(x_{i}(i=1,2,...)\) are given by ; \[; x_{i} = x_{i-1} + \lambda(B-x_{i-1}); \]. \(\lambda\) is equal to the first member of the sequence 1,1/2,1/4,... for which \(r(x_{i-1}, x_{i}) < EPS\). If, at any stage in the process of subdivision, the ratio ; \[; q = \left|\frac{x_{i}-x_{i-1}}{B-A}\right|; \]. is so small that 1+0.005q is indistinguishable from 1 to machine accuracy, an error exit occurs with the function value set equal to zero.; Accuracy: The user provides absolute and relati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussIntegrator.html:6340,rout,routine,6340,doc/master/classROOT_1_1Math_1_1GaussIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussIntegrator.html,1,['rout'],['routine']
Integrability,"al pad - the viewer is always; bound to a TPad object at present [This may be removed as a restriction in; the future] . You should perform the publishing to the viewer described below; in the Paint() method of the object you attach to the pad (via Draw()); TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or; Pad ""pad"" (default). The viewer is created via the plugin manager,; attached to pad, and the interface returned.; Begin / End Scene; Objects must be added to viewer between BeginScene/EndScene calls e.g.; v->BeginScene();; .....; v->AddObject(....);; v->AddObject(....);; .....; v->EndScene();>; The BeginScene call will cause the viewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:2515,interface,interface,2515,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['interface'],['interface']
Integrability,"al part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Returns the point #ipoint.; For 1d, if ipoint > fN/2+1 (the point is in the Hermitian symmetric part), it is still; returned. For >1d, only the first (roughly)half of points can be returned; For 2d, see function GetPointComplex(Int_t *ipoint,...). void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint.; In case of transforms of more than 2 dimensions,; only points from the first (roughly)half are returned, the rest being Hermitian symmetric. Double_t* GetPointsReal(Bool_t fromInput = kFALSE) const; Returns the input array// One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void GetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0); Set the point #ipoint. void SetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); For multidimensional transforms. Set the point #ipoint. void SetPoints(const Double_t* data); Set all input points. void SetPointComplex(Int_t ipoint, TComplex& c)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTRealComplex.html:11368,interface,interface,11368,root/html528/TFFTRealComplex.html,https://root.cern,https://root.cern/root/html528/TFFTRealComplex.html,6,['interface'],['interface']
Integrability,al table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:23880,interface,interface,23880,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,5,"['integrat', 'interface']","['integrators', 'interface']"
Integrability,"al to offer all observables for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 50 of file RooAddPdf.h. ◆ genContext(). RooAbsGenContext * RooAddPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ; Reimplemented from RooAbsPdf.; Definition at line 901 of file RooAddPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Determine which part (if any) of given integral can be performed analytically. ; If any analytical integration is possible, return integration scenario code; RooAddPdf queries each component PDF for its analytical integration capability of the requested set ('allVars'). It finds the largest common set of variables that can be integrated by all components. If such a set exists, it reconfirms that each component is capable of analytically integrating the common set, and combines the components individual integration codes into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:88177,integrat,integration,88177,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,6,['integrat'],['integration']
Integrability,"al void Transform()=0; TVirtualFFT::GetPointComplexvirtual void GetPointComplex(Int_t ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::GetNvirtual Int_t * GetN() const =0; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::SetPointvirtual void SetPoint(Int_t ipoint, Double_t re, Double_t im=0)=0; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::GetXlastvirtual Int_t GetXlast() constDefinition TVirtualFitter.h:86; TVirtualFitter::GetObjectFitvirtual TObject * GetObjectFit() constDefinition TVirtualFitter.h:77; TVirtualFitter::GetXfirstvirtual Int_t GetXfirst() constDefinition TVirtualFitter.h:85; TVirtualFitter::GetFitterstatic TVirtualFitter * GetFitter()static: return the current FitterDefinition TVirtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualHistPainterAbstract interface to a histogram painter.Definition TVirtualHistPainter.h:30; TVirtualHistPainter::DrawPanelvirtual void DrawPanel()=0; TVirtualHistPainter::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) override=0Computes distance from point (px,py) to the object.; TVirtualHistPainter::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) override=0Execute action corresponding to an event at (px,py).; TVirtualHistPainter::SetHighlightvirtual void SetHighlight()=0; TVirtualHistPainter::HistPainterstatic TVirtualHistPainter * HistPainter(TH1 *obj)Static function returning a pointer to the current histogram painter.Definition TVirtualHistPainter.cxx:31; TVirtualHistPainter::Paintvoid Paint(Option_t *option="""") override=0This method must be overridden if a class wants to paint itself.; TVirtualPaveStatsDefinition TVirtualPaveStats.h:28; TVirtualPaveStats::SetParentvirtual void SetParent(TObject *)=0; bool; double; int; unsigned int; ROOT::Math::gamma_quantile_cdouble ga",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:472363,interface,interface,472363,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['interface'],['interface']
Integrability,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatus.html:6144,message,messages,6144,root/html534/TStatus.html,https://root.cern,https://root.cern/root/html534/TStatus.html,3,['message'],['messages']
Integrability,"al void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooRealProxy beta;  ; RooRealProxy gamma;  ; RooRealProxy mu;  ; RooRealProxy x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGamma.html:68780,integrat,integration,68780,doc/master/classRooGamma.html,https://root.cern,https://root.cern/doc/master/classRooGamma.html,1,['integrat'],['integration']
Integrability,"al || print_ferrors) {; 4894 Double_t parmin,parmax;; 4895 for (Int_t ipar=0;ipar<fit->GetNpar();ipar++) {; 4896 fit->GetParLimits(ipar,parmin,parmax);; 4897 if (print_fval < 2 && parmin*parmax != 0 && parmin >= parmax) continue;; 4898 if (print_ferrors) {; 4899 snprintf(textstats,50,""%-8s = %s%s #pm %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat(),""%"",stats->GetFitFormat());; 4900 snprintf(t,64,textstats,fit->GetParameter(ipar); 4901 ,fit->GetParError(ipar));; 4902 } else {; 4903 snprintf(textstats,50,""%-8s = %s%s "",fit->GetParName(ipar),""%"",stats->GetFitFormat());; 4904 snprintf(t,64,textstats,fit->GetParameter(ipar));; 4905 }; 4906 t[63] = 0;; 4907 stats->AddText(t);; 4908 }; 4909 }; 4910 ; 4911 if (!done) functions->Add(stats);; 4912 stats->Paint();; 4913}; 4914 ; 4915 ; 4916////////////////////////////////////////////////////////////////////////////////; 4917/// Smooth a curve given by N points.; 4918///; 4919/// The original code is from an underlaying routine for Draw based on the; 4920/// CERN GD3 routine TVIPTE:; 4921///; 4922/// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; 4923///; 4924/// This method draws a smooth tangentially continuous curve through; 4925/// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; 4926/// The curve is approximated by a polygonal arc of short vectors.; 4927/// The data points can represent open curves, P(1) != P(N) or closed; 4928/// curves P(2) == P(N). If a tangential discontinuity at P(I) is; 4929/// required, then set P(I)=P(I+1). Loops are also allowed.; 4930///; 4931/// Reference Marlow and Powell, Harwell report No.R.7092.1972; 4932/// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; 4933///; 4934/// - npoints : Number of data points.; 4935/// - x : Abscissa; 4936/// - y : Ordinate; 4937 ; 4938void TGraphPainter::Smooth(TGraph *theGraph, Int_t npoints, Double_t *x, Double_t *y, Int_t drawtype); 4939{; 4940 ; 4941 Int_t i, k, kp, km, npointsMax, banksize, n2, npt;; 4942 Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:172299,rout,routine,172299,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['rout'],['routine']
Integrability,"al"". That is, we create an ""efficiency"" graph, where each entry is; between 0 and 1, inclusive. If the histograms are not filled with unit weights, the number of effective; entries is used to normalise the bin contents which might lead to wrong results.; . The points are assigned a x value at the center of each histogram bin.; The y values are for all options except for the; bayesian methods where the result depends on the chosen option. If the denominator becomes 0 or pass > total, the corresponding bin is; skipped. 2) calculating ratios of two Poisson means (option 'pois'):. The two histograms are interpreted as independent Poisson processes and the ratio; ; The histogram 'pass' is interpreted as n_{1} and the total histogram; is used for n_{2}. The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; of efficiency by a parameter transformation:; . The x errors span each histogram bin (lowedge ... lowedge+width); The y errors depend on the chosen statistic methode which can be determined; by the options given below. For a detailed description of the used statistic; calculations please have a look at the corresponding functions!. Options:; - v : verbose mode: prints information about the number of used bins; and calculated efficiencies with their errors; - cl=x : determine the used confidence level (0<x<1) (default is 0.683); - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); - w : Wilson interval (see TEfficiency::Wilson); - n : normal approximation propagation (see TEfficiency::Normal); - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; (see TEfficiency::Bayesian); - mode : use mode of posterior for Bayesian interval (default is mean); - shortest: use shortest interval (done by default if mode is set); - central: use central interval (done by default if mode is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphAsymmErrors.html:19578,depend,depend,19578,root/html532/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html532/TGraphAsymmErrors.html,4,['depend'],['depend']
Integrability,"al() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooArgList&list() const; const RooArgList&list1() const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:17734,message,message,17734,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,3,['message'],['message']
Integrability,"al() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 1e-3, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fractio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:43507,integrat,integration,43507,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,1,['integrat'],['integration']
Integrability,"al); // reset the plot variable value to not disturb the original state; 2193 return frame;; 2194}; 2195 ; 2196 ; 2197//_____________________________________________________________________________; 2198// coverity[PASS_BY_VALUE]; 2199RooPlot* RooAbsReal::plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const; 2200 ; 2201{; 2202 // Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); 2203 //; 2204 // Plot asymmetry of ourselves, defined as; 2205 //; 2206 // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:97528,depend,dependents,97528,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['depend'],['dependents']
Integrability,al*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooAbsReal*_funcInt! Function integral; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsTestStatistic::_init! Is object initialized ; RooNumIntConfig_intConfigNumeric integrator configuration for integration of function over bin; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_integrateIs integration over the bin volume requested; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealMPFE**RooAbsTestStatistic::_mpfeArray! Array of parallel execution frond ends; RooFit::MPSplitRooAbsTestStatistic::_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_tRooAbsTestStatistic::_nCPUNumber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts ; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:38430,integrat,integrator,38430,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,3,['integrat'],"['integration', 'integrator']"
Integrability,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussian.html:38266,integrat,integrator,38266,root/html526/RooGaussian.html,https://root.cern,https://root.cern/root/html526/RooGaussian.html,2,['integrat'],['integrator']
Integrability,"al*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBreitWigner.html:38394,integrat,integrator,38394,root/html526/RooBreitWigner.html,https://root.cern,https://root.cern/root/html526/RooBreitWigner.html,1,['integrat'],['integrator']
Integrability,al::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  ROOT::Experimental::Internal::RPageStorage;  Common functi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__NTuple.html:12610,interface,interface,12610,doc/master/group__NTuple.html,https://root.cern,https://root.cern/doc/master/group__NTuple.html,1,['interface'],['interface']
Integrability,"al::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:33225,integrat,integrator,33225,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,2,['integrat'],['integrator']
Integrability,"al::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction1Binding_double_int_.html:32940,integrat,integrator,32940,root/html530/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction1Binding_double_int_.html,1,['integrat'],['integrator']
Integrability,"al::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgList& sumSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:35298,integrat,integrator,35298,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,1,['integrat'],['integrator']
Integrability,"al::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.d.f; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooSetProxyintobsobservables that p.d.f is integrated over; RooRealProxyintpdfp.d.f that is integrated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProjectedPdf(); Default constructor. RooProjectedPdf(const char* name, const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); Construct projection of input pdf '_intpdf' over observables 'intObs'. RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:40129,integrat,integrated,40129,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,['integrat'],['integrated']
Integrability,"al::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.d.f; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooSetProxyintobsobservables that p.d.f is integrated over; RooRealProxyintpdfp.d.f that is integrated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProjectedPdf(); Default constructor. RooProjectedPdf(const char* name, const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); Construct projection of input pdf '_intpdf' over observables 'intObs'. RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getValV(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getValF() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:42420,integrat,integrated,42420,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,1,['integrat'],['integrated']
Integrability,"al::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBMixDecay(const char* name, const char* title, RooRealVar& t, RooAbsCategory& mixState, RooAbsCategory& tagFlav, RooAbsReal& tau, RooAbsReal& dm, RooAbsReal& mistag, RooAbsReal& delMistag, const RooResolutionModel& model, RooBMixDecay::DecayType type = DoubleSided); Constructor. RooBMixDecay(const RooBMixDecay& other, const char* name = 0); Copy constructor. ~RooBMixDecay(); Destructor. Double_t coefficient(Int_t basisIndex) const; Comp with tFit MC: must be (1 - tagFlav*...). Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; cout << ""RooBMixDecay::getCoefAI "" ; allVars.Print(""1"") ;. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const. void initGenerator(Int_t code). void generateEvent(Int_t code); Generate mix-state dependent. inline RooBMixDecay(); Constructors, assignment etc. { }. TObject* clone(const char* newname) const; { return new RooBMixDecay(*this,newname) ; }. » Last changed: Tue Jun 30 14:31:02 2015 » Last generated: 2015-06-30 14:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBMixDecay.html:48211,depend,dependent,48211,root/html602/RooBMixDecay.html,https://root.cern,https://root.cern/root/html602/RooBMixDecay.html,1,['depend'],['dependent']
Integrability,al;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the nuisance according to their pdf. More...;  ; class  ProfileInspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:6723,interface,interface,6723,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['interface'],['interface']
Integrability,"al;  number of function evaluation ;  ; double fRelError;  Relative error. ;  ; double fRelTol;  relative tolerance ;  ; double fResult;  last integration result ;  ; unsigned int fSize;  max size of working array (explode with dimension) ;  ; int fStatus;  status of algorithm (error if not zero) ;  . #include <Math/AdaptiveIntegratorMultiDim.h>. Inheritance diagram for ROOT::Math::AdaptiveIntegratorMultiDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ AdaptiveIntegratorMultiDim() [1/2]. ROOT::Math::AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim ; (; double ; absTol = 0.0, . double ; relTol = 1E-9, . unsigned int ; maxpts = 100000, . unsigned int ; size = 0 . ). explicit . Construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ; The integration will stop when the absolute error is less than the absolute tolerance OR when the relative error is less than the relative tolerance. The absolute tolerance by default is not used (it is equal to zero). The size of working array represents the number of sub-division used for calculating the integral. Higher the dimension, larger sizes are required for getting the same accuracy. The size must be larger than \( (2n + 3) (1 + maxpts/(2^n + 2n(n + 1) + 1))/2) \). For smaller value passed, the minimum allowed will be used ; Definition at line 17 of file AdaptiveIntegratorMultiDim.cxx. ◆ AdaptiveIntegratorMultiDim() [2/2]. ROOT::Math::AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim ; (; const IMultiGenFunction & ; f, . double ; absTol = 0.0, . double ; relTol = 1E-9, . unsigned int ; maxcall = 100000, . unsigned int ; size = 0 . ). explicit . Construct with a reference to the integrand function and given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:6684,integrat,integration,6684,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['integrat'],['integration']
Integrability,"alContext & ; ctx); const. overrideprotectedvirtual . Compute multiple values of BifurGauss distribution. ; Reimplemented from RooAbsReal.; Definition at line 72 of file RooBifurGauss.cxx. ◆ evaluate(). double RooBifurGauss::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 58 of file RooBifurGauss.cxx. ◆ getAnalyticalIntegral(). Int_t RooBifurGauss::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooBifurGauss.cxx. ◆ IsA(). TClass * RooBifurGauss::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 49 of file RooBifurGauss.h. ◆ Streamer(). void RooBifurGauss::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBifurGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooBifurGauss.h. ◆ translate(). void RooBifurGauss::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from transl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBifurGauss.html:77064,integrat,integration,77064,doc/master/classRooBifurGauss.html,https://root.cern,https://root.cern/doc/master/classRooBifurGauss.html,1,['integrat'],['integration']
Integrability,"alIntegral to offer all our actual observable for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 322 of file RooAbsCachedPdf.cxx. ◆ getAnalyticalIntegralWN(). int RooAbsCachedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Advertises internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 334 of file RooAbsCachedPdf.cxx. ◆ getCache(). RooAbsCachedPdf::PdfCacheElem * RooAbsCachedPdf::getCache ; (; const RooArgSet * ; nset, . bool ; recalculate = true . ); const. protected . Retrieve cache object associated with given choice of observables. ; If cache object does not exist, create and fill and register it on the fly. If recalculate=false recalculation of cache contents of existing caches that are marked dirty due to dependent parameter changes is suppressed. ; Definition at line 113 of file RooAbsCachedPdf.cxx. ◆ getCacheHist() [1/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet & ; nset); const. inline . Definition at line 43 of file RooAbsCachedPdf.h. ◆ getCacheHist() [2/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooDataHist cache histogram for given choice of observables. ; Definition at line 100 of file RooAbsCachedPdf.cxx. ◆ getCachePdf() [1/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet & ; nset); const. inline . Definition at line 39 of file RooAbsCachedPdf.h. ◆ getCachePdf() [2/2]. RooAbsPdf * RooAbsCachedPdf::getCachePdf ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooHistPdf cache pdf for given choice of observables. ; Definition at line 90 of file RooAbsCachedPdf.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedPdf::getInterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:81771,depend,dependent,81771,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['depend'],['dependent']
Integrability,"alIntegratorOneDim::SetFunctionvirtual void SetFunction(const IGenFunction &)=0set integration function; ROOT::Math::VirtualIntegratorOneDim::IntegralCauchyvirtual double IntegralCauchy(double a, double b, double c)=0evaluate Cauchy integral; ROOT::Math::VirtualIntegratorOneDim::IntegralLowvirtual double IntegralLow(double b)=0evaluate integral over the (-inf, b); ROOT::Math::VirtualIntegratorOneDim::SetOptionsvirtual void SetOptions(const ROOT::Math::IntegratorOneDimOptions &opt)set the options (should be re-implemented by derived classes -if more options than tolerance existDefinition VirtualIntegrator.h:140; ROOT::Math::VirtualIntegratorOneDim::Integralvirtual double Integral(double a, double b)=0evaluate integral; ROOT::Math::VirtualIntegratorOneDim::IntegralUpvirtual double IntegralUp(double a)=0evaluate integral over the (a, +inf); ROOT::Math::VirtualIntegrator::SetRelTolerancevirtual void SetRelTolerance(double)=0set the desired relative Error; ROOT::Math::VirtualIntegrator::SetAbsTolerancevirtual void SetAbsTolerance(double)=0set the desired absolute Error; ROOT::Math::VirtualIntegrator::Errorvirtual double Error() const =0return the estimate of the absolute Error of the last Integral calculation; ROOT::Math::VirtualIntegrator::NEvalvirtual int NEval() constreturn number of function evaluations in calculating the integral (if integrator do not implement thi...Definition VirtualIntegrator.h:84; ROOT::Math::VirtualIntegrator::Resultvirtual double Result() const =0return the Result of the last Integral calculation; ROOT::Math::VirtualIntegrator::Statusvirtual int Status() const =0return the Error Status of the last Integral calculation; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; ROOT::Math::IntegrationOneDim::kDEFAULT@ kDEFAULTdefault type specified i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:31742,integrat,integrator,31742,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['integrat'],['integrator']
Integrability,"alNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html:37244,integrat,integrator,37244,root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,2,['integrat'],['integrator']
Integrability,"alNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataHist& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:44254,integrat,integrator,44254,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['integrat'],['integrator']
Integrability,"alSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_double_.html:33525,integrat,integrator,33525,root/html532/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_double_double_double_.html,1,['integrat'],['integrator']
Integrability,"alVdouble getValV(const RooArgSet *set=nullptr) const overrideReturn current value, normalized by integrating over the observables in nset.Definition RooAbsPdf.cxx:319; RooAbsPdf::fitToImplvirtual std::unique_ptr< RooFitResult > fitToImpl(RooAbsData &data, const RooLinkedList &cmdList)Protected implementation of the likelihood fitting routine.Definition RooAbsPdf.cxx:1072; RooAbsPdf::generateEventvirtual void generateEvent(Int_t code)Interface for generation of an event using the algorithm corresponding to the specified code.Definition RooAbsPdf.cxx:1544; RooAbsPdf::createScanCdfRooFit::OwningPtr< RooAbsReal > createScanCdf(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Definition RooAbsPdf.cxx:2545; RooAbsPdf::setGeneratorConfigvoid setGeneratorConfig()Remove the specialized numeric MC generator configuration associated with this object.Definition RooAbsPdf.cxx:2675; RooAbsPdf::resetErrorCountersvirtual void resetErrorCounters(Int_t resetValue=10)Reset error counter to given value, limiting the number of future error messages for this pdf to 'res...Definition RooAbsPdf.cxx:586; RooAbsPdf::verboseEvalstatic int verboseEval()Return global level of verbosity for p.d.f. evaluations.Definition RooAbsPdf.cxx:2418; RooAbsPdf::createCdfRooFit::OwningPtr< RooAbsReal > createCdf(const RooArgSet &iset, const RooArgSet &nset=RooArgSet())Create a cumulative distribution function of this p.d.f in terms of the observables listed in iset.Definition RooAbsPdf.cxx:2468; RooAbsPdf::isActiveNormSetbool isActiveNormSet(RooArgSet const *normSet) constChecks if normSet is the currently active normalization set of this PDF, meaning is exactly the same ...Definition RooAbsPdf.h:299; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::binnedGenContextvirtual RooAbsGenContext * binnedGenContext(const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:144924,message,messages,144924,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['message'],['messages']
Integrability,"alX.; Definition at line 4334 of file TGCocoa.mm. ◆ IsA(). TClass * TGCocoa::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGQuartz.; Definition at line 476 of file TGCocoa.h. ◆ IsCmdThread(). Bool_t TGCocoa::IsCmdThread ; (; ); const. inlineoverridevirtual . Reimplemented from TVirtualX.; Definition at line 429 of file TGCocoa.h. ◆ IsCocoaDraw(). bool TGCocoa::IsCocoaDraw ; (; ); const. Definition at line 4419 of file TGCocoa.mm. ◆ IsDNDAware(). Bool_t TGCocoa::IsDNDAware ; (; Window_t ; win, . Atom_t * ; typelist . ). overridevirtual . Checks if the Window is DND aware, and knows any of the DND formats passed in argument. ; Reimplemented from TVirtualX.; Definition at line 3969 of file TGCocoa.mm. ◆ KeysymToKeycode(). Int_t TGCocoa::KeysymToKeycode ; (; UInt_t ; keysym). overridevirtual . Converts the ""keysym"" to the appropriate keycode. ; For example, keysym is a letter and keycode is the matching keyboard key (which is dependent on the current keyboard mapping). If the specified ""keysym"" is not defined for any keycode, returns zero. ; Reimplemented from TVirtualX.; Definition at line 2757 of file TGCocoa.mm. ◆ ListFonts(). char ** TGCocoa::ListFonts ; (; const char * ; fontname, . Int_t ; max, . Int_t & ; count . ). overridevirtual . Returns list of font names matching fontname regexp, like ""-*-times-*"". ; The pattern string can contain any characters, but each asterisk (*) is a wildcard for any number of characters, and each question mark (?) is a wildcard for a single character. If the pattern string is not in the Host Portable Character Encoding, the result is implementation dependent. Use of uppercase or lowercase does not matter. Each returned string is null-terminated.; Parameters. [in]fontnamespecifies the null-terminated pattern string that can contain wildcard characters ; [in]maxspecifies the maximum number of names to be returned ; [in]countreturns the actual number of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:95175,depend,dependent,95175,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['depend'],['dependent']
Integrability,"alX.h:339; TWinNTSystem.h; ThreadLocalStorage.h; Windows4Root.h; protoconst char * protoDefinition civetweb.c:17535; ROOT::Internal::TROOTAllocatorDefinition TROOT.cxx:304; ROOT::Internal::TROOTAllocator::TROOTAllocatorTROOTAllocator()Definition TROOT.cxx:341; ROOT::Internal::TROOTAllocator::fHolderchar fHolder[sizeof(TROOT)]Definition TROOT.cxx:338; ROOT::Internal::TROOTAllocator::fObjTROOT fObjDefinition TROOT.cxx:337; ROOT::Internal::TROOTAllocator::~TROOTAllocator~TROOTAllocator()Definition TROOT.cxx:344; ROOT::TVirtualRWMutexDefinition TVirtualRWMutex.h:39; TApplication::CreateApplicationstatic void CreateApplication()Static function used to create a default application environment.Definition TApplication.cxx:1975; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBrowser::SetRefreshFlagvoid SetRefreshFlag(Bool_t flag)Definition TBrowser.h:100; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTableThis class registers for all classes their name, id and dictionary function in a hash table.Definition TClassTable.h:37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::AddClassstatic void AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::RemoveClassstatic void RemoveClass(TClass *cl)static: Remove a class from the list and map of classesDefinition TClass.cxx:585; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:130503,interface,interface,130503,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['interface'],['interface']
Integrability,"alXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const Int_t *kind)=0; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131; TVirtualFFT::GetCurrentTransformstatic TVirtualFFT * GetCurrentTransform()static: return current fgFFTDefinition TVirtualFFT.cxx:348; TVirtualFFT::GetNdimvirtual Int_t GetNdim() const =0; TVirtualFFT::SineCosinestatic TVirtualFFT * SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option)Returns a po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14951,interface,interface,14951,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['interface'],['interface']
Integrability,alXProxy.cxx:68; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TObject.h; TQObject.h; TApplicationImpABC describing GUI independent application implementation protocol.Definition TApplicationImp.h:29; TApplicationImp::Showvirtual void Show()Definition TApplicationImp.h:40; TApplicationImp::ApplicationNamevirtual const char * ApplicationName() constDefinition TApplicationImp.h:39; TApplicationImp::Raisevirtual void Raise()Definition TApplicationImp.h:46; TApplicationImp::Hidevirtual void Hide()Definition TApplicationImp.h:41; TApplicationImp::Initvirtual void Init()Definition TApplicationImp.h:44; TApplicationImp::Iconifyvirtual void Iconify()Definition TApplicationImp.h:42; TApplicationImp::Lowervirtual void Lower()Definition TApplicationImp.h:47; TApplicationImp::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplicationImp.h:43; TApplicationImp::Openvirtual void Open()Definition TApplicationImp.h:45; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TApplication::ExitOnExceptionEExitOnException ExitOnExceptio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:9260,protocol,protocol,9260,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['protocol'],['protocol']
Integrability,"alculator class ;  ; RooAbsPdf * GetPosteriorPdf () const;  return posterior pdf (object is managed by the user) ;  ; RooPlot * GetPosteriorPlot (bool norm=false, double precision=0.01) const;  get the plot with option to get it normalized ;  ; TClass * IsA () const override;  ; void SetBrfPrecision (double precision);  set the precision of the Root Finder ;  ; virtual void SetConditionalObservables (const RooArgSet &set);  set the conditional observables which will be used when creating the NLL so the pdf's will not be normalized on the conditional observables when computing the NLL ;  ; void SetConfidenceLevel (double cl) override;  set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval) ;  ; void SetData (RooAbsData &data) override;  Set the DataSet ( add to the workspace if not already there ?) ;  ; virtual void SetGlobalObservables (const RooArgSet &set);  set the global observables which will be used when creating the NLL so the constraint pdf's will be normalized correctly on the global observables when computing the NLL ;  ; void SetIntegrationType (const char *type);  set the integration type (possible type are) : ;  ; void SetLeftSideTailFraction (double leftSideFraction);  set the fraction of probability content on the left tail Central limits use 0.5 (default case) for upper limits it is 0 and 1 for lower limit For shortest intervals a negative value (i.e. ;  ; void SetModel (const ModelConfig &model) override;  set the model via the ModelConfig ;  ; virtual void SetNuisanceParameters (const RooArgSet &set);  specify the nuisance parameters (eg. the rest of the parameters) ;  ; virtual void SetNumIters (Int_t numIters);  set the number of iterations when running a MC integration algorithm If not set use default algorithmic values In case of ToyMC sampling of the nuisance the value is 100 In case of using the GSL MCintegrations types the default value is defined in ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls() ;  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:5390,integrat,integration,5390,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['integrat'],['integration']
Integrability,"alid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; set<Int_t>*fHighlightSet; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveDigitSetGL(); Constructor. Bool_t SetupColor(const TEveDigitSet::DigitBase_t& q) const; Set color for rendering of the specified digit. void DrawFrameIfNeeded(TGLRnrCtx& rnrCtx) const; Make a decision if the frame should be drawn.; This depends on the render state (selection / highligt) and; on values of members fSelectViaFrame and fHighlightFrame. void SetBBox(); Set bounding box. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the quad-set in highlight mode.; Incoming lvl is ignored -- physical shape always calls it with -1. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Processes secondary selection from TGLViewer.; Calls DigitSelected(Int_t) in the model object with index of; selected point as the argument. TEveDigitSetGL(const TEveDigitSetGL& ). TEveDigitSetGL& operator=(const TEveDigitSetGL& ). virtual ~TEveDigitSetGL(); {}. Bool_t SupportsSecondarySelect() const; { return kTRUE; }. Bool_t AlwaysSecondarySelect() const; { return ((TEveDigitSet*)fExternalObj)->GetAlwaysSecSelect(); }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:43; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveDigitSetGL.html:4847,depend,depends,4847,root/html604/TEveDigitSetGL.html,https://root.cern,https://root.cern/root/html604/TEveDigitSetGL.html,1,['depend'],['depends']
Integrability,"alid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; set<Int_t>*fHighlightSet; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveDigitSetGL(); Constructor. Bool_t SetupColor(const TEveDigitSet::DigitBase_t& q) const; Set color for rendering of the specified digit. void DrawFrameIfNeeded(TGLRnrCtx& rnrCtx) const; Make a decision if the frame should be drawn.; This depends on the render state (selection / highligt) and; on values of members fSelectViaFrame and fHighlightFrame. void SetBBox(); Set bounding box. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the quad-set in highlight mode.; Incoming lvl is ignored -- physical shape always calls it with -1. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Processes secondary selection from TGLViewer.; Calls DigitSelected(Int_t) in the model object with index of; selected point as the argument. TEveDigitSetGL(const TEveDigitSetGL& ). TEveDigitSetGL& operator=(const TEveDigitSetGL& ). virtual ~TEveDigitSetGL(); {}. Bool_t SupportsSecondarySelect() const; { return kTRUE; }. Bool_t AlwaysSecondarySelect() const; { return ((TEveDigitSet*)fExternalObj)->GetAlwaysSecSelect(); }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveDigitSetGL.html:4847,depend,depends,4847,root/html602/TEveDigitSetGL.html,https://root.cern,https://root.cern/root/html602/TEveDigitSetGL.html,1,['depend'],['depends']
Integrability,"alidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output. Class Charts. Inheritance Chart:. TObject. ←; TSQLStatement. ←. TMySQLStatement. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:19375,message,message,19375,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,4,['message'],"['message', 'messages']"
Integrability,"alidReal ; (; double ; , . bool ; printError . ); const. inlineoverrideprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented from RooAbsReal.; Definition at line 83 of file RooFormulaVar.h. ◆ nParameters(). size_t RooFormulaVar::nParameters ; (; ); const. inline . Return the number of parameters. ; Definition at line 53 of file RooFormulaVar.h. ◆ ok(). bool RooFormulaVar::ok ; (; ); const. Definition at line 149 of file RooFormulaVar.cxx. ◆ plotSamplingHint(). std::list< double > * RooFormulaVar::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 256 of file RooFormulaVar.cxx. ◆ printMetaArgs(). void RooFormulaVar::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Add formula expression as meta argument in printing interface. ; Reimplemented from RooAbsArg.; Definition at line 201 of file RooFormulaVar.cxx. ◆ printMultiline(). void RooFormulaVar::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Print info about this object to the specified stream. ; Reimplemented from RooAbsReal.; Definition at line 186 of file RooFormulaVar.cxx. ◆ readFromStream(). bool RooFormulaVar::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from given stream. ; Reimplemented from RooAbsReal.; Definition at line 212 of file RooFormulaVar.cxx. ◆ redirectServersHook(). bool RooFormulaVar::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Propagate server change information to embedded RooFormula object. ; Reimplemented f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:68636,interface,interface,68636,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['interface'],['interface']
Integrability,"alisation value (aggIdentity)"");; 2918 return Aggregate(std::move(aggregator), std::move(merger), columnName, U());; 2919 }; 2920 ; 2921 // clang-format off; 2922 ////////////////////////////////////////////////////////////////////////////; 2923 /// \brief Book execution of a custom action using a user-defined helper object.; 2924 /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; 2925 /// \tparam OtherColumns A list of the types of the other columns used by this action; 2926 /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; 2927 /// \param[in] helper The Action Helper to be scheduled.; 2928 /// \param[in] columns The names of the columns on which the helper acts.; 2929 /// \return the result of the helper wrapped in a RResultPtr.; 2930 ///; 2931 /// This method books a custom action for execution. The behavior of the action is completely dependent on the; 2932 /// Helper object provided by the caller. The required interface for the helper is described below (more; 2933 /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; 2934 ///; 2935 /// ### Mandatory interface; 2936 ///; 2937 /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; 2938 /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; 2939 /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; 2940 /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; 2941 /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; 2942 /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; 2943 /// * `void Initiali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:165041,depend,dependent,165041,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['depend'],['dependent']
Integrability,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:2656,integrat,integration,2656,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['integrat'],['integration']
Integrability,"alization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooKeysPdf.html:40800,integrat,integrator,40800,root/html532/RooKeysPdf.html,https://root.cern,https://root.cern/root/html532/RooKeysPdf.html,3,['integrat'],['integrator']
Integrability,"alization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:41213,integrat,integrator,41213,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,1,['integrat'],['integrator']
Integrability,"all TH1::ResetStats. See TH1::GetStats. ; Definition at line 7607 of file TH1.cxx. ◆ GetStdDevError(). Double_t TH1::GetStdDevError ; (; Int_t ; axis = 1); const. virtual . Return error of standard deviation estimation for Normal distribution. ; Note that the mean value/StdDev is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.; Value returned is standard deviation of sample standard deviation. Note that it is an approximated value which is valid only in the case that the original data distribution is Normal. The correct one would require the 4-th momentum value, which cannot be accurately estimated from a histogram since the x-information for all entries is not kept.; IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned value is the (unbinned) one calculated at fill time. If a range has been set, however, the value is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis::SetRange(0, 0) to unset the range. To ensure that the returned value (and all other statistics) is always that of the binned data stored in the histogram, call TH1::ResetStats. See TH1::GetStats. ; Definition at line 7655 of file TH1.cxx. ◆ GetSumOfWeights(). Double_t TH1::GetSumOfWeights ; (; ); const. virtual . Return the sum of weights excluding under/overflows. ; Definition at line 7917 of file TH1.cxx. ◆ GetSumw2() [1/2]. virtual TArrayD * TH1::GetSumw2 ; (; ). inlinevirtual . Definition at line 313 of file TH1.h. ◆ GetSumw2() [2/2]. virtual const TArrayD * TH1::GetSumw2 ; (; ); const. inlinevirtual . Definition at line 314 of file TH1.h. ◆ GetSumw2N(). virtual Int_t TH1::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:177219,depend,depends,177219,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['depend'],['depends']
Integrability,"all cases, though, this routine is called by an idle handler. ; Definition at line 544 of file TGHtml.cxx. ◆ RedrawArea(). void TGHtml::RedrawArea ; (; int ; left, . int ; top, . int ; right, . int ; bottom . ). protected . If any part of the screen needs to be redrawn, then call this routine with the values of a box (in window coordinates) that needs to be redrawn. ; This routine will schedule an idle handler to do the redraw.; The box coordinates are relative to the clipping window (fCanvas). ; Definition at line 789 of file TGHtml.cxx. ◆ RedrawBlock(). void TGHtml::RedrawBlock ; (; TGHtmlBlock * ; p). protected . Redraw the TGHtmlBlock given. ; Definition at line 866 of file TGHtml.cxx. ◆ RedrawEverything(). void TGHtml::RedrawEverything ; (; ). protected . Call this routine to force the entire widget to be redrawn. ; Definition at line 877 of file TGHtml.cxx. ◆ RedrawText(). void TGHtml::RedrawText ; (; int ; y). protected . Call this routine to cause all of the rendered HTML at the virtual canvas coordinate of Y and beyond to be redrawn. ; Definition at line 887 of file TGHtml.cxx. ◆ ResetBlocks(). void TGHtml::ResetBlocks ; (; ). inline . Definition at line 978 of file TGHtml.h. ◆ ResetLayoutContext(). void TGHtml::ResetLayoutContext ; (; ). protected . Reset the main layout context in the main widget. ; This happens before we redo the layout, or just before deleting the widget. ; Definition at line 533 of file TGHtml.cxx. ◆ ResolveUri(). char * TGHtml::ResolveUri ; (; const char * ; zUri). virtual . This function resolves the specified URI and returns the result in a newly allocated string. ; The resolver algorithm specified in section 5.2 of RFC 2396 is used. ; Definition at line 284 of file TGHtmlUri.cxx. ◆ SaveFileAs(). void TGHtml::SaveFileAs ; (; ). Save file. ; Ask user for a file name via the file dialog. The pre-filled file name will be extracted from the current URI, if any ; Definition at line 1348 of file TGHtml.cxx. ◆ SavePrimitive(). void TGHtml:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:83409,rout,routine,83409,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['rout'],['routine']
Integrability,"allArg &arg);  Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data. ;  ; void ProvideQueueEntry (unsigned connid, EQueueEntryKind kind, std::string &&arg);  Provide data to user callback User callback must be executed in the window thread. ;  ; std::shared_ptr< WebConn > RemoveConnection (unsigned wsid);  Remove connection with given websocket id. ;  ; void RemoveEmbedWindow (unsigned connid, int channel);  Remove RWebWindow associated with the channelfEmbed. ;  ; void RemoveKey (const std::string &key);  Removes all connections with the key. ;  ; void RemoveMasterConnection (unsigned connid=0);  Remove master connection - if any. ;  ; void SubmitData (unsigned connid, bool txt, std::string &&data, int chid=1);  Internal method to send data. ;  . Static Private Member Functions; static std::string HMAC (const std::string &key, const std::string &sessionKey, const char *msg, int msglen);  Calculate HMAC checksum for provided key and message Key combained from connection key and session key. ;  ; static void SetStartDialogFunc (std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>);  Configure func which has to be used for starting dialog. ;  . Private Attributes; std::thread::id fCallbacksThrdId;  ! thread id where callbacks should be invoked ;  ; bool fCallbacksThrdIdSet {false};  ! flag indicating that thread id is assigned ;  ; std::shared_ptr< void > fClearOnClose;  ! entry which is cleared when last connection is closed ;  ; std::string fClientVersion;  ! configured client version, used as prefix in scripts URL ;  ; ConnectionsList_t fConn;  ! list of all accepted connections ;  ; WebWindowConnectCallback_t fConnCallback;  ! callback for connect event ;  ; unsigned fConnCnt {0};  ! counter of new connections to assign ids ;  ; unsigned fConnLimit {1};  ! number of allowed active connections ;  ; std::mutex f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:17660,message,message,17660,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['message'],['message']
Integrability,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-12-01 01:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodBrowsable.html:10619,depend,depending,10619,root/html528/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html,2,['depend'],['depending']
Integrability,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMethodBrowsable.html:10688,depend,depending,10688,root/html530/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html530/TMethodBrowsable.html,2,['depend'],['depending']
Integrability,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08-16 11:52:09Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethodBrowsable.html:10688,depend,depending,10688,root/html532/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html532/TMethodBrowsable.html,2,['depend'],['depending']
Integrability,"alog*fDialogowner dialog; TGTextEntry*fFileNamefile to save to; Bool_tfFullText0 - when grep was called; TGTextButton*fGrepButtongrep button; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23399,message,messages,23399,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,3,['message'],['messages']
Integrability,"alse) constInterface function to create a generator context from a p.d.f.Definition RooAbsPdf.cxx:1127; RooAbsPdf::getLogProbabilitiesvoid getLogProbabilities(std::span< const double > pdfValues, double *output) constDefinition RooAbsPdf.cxx:671; RooAbsPdf::_normRangeOverridestatic TString _normRangeOverrideDefinition RooAbsPdf.h:343; RooAbsPdf::_verboseEvalstatic Int_t _verboseEvalDefinition RooAbsPdf.h:314; RooAbsPdf::extendedTermdouble extendedTerm(double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) constDefinition RooAbsPdf.cxx:730; RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsPdf::getLogValvirtual double getLogVal(const RooArgSet *set=nullptr) constReturn the log of the current value with given normalization An error message is printed if the argum...Definition RooAbsPdf.cxx:620; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::maxValvirtual double maxVal(Int_t code) constReturn maximum value for set of observables identified by code assigned in getMaxVal.Definition RooAbsReal.cxx:3397; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooArgListRooArgList is a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:33565,integrat,integrated,33565,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['integrat'],['integrated']
Integrability,"alse) constInterface function to create a generator context from a p.d.f.Definition RooAbsPdf.cxx:1127; RooAbsPdf::getLogProbabilitiesvoid getLogProbabilities(std::span< const double > pdfValues, double *output) constDefinition RooAbsPdf.cxx:671; RooAbsPdf::_normRangeOverridestatic TString _normRangeOverrideDefinition RooAbsPdf.h:343; RooAbsPdf::_verboseEvalstatic Int_t _verboseEvalDefinition RooAbsPdf.h:314; RooAbsPdf::extendedTermdouble extendedTerm(double sumEntries, double expected, double sumEntriesW2=0.0, bool doOffset=false) constDefinition RooAbsPdf.cxx:730; RooAbsPdf::getGeneratorvirtual Int_t getGenerator(const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) constLoad generatedVars with the subset of directVars that we can generate events for, and return a code t...Definition RooAbsPdf.cxx:1522; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsPdf::getLogValvirtual double getLogVal(const RooArgSet *set=nullptr) constReturn the log of the current value with given normalization An error message is printed if the argum...Definition RooAbsPdf.cxx:620; RooAbsRealLValue::hasRangebool hasRange(const char *name) const overrideCheck if variable has a binning with given name.Definition RooAbsRealLValue.h:97; RooAbsRealLValue::getRangestd::pair< double, double > getRange(const char *name=nullptr) constGet low and high bound of the variable.Definition RooAbsRealLValue.h:88; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::fillDataHistRooDataHist * fillDataHist(RooDataHist *hist, const RooArgSet *nset, double scaleFactor, bool correctForBinVolume=false, bool showProgress=false) constFill a RooDataHist with values sampled from this function at the bin centers.Definition RooAbsReal.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:154920,integrat,integrated,154920,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['integrat'],['integrated']
Integrability,"alse);  Write the GraphViz representation of the expression tree headed by this RooAbsArg object to the given ostream. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const =0;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; virtual bool operator== (const RooAbsArg &other) const =0;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:12292,depend,dependents,12292,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['depend'],['dependents']
Integrability,"aluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooSetProxy _anaList;  Set of observables over which is integrated/summed analytically. ;  ; bool _cacheNum = false;  Cache integral if numeric. ;  ; RooSetProxy _facList;  Set of observables on which function does not depends, which are integrated nevertheless. ;  ; std::unique_ptr< RooArgSet > _funcNormSet;  Optional normalization set passed to function. ;  ; RooRealProxy _function;  Function being integrated. ;  ; RooNumIntConfig * _iconfig = nullptr;  ; RooSetProxy _intList;  Set of continuous observables over which is integrated numerically. ;  ; IntOperMode _intOperMode = Hybrid;  integration operation mode ;  ; RooSetProxy _jacList;  Set of lvalue observables over which is analytically integration that have a non-unit Jacobian. ;  ; Int_t _mode = 0;  ; std::unique_ptr< RooAbsFunc > _numIntegrand;  ! ;  ; std::unique_ptr< RooAbsIntegrator > _numIntEngine;  ! ;  ; std::unique_ptr< RooArgSet > _params;  ! cache for set of parameters ;  ; TNamed * _rangeName = nullptr;  ; bool _respectCompSelect = true;  ; bool _restartNumIntEngine = false;  ! ;  ; RooArgSet _saveInt;  ! ;  ; RooArgSet _saveSum;  ! ;  ; RooListProxy _sumCat;  ! ;  ; RooSetProxy _sumList;  Set of discrete observable over which is summed numerically. ;  ; bool _valid = false;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _la",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:57623,integrat,integrated,57623,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['integrat'],['integrated']
Integrability,"aluate product of PDFs in batch mode. ;  ; double evaluate () const override;  Calculate current value of object. ;  ; void factorizeProduct (const RooArgSet &normSet, const RooArgSet &intSet, RooLinkedList &termList, RooLinkedList &normList, RooLinkedList &impDepList, RooLinkedList &crossDepList, RooLinkedList &intList) const;  Factorize product in irreducible terms for given choice of integration/normalization. ;  ; std::unique_ptr< RooArgSet > fillNormSetForServer (RooArgSet const &normSet, RooAbsArg const &server) const;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Return generator context optimized for generating events from product p.d.f.s. ;  ; CacheElem * getCacheElem (RooArgSet const *nset) const;  The cache manager. ;  ; void getParametersHook (const RooArgSet *, RooArgSet *, bool stripDisconnected) const override;  ; Int_t getPartIntList (const RooArgSet *nset, const RooArgSet *iset, const char *isetRangeName=nullptr) const;  Return list of (partial) integrals of product terms for integration of p.d.f over observables iset while normalization over observables nset. ;  ; void groupProductTerms (std::list< std::vector< RooArgSet * > > &groupedTerms, RooArgSet &outerIntDeps, const RooLinkedList &terms, const RooLinkedList &norms, const RooLinkedList &imps, const RooLinkedList &ints, const RooLinkedList &cross) const;  Group product into terms that can be calculated independently. ;  ; void initializeFromCmdArgList (const RooArgSet &fullPdfSet, const RooLinkedList &l);  Initialize RooProdPdf configuration from given list of RooCmdArg configuration arguments and set of 'regular' p.d.f.s in product. ;  ; std::unique_ptr< RooAbsReal > makeCondPdfRatioCorr (RooAbsReal &term, const RooArgSet &termNset, const RooArgSet &termImpSet, const char *normRange, const char *refRange) const;  For single normalization ranges. ;  ; std::string makeRGPPName (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:63948,integrat,integration,63948,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['integrat'],['integration']
Integrability,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(GSLFuncPointer f, void * p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(GSL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html:10840,integrat,integration,10840,root/html526/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html,1,['integrat'],['integration']
Integrability,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:11134,integrat,integration,11134,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,6,['integrat'],['integration']
Integrability,"aluate<T>::EvalPdf(BaseFCN::ModelFunction(), BaseFCN::Data(), x, i, g, h, BaseFCN::IsAGradFCN(), fullHessian);; 124 }; 125 ; 126 // need to be virtual to be instantiated; 127 virtual void Gradient(const double *x, double *g) const {; 128 // evaluate the chi2 gradient; 129 FitUtil::Evaluate<typename BaseFCN::T>::EvalLogLGradient(BaseFCN::ModelFunction(), BaseFCN::Data(), x, g,; 130 fNEffPoints, fExecutionPolicy);; 131 }; 132 ; 133 /// get type of fit method function; 134 virtual typename BaseObjFunction::Type_t Type() const { return BaseObjFunction::kLogLikelihood; }; 135 ; 136 ; 137 // Use sum of the weight squared in evaluating the likelihood; 138 // (this is needed for calculating the errors); 139 void UseSumOfWeightSquare(bool on = true) {; 140 if (fWeight == 0) return; // do nothing if it was not weighted; 141 if (on) fWeight = 2;; 142 else fWeight = 1;; 143 }; 144 ; 145 ; 146 ; 147protected:; 148 ; 149 ; 150private:; 151 ; 152 /**; 153 Evaluation of the function (required by interface); 154 */; 155 virtual double DoEval (const double * x) const {; 156 this->UpdateNCalls();; 157 return FitUtil::Evaluate<T>::EvalLogL(BaseFCN::ModelFunction(), BaseFCN::Data(), x, fWeight, fIsExtended, fNEffPoints, fExecutionPolicy);; 158 }; 159 ; 160 // for derivatives; 161 virtual double DoDerivative(const double * x, unsigned int icoord ) const {; 162 Gradient(x, &fGrad[0]);; 163 return fGrad[icoord];; 164 }; 165 ; 166 ; 167 //data member; 168 bool fIsExtended; ///< flag for indicating if likelihood is extended; 169 int fWeight; ///< flag to indicate if needs to evaluate using weight or weight squared (default weight = 0); 170 ; 171 ; 172 mutable unsigned int fNEffPoints; ///< number of effective points used in the fit; 173 ; 174 mutable std::vector<double> fGrad; ///< for derivatives; 175 ; 176 ::ROOT::EExecutionPolicy fExecutionPolicy; ///< Execution policy; 177};; 178 // define useful typedef's; 179 // using LogLikelihoodFunction_v = LogLikelihoodFCN<ROOT::Math::IMultiGenFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/LogLikelihoodFCN_8h_source.html:5231,interface,interface,5231,doc/master/LogLikelihoodFCN_8h_source.html,https://root.cern,https://root.cern/doc/master/LogLikelihoodFCN_8h_source.html,1,['interface'],['interface']
Integrability,"alue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf316_llratioplotDefinition rf316_llratioplot.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf316_llratioplot.C. tutorialsroofitrf316_llratioplot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8C.html:6817,integrat,integrates,6817,doc/master/rf316__llratioplot_8C.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html,1,['integrat'],['integrates']
Integrability,"alue is 0 (miter join). /*; ; */. To change the line join behaviour just do:; TPostScript::SetLineJoin(2); // Set the PS line join to bevel. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; else = solid. See TStyle::SetLineStyleString for style definition. void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set the current color. void SetColor(Float_t r, Float_t g, Float_t b); Set directly current color (don't go via TColor). void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void Text(Double_t x, Double_t y, const wchar_t* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. void TextNDC(Double_t u, Double_t v, const wchar_t* string); Write a string of characters in NDC. Int_t UtoPS(Double_t u); Convert U from NDC coordinate to PostScript. Int_t VtoPS(Double_t v); Convert V from NDC coordinate to PostScript. Int_t XtoPS(Double_t x); Convert X from world coordinate to PostScript. Int_t YtoPS(Double_t y); Convert Y from world coordinate to PostScript. void Zone(); Initialize the PostScript page in zones. Int_t CMtoPS(Double_t u); {return Int_t(0.5 + 72*u/2.54);}. void SetLineScale(Float_t scale = 3); {fLineScale = scale;}. » Author: O.Couet 16/07/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-03-20 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPostScript.html:30193,rout,routine,30193,root/html534/TPostScript.html,https://root.cern,https://root.cern/root/html534/TPostScript.html,1,['rout'],['routine']
Integrability,"alue is 0 (miter join). /*; ; */. To change the line join behaviour just do:; TPostScript::SetLineJoin(2); // Set the PS line join to bevel. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; else = solid. See TStyle::SetLineStyleString for style definition. void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set the current color. void SetColor(Float_t r, Float_t g, Float_t b); Set directly current color (don't go via TColor). void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void Text(Double_t x, Double_t y, const wchar_t* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. void TextNDC(Double_t u, Double_t v, const wchar_t* string); Write a string of characters in NDC. Int_t UtoPS(Double_t u); Convert U from NDC coordinate to PostScript. Int_t VtoPS(Double_t v); Convert V from NDC coordinate to PostScript. Int_t XtoPS(Double_t x); Convert X from world coordinate to PostScript. Int_t YtoPS(Double_t y); Convert Y from world coordinate to PostScript. void Zone(); Initialize the PostScript page in zones. TPostScript(). Int_t CMtoPS(Double_t u); {return Int_t(0.5 + 72*u/2.54);}. void SetLineScale(Float_t scale = 3); {fLineScale = scale;}. » Author: O.Couet 16/07/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPostScript.html:30686,rout,routine,30686,root/html604/TPostScript.html,https://root.cern,https://root.cern/root/html604/TPostScript.html,1,['rout'],['routine']
Integrability,"alue is 0 (miter join). /*; ; */. To change the line join behaviour just do:; TPostScript::SetLineJoin(2); // Set the PS line join to bevel. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; else = solid. See TStyle::SetLineStyleString for style definition. void SetLineWidth(Width_t linewidth = 1); Change the line width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set the current color. void SetColor(Float_t r, Float_t g, Float_t b); Set directly current color (don't go via TColor). void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void Text(Double_t x, Double_t y, const wchar_t* string); Write a string of characters. This routine writes the string chars into a PostScript file; at position xx,yy in world coordinates. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. void TextNDC(Double_t u, Double_t v, const wchar_t* string); Write a string of characters in NDC. Int_t UtoPS(Double_t u); Convert U from NDC coordinate to PostScript. Int_t VtoPS(Double_t v); Convert V from NDC coordinate to PostScript. Int_t XtoPS(Double_t x); Convert X from world coordinate to PostScript. Int_t YtoPS(Double_t y); Convert Y from world coordinate to PostScript. void Zone(); Initialize the PostScript page in zones. TPostScript(). Int_t CMtoPS(Double_t u); {return Int_t(0.5 + 72*u/2.54);}. void SetLineScale(Float_t scale = 3); {fLineScale = scale;}. » Author: O.Couet 16/07/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPostScript.html:30685,rout,routine,30685,root/html602/TPostScript.html,https://root.cern,https://root.cern/root/html602/TPostScript.html,1,['rout'],['routine']
Integrability,"alue is precisely 1. It is also possible to choose a different normalization for multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can construct a partial cdf c(x,y) that only when integrated itself over z results in a maximum value of 1. To construct such a cdf pass z as argument to the optional nset argument ; Definition at line 2468 of file RooAbsPdf.cxx. ◆ createCdf() [2/2]. RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over; The following named arguments are accepted . Type of CmdArg Effect on CDF . SupNormSet(const RooArgSet&) Observables over which should be normalized in addition to the integration observables . ScanNumCdf() Apply scanning technique if cdf integral involves numeric integration [ default ] . ScanAllCdf() Always apply scanning technique . ScanNoCdf() Never apply scanning technique . ScanParameters(Int_t nbins, Int_t intOrder) Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf . PyROOT; The RooAbsPdf::createCdf() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2490 of file RooAbsPdf.cxx. ◆ createExpectedEventsFunc(). std::unique_ptr< RooAbsReal > RooAbsPdf::createExpectedEventsFunc ; (; const RooArgSet * ; nset); const. virtual . Returns an object that represents the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:85363,integrat,integrates,85363,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,['integrat'],['integrates']
Integrability,"alue of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:3053,message,message,3053,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['message'],['message']
Integrability,"alue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.; There are two main groups of buttons: command buttons with a text or graphics inside that indicate the action to be accomplished and option buttons well known as radio and check buttons that select or change properties. The first group is presented in ROOT by TGPictureButton and TGTextButton classes. They yield an action as soon as they are clicked. It can be opening/closing a dialog box or invoking a specific function in an application. Remember the Draw button from the example. The radio and check buttons from the second group are used to select an option. There is a visual difference between these two groups: the text buttons appear “pressed in” only while they are clicked, while the radio and check buttons change their appearance when they are selected and keep that appearance afterwards.; A text button is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175863,interface,interfaces,1175863,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interfaces']
Integrability,"alue. ◆ setLabel() [1/4]. bool RooSuperCategory::setLabel ; (; const char * ; label, . bool ; printError = true . ). overridevirtual . Set the value of the super category by specifying the state name. ; This looks up the corresponding index number, and calls setIndex(). ; Implements RooAbsCategoryLValue.; Definition at line 119 of file RooSuperCategory.cxx. ◆ setLabel() [2/4]. virtual bool RooAbsCategoryLValue::setLabel ; (; const char * ; label, . bool ; printError = true . ). virtual . Change category state by specifying a state name. ; If printError is set, a message will be printed if the specified state name does not represent a valid state. Returnsbool to signal an error. ; Implements RooAbsCategoryLValue. ◆ setLabel() [3/4]. bool RooAbsCategoryLValue::setLabel ; (; const std::pair< std::string, value_type > & ; nameIdxPair, . bool ; printError = true . ). inline . Change category state to the state name of another category. ; If printError is set, a message will be printed if the specified state name does not represent a valid state. NoteThe state index of the other category is ignored. ; Returnsbool to signal an error. ; Definition at line 69 of file RooAbsCategoryLValue.h. ◆ setLabel() [4/4]. bool RooAbsCategoryLValue::setLabel ; (; const std::string & ; label, . bool ; printError = true . ). inline . Set the value of the super category by specifying the state name. ; This looks up the corresponding index number, and calls setIndex(). ; Definition at line 60 of file RooAbsCategoryLValue.h. ◆ Streamer(). void RooSuperCategory::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCategoryLValue. ◆ StreamerNVirtual(). void RooSuperCategory::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 66 of file RooSuperCategory.h. Member Data Documentation. ◆ _multiCat. RooTemplateProxy<RooMultiCategory> RooSuperCategory::_multiCat. private . Definition at line 64 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSuperCategory.html:54058,message,message,54058,doc/master/classRooSuperCategory.html,https://root.cern,https://root.cern/doc/master/classRooSuperCategory.html,1,['message'],['message']
Integrability,"alue; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:44923,integrat,integration,44923,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['integrat'],['integration']
Integrability,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindOffset(); Default constructor. RooUnblindOffset(const char* name, const char* title, const char* blin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:37287,integrat,integrator,37287,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,2,['integrat'],['integrator']
Integrability,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooUnblindUniform(); Default constructor. RooUnblindUniform(const char* name, const char* title, const char* bl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:36616,integrat,integrator,36616,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,2,['integrat'],['integrator']
Integrability,"alue; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction1Ref<VO,VI> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html:36954,integrat,integrator,36954,root/html602/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html,2,['integrat'],['integrator']
Integrability,"alues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep);  Function that is called at the end of redirectServers(). ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:20236,depend,depend,20236,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,7,['depend'],['depend']
Integrability,"alues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxyolist; RooListProxyplist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTFnBinding.html:32674,integrat,integrator,32674,root/html532/RooTFnBinding.html,https://root.cern,https://root.cern/root/html532/RooTFnBinding.html,1,['integrat'],['integrator']
Integrability,"alues of the domain ;  . #include <TUnuranMultiContDist.h>. Inheritance diagram for TUnuranMultiContDist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TUnuranMultiContDist() [1/3]. TUnuranMultiContDist::TUnuranMultiContDist ; (; TF1 * ; func = nullptr, . unsigned int ; dim = 0, . bool ; isLogPdf = false . ). Constructor from a TF1 object representing the Probability density function. ; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm, using numerical derivation. If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim(). This works only for 2D and 3D (for TF2 and TF3 objects). ; Definition at line 29 of file TUnuranMultiContDist.cxx. ◆ TUnuranMultiContDist() [2/3]. TUnuranMultiContDist::TUnuranMultiContDist ; (; const ROOT::Math::IMultiGenFunction & ; pdf, . bool ; isLogPdf = false . ). Constructor as before but from a generic function object interface for multi-dim functions. ; Definition at line 20 of file TUnuranMultiContDist.cxx. ◆ ~TUnuranMultiContDist(). TUnuranMultiContDist::~TUnuranMultiContDist ; (; ). override . Destructor. ; Definition at line 69 of file TUnuranMultiContDist.cxx. ◆ TUnuranMultiContDist() [3/3]. TUnuranMultiContDist::TUnuranMultiContDist ; (; const TUnuranMultiContDist & ; rhs). Copy constructor. ; Definition at line 43 of file TUnuranMultiContDist.cxx. Member Function Documentation. ◆ Class(). static TClass * TUnuranMultiContDist::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUnuranMultiContDist::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUnuranMultiContDist::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 176 of file TUnuranMultiContDist.h. ◆ Clone(). TUnuranMultiContDist * TUnuranMultiContDist::Clone ; (; ); const. inlineover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranMultiContDist.html:5328,interface,interface,5328,doc/master/classTUnuranMultiContDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranMultiContDist.html,1,['interface'],['interface']
Integrability,"alues used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointers). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). tem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html:7077,integrat,integration,7077,root/html604/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html,1,['integrat'],['integration']
Integrability,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:56252,integrat,integration,56252,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,2,['integrat'],['integration']
Integrability,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:50949,integrat,integration,50949,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,4,['integrat'],['integration']
Integrability,"alues.; It's posiible to write image into an animated GIF file by specifying file; name as ""myfile.gif+"" of ""myfile.gif+NN"", where NN is delay of displaying; subimages during animation in 10ms seconds units.; If NN is ommitted the delay between subimages is zero.; For repeated animation the last subimage must be specified as; ""myfile.gif++NN"", where NN is number of cycles. If NN is ommitted the; animation will be infinite. The following macro creates animated gif from jpeg images with names; imageNN.jpg, where 1<= NN <= 10; {; TImage *img = 0;; gSystem->Unlink(""anim.gif""); // delete existing file. for (int i = 1; i <= 10; i++) {; delete img; // delete previous image. // Read image data. Image can be in any format, e.g. png, gif, etc.; img = TImage::Open(Form(""image%d.jpg"", i));. if (i < 10) {; img->WriteImage(""anim.gif+"");; } else { // the last image written. ""++"" stands for infinit animation.; img->WriteImage(""anim.gif++"");; }; }; }. TImage::EImageFileTypes GetFileType(const char* ext); Return file type depending on specified extension.; Protected method. void MapFileTypes(TImage::EImageFileTypes& type, UInt_t& astype, Bool_t toas = kTRUE); Map file type to/from AfterImage types.; Protected method. void MapQuality(TAttImage::EImageQuality& quality, UInt_t& asquality, Bool_t toas = kTRUE); Map quality to/from AfterImage quality.; Protected method. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0); Deletes the old image and creates a new image depending on the values; of imageData. The size of the image is width X height.; The color of each pixel depends on the imageData of the corresponding; pixel. The palette is used to convert an image value into its color.; If palette is not defined (palette = 0) a default palette is used.; Any previously defined zooming is reset. void SetImage(const TArrayD &imageData, UInt_t width, TImagePalette *palette); Delete the old image and creates a new image depending on the values; of ima",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:22507,depend,depending,22507,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,1,['depend'],['depending']
Integrability,"alues.; It's posiible to write image into an animated GIF file by specifying file; name as ""myfile.gif+"" of ""myfile.gif+NN"", where NN is delay of displaying; subimages during animation in 10ms seconds units.; If NN is ommitted the delay between subimages is zero.; For repeated animation the last subimage must be specified as; ""myfile.gif++NN"", where NN is number of cycles. If NN is ommitted the; animation will be infinite. The following macro creates animated gif from jpeg images with names; imageNN.jpg, where 1<= NN <= 10; {; TImage *img = 0;; gSystem->Unlink(""anim.gif""); // delete existing file. for (int i = 1; i <= 10; i++) {; delete img; // delete previous image. // Read image data. Image can be in any format, e.g. png, gif, etc.; img = TImage::Open(Form(""image%d.jpg"", i));. if (i < 10) {; img->WriteImage(""anim.gif+"");; } else { // the last image written. ""++"" stands for infinit animation.; img->WriteImage(""anim.gif++"");; }; }; }. TImage::EImageFileTypes GetFileType(const char* ext); Return file type depending on specified extension.; Protected method. void MapFileTypes(TImage::EImageFileTypes& type, UInt_t& astype, Bool_t toas = kTRUE); Map file type to/from AfterImage types.; Protected method. void MapQuality(TAttImage::EImageQuality& quality, UInt_t& asquality, Bool_t toas = kTRUE); Map quality to/from AfterImage quality.; Protected method. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0); Deletes the old image and creates a new image depending on the values; of imageData. The size of the image is width X height.; The color of each pixel depends on the imageData of the corresponding; pixel. The palette is used to convert an image value into its color.; If palette is not defined (palette = 0) a default palette is used.; Any previously defined zooming is reset. void SetImage(const TArrayD& imageData, UInt_t width, TImagePalette* palette = 0); Delete the old image and creates a new image depending on the values; of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TASImage.html:22525,depend,depending,22525,root/html528/TASImage.html,https://root.cern,https://root.cern/root/html528/TASImage.html,4,['depend'],['depending']
Integrability,"always be taken as identity. ;  ; virtual void DestroyOrWarn ();  Destroy this element. Prints a warning if deny-destroy is in force. ;  ; void DisableListElements (Bool_t rnr_self=kFALSE, Bool_t rnr_children=kFALSE);  Disable rendering of children and their list contents. ;  ; void DumpSourceObject () const;  Call Dump() on source object. ;  ; void EnableListElements (Bool_t rnr_self=kTRUE, Bool_t rnr_children=kTRUE);  Enable rendering of children and their list contents. ;  ; List_i EndChildren ();  ; List_ci EndChildren () const;  ; List_i EndParents ();  ; List_ci EndParents () const;  ; virtual void ExpandIntoListTree (TGListTree *ltree, TGListTreeItem *parent);  Populates parent with elements. ;  ; void ExportSourceObjectToCINT (char *var_name) const;  Export source object to CINT with given name for the variable. ;  ; virtual void ExportToCINT (char *var_name);  Export render-element to CINT with variable name var_name. ;  ; virtual void FillImpliedSelectedSet (Set_t &impSelSet);  Populate set impSelSet with derived / dependant elements. ;  ; TEveElement * FindChild (const TString &name, const TClass *cls=nullptr);  Find the first child with given name. ;  ; TEveElement * FindChild (TPRegexp &regexp, const TClass *cls=nullptr);  Find the first child whose name matches regexp. ;  ; Int_t FindChildren (List_t &matches, const TString &name, const TClass *cls=nullptr);  Find all children with given name and append them to matches list. ;  ; Int_t FindChildren (List_t &matches, TPRegexp &regexp, const TClass *cls=nullptr);  Find all children whose name matches regexp and append them to matches list. ;  ; virtual sLTI_i FindItem (TGListTree *ltree);  Find any list-tree-item of this element in list-tree 'ltree'. ;  ; virtual sLTI_i FindItem (TGListTree *ltree, TGListTreeItem *parent_lti);  Find list-tree-item of this element with given parent list-tree-item. ;  ; virtual TGListTreeItem * FindListTreeItem (TGListTree *ltree);  Find any list-tree-item of this element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:13901,depend,dependant,13901,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['depend'],['dependant']
Integrability,"al~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfString[33]!string representation of digest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t[16] digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:1910,message,message,1910,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,4,['message'],['message']
Integrability,"am *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double ApproxErf (double arg) const;  ; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of Crystal ball Shape distribution. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:59469,rout,routine,59469,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,1,['rout'],['routine']
Integrability,"am f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:9845,integrat,integration,9845,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,6,['integrat'],['integration']
Integrability,"am. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:40523,depend,dependents,40523,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,121,['depend'],['dependents']
Integrability,"am. ;  ; bool hasClients () const;  ; bool hasDataToken () const;  ; virtual bool hasRange (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to file if filename is specified. ;  ; void printCompactTree (std::ostream &os, const char *indent="""", const char *namePat=nullptr, RooAbsArg *client=nullptr);  Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:25828,depend,dependents,25828,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,15,['depend'],['dependents']
Integrability,"amFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p+NPar(), fParams.begin() );; 106 }; 107 ; 108 unsigned int NPar() const override { return fParams.size(); }; 109 ; 110 unsigned int NDim() const override { return fDim; }; 111 ; 112 ; 113private:; 114 ; 115 /// evaluate the function given values and parameters (requested interface); 116 double DoEvalPar(const double * x, const double * p) const override {; 117 return (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4048,interface,interface,4048,doc/master/WrappedParamFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html,3,"['interface', 'wrap']","['interface', 'interface-like', 'wrap']"
Integrability,"ame ""Peaks""; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TMacroClass supporting a collection of lines with C++ code.Definition TMacro.h:31; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; mTMarker mDefinition textangle.C:8. Definition at line 31 of file TMacro.h. Public Member Functions;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual Longptr_t Exec (const char *params=nullptr, Int_t *error=nullptr);  Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:2408,depend,depending,2408,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['depend'],['depending']
Integrability,"ame ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void InitStreaming (Bool_t isTransient);  Error message in case of checksum/version mismatch. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t & fBaseCheckSum;  ; TClass * fBaseClass;  checksum of the base class (used during memberwise streaming) ;  ; Int_t fBaseVersion;  ; ClassConvStreamerFunc_t fConvStreamerFunc;  Pointer to a wrapper around a custom streamer member function. ;  ; TString fErrorMsg;  Pointer to the current StreamerInfo for the baset class. ;  ; TClass * fNewBaseClass;  pointer to base class ;  ; ClassStreamerFunc_t fStreamerFunc;  pointer to new base class if renamed ;  ; TVirtualStreamerInfo * fStreamerInfo;  Pointer to a wrapper around a custom convertion streamer member function. ;  ;  Protected Attributes inherited from TStreamerElement; Int_t fArrayDim;  ; Int_t fArrayLength;  ; TClass * fClassObject;  ; Double_t fFactor;  Maximum of data member if a range is specified [xmin,xmax,nbits]. ;  ; Int_t fMaxIndex [5];  ; TClass * fNewClass;  pointer to class of object ;  ; Int_t fNewType;  base offset for TObject if the element inherits from it ;  ; Int_t fOffset;  ; Int_t fSize;  ; TMemberStreamer * fStreamer;  new element class when reading ;  ; Int_t fTObjectOffset;  element offset in class ;  ; Int_t fTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:14950,wrap,wrapper,14950,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['wrap'],['wrapper']
Integrability,"ame ; (; ). private . Create the frame that contains all the necessary information for the Confidence Level method. ; Definition at line 268 of file TAdvancedGraphicsDialog.cxx. ◆ CreateContourFrame(). void TAdvancedGraphicsDialog::CreateContourFrame ; (; ). private . Create the frame that contains all the necessary information for the Contour method. ; Definition at line 122 of file TAdvancedGraphicsDialog.cxx. ◆ CreateScanFrame(). void TAdvancedGraphicsDialog::CreateScanFrame ; (; ). private . Create the frame that contains all the necessary information for the Scan method. ; Definition at line 203 of file TAdvancedGraphicsDialog.cxx. ◆ DeclFileName(). static const char * TAdvancedGraphicsDialog::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file TAdvancedGraphicsDialog.h. ◆ DoChangedScanPar(). void TAdvancedGraphicsDialog::DoChangedScanPar ; (; Int_t ; selected). Changes the Min and Max default values of the scan method, depending on the selected parameter. ; Definition at line 326 of file TAdvancedGraphicsDialog.cxx. ◆ DoDraw(). void TAdvancedGraphicsDialog::DoDraw ; (; ). Calls the corresponding method, depending on the selected tab. ; Definition at line 337 of file TAdvancedGraphicsDialog.cxx. ◆ DrawConfidenceLevels(). void TAdvancedGraphicsDialog::DrawConfidenceLevels ; (; ). private . Generates all necessary data for the Scan method from its tab. ; Then it call Virtual Fitter to perform it. ; Definition at line 405 of file TAdvancedGraphicsDialog.cxx. ◆ DrawContour(). void TAdvancedGraphicsDialog::DrawContour ; (; ). private . Generates all necessary data for the Contour method from its tab. ; Then it call Virtual Fitter to perform it. ; Definition at line 352 of file TAdvancedGraphicsDialog.cxx. ◆ DrawScan(). void TAdvancedGraphicsDialog::DrawScan ; (; ). private . Generates all necessary data for the Scan method from its tab. ; Then it call Virtual Fitter to perform it. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAdvancedGraphicsDialog.html:40981,depend,depending,40981,doc/master/classTAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/doc/master/classTAdvancedGraphicsDialog.html,1,['depend'],['depending']
Integrability,"ame = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Tue Dec 14 15:30:40 2010 » Last generated: 2010-12-14 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:35833,message,message,35833,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,1,['message'],['message']
Integrability,"ame V = RDFDetail::RInferredType>; 2562 RResultPtr<TStatistic> Stats(std::string_view value = """"); 2563 {; 2564 ColumnNames_t columns;; 2565 if (!value.empty()) {; 2566 columns.emplace_back(std::string(value));; 2567 }; 2568 const auto validColumnNames = GetValidatedColumnNames(1, columns);; 2569 if (std::is_same<V, RDFDetail::RInferredType>::value) {; 2570 return Fill(TStatistic(), validColumnNames);; 2571 } else {; 2572 return Fill<V>(TStatistic(), validColumnNames);; 2573 }; 2574 }; 2575 ; 2576 ////////////////////////////////////////////////////////////////////////////; 2577 /// \brief Return a TStatistic object, filled once per event (*lazy action*).; 2578 ///; 2579 /// \tparam V The type of the value column; 2580 /// \tparam W The type of the weight column; 2581 /// \param[in] value The name of the column with the values to fill the statistics with.; 2582 /// \param[in] weight The name of the column with the weights to fill the statistics with.; 2583 /// \return the filled TStatistic object wrapped in a RResultPtr.; 2584 ///; 2585 /// ### Example usage:; 2586 /// ~~~{.cpp}; 2587 /// // Deduce column types (this invocation needs jitting internally); 2588 /// auto stats0 = myDf.Stats(""values"", ""weights"");; 2589 /// // Explicit column types; 2590 /// auto stats1 = myDf.Stats<int, float>(""values"", ""weights"");; 2591 /// ~~~; 2592 ///; 2593 template <typename V = RDFDetail::RInferredType, typename W = RDFDetail::RInferredType>; 2594 RResultPtr<TStatistic> Stats(std::string_view value, std::string_view weight); 2595 {; 2596 ColumnNames_t columns{std::string(value), std::string(weight)};; 2597 constexpr auto vIsInferred = std::is_same<V, RDFDetail::RInferredType>::value;; 2598 constexpr auto wIsInferred = std::is_same<W, RDFDetail::RInferredType>::value;; 2599 const auto validColumnNames = GetValidatedColumnNames(2, columns);; 2600 // We have 3 cases:; 2601 // 1. Both types are inferred: we use Fill and let the jit kick in.; 2602 // 2. One of the two types is explicit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:145113,wrap,wrapped,145113,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['wrap'],['wrapped']
Integrability,"ame allows to analyse data stored in TTrees with a high level interface. . Files; file  ActionHelpers.hxx;  ; file  RMergeableValue.hxx;  . Classes; class  GraphCreatorHelper;  Helper class that provides the operation graph nodes. More...;  ; class  ROOT::Internal::RDF::GraphDrawing::GraphNode;  Class used to create the operation graph to be printed in the dot representation. More...;  ; class  ROOT::Internal::RDF::RAction< Helper, PrevNode, ColumnTypes_t >;  A RDataFrame node that produces a result. More...;  ; class  ROOT::RDF::RArrowDS;  RDataFrame data source class to interface with Apache Arrow. More...;  ; class  RColumnReaderBase;  Pure virtual base class for all column reader types. More...;  ; class  ROOT::Internal::RDF::RColumnRegister;  A binder for user-defined columns, variations and aliases. More...;  ; class  ROOT::RDF::RCsvDS;  RDataFrame data source class for reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class  RInterfaceBase;  The public interface to the RDataFrame federation of classes. More...;  ; class  ROOT::Detail::RDF::RMergeableCount;  Specializa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__dataframe.html:1138,interface,interface,1138,doc/master/group__dataframe.html,https://root.cern,https://root.cern/doc/master/group__dataframe.html,1,['interface'],['interface']
Integrability,"ame object is clicked.; 76 ; 77void TFrame::ExecuteEvent(Int_t event, Int_t px, Int_t py); 78{; 79 if (!gPad) return;; 80 ; 81 if (!gPad->IsEditable()) return;; 82 ; 83 TWbox::ExecuteEvent(event, px, py);; 84 ; 85 Bool_t opaque = gPad->OpaqueMoving();; 86 ; 87 if ((event == kButton1Up) || ((opaque)&&(event == kButton1Motion))) {; 88 // update pad margins; 89 Double_t xmin = gPad->GetUxmin();; 90 Double_t xmax = gPad->GetUxmax();; 91 Double_t ymin = gPad->GetUymin();; 92 Double_t ymax = gPad->GetUymax();; 93 Double_t dx = xmax-xmin;; 94 Double_t dy = ymax-ymin;; 95 Double_t leftMargin = (fX1-gPad->GetX1())/(gPad->GetX2()-gPad->GetX1());; 96 Double_t topMargin = (gPad->GetY2()-fY2)/(gPad->GetY2()-gPad->GetY1());; 97 Double_t rightMargin = (gPad->GetX2()-fX2)/(gPad->GetX2()-gPad->GetX1());; 98 Double_t bottomMargin = (fY1-gPad->GetY1())/(gPad->GetY2()-gPad->GetY1());; 99 // margin may get very small negative values; 100 if (leftMargin < 0) leftMargin = 0;; 101 if (topMargin < 0) topMargin = 0;; 102 if (rightMargin < 0) rightMargin = 0;; 103 if (bottomMargin < 0) bottomMargin = 0;; 104 gPad->SetLeftMargin(leftMargin);; 105 gPad->SetRightMargin(rightMargin);; 106 gPad->SetBottomMargin(bottomMargin);; 107 gPad->SetTopMargin(topMargin);; 108 Double_t dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 109 Double_t dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 110 ; 111 // Range() could change the size of the pad pixmap and therefore should; 112 // be called before the other paint routines; 113 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 114 ymin - dyr*gPad->GetBottomMargin(),; 115 xmax + dxr*gPad->GetRightMargin(),; 116 ymax + dyr*gPad->GetTopMargin());; 117 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 118 fX1 = xmin;; 119 fY1 = ymin;; 120 fX2 = xmax;; 121 fY2 = ymax;; 122 }; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// Paint this wbox with its current attributes.; 127 ; 128void TFrame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFrame_8cxx_source.html:3778,rout,routines,3778,doc/master/TFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFrame_8cxx_source.html,1,['rout'],['routines']
Integrability,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:67044,integrat,integration,67044,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,7,['integrat'],['integration']
Integrability,"ame x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); { }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGedPopup.html:20733,message,messages,20733,root/html604/TGedPopup.html,https://root.cern,https://root.cern/root/html604/TGedPopup.html,1,['message'],['messages']
Integrability,"ame x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); { }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPopup.html:20733,message,messages,20733,root/html602/TGedPopup.html,https://root.cern,https://root.cern/root/html602/TGedPopup.html,1,['message'],['messages']
Integrability,ame(). static const char * RooNumIntConfig::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 87 of file RooNumIntConfig.h. ◆ defaultConfig(). RooNumIntConfig & RooNumIntConfig::defaultConfig ; (; ). static . Return reference to instance of default numeric integrator configuration object. ; Definition at line 44 of file RooNumIntConfig.cxx. ◆ defaultPrintStyle(). RooPrintable::StyleOption RooNumIntConfig::defaultPrintStyle ; (; Option_t * ; opt); const. overridevirtual . Reimplemented from RooPrintable.; Definition at line 240 of file RooNumIntConfig.cxx. ◆ epsAbs(). double RooNumIntConfig::epsAbs ; (; ); const. inline . Definition at line 50 of file RooNumIntConfig.h. ◆ epsRel(). double RooNumIntConfig::epsRel ; (; ); const. inline . Definition at line 51 of file RooNumIntConfig.h. ◆ getConfigSection() [1/2]. RooArgSet & RooNumIntConfig::getConfigSection ; (; const char * ; name). Return section with configuration parameters for integrator with given (class) name. ; Definition at line 205 of file RooNumIntConfig.cxx. ◆ getConfigSection() [2/2]. const RooArgSet & RooNumIntConfig::getConfigSection ; (; const char * ; name); const. Retrieve configuration information specific to integrator with given name. ; Definition at line 214 of file RooNumIntConfig.cxx. ◆ IsA(). TClass * RooNumIntConfig::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 87 of file RooNumIntConfig.h. ◆ method1D() [1/2]. RooCategory & RooNumIntConfig::method1D ; (; ). inline . Definition at line 34 of file RooNumIntConfig.h. ◆ method1D() [2/2]. const RooCategory & RooNumIntConfig::method1D ; (; ); const. inline . Definition at line 37 of file RooNumIntConfig.h. ◆ method1DOpen() [1/2]. RooCategory & RooNumIntConfig::method1DOpen ; (; ). inline . Definition at line 42 of file RooNumIntConfig.h. ◆ method1DOpen() [2/2]. const RooCategory & RooNumIntConfig::me,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumIntConfig.html:17630,integrat,integrator,17630,doc/master/classRooNumIntConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumIntConfig.html,1,['integrat'],['integrator']
Integrability,"ame(). static const char * TProofMonSenderSQL::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofMonSenderSQL::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 53 of file TProofMonSenderSQL.h. ◆ DeclFileName(). static const char * TProofMonSenderSQL::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 53 of file TProofMonSenderSQL.h. ◆ IsA(). TClass * TProofMonSenderSQL::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofMonSender.; Definition at line 53 of file TProofMonSenderSQL.h. ◆ SendDataSetInfo(). Int_t TProofMonSenderSQL::SendDataSetInfo ; (; TDSet * ; dset, . TList * ; missing, . const char * ; begin, . const char * ; qid . ). overridevirtual . Post information about the processed dataset(s). ; The information is taken from the TDSet object 'dset' and integrated with the missing files information in the list 'missing'. The string 'qid' is the uninque ID of the query; 'begin' the starting time.; The record is formatted for the table 'proofquerydsets'.; There are two versions of this record, with or without the starting time. The starting time could be looked up from the summary record, if available.; The default version 1 corresponds to the table created with the following command:; CREATE TABLE proofquerydsets ( id int(11) NOT NULL auto_increment, dsn varchar(512) NOT NULL, querytag varchar(64) NOT NULL, querybegin datetime default NULL, numfiles int(11) default NULL, missfiles int(11) default NULL, PRIMARY KEY (id), KEY ix_querytag (querytag) );; Version 0 corresponds to the table created with the following command: (no 'querybegin'); CREATE TABLE proofquerydsets ( id int(11) NOT NULL auto_increment, dsn varchar(512) NOT NULL, querytag varchar(64) NOT NULL, numfiles int(11) default NULL, missfiles int(11) default NULL, PRIMARY KEY (id)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMonSenderSQL.html:14418,integrat,integrated,14418,doc/master/classTProofMonSenderSQL.html,https://root.cern,https://root.cern/doc/master/classTProofMonSenderSQL.html,1,['integrat'],['integrated']
Integrability,"ame(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::IsAutoParsingSuspendedBool_t IsAutoParsingSuspended() const finalDefinition TCling.h:353; TCling::fSharedLibsTString fSharedLibsDefinition TCling.h:113; TCling::fPendingRdictsstd::map< std::string, llvm::StringRef > fPendingRdictsDefinition TCling.h:634; TCling::UpdateClassInfoWorkstatic void UpdateClassInfoWork(const char *name)Definition TCling.cxx:6745; TCling::LoadInt_t Load(const char *filenam, Bool_t system=kFALSE) finalLoad a library file in cling's memory.Definition TCling.cxx:3515; TCling::TypedefInfo_Nextint TypedefInfo_Next(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9490; TCling::GetInterfaceMethodvoid * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE) finalReturn pointer to cling interface function for a method of a class with parameters params (params is ...Definition TCling.cxx:5007; TCling::TypeInfo_Initvoid TypeInfo_Init(TypeInfo_t *tinfo, const char *funcname) const finalDefinition TCling.cxx:9371; TCling::SetSuspendAutoParsingBool_t SetSuspendAutoParsing(Bool_t value) finalSuspend the Autoparsing of headers.Definition TCling.cxx:7596; TCling::DataMemberInfo_TypeSizeint DataMemberInfo_TypeSize(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8674; TCling::fgSetOfSpecialsstatic void * fgSetOfSpecialsDefinition TCling.h:105; TCling::ClassInfo_Titleconst char * ClassInfo_Title(ClassInfo_t *info) const finalDefinition TCling.cxx:8442; TCling::DataMemberInfo_Nameconst char * DataMemberInfo_Name(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8698; TCling::TypeNameconst char * TypeName(const char *typeDesc) finalReturn the absolute type of typeDesc.Definition TCling.cxx:5478; TCling::fNormalized",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:63508,interface,interface,63508,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['interface'],['interface']
Integrability,"ame*fCe[16]matrix of color cells; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TG16ColorSelector.html:17985,message,messages,17985,root/html528/TG16ColorSelector.html,https://root.cern,https://root.cern/root/html528/TG16ColorSelector.html,6,['message'],['messages']
Integrability,"ame, Long_t tagnum); Static function called by CINT when it changes the tagnum for; a class (e.g. after re-executing the setup function). In such; cases we have to update the tagnum in the G__ClassInfo used by; the TClass for class ""item"". void UpdateClassInfoWork(const char* name, Long_t tagnum); This does the actual work of UpdateClassInfo. void UpdateAllCanvases(); Update all canvases at end the terminal input command. const char* GetSharedLibs(); Refresh the list of shared libraries and return it. const char * GetClassSharedLibs(const char* cls); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. const char * GetSharedLibDeps(const char* lib); Get the list a libraries on which the specified lib depends. The; returned string contains as first element the lib itself.; Returns 0 in case the lib does not exist or does not have; any dependencies. Bool_t IsErrorMessagesEnabled() const; If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Bool_t SetErrorMessages(Bool_t enable = kTRUE); If error messages are disabled, the interpreter should suppress its; failures and warning messages from stdout. Return the previous state. void AddIncludePath(const char* path); Add the given path to the list of directories in which the interpreter; looks for include files. Only one path item can be specified at a; time, i.e. ""path1:path2"" is not supported. const char * GetIncludePath(); Refresh the list of include paths known to the interpreter and return it; with -I prepended. const char * GetSTLIncludePath() const; Return the directory containing CINT's stl cintdlls. int DisplayClass(FILE* fout, char* name, int base, int start) const; Interface to CINT function. int DisplayIncludePath(FILE* fout) const; Interface to CINT function. void * FindSym(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:30218,depend,dependencies,30218,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,1,['depend'],['dependencies']
Integrability,"ame, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void enableOffsetting(Bool_t ). Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Tue Jun 30 14:30:49 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:38889,depend,depend,38889,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,2,"['depend', 'integrat']","['depend', 'integration']"
Integrability,"ame, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE). RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE). RooAddition(const RooAddition& other, const char* name = 0). ~RooAddition(). Double_t evaluate() const; Calculate and return current value of self. Double_t defaultErrorLevel() const; Return the default error level for MINUIT error analysis; If the addition contains one or more RooNLLVars and; no RooChi2Vars, return the defaultErrorLevel() of; RooNLLVar. If the addition contains one ore more RooChi2Vars; and no RooNLLVars, return the defaultErrorLevel() of; RooChi2Var. If the addition contains neither or both; issue a warning message and return a value of 1. void enableOffsetting(Bool_t ). Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE). void printMetaArgs(ostream& os) const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate integral cache. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. TObject* clone(const char* newname) const; { return new RooAddition(*this, newname); }. const RooArgList& list1() const; { return _set ; }. const RooArgList& list() const; { return _set ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. » Last changed: Tue Mar 10 17:14:25 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:37389,depend,depend,37389,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,2,"['depend', 'integrat']","['depend', 'integration']"
Integrability,"ame, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); Constructor of an empty data set from a RooArgSet defining the dimensions; of the data space. RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const char* cuts = 0, const char* wgtVarName = 0); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cuts' string is an optional RooFormula; expression and can be used to select the subset of the data; points in 'dset' to be copied. The cut expression can refer to; any variable in the source dataset. For cuts involving variables; other than those contained in the source data set, such as; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, RooDataSet* data, const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName = 0); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char* name, const char* title, TTree* t, const RooArgSet& vars, const RooFormulaVar& cutVar, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:20678,wrap,wrapper,20678,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,6,['wrap'],['wrapper']
Integrability,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:29925,depend,depend,29925,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['depend'],['depend']
Integrability,"ame, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Interface function signaling a request to perform constant term; optimization. This default implementation takes no action other than to; forward the calls to all servers. void setOperMode(RooAbsArg::OperM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:30385,depend,depend,30385,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['depend'],['depend']
Integrability,"ame.c_str(), g_title.c_str());; 2293 graph->GetXaxis()->SetTitle(validatedColumns[0].c_str());; 2294 graph->GetYaxis()->SetTitle(validatedColumns[1].c_str());; 2295 ; 2296 return CreateAction<RDFInternal::ActionTags::GraphAsymmErrors, X, Y, EXL, EXH, EYL, EYH>(validatedColumns, graph,; 2297 graph, fProxiedPtr);; 2298 }; 2299 ; 2300 ////////////////////////////////////////////////////////////////////////////; 2301 /// \brief Fill and return a one-dimensional profile (*lazy action*).; 2302 /// \tparam V1 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2303 /// \tparam V2 The type of the column the values of which are used to fill the profile. Inferred if not present.; 2304 /// \param[in] model The model to be considered to build the new return value.; 2305 /// \param[in] v1Name The name of the column that will fill the x axis.; 2306 /// \param[in] v2Name The name of the column that will fill the y axis.; 2307 /// \return the monodimensional profile wrapped in a RResultPtr.; 2308 ///; 2309 /// This action is *lazy*: upon invocation of this method the calculation is; 2310 /// booked but not executed. Also see RResultPtr.; 2311 ///; 2312 /// ### Example usage:; 2313 /// ~~~{.cpp}; 2314 /// // Deduce column types (this invocation needs jitting internally); 2315 /// auto myProf1 = myDf.Profile1D({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; 2316 /// // Explicit column types; 2317 /// auto myProf2 = myDf.Graph<int, float>({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; 2318 /// ~~~; 2319 ///; 2320 /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; 2321 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 2322 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 2323 template <typename V1 = RDFDetail::RInferredType, typename V2 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:129637,wrap,wrapped,129637,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['wrap'],['wrapped']
Integrability,ame.cxx. ◆ GetPopup(). TGPopupMenu * TGMdiTitleIcon::GetPopup ; (; ); const. inline . Definition at line 168 of file TGMdiDecorFrame.h. ◆ HandleButton(). Bool_t TGMdiTitleIcon::HandleButton ; (; Event_t * ; event). overridevirtual . Handle button event on MDI icon (popup menu) ; Reimplemented from TGFrame.; Definition at line 746 of file TGMdiDecorFrame.cxx. ◆ HandleDoubleClick(). Bool_t TGMdiTitleIcon::HandleDoubleClick ; (; Event_t * ; event). overridevirtual . Handle double click event on MDI icon (close the window) ; Reimplemented from TGFrame.; Definition at line 732 of file TGMdiDecorFrame.cxx. ◆ IsA(). TClass * TGMdiTitleIcon::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGIcon.; Definition at line 170 of file TGMdiDecorFrame.h. ◆ Streamer(). void TGMdiTitleIcon::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGIcon. ◆ StreamerNVirtual(). void TGMdiTitleIcon::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 170 of file TGMdiDecorFrame.h. Friends And Related Symbol Documentation. ◆ TGMdiFrame. friend class TGMdiFrame. friend . Definition at line 152 of file TGMdiDecorFrame.h. ◆ TGMdiTitleBar. friend class TGMdiTitleBar. friend . Definition at line 153 of file TGMdiDecorFrame.h. Member Data Documentation. ◆ fMsgWindow. const TGWindow* TGMdiTitleIcon::fMsgWindow. protected . window handling container messages ; Definition at line 156 of file TGMdiDecorFrame.h. ◆ fPopup. TGPopupMenu* TGMdiTitleIcon::fPopup. protected . Popup menu associated to the title icon. ; Definition at line 157 of file TGMdiDecorFrame.h. Libraries for TGMdiTitleIcon:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGMdiDecorFrame.h; gui/gui/src/TGMdiDecorFrame.cxx. TGMdiTitleIcon. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:27 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMdiTitleIcon.html:31562,message,messages,31562,doc/master/classTGMdiTitleIcon.html,https://root.cern,https://root.cern/doc/master/classTGMdiTitleIcon.html,1,['message'],['messages']
Integrability,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8py.html:2677,integrat,integrator,2677,doc/master/rf105__funcbinding_8py.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html,4,['integrat'],['integrator']
Integrability,"ame::SaveFrameAsCodeOrImage ; (; const TString & ; fileName). virtual . Saves the frame contents as a ROOT macro or as an image, depending on the extension of the fileName argument. ; If preexisting, the file is overwritten. Returns kTRUE if something was saved. ; Definition at line 1564 of file TGFrame.cxx. ◆ SavePrimitive(). void TGMainFrame::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a main frame widget as a C++ statement(s) on output stream out. ; Reimplemented from TGCompositeFrame.; Reimplemented in TGTransientFrame.; Definition at line 3092 of file TGFrame.cxx. ◆ SaveSource(). void TGMainFrame::SaveSource ; (; const char * ; filename = ""Rootappl.C"", . Option_t * ; option = """" . ). virtual . Save the GUI main frame widget in a C++ macro file. ; Reimplemented in TTreeViewer, and TGTransientFrame.; Definition at line 2817 of file TGFrame.cxx. ◆ SendCloseMessage(). void TGMainFrame::SendCloseMessage ; (; ). virtual . Send close message to self. ; This method should be called from a button to close this window. ; Definition at line 1744 of file TGFrame.cxx. ◆ SetClassHints(). void TGMainFrame::SetClassHints ; (; const char * ; className, . const char * ; resourceName . ). Set the windows class and resource name. ; Used to get the right resources from the resource database. However, ROOT applications will typically use the .rootrc file for this. ; Definition at line 1858 of file TGFrame.cxx. ◆ SetIconName(). void TGMainFrame::SetIconName ; (; const char * ; name). Set window icon name. This is typically done via the window manager. ; Definition at line 1801 of file TGFrame.cxx. ◆ SetIconPixmap() [1/2]. void TGMainFrame::SetIconPixmap ; (; char ** ; xpm_array). Set window icon by xpm array. ; That allows to have icons builtin to the source code.; For example, #include ""/home/root/icons/bld_rgb.xpm""; //bld_rgb.xpm contains char *bld_rgb[] array; main_frame->SetIconPixmap(bld_rgb);. Definition at line 1839 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMainFrame.html:43517,message,message,43517,doc/master/classTGMainFrame.html,https://root.cern,https://root.cern/doc/master/classTGMainFrame.html,1,['message'],['message']
Integrability,"ame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id). virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 15:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGedMarkerSelect.html:24201,message,messages,24201,root/html604/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html604/TGedMarkerSelect.html,1,['message'],['messages']
Integrability,"ame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id). virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedMarkerSelect.html:24201,message,messages,24201,root/html602/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html602/TGedMarkerSelect.html,1,['message'],['messages']
Integrability,"ame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGListBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kSunkenFrame | kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a listbox. ~TGListBox(); Delete a listbox widget. void InitListBox(); Initiate the internal classes of a list box. void DrawBorder(); Draw borders of the list box widget. void AddEntry(TGString* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntry(const char* s, Int_t id); Add entry with specified string and id to listbox. The id will be; used in the event processing routine when the item is selected. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); Add specified TGLBEntry and TGLayoutHints to listbox. The; entry and layout will be adopted and later deleted by the listbox. void AddEntrySort(TGString* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected.; The string will be adopted by the listbox. void AddEntrySort(const char* s, Int_t id); Add entry with specified string and id to listbox sorted by increasing id.; This sorting works proberly only if EntrySort functions are used to add; entries without mixing them with other add or insert functions. The id will be; used in the event processing routine when the item is selected. void AddEntrySort(TGLBEntry* lbe, TGLayoutHints* lhints); Add s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGListBox.html:23336,rout,routine,23336,root/html602/TGListBox.html,https://root.cern,https://root.cern/root/html602/TGListBox.html,2,['rout'],['routine']
Integrability,"ame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleBar(const TGWindow* p, const TGWindow* mdiwin, const char* name = ""Untitled""); TGMdiTitleBar constructor.; the TGMdiTitleBar is the frame containing a title (window name); an icon and MDI picture buttons as minimize, maximize, restore,; close and help. ~TGMdiTitleBar(); TGMdiTitleBar destructor. void LayoutButtons(UInt_t buttonmask, Bool_t isMinimized, Bool_t isMaximized); Recalculates the position of every enabled (displayed) buttons. void SetTitleBarColors(UInt_t fore, UInt_t back, TGFont* f); Set title bar color (blue or grey, depends on active state). Bool_t HandleDoubleClick(Event_t* event); Handle double click in title bar (maximize window). Bool_t HandleButton(Event_t* event); Handle mouse click on title bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for title bar. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in title bar (used to move MDI window). void AddFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Restore(). void RemoveFrames(TGMdiTitleIcon* icon, TGMdiButtons* buttons); This is called from TGMdiMainFrame on Maximize(). TGMdiButtons * GetButtons() const; { return fButtons; }. TGMdiTitleIcon * GetWinIcon() const; { return fWinIcon; }. TGLabel * GetWinName() const; { return fWinName; }. Int_t GetX0(); { return fX0; }. Int_t GetY0(); { return fY0; }. Bool_t IsLeftButPressed(); { return fLeftButPressed; }. Bool_t IsRightButPressed(); { return fRightButPressed; }. Bool_t IsMidButPressed(); { return fMidButPressed; }. void SetX0(Int_t x0); { fX0 = x0; }. void SetY0(Int_t y0); { fY0 = y0; }. void SetLeftButPressed(Bool_t press = kTRUE); { fLeftButPressed = press; }. void SetRightButPressed(Bool_t press = kTRUE); { fRightButPressed= press; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMdiTitleBar.html:20623,message,messages,20623,root/html528/TGMdiTitleBar.html,https://root.cern,https://root.cern/root/html528/TGMdiTitleBar.html,4,['message'],['messages']
Integrability,"ame; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. vector<std::string>_args; stack<std::string>_autoNamePrefix; Int_t_errorCountError counter for a given expression processing; static map<std::string,IFace*>*_hooks; static Int_tRooPrintable::_nameLength; static RooFactoryWSTool*_of; map<std::string,std::string>_typeAliases; RooWorkspace*_ws! Associated workspace; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFactoryWSTool(RooWorkspace& inws); Default constructor. ~RooFactoryWSTool(); Destructor. RooRealVar* createVariable(const char* name, Double_t xmin, Double_t xmax); Low-level factory interface for creating a RooRealVar with a given range and initial value. RooCategory* createCategory(const char* name, const char* stateNameList = 0); Low-level factory interface for creating a RooCategory with a given list of state names. The State name list; can be of the form 'name1,name2,name3' or of the form 'name1=id1,name2=id2,name3=id3'. RooAbsArg* createArg(const char* className, const char* objName, const char* varList); Low-level factory interface for creating a RooAbsPdf of a given class with a given list of input variables; The variable list varList should be of the form ""a,b,c"" where the interpretation of the argument is; dependent on the p.d.f. Set and List arguments can be passed by substituting a single argument with; the form (a,b,c), i.e. one can set varList to ""x,(a0,a1,a2)"" to pass a RooAbsReal and a RooArgSet as arguments. vector<string> ctorArgs(const char* className). RooAddPdf* add(const char* objName, const char* specList, Bool_t recursiveCoefs = kFALSE). RooRealSumPdf* amplAdd(const char* objName, const char* specList). RooProdPdf* prod(const char* objName, const char* pdfList). RooSimultaneous* simul(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:10702,interface,interface,10702,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,1,['interface'],['interface']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooJeffreysPrior.html:21179,message,message,21179,root/html534/RooJeffreysPrior.html,https://root.cern,https://root.cern/root/html534/RooJeffreysPrior.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); const RooArgList&lowList() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:17684,message,message,17684,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); MINIMIZER*minimizer(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumEval() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:18060,message,message,18060,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,1,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); RooMinimizer*minimizer(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumEval() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:17878,message,message,17878,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,2,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:23912,message,message,23912,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,195,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:25097,message,message,25097,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; RooAbsReal&nll(); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:17593,message,message,17593,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:17668,message,message,17668,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,150,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tnumBins() const; Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:18042,message,message,18042,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::obse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:23542,message,message,23542,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsReal&model() const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:19856,message,message,19856,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*RooResolutionModel::modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:22565,message,message,22565,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,9,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTruthModel.html:21916,message,message,21916,root/html534/RooTruthModel.html,https://root.cern,https://root.cern/root/html534/RooTruthModel.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf&, const RooArgSet&, const RooDataSet*, const RooArgSet*, Bool_t) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:23674,message,message,23674,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsReal*mean(); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:17649,message,message,17649,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,3,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCBShape.html:21164,message,message,21164,root/html534/RooCBShape.html,https://root.cern,https://root.cern/root/html534/RooCBShape.html,9,['message'],['message']
Integrability,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:17821,message,message,17821,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,9,['message'],['message']
Integrability,"amed arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:25794,integrat,integrator,25794,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,6,['integrat'],"['integration', 'integrator']"
Integrability,"amed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:3515,depend,dependsOnValue,3515,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,3,['depend'],['dependsOnValue']
Integrability,"amed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); Construct Monte Carlo Study Manager. This class automates generating data from a given PDF,; fitting the PDF to that data and accumulating the fit statistics. The constructor accepts the following arguments. model -- The PDF to be studied; observables -- The variables of the PDF to be considered the observables. Silence() -- Suppress all RooFit messages during running below PROGRESS level; FitModel(const RooAbsPdf&) -- The PDF for fitting, if it is different from the PDF for generating; ConditionalObservables; (const RooArgSet& set) -- The set of observables that the PDF should _not_ be normalized over; Binned(Bool_t flag) -- Bin the dataset before fitting it. Speeds up fitting of large data samples; FitOptions(const char*) -- Classic fit options, provided for backward compatibility; FitOptions(....) -- Options to be used for fitting. All named arguments inside FitOptions(); are passed to RooAbsPdf::fitTo();; Verbose(Bool_t flag) -- Activate informational messages in event generation phase; Extended(Bool_t flag) -- Determine number of events for each sample anew from a Poisson distribution; Constrain(const RooArgSet& pars) -- Apply internal constraints on given parameters in fit and sample constrained parameter; values from constraint p.d.f for each toy.; ExternalConstraints(const RooArgSet& ) -- Apply internal constraints on given parameters in fit and sample constrained parameter; values from constraint p.d.f for each toy.; ProtoData(const RooDataSet&,; Bool_t rand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:12851,message,messages,12851,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['message'],['messages']
Integrability,"amer information for one class; TVirtualTableInterface ; TVirtualTreePlayer Abstract interface for Tree players; TVirtualViewer3D Abstract interface to 3D viewers; TVirtualX ABC defining a generic interface to graphics system; TVolume Description of parameters to position a 3-D geometry object; TVolumePosition Description of parameters to position a 3-D geometry object; TVolumeView Special kind of TDataSet; TVolumeViewIter Volume view iterator; TWbox A window box (box with 3-D effects); TWebFile A ROOT file that reads via a http server; TWebSystem Directory handler for HTTP (TWebFiles); TX11GLManager X11-specific version of TGLManager; TXHandler Template class for handling of async events; TXMLAttr XML attribute pair; TXMLDocument XML document created by the DOM parser; TXMLEngine ROOT XML I/O parser, user by TXMLFile to read/write xml files; TXMLFile ROOT file in XML format; TXMLNode XML node under DOM tree; TXMLParser XML SAX parser; TXMLPlayer Generation of external xml streamers; TXMLSetup settings to be stored in XML files; TXNetFile TFile implementation to deal with new xrootd server.; TXNetFileStager Interface to a 'XRD' staging; TXNetSystem System management class for xrootd servers; TXProofMgr XrdProofd PROOF manager interface; TXProofServ XRD PROOF Server Application Interface; TXSlave Xrd PROOF slave server; TXSocket A high level connection class for PROOF; TXSocketHandler Input handler class for xproofd sockets; TXTRU TXTRU shape; TXUnixSocket Connection class for Xrd PROOF using UNIX sockets; TZIPFile A ZIP archive file; TZIPMember A ZIP archive member file; ToolBarData_t ; UserGroup_t ; WindowAttributes_t ; _root_std_complex<double> ; _root_std_complex<float> ; _root_std_complex<int> ; _root_std_complex<long> ; tableDescriptor_st . » Last changed: 2015-06-30 14:20 » Last generated: 2015-06-30 14:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:135091,interface,interface,135091,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,1,['interface'],['interface']
Integrability,"amer information for one class; TVirtualTableInterface ; TVirtualTreePlayer Abstract interface for Tree players; TVirtualViewer3D Abstract interface to 3D viewers; TVirtualX ABC defining a generic interface to graphics system; TVolume Description of parameters to position a 3-D geometry object; TVolumePosition Description of parameters to position a 3-D geometry object; TVolumeView Special kind of TDataSet; TVolumeViewIter Volume view iterator; TWbox A window box (box with 3-D effects); TWebFile A ROOT file that reads via a http server; TWebSystem Directory handler for HTTP (TWebFiles); TX11GLManager X11-specific version of TGLManager; TXHandler Template class for handling of async events; TXMLAttr XML attribute pair; TXMLDocument XML document created by the DOM parser; TXMLEngine ROOT XML I/O parser, user by TXMLFile to read/write xml files; TXMLFile ROOT file in XML format; TXMLNode XML node under DOM tree; TXMLParser XML SAX parser; TXMLPlayer Generation of external xml streamers; TXMLSetup settings to be stored in XML files; TXNetFile TFile implementation to deal with new xrootd server.; TXNetFileStager Interface to a 'XRD' staging; TXNetSystem System management class for xrootd servers; TXProofMgr XrdProofd PROOF manager interface; TXProofServ XRD PROOF Server Application Interface; TXSlave Xrd PROOF slave server; TXSocket A high level connection class for PROOF; TXSocketHandler Input handler class for xproofd sockets; TXTRU TXTRU shape; TXUnixSocket Connection class for Xrd PROOF using UNIX sockets; TZIPFile A ZIP archive file; TZIPMember A ZIP archive member file; ToolBarData_t ; UserGroup_t ; WindowAttributes_t ; _root_std_complex<double> ; _root_std_complex<float> ; _root_std_complex<int> ; _root_std_complex<long> ; tableDescriptor_st . » Last changed: 2015-09-08 17:32 » Last generated: 2015-09-08 17:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ClassIndex.html:135923,interface,interface,135923,root/html604/ClassIndex.html,https://root.cern,https://root.cern/root/html604/ClassIndex.html,1,['interface'],['interface']
Integrability,"amerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:46000,wrap,wrapper,46000,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['wrap'],['wrapper']
Integrability,"amerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 where uid id the uid of the ProcessID. Int_t GetCompressionAlgorithm() const. Int_t GetCompre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:24133,message,message,24133,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,5,['message'],['message']
Integrability,"amera along eye line, retaining lens focal length'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive dolly in, -ive dolly out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. const TGLPlane & FrustumPlane(TGLCamera::EFrustumPlane plane) const; Return one of the planes forming the camera frustum. TGLCamera(const TGLCamera& ); Non-copyable class. TGLCamera & operator=(const TGLCamera& ). Bool_t IsOrthographic() const; { return kFALSE; }. Bool_t IsPerspective() const; { return kFALSE; }. const TGLMatrix& RefModelViewMatrix() const; { return fModVM; }. Bool_t IsCacheDirty() const; { return fCacheDirty; }. void IncTimeStamp(); { fCacheDirty = kTRUE; ++fTimeStamp; }. UInt_t TimeStamp() const; { return fTimeStamp; }. TGLRect& RefViewport(); { return fViewport; }. const TGLRect& RefViewport() const; { return fViewport; }. void Setup(const TGLBoundingBox& box, Bool_t reset = kTRUE); Camera manipulation interface (GL coord - origin bottom left). void Reset(). Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2). Bool_t Truck(Double_t xDelta, Double_t yDelta). void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const. Bool_t GetExternalCenter(); { return fExternalCenter; }. Double_t* GetCenterVec(); { return fCenter->Arr(); }. void SetFixDefCenter(Bool_t x); { fFixDefCenter = x; }. void SetFixDefCenterVec(Double_t x, Double_t y, Double_t z); { fFDCenter.Set(x, y, z); }. Double_t* GetFixDefCenterVec(); { return fFDCenter.Arr(); }. Double_t GetNearClip() const; { return fNearClip; }. Double_t GetFarClip() const; { return fFarClip; }. const TGLMatrix& GetCamBase() const; { return fCamBase; }. const TGLMatrix& GetCamTrans() const; If you manipulate camera ... also call IncTimeStamp() before redraw. { return fCamTrans; }. TGLMatrix& RefCamBase(); { return fCamBase; }. TGLMatrix& RefCamTrans(); { return fCamTrans; }. TGLMatrix& RefLastNoPickProjM() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCamera.html:24117,interface,interface,24117,root/html602/TGLCamera.html,https://root.cern,https://root.cern/root/html602/TGLCamera.html,2,['interface'],['interface']
Integrability,"amervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Ind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:127241,message,message,127241,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['message'],['message']
Integrability,"ames of the packages available. ; Definition at line 9108 of file TProof.cxx. ◆ GetListOfQueries(). TList * TProof::GetListOfQueries ; (; Option_t * ; opt = """"). virtual . Ask the master for the list of queries. ; Reimplemented in TProofLite.; Definition at line 2088 of file TProof.cxx. ◆ GetListOfSlaveInfos(). TList * TProof::GetListOfSlaveInfos ; (; ). Returns list of TSlaveInfo's. In case of error return 0. ; Definition at line 2321 of file TProof.cxx. ◆ GetListOfSlaves(). TList * TProof::GetListOfSlaves ; (; ); const. inlineprivate . Definition at line 654 of file TProof.h. ◆ GetListOfUniqueSlaves(). TList * TProof::GetListOfUniqueSlaves ; (; ); const. inlineprivate . Definition at line 656 of file TProof.h. ◆ GetLoadedMacros(). TList * TProof::GetLoadedMacros ; (; ); const. inline . Definition at line 944 of file TProof.h. ◆ GetLog(). void TProof::GetLog ; (; Int_t ; start = -1, . Int_t ; end = -1 . ). Ask for remote logs in the range [start, end]. ; If start == -1 all the messages not yet received are sent back. ; Definition at line 10240 of file TProof.cxx. ◆ GetLogLevel(). Int_t TProof::GetLogLevel ; (; ); const. inline . Definition at line 916 of file TProof.h. ◆ GetMacroLog(). TMacro * TProof::GetMacroLog ; (; ). inline . Definition at line 1019 of file TProof.h. ◆ GetManager(). TProofMgr * TProof::GetManager ; (; ). inline . Definition at line 1037 of file TProof.h. ◆ GetMaster(). const char * TProof::GetMaster ; (; ); const. inline . Definition at line 903 of file TProof.h. ◆ GetMaxQueries(). void TProof::GetMaxQueries ; (; ). Get max number of queries whose full results are kept in the remote sandbox. ; Definition at line 2128 of file TProof.cxx. ◆ GetMissingFiles(). TFileCollection * TProof::GetMissingFiles ; (; TQueryResult * ; qr = 0). Get a TFileCollection with the files missing in the query described by 'qr' or the last query if qr is null (default). ; Return a null pointer if none were found, for whatever reason. The caller is responsible for the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:97587,message,messages,97587,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['messages']
Integrability,"amespace  FoundationUtils;  ; namespace  GLTutorials;  ; namespace  Internal;  ; namespace  MacOSX;  ; namespace  Math;  ; namespace  MathMore;  ; namespace  Meta;  ; namespace  Minuit;  ; namespace  Minuit2;  ; namespace  option;  The namespace of The Lean Mean C++ Option Parser. ;  ; namespace  Quartz;  ; namespace  R;  namespace associated R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v620/namespaceROOT.html:1528,interface,interface,1528,doc/v620/namespaceROOT.html,https://root.cern,https://root.cern/doc/v620/namespaceROOT.html,1,['interface'],['interface']
Integrability,"amespaces; namespace  CocoaTutorials;  ; namespace  Detail;  ; namespace  ExecutorUtils;  This namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce. ;  ; namespace  Experimental;  ; namespace  Fit;  Namespace for the fitting classes. ;  ; namespace  FoundationUtils;  ; namespace  Geom;  ; namespace  GLTutorials;  ; namespace  Internal;  ; namespace  MacOSX;  ; namespace  Math;  ; namespace  MathMore;  ; namespace  Meta;  ; namespace  Minuit;  ; namespace  Minuit2;  ; namespace  option;  The namespace of The Lean Mean C++ Option Parser. ;  ; namespace  Quartz;  ; namespace  R;  namespace associated R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:1378,depend,depend,1378,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['depend'],['depend']
Integrability,"amespaces; namespace  CocoaTutorials;  ; namespace  Detail;  ; namespace  ExecutorUtils;  This namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce. ;  ; namespace  Experimental;  ; namespace  Fit;  Namespace for the fitting classes. ;  ; namespace  FoundationUtils;  ; namespace  Geom;  ; namespace  GLTutorials;  ; namespace  Internal;  ; namespace  MacOSX;  ; namespace  Math;  ; namespace  MathMore;  ; namespace  Meta;  ; namespace  Minuit;  ; namespace  Minuit2;  ; namespace  option;  The namespace of The Lean Mean C++ Option Parser. ;  ; namespace  Quartz;  ; namespace  R;  namespace associated R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:1419,depend,depend,1419,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['depend'],['depend']
Integrability,"ameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the minimum, this may be because the true; minimum is indeed at a limit, or it may be because the minimizer has; become ``blocked'' at a limit. This may normally happen only if the; parameter is so close to a limit (internal value at an odd multiple of #((pi)/(2)); that MINUIT prints a warning to this effect when it prints; the parameter values.; The minimizer can become blocked at a limit, because at a limit the; derivative seen by the minimizer partial F/partial Pint is zer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:5179,depend,depends,5179,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['depend'],['depends']
Integrability,"ameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 101 of file RooAbsCollection.cxx. ◆ snapshot() [2/3]. RooArgSet * RooArgSet::snapshot ; (; bool ; deepCopy = true); const. inline . Use RooAbsCollection::snapshot(), but return as RooArgSet. ; Definition at line 154 of file RooArgSet.h. ◆ snapshot() [3/3]. bool RooAbsCollection::snapshot ; (; RooAbsCollection & ; output, . bool ; deepCopy = true . ); const. Take a snap shot of current collection contents: A collection that owns its elements is returned containing clones of. . Elements in this collection; External dependents of those elements and recursively any dependents of those dependents (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 102 of file RooAbsCollection.cxx. ◆ Streamer(). void RooArgSet::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCollection.; Reimplemented in RooCollectionProxy< RooArgSet >. ◆ StreamerNVirtual(). void RooArgSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 188 of file RooArgSet.h. ◆ writeToFile(). void RooArgSet::writeToFile ; (; const char * ; fileName); const. Write contents of the argset to specified file. ; See writeToStream() for details ; Definition at line 230 of file RooArgSet.cxx. ◆ writeToStream(). void RooArgSet::writeToStream ; (; std::ostream & ; os, . bool ; compact, . const char * ; section = nullptr . ); const. virtual . Write the contents of the argset in ASCII form to given stream. ; A line is written for each element contained in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:44559,depend,dependents,44559,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['depend'],['dependents']
Integrability,"ameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPOI, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:2287,integrat,integration,2287,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,2,['integrat'],['integration']
Integrability,"ameters, etc..). After configuring the calculator, one only needs to ask GetInterval(), which; will return an SimpleInterval object. By default the extrem of the integral are obtained by inverting directly the; cumulative posterior distribution. By using the method SetScanOfPosterior(nbins) the interval is then obtained by ; scanning the posterior function in the given number of points. The firts method is in general faster but it requires an; integration one extra dimension ( in the poi in addition to the nuisance parameters), therefore in some case it can be; less robust. . The class can also return the posterior function (method GetPosteriorFunction) or if needed the normalized; posterior function (the posterior pdf) (method GetPosteriorPdf). A posterior plot is also obtained using ; the GetPosteriorPlot method. The class allows to use different integration methods for integrating in the nuisances and in the poi. All the numerical ; integration methods of ROOT can be used via the method SetIntegrationType (see more in the documentation of; this method). Function Members (Methods); public:. virtual~BayesianCalculator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooStats::BayesianCalculatorBayesianCalculator(); RooStats::BayesianCalculatorBayesianCalculator(const RooStats::BayesianCalculator&); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); RooStats::BayesianCalculatorBayesianCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& POI, RooAbsPdf& priorPdf, const RooArgSet* nuisanceParameters = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__BayesianCalculator.html:2287,integrat,integration,2287,root/html534/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__BayesianCalculator.html,3,['integrat'],['integration']
Integrability,"amevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:267422,message,message,267422,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['message'],['message']
Integrability,"amicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:35603,message,message,35603,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['message'],['message']
Integrability,"ample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Training Network; : ; : Finalizing handling of Regulator terms, trainE=0.713219 testE=0.724617; : Done with handling of Regulator terms; : Elapsed time for training with 2000 events: 2.56 sec ; MLPBNN : [dataset] : Evaluation of MLPBNN on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0055 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.class.C␛[0m; : Write special histos to file: TMVAC.root:/dataset/Method_MLP/MLPBNN; Factory : Training finished; : ; Factor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:44333,message,message,44333,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['message'],['message']
Integrability,"ample scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:5875,interface,interfaces,5875,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['interface'],['interfaces']
Integrability,"ample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Definition IntegratorOptions.h:140; See alsoROOT::Math::IntegratorOneDim::SetOptions for more details on integration options. ; NoteWhen RooBinSamplingPdf is loaded from files, integrator options will fall back to the default values. ; Definition at line 278 of file RooBinSamplingPdf.cxx. ◆ IsA(). TClass * RooBinSamplingPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 134 of file RooBinSamplingPdf.h. ◆ isBinnedDistribution(). bool RooBinSamplingPdf::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Returns true, since this PDF is meant to be binned. ; Reimplemented from RooAbsReal.; Definition at line 101 of file RooBinSamplingPdf.h. ◆ isDirectGenSafe(). bool RooBinSamplingPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 91 of file RooBinSamplingPdf.h. ◆ maxVal(). double RooBinSamplingPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return maximum value for set of observables identified by code assigned in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:87710,integrat,integrator,87710,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability,"amplelist; }; ; # Plot input templates; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame0 = obsvar.frame(Title=""Input templates for p_{T}^{V}""); for sample, color in zip(samplelist, ""krb""):; input_datahists[sample].plotOn(frame0, Name=sample, LineColor=color, MarkerColor=color, MarkerSize=1); ; # Plot morphed templates for cHq3=0.01,0.25,0.5; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; frame1 = obsvar.frame(Title=""Morphed templates for selected values""); plot_args = dict(; DrawOption=""C"",; DataError=None,; XErrorSize=0,; ); morph_datahist_0p01.plotOn(frame1, Name=""morph_dh_cHq3=0.01"", LineColor=""kGreen"", **plot_args); morph_datahist_0p25.plotOn(frame1, Name=""morph_dh_cHq3=0.25"", LineColor=""kGreen+1"", **plot_args); morph_datahist_0p5.plotOn(frame1, Name=""morph_dh_cHq3=0.5"", LineColor=""kGreen+2"", **plot_args); ; # Create wrapped pdf to generate 2D dataset of cHq3 as a function of pTV; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; model = ROOT.RooWrapperPdf(""wrap_pdf"", ""wrap_pdf"", morphfunc); data = model.generate({cHq3, obsvar}, 1000000); hh_data = data.createHistogram(""x,y"", obsvar, Binning=20, YVar=dict(var=cHq3, Binning=50)); hh_data.SetTitle(""Morphing prediction""); ; # Draw plots on canvas; # -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -; ; c1 = ROOT.TCanvas(""fig3"", ""fig3"", 1200, 400); c1.Divide(3, 1); ; c1.cd(1); ROOT.gPad.SetLeftMargin(0.15); ROOT.gPad.SetRightMargin(0.05); ; frame0.Draw(); leg1 = ROOT.TLegend(0.55, 0.65, 0.94, 0.87); leg1.SetTextSize(0.04); leg1.SetFillColor(ROOT.kWhite); leg1.SetLineColor(ROOT.kWhite); leg1.AddEntry(""SM_NPsq0"", ""SM"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq1"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-2}"", ""LP""); leg1.AddEntry(0, """", """"); leg1.AddEntry(""cHq3_NPsq2"", ""c_{Hq^{(3)}}=1.0 at #Lambda^{-4}"", ""LP""); leg1.Draw();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html:3992,wrap,wrapped,3992,doc/master/rf711__lagrangianmorph_8py.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8py.html,1,['wrap'],['wrapped']
Integrability,"amples from an background hypothesis here the zz samples and a target hypothesis, here the higgs samples. The data preparation is based on the tutorial 'df106_HiggsToFourLeptons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf618__mixture__models_8py.html:1586,depend,dependence,1586,doc/master/rf618__mixture__models_8py.html,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html,1,['depend'],['dependence']
Integrability,"ams is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);; 149 else {; 150 if ( fConfig.ParamsSettings().size() != npar) {; 151 MATH_ERROR_MSG(""Fitter::SetFCN"",""wrong fit parameter settings"");; 152 return false;; 153 }; 154 }; 155 fFitType = fitType;; 156 fBinFit = (fFitType == ROOT::Math::FitMethodFunction::kLeastSquare || fFitType == ROOT::Math::FitMethodFunction::kPoissonLikelihood);; 157 ; 158 fDataSize = dataSize;; 159 ; 160 // store external provided FCN without cloning it; 161 // it will be cloned in fObjFunc after the fit; 162 if (extFcn) {; 163 fExtObjFunction = &fcn;; 164 fObjFunction.reset();; 165 }; 166 else {; 167 // case FCN is built from Minuit interface so function object is created internally in Fitter class; 168 // and needs to be cloned and managed; 169 fExtObjFunction = nullptr;; 170 fObjFunction.reset(fcn.Clone());; 171 }; 172 ; 173 // in case a model function and data exists from a previous fit - reset shared-ptr; 174 if (fResult && fResult->FittedFunction() == nullptr && fFunc) fFunc.reset();; 175 if (fData) fData.reset();; 176 ; 177 return true;; 178}; 179bool Fitter::SetFCN(const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 180 // set the objective function for the fit; 181 return DoSetFCN(true, fcn, params, dataSize, fitType);; 182}; 183bool Fitter::SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params, unsigned int dataSize, int fitType) {; 184 // set the objective function for the fit and a model function; 185 if (!SetFCN(fcn, params, dataSize, fitType) ) return false;; 186 // need to set fFunc afterwards because SetFCN could reset fFunc; 187 fFunc = std::unique",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:5913,interface,interface,5913,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['interface'],['interface']
Integrability,"ams, . const RooArgSet * ; nset = nullptr, . bool ; stripDisconnected = true . ); const. private . Add all parameters of the function and its daughters to params. ; Parameters. [in]paramsCollection that stores all parameters. Add all new parameters to this. ; [in]nsetNormalisation set (optional). If a value depends on this set, it's not a parameter. ; [in]stripDisconnectedPassed on to getParametersHook(). . Definition at line 582 of file RooAbsArg.cxx. ◆ addServer(). void RooAbsArg::addServer ; (; RooAbsArg & ; server, . bool ; valueProp = true, . bool ; shapeProp = false, . std::size_t ; refCount = 1 . ). Register another RooAbsArg as a server to us, ie, declare that we depend on it. ; Parameters. serverThe server to be registered. ; valuePropIn addition to the basic client-server relationship, declare dependence on the server's value. ; shapePropIn addition to the basic client-server relationship, declare dependence on the server's shape. ; refCountOptionally add with higher reference count (if multiple components depend on it) . Definition at line 327 of file RooAbsArg.cxx. ◆ addServerList(). void RooAbsArg::addServerList ; (; RooAbsCollection & ; serverList, . bool ; valueProp = true, . bool ; shapeProp = false . ). Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ; Definition at line 363 of file RooAbsArg.cxx. ◆ aggregateCacheUniqueSuffix(). const char * RooAbsArg::aggregateCacheUniqueSuffix ; (; ); const. Definition at line 2336 of file RooAbsArg.cxx. ◆ applyWeightSquared(). void RooAbsArg::applyWeightSquared ; (; bool ; flag). virtual . Disables or enables the usage of squared weights. ; Needs to be overloaded in the likelihood classes for which this is relevant. ; Reimplemented in RooNLLVar, and ProgressMonitor.; Definition at line 2521 of file RooAbsArg.cxx. ◆ attachArgs(). void RooAbsArg::attachArgs ; (; const RooAbsCollection & ; set). Bind this node to objects in set. ; Search the set for objects that have the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:45247,depend,depend,45247,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['depend'],['depend']
Integrability,"an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). support for streaming TStreamerInfo added by Rene Brun May 2008 support for streaming TProcessID added by Rene Brun June 2008 ; Reimplemented from TSocket.; Definition at line 254 of file TSSLSocket.cxx. ◆ Send() [3/4]. Int_t TSSLSocket::Send ; (; Int_t ; kind). inlineoverridevirtual . Send a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 71 of file TSSLSocket.h. ◆ Send() [4/4]. Int_t TSSLSocket::Send ; (; Int_t ; status, . Int_t ; kind . ). inlineoverridevirtual . Send a status and a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 72 of file TSSLSocket.h. ◆ SendRaw(). Int_t TSSLSocket::SendRaw ; (; const void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). overridevirtual . Send a raw buffer of specified length. ; Reimplemented from TSocket.; Definition at line 263 of file TSSLSocket.cxx. ◆ SetUpSSL(). void TSSLSocket::SetUpSSL ; (; const char * ; cafile, . const char * ; capath, . const char * ; ucert, . const char * ; ukey . ). static . Set up the static configuration variables. ; Definition at line 174 of file TSSLSocket.cxx. ◆ Streamer(). void TSSLSocket::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSSLSocket.html:25240,message,message,25240,doc/master/classTSSLSocket.html,https://root.cern,https://root.cern/doc/master/classTSSLSocket.html,1,['message'],['message']
Integrability,"an add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, he has to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, he can fix a parameter or put limits on another one before handing them over to Minit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply his own gradie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:37328,interface,interface,37328,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"an add parameters giving them a name and starting values. More information can be found in [api:parameters].; 4.2.3 MnUserCovariance; The user can (optionally) provide a covariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their ow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33312,interface,interface,33312,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"an be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. ~RooHistFunc(). Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Int_t getMaxVal(const RooArgSet& vars) const; Only handle case of maximum in all variables. Double_t maxVal(Int_t code) const. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:38608,depend,dependents,38608,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['depend'],['dependents']
Integrability,"an be in any format, e.g. png, gif, etc.; img = TImage::Open(Form(""image%d.jpg"", i));. if (i < 10) {; img->WriteImage(""anim.gif+10""); // 10 centiseconds delay; } else { // the last image written. ""++"" stands for infinit animation.; img->WriteImage(""anim.gif++10++""); // 10 centiseconds delay of last image; }; }; }. TImage::EImageFileTypes GetFileType(const char* ext); Return file type depending on specified extension.; Protected method. void MapFileTypes(TImage::EImageFileTypes& type, UInt_t& astype, Bool_t toas = kTRUE); Map file type to/from AfterImage types.; Protected method. void MapQuality(TAttImage::EImageQuality& quality, UInt_t& asquality, Bool_t toas = kTRUE); Map quality to/from AfterImage quality.; Protected method. void SetImage(const Double_t* imageData, UInt_t width, UInt_t height, TImagePalette* palette = 0); Deletes the old image and creates a new image depending on the values; of imageData. The size of the image is width X height.; The color of each pixel depends on the imageData of the corresponding; pixel. The palette is used to convert an image value into its color.; If palette is not defined (palette = 0) a default palette is used.; Any previously defined zooming is reset. void SetImage(const TArrayD& imageData, UInt_t width, TImagePalette* palette = 0); Delete the old image and creates a new image depending on the values; of imageData. The size of the image is width X (imageData.fN / width).; The color of each pixel depends on the imageData of the corresponding; pixel. The palette is used to convert an image value into its color.; If palette is not defined (palette = 0) a default palette is used.; Any previously defined zooming is reset. void SetImage(const TVectorD& imageData, UInt_t width, TImagePalette* palette = 0); Delete the old image and creates a new image depending on the values; of imageData. The size of the image is width X (imageData.fN / width).; The color of each pixel depends on the imageData of the corresponding; pixel. The palet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TASImage.html:24341,depend,depends,24341,root/html534/TASImage.html,https://root.cern,https://root.cern/root/html534/TASImage.html,2,['depend'],['depends']
Integrability,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:42640,message,message,42640,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,2,['message'],['message']
Integrability,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:40539,message,message,40539,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['message'],['message']
Integrability,"an nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:36487,integrat,integrator,36487,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,2,['integrat'],['integrator']
Integrability,"an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursiveness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:5925,interface,interface,5925,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"an resolution model; RooBMixDecay bmix_gm1(""bmix"", ""decay"", dt, mixState, tagFlav, tau, dm, w, dw, gm1, RooBMixDecay::DoubleSided);; ; // Generate BMixing data with above set of event errors; std::unique_ptr<RooDataSet> data{bmix_gm1.generate({dt, tagFlav, mixState}, 20000)};; ; // P l o t f u l l d e c a y d i s t r i b u t i o n; // ----------------------------------------------------------; ; // Create frame, plot data and pdf projection (integrated over tagFlav and mixState); RooPlot *frame = dt.frame(Title(""Inclusive decay distribution""));; data->plotOn(frame);; bmix_gm1.plotOn(frame);; ; // P l o t d e c a y d i s t r . f o r m i x e d a n d u n m i x e d s l i c e o f m i x S t a t e; // ------------------------------------------------------------------------------------------------------------------; ; // Create frame, plot data (mixed only); RooPlot *frame2 = dt.frame(Title(""Decay distribution of mixed events""));; data->plotOn(frame2, Cut(""mixState==mixState::mixed""));; ; // Position slice in mixState at ""mixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame2, Slice(mixState, ""mixed""));; ; // Create frame, plot data (unmixed only); RooPlot *frame3 = dt.frame(Title(""Decay distribution of unmixed events""));; data->plotOn(frame3, Cut(""mixState==mixState::unmixed""));; ; // Position slice in mixState at ""unmixed"" and plot slice of pdf in mixstate over data (integrated over tagFlav); bmix_gm1.plotOn(frame3, Slice(mixState, ""unmixed""));; ; TCanvas *c = new TCanvas(""rf310_sliceplot"", ""rf310_sliceplot"", 1200, 400);; c->Divide(3);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; gPad->SetLogy();; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; gPad->SetLogy();; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.4);; gPad->SetLogy();; frame3->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooBMixD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf310__sliceplot_8C.html:2751,integrat,integrated,2751,doc/master/rf310__sliceplot_8C.html,https://root.cern,https://root.cern/doc/master/rf310__sliceplot_8C.html,1,['integrat'],['integrated']
Integrability,"an up to 'scan - 1' ports starting from port + 1, i.e. ; port + 1, ... , port + scan - 1 ; Definition at line 94 of file TApplicationRemote.cxx. ◆ ~TApplicationRemote(). TApplicationRemote::~TApplicationRemote ; (; ). virtual . Destructor. ; Definition at line 256 of file TApplicationRemote.cxx. Member Function Documentation. ◆ ApplicationName(). const char * TApplicationRemote::ApplicationName ; (; ); const. inlineoverridevirtual . Reimplemented from TApplication.; Definition at line 101 of file TApplicationRemote.h. ◆ Broadcast() [1/3]. Int_t TApplicationRemote::Broadcast ; (; const char * ; str, . Int_t ; kind = kMESS_STRING, . Int_t ; type = kRRT_Undef . ). private . Broadcast a character string buffer to the remote session. ; Use kind to set the TMessage what field. Returns 0 on success, -1 in case of error. ; Definition at line 283 of file TApplicationRemote.cxx. ◆ Broadcast() [2/3]. Int_t TApplicationRemote::Broadcast ; (; const TMessage & ; mess). private . Broadcast a message to the remote session. ; Returns 0 on success, -1 in case of error. ; Definition at line 266 of file TApplicationRemote.cxx. ◆ Broadcast() [3/3]. Int_t TApplicationRemote::Broadcast ; (; Int_t ; kind, . Int_t ; type = kRRT_Undef . ). inlineprivate . Definition at line 86 of file TApplicationRemote.h. ◆ BroadcastObject(). Int_t TApplicationRemote::BroadcastObject ; (; const TObject * ; obj, . Int_t ; kind = kMESS_OBJECT . ). private . Broadcast an object to the remote session. ; Use kind to set the TMessage what field. Returns 0 on success, -1 in case of error. ; Definition at line 297 of file TApplicationRemote.cxx. ◆ BroadcastRaw(). Int_t TApplicationRemote::BroadcastRaw ; (; const void * ; buffer, . Int_t ; length . ). private . Broadcast a raw buffer of specified length to the remote session. ; Returns 0 on success, -1 in case of error. ; Definition at line 308 of file TApplicationRemote.cxx. ◆ Browse(). void TApplicationRemote::Browse ; (; TBrowser * ; b). overridevirtual . Browse r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:24787,message,message,24787,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['message'],['message']
Integrability,"an writing RVecs to disk. Note that, currently, RVecs written e.g. in a TTree cannot be read back using certain ROOT interfaces (e.g. TTreeReaderArray, RDataFrame and the experimental RNTuple). All these limitations will be lifted in v6.26.; Portable implementation of the RANLUX++ generator, see RanluxppEngine and our blog post.; Change TRandom3::GetSeed to return the current state element in the contained seed vector of TRandom3. The return value will now change after every call of TRandom3::Rndm (when generating a random number). Before the function was returning the first element of the state, which was changing only after 624 calls to Rndm().; Fix a bug in ROOT::Fit::BinData copy constructor; Fix a bug in applying a correction factor used for the computation of the fit confidence level in ROOT::Fit::FitResult.; TMatrix: optimize implementation of TPrincipal::AddRow that is heavily used by CMS. Minuit2. Add a new improved message logging system. Debug message now can be enabled in Minuit2 when using maximum print level.; When using external provided gradient, compute in MnSeed still numerical gradients to obtain correct step sizes and initial estimate of covariance matrix. This allows to start with a good first state estimation, reducing significantly the number of subsequent iterations. TMVA. Introducing TMVA PyTorch Interface, a method to use PyTorch internally with TMVA for deep learning. This can be used as an alternative to PyKeras Interface for complex models providing more flexibility and power.; Add support in the TMVA Keras interface for Tensorflow.Keras (the version embedded in Tensorflow) and for standalone Keras versions up to it latest 2.3. For using Tensorflow.Keras one needs to use the booking option tf.keras=True.; Update the TMVA Keras tutorials to use now tensorflow.keras.; Deprecate the MethodDNN in favour of MethodDL supporting both CNN and RNN; Add possibility to customize all relevant minimizer parameters used for training in MethodDL; Add s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:14965,message,message,14965,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['message'],['message']
Integrability,anConstruction. More...;  ; class  NuisanceParametersSampler;  Helper class for ToyMCSampler. More...;  ; class  NumberCountingPdfFactory;  A factory for building PDFs and data for a number counting combination. More...;  ; class  NumEventsTestStat;  NumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting. More...;  ; class  PdfProposal;  PdfProposal is a concrete implementation of the ProposalFunction interface. More...;  ; class  PointSetInterval;  PointSetInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  PosteriorCdfFunction;  ; class  PosteriorFunction;  ; class  PosteriorFunctionFromToyMC;  Posterior function obtaining sampling toy MC for the nuisance according to their pdf. More...;  ; class  ProfileInspector;  Utility class to plot conditional MLE of nuisance parameters vs. More...;  ; class  ProfileLikelihoodCalculator;  The ProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:6262,interface,interface,6262,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['interface'],['interface']
Integrability,"anDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TPostScript.h>. Inheritance diagram for TPostScript:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TPostScript() [1/2]. TPostScript::TPostScript ; (; ). Default PostScript constructor. ; Definition at line 269 of file TPostScript.cxx. ◆ TPostScript() [2/2]. TPostScript::TPostScript ; (; const char * ; fname, . Int_t ; wtype = -111 . ). Initialize the PostScript interface. . fname : PostScript file name; wtype : PostScript workstation type. The possible workstation types are:; 111 ps Portrait; 112 ps Landscape; 113 eps . Definition at line 346 of file TPostScript.cxx. ◆ ~TPostScript(). TPostScript::~TPostScript ; (; ). override . Default PostScript destructor. ; Definition at line 434 of file TPostScript.cxx. Member Function Documentation. ◆ CellArrayBegin(). void TPostScript::CellArrayBegin ; (; Int_t ; W, . Int_t ; H, . Double_t ; x1, . Double_t ; x2, . Double_t ; y1, . Double_t ; y2 . ). overridevirtual . Draw a Cell Array. ; Drawing a PostScript Cell Array is in fact done thanks to three procedures: CellArrayBegin, CellArrayFill, and CellArrayEnd. CellArrayBegin: Initiate the Cell Array by writing the necessary PostScript procedures and the initial values of the required parameters. The input parameters are:; W: number of boxes along the width.; H: number of boxes along the height; x1,x2,y1,y2: First box coordinates. CellArrayFill:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:37023,interface,interface,37023,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['interface'],['interface']
Integrability,"anStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:35440,integrat,integrator,35440,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,8,['integrat'],['integrator']
Integrability,"anager must be alive; 605 auto &prevNodePtr = *prevNodeOnHeap;; 606 auto &loopManager = *prevNodePtr->GetLoopManagerUnchecked();; 607 using ColTypes_t = TypeList<ColTypes...>;; 608 constexpr auto nColumns = ColTypes_t::list_size;; 609 auto ds = loopManager.GetDataSource();; 610 if (ds != nullptr); 611 AddDSColumns(cols, loopManager, *ds, ColTypes_t(), *colRegister);; 612 ; 613 auto actionPtr = BuildAction<ColTypes...>(cols, std::move(*helperArgOnHeap), nSlots, std::move(prevNodePtr),; 614 ActionTag{}, *colRegister);; 615 jittedActionOnHeap->SetAction(std::move(actionPtr));; 616 ; 617 doDeletes();; 618}; 619 ; 620/// The contained `type` alias is `double` if `T == RInferredType`, `U` if `T == std::container<U>`, `T` otherwise.; 621template <typename T, bool Container = IsDataContainer<T>::value && !std::is_same<T, std::string>::value>; 622struct RMinReturnType {; 623 using type = T;; 624};; 625 ; 626template <>; 627struct RMinReturnType<RInferredType, false> {; 628 using type = double;; 629};; 630 ; 631template <typename T>; 632struct RMinReturnType<T, true> {; 633 using type = TTraits::TakeFirstParameter_t<T>;; 634};; 635 ; 636// return wrapper around f that prepends an `unsigned int slot` parameter; 637template <typename R, typename F, typename... Args>; 638std::function<R(unsigned int, Args...)> AddSlotParameter(F &f, TypeList<Args...>); 639{; 640 return [f](unsigned int, Args... a) mutable -> R { return f(a...); };; 641}; 642 ; 643template <typename ColType, typename... Rest>; 644struct RNeedJittingHelper {; 645 static constexpr bool value = RNeedJittingHelper<Rest...>::value;; 646};; 647 ; 648template <typename... Rest>; 649struct RNeedJittingHelper<RInferredType, Rest...> {; 650 static constexpr bool value = true;; 651};; 652 ; 653template <typename T>; 654struct RNeedJittingHelper<T> {; 655 static constexpr bool value = false;; 656};; 657 ; 658template <>; 659struct RNeedJittingHelper<RInferredType> {; 660 static constexpr bool value = true;; 661};; 662 ; 663te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:28714,wrap,wrapper,28714,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['wrap'],['wrapper']
Integrability,"anager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooVoigtian.html:39343,integrat,integrator,39343,root/html528/RooVoigtian.html,https://root.cern,https://root.cern/root/html528/RooVoigtian.html,1,['integrat'],['integrator']
Integrability,"anagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:44014,integrat,integrator,44014,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,1,['integrat'],['integrator']
Integrability,"analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& analDeps, 			 const RooArgSet& refset); Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:58675,integrat,integration,58675,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['integrat'],['integration']
Integrability,"analysis context ;  CRegressionVarianceCalculate the ""SeparationGain"" for Regression analysis separation criteria used in various training algorithms ;  CResultsClass that is the base-class for a vector of result ;  CResultsClassificationClass that is the base-class for a vector of result ;  CResultsMulticlassClass which takes the results of a multiclass classification ;  CResultsRegressionClass that is the base-class for a vector of result ;  CRMethodBase;  CROCCalc;  CROCCurve;  CRootFinderRoot finding using Brents algorithm (translated from CERNLIB function RZERO) ;  CRuleImplementation of a rule ;  CRuleCutA class describing a 'rule cut' ;  CRuleEnsemble;  CRuleFitA class implementing various fits of rule ensembles ;  ►CRuleFitAPIJ Friedman's RuleFit method ;  CIntParms;  CRealParms;  CRuleFitParamsA class doing the actual fitting of a linear model using rules as base functions ;  CSdivSqrtSplusBImplementation of the SdivSqrtSplusB as separation criterion ;  CSeparationBaseAn interface to calculate the ""SeparationGain"" for different separation criteria used in various training algorithms ;  CSimulatedAnnealingBase implementation of simulated annealing fitting procedure ;  CSimulatedAnnealingFitterFitter using a Simulated Annealing Algorithm ;  CStatDialogBDT;  CStatDialogBDTReg;  CStatDialogMVAEffs;  CSVEventEvent class for Support Vector Machine ;  CSVKernelFunctionKernel for Support Vector Machine ;  CSVKernelMatrixKernel matrix for Support Vector Machine ;  CSVWorkingSetWorking class for Support Vector Machine ;  CTActivationInterface for TNeuron activation function classes ;  CTActivationChooserClass for easily choosing activation functions ;  CTActivationIdentityIdentity activation function for TNeuron ;  CTActivationRadialRadial basis activation function for ANN ;  CTActivationReLURectified Linear Unit activation function for TNeuron ;  CTActivationSigmoidSigmoid activation function for TNeuron ;  CTActivationTanhTanh activation function for ANN ;  CTimerT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:77749,interface,interface,77749,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['interface'],['interface']
Integrability,"analysis function. See “Example Analysis”.; In case one of the ntuple columns has a variable length (e.g. px(ntrack)), h.Draw(""px"") will histogram the px column for all tracks in the same histogram. Use the script quoted above to generate the skeleton function and create/fill the relevant histogram yourself.; 3 Histograms; This chapter covers the functionality of the histogram classes. We begin with an overview of the histogram classes, after which we provide instructions and examples on the histogram features.; We have put this chapter ahead of the graphics chapter so that you can begin working with histograms as soon as possible. Some of the examples have graphics commands that may look unfamiliar to you. These are covered in the chapter “Input/Output”.; 3.1 The Histogram Classes. ROOT supports histograms up to three dimensions. Separate concrete classes are provided for one-dimensional, two-dimensional and three-dimensional classes. The histogram classes are split into further categories, depending on the set of possible bin values:. TH1C, TH2C and TH3C contain one char (one byte) per bin (maximum bin content = 255); TH1S, TH2S and TH3S contain one short (two bytes) per bin (maximum bin content = 65 535).; TH1I, TH2I and TH3I contain one integer (four bytes) per bin (maximum bin content = 2 147 483 647).; TH1L, TH2L and TH3L contain one long64 (eight bytes) per bin (maximum bin content = 9 223 372 036 854 775 807).; TH1F, TH2F and TH3F contain one float (four bytes) per bin (maximum precision = 7 digits).; TH1D, TH2D and TH3D contain one double (eight bytes) per bin (maximum precision = 14 digits). ROOT also supports profile histograms, which constitute an elegant replacement of two-dimensional histograms in many cases. The inter-relation of two measured quantities X and Y can always be visualized with a two-dimensional histogram or scatter-plot. Profile histograms, on the other hand, are used to display the mean value of Y and its RMS for each bin in X. If Y is a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:70220,depend,depending,70220,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['depend'],['depending']
Integrability,"ance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TWebFile. ←. TS3WebFile. Function documentation; TWebFile(const char* url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. The url; argument must be of the form: http://host.dom.ain/file.root.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:25852,interface,interface,25852,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,2,['interface'],['interface']
Integrability,"ance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct way if the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:35385,interface,interface,35385,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"ance matrix for input if one is available. The covariance matrix can be supplied in form of a std::vector\(<\)double\(>\) in packed storage format (upper triangular), or in a more user-friendly way by using the interface provided by the MnUserCovariance.; 4.4 Running a M minimization; Two use cases are addressed for minimization:. The user just wants the function to be minimized in one go.; The user wants to minimize the \(\mbox{FCN}\) in several minimization steps, re-using the result of the preceeding minimization in the next step and change parameters in between (fix/release/put limits on them, etc.). How M minimizations can be performed is shown in [example:main].; 4.4.1 Direct usage of minimizers; Minimizers such as the VariableMetricMinimizer are designed as state-less minimization engines, which means that they do not depend on the current function and its parameters. Any \(\mbox{FCN}\) function can be minimized with the same minimizer. The interface is restricted to minimization and no parameter interaction is possible.; 4.4.2 Using an application (MnMigrad); MnMigrad uses the VariableMetricMinimizer for minimization but allows as well for parameter interaction by the user. An instance of MnMigrad is specific to the current \(\mbox{FCN}\) and user parameters. Any parameter interaction of the user between two minimization steps will make use of the result of the preceeding minimization in an optimal way. The interface for parameters (see [api:parameters], [api:covariance] and [api:state]) is forwardedin MnMigrad.; 4.4.3 Subsequent minimizations; M takes care that all information is treated in an optimal and correct wayif the user interacts with the parameters between two minimizations. MnMigrad retains the result of the last minimization and uses this as input for the next step. Between two minimization requests to MnMigrad the user can fix or release parameters, put limits on them or remove limits from them. Each instance of a MnMigrad object maintains its o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:39393,interface,interface,39393,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"ance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=CMES='SHO', it prints the messages in; *-* the circular buffer, FIFO, and empties the buffer.; *. void mnwerr(); -*Calculates the WERR, external parameter errors; *-* ==============================================; *-* and the global correlation coefficients, to be called; *-* whenever a new covariance matrix is available.; *. TMinuit& operator=(const TMinuit& m). TMethodCall * GetMethodCall() const; {return fMethodCall;}. TObject * GetObjectFit() const; {return fObjectFit;}. Int_t GetMaxIterations() const; {return fMaxIterations;}. TObject * GetPlot() const; {return fPlot;}. Int_t GetStatus() const; {return fStatus;}. void SetGraphicsMode(Bool_t mode = kTRUE); {fGraphicsMode = mode;}. void SetMaxIterations(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMinuit.html:56876,message,message,56876,root/html604/TMinuit.html,https://root.cern,https://root.cern/root/html604/TMinuit.html,1,['message'],['message']
Integrability,"anceParameters(const RooArgSet&); virtual voidRooStats::TestStatSampler::SetObservables(const RooArgSet&); virtual voidSetParameters(RooArgSet&); virtual voidSetParametersForTestStat(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidRooStats::TestStatSampler::SetPriorNuisance(RooAbsPdf*); virtual voidRooStats::TestStatSampler::SetSamplingDistName(const char* name); virtual voidSetTestSize(Double_t size); virtual voidSetTestStatistic(RooStats::TestStatistic*); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. TRandom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__DebuggingSampler.html:2372,interface,interface,2372,root/html534/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html534/RooStats__DebuggingSampler.html,1,['interface'],['interface']
Integrability,"anchClones in case the branch is an array of clone objects . Definition at line 93 of file TBranch.h. Public Member Functions;  TBranch ();  Default constructor. Used for I/O by default. ;  ;  TBranch (TBranch *parent, const char *name, void *address, const char *leaflist, Int_t basketsize=32000, Int_t compress=ROOT::RCompressionSetting::EAlgorithm::kInherit);  Create a Branch as a child of another Branch. ;  ;  TBranch (TTree *tree, const char *name, void *address, const char *leaflist, Int_t basketsize=32000, Int_t compress=ROOT::RCompressionSetting::EAlgorithm::kInherit);  Create a Branch as a child of a Tree. ;  ;  ~TBranch () override;  Destructor. ;  ; virtual void AddBasket (TBasket &b, bool ondisk, Long64_t startEntry);  Add the basket to this branch. ;  ; virtual void AddLastBasket (Long64_t startEntry);  Add the start entry of the write basket (not yet created) ;  ; Int_t BackFill ();  Loop on all leaves of this branch to back fill Basket buffer. ;  ; void Browse (TBrowser *b) override;  Browser interface. ;  ; virtual void DeleteBaskets (Option_t *option="""");  Loop on all branch baskets. ;  ; virtual void DropBaskets (Option_t *option="""");  Loop on all branch baskets. ;  ; void ExpandBasketArrays ();  Increase BasketEntry buffer of a minimum of 10 locations and a maximum of 50 per cent of current size. ;  ; Int_t Fill ();  ; virtual Int_t FillImpl (ROOT::Internal::TBranchIMTHelper *);  Loop on all leaves of this branch to fill Basket buffer. ;  ; virtual TBranch * FindBranch (const char *name);  Find the immediate sub-branch with passed name. ;  ; virtual TLeaf * FindLeaf (const char *name);  Find the leaf corresponding to the name 'searchname'. ;  ; Int_t FlushBaskets ();  Flush to disk all the baskets of this branch and any of subbranches. ;  ; Int_t FlushOneBasket (UInt_t which);  If we have a write basket in memory and it contains some entries and has not yet been written to disk, we write it and delete it from memory. ;  ; virtual char * GetAddress ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:1692,interface,interface,1692,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['interface'],['interface']
Integrability,"anches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddition(). RooAddition(const char* name, const char* title, const RooArgSet& sumSet,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:33460,integrat,integrator,33460,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,1,['integrat'],['integrator']
Integrability,"and YW(1) are written in the PostScript file; according to the current NT.; If nn>0 the line is clipped as a line.; If nn<0 the line is clipped as a fill area. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); Draw a PolyLine. Draw a polyline through the points xw,yw.; If nn=1 moves only to point xw,yw.; If nn=0 the xw(1) and YW(1) are written in the PostScript file; according to the current NT.; If nn>0 the line is clipped as a line.; If nn<0 the line is clipped as a fill area. void DrawHatch(Float_t dy, Float_t angle, Int_t n, Float_t* x, Float_t* y); Draw Fill area with hatch styles. void DrawHatch(Float_t dy, Float_t angle, Int_t n, Double_t* x, Double_t* y); Draw Fill area with hatch styles. Bool_t FontEmbedType1(const char* filename). Bool_t FontEmbedType2(const char* filename). Bool_t FontEmbedType42(const char* filename). void FontEmbed(void); Embed font in PS file. void FontEncode(); Font Re-encoding. void Initialize(); PostScript Initialisation. This routine initialize the following PostScript procedures:. +------------+------------------+-----------------------------------+; | Macro Name | Input parameters | Explanation |; +------------+------------------+-----------------------------------+; | l | x y | Draw a line to the x y position |; +------------+------------------+-----------------------------------+; | m | x y | Move to the position x y |; +------------+------------------+-----------------------------------+; | box | dx dy x y | Define a box |; +------------+------------------+-----------------------------------+; | bl | dx dy x y | Draw a line box |; +------------+------------------+-----------------------------------+; | bf | dx dy x y | Draw a filled box |; +------------+------------------+-----------------------------------+; | t | x y | Translate |; +------------+------------------+-----------------------------------+; | r | angle | Rotate |; +------------+------------------+-----------------------------------+; | rl | i j | Roll the stack |;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPostScript.html:25024,rout,routine,25024,root/html604/TPostScript.html,https://root.cern,https://root.cern/root/html604/TPostScript.html,1,['rout'],['routine']
Integrability,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8C.html:2231,integrat,integrating,2231,doc/master/rf609__xychi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html,1,['integrat'],['integrating']
Integrability,"and fitted pdf; RooPlot *frame = x.frame(Bins(25));; d->plotOn(frame);; projModel->plotOn(frame);; ; // Make 2d histogram of model(x;mean); TH1 *hh = model.createHistogram(""hh"", x, Binning(50), YVar(mean, Binning(50)), ConditionalObservables(mean));; hh->SetTitle(""histogram of model(x|mean)"");; hh->SetLineColor(kBlue);; ; // Draw frame on canvas; TCanvas *c = new TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataHist.h; RooFFTConvPdf.h; RooFormulaVar.h; RooGaussian.h; RooGenericPdf.h; RooPlot.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TH2.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:2806,interface,interface,2806,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,1,['interface'],['interface']
Integrability,"and functions.; In this case ROOT::Fit::Fitter::SetFCN is used to set the method function and ROOT::Fit::FitFCN is used for fitting. The method function can be passed also in ROOT::Fit::FitFCN, but in this case a previously defined fitting configuration is used.; The possible type of method functions that are based in ROOT::Fit::Fitter::SetFCN are:. A generic functor object implementing operator()(const double * p) where p is the parameter vectors. In this case one needs to pass the number of parameters, the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit). In the last two parameters are given, the chi2/ndf can be computed after fitting the data. template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::IBaseFunctionMultiDim interface:. bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::FitMethodFunction interface. This is an interface class extending the ROOT::Math::IBaseFunctionMultiDim with some extra functionality which can be used when fitting. This extra functionality is required by dedicated fitting algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:209576,interface,interface,209576,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"and marker attributes ;  CTEveLineEditorEditor for TEveLine class ;  CTEveLineGLGL-renderer for TEveLine class ;  CTEveLineProjectedProjected copy of a TEveLine ;  CTEveListTreeItemSpecial list-tree-item for Eve ;  CTEveMacroSub-class of TMacro, overriding Exec to unload the previous version and cleanup after the execution ;  CTEveMagFieldAbstract base-class for interfacing to magnetic field needed by the TEveTrackPropagator ;  CTEveMagFieldConstImplements constant magnetic field, given by a vector fB ;  CTEveMagFieldDuoImplements constant magnetic filed that switches on given axial radius fR2 from vector fBIn to fBOut ;  ►CTEveManagerCentral application manager for Eve ;  CTExceptionHandlerException handler for Eve exceptions ;  CTRedrawDisabler;  CTEveMCRecCrossRef;  CTEveMCTrack;  CTEventIter;  CTEventIterObj;  ►CTEventIterTree;  CTFileTree;  CTEventIterUnit;  CTEventListA TEventList object is a list of selected events (entries) in a TTree ;  CTEvePadThis was intended as a TPad wrapper to allow smart updates of groups of pads ;  CTEvePadHolderException safe wrapper for setting gPad ;  ►CTEveParamListCollection of named parameters ;  CBoolConfig_t;  CFloatConfig_t;  CIntConfig_t;  CTEveParamListEditorGUI editor for TEveParamList ;  CTEvePathMarkTSpecial-point on track: ;  CTEvePlot3DDescription of TEvePlot3D ;  CTEvePlot3DGLOpenGL renderer class for TEvePlot3D ;  CTEvePointSelectorTEvePointSelector is a sub-class of TSelectorDraw for direct extraction of point-like data from a Tree ;  CTEvePointSelectorConsumerTEvePointSelectorConsumer is a virtual base for classes that can be filled from TTree data via the TEvePointSelector class ;  CTEvePointSetTEvePointSet is a render-element holding a collection of 3D points with optional per-point TRef and an arbitrary number of integer ids (to be used for signal, volume-id, track-id, etc) ;  CTEvePointSetArrayAn array of point-sets with each point-set playing a role of a bin in a histogram ;  CTEvePointSetArrayEditorEditor f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:105375,wrap,wrapper,105375,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['wrap'],['wrapper']
Integrability,"and other data formats ;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree ;  CTPoolManagerA manager for the scheduler behind ROOT multithreading operations ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTReadLockGuard;  CTReentrantRWLock;  CTRWMutexImp;  CTRWSpinLock;  CTRWSpinLockReadGuard;  CTRWSpinLockWriteGuard;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSequentialExecutor;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►CTVirtualRWMutex;  CStateEarlier lock state as returned by GetState() that can be passed to Restore() ;  CStateDeltaState as returned by GetStateDelta() that can be passed to Restore() ;  CTWriteLockGuard;  CTypeTraits;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  Ccheck_bound_t;  Cspan;  ►NDetail;  Cnot_fn_t;  C__make_integer_sequence_checked;  Chash< nlohmann::json >Hash value for JSON objects ;  Cinteger_sequence;  Cless< ROOT::Internal::RConcurrentHashColl::HashValue >;  ►NTClassEdit;  CFunctionSplitInfoResult of splitting a function declaration into fReturnType fScopeName::fFunctionName<fFunctionTemplateArguments>(fFunctionParameters) ;  CTInterpreterLookupHelper;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:76260,interface,interface,76260,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['interface'],['interface']
Integrability,"and parses them into data structures that are easier to work with. More...;  ; struct  PrintUsageImplementation;  ; struct  Stats;  Determines the minimum lengths of the buffer and options arrays used for Parser. More...;  . Typedefs; typedef ArgStatus(* CheckArg) (const Option &option, bool msg);  Signature of functions that check if an argument is valid for a certain type of option. ;  . Enumerations; enum  ArgStatus { ARG_NONE; , ARG_OK; , ARG_IGNORE; , ARG_ILLEGAL; };  Possible results when checking if an argument is valid for a certain option. More...;  . Functions; template<typename Temporary > ; void printUsage (const Temporary &prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75);  ; template<typename Function > ; void printUsage (Function *prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75);  ; template<typename Function , typename Stream > ; void printUsage (Function *prn, Stream *stream, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75);  ; template<typename OStream > ; void printUsage (OStream &prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75);  Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping. ;  ; template<typename Syscall > ; void printUsage (Syscall *prn, int fd, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75);  . Detailed Description; The namespace of The Lean Mean C++ Option Parser. ; Typedef Documentation. ◆ CheckArg. typedef ArgStatus(* ROOT::option::CheckArg) (const Option &option, bool msg). Signature of functions that check if an argument is valid for a certain type of option. ; Every Option has such a function assigned in its Descriptor. Descriptor usage[] = { {UNKNOWN, 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1option.html:2072,wrap,wrapping,2072,doc/master/namespaceROOT_1_1option.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1option.html,2,['wrap'],['wrapping']
Integrability,"and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values \(F_{i}\) are fitted with theoretical functions \(f_{i}(\vec{x_{i}},\vec{\theta})\), where \(\vec{x_{i}}\) are coordinates, and \(\vec{\theta}\) - vector of parameters. Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:226458,depend,dependency,226458,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['depend'],['dependency']
Integrability,"and spread. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__RuleFit.html:6090,rout,routine,6090,root/html528/TMVA__RuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__RuleFit.html,3,['rout'],['routine']
Integrability,"and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; The method IsEnabled() - returns kTRUE if the widget has flag kWidgetIsEnabled and it accepts user events. This method is very important for creating a good user interface because it allows you to disable or enable a widget depending on the situation of your application. As a standard all disabled widgets are displayed “grayed out”. HasFocus() - returns kTRUE if the widget has the input focus (i.e. flag kWidgetHasFocus is set). Remember that only one item in a complex widget as a dialog can have the value of HasFocus() sets as true. WantFocus() - returns kTRUE if the flag kWidgetWantFocus is set.; 25.5.3 TGWindow; TGWindow is a ROOT GUI window base class. It inherits from TGObject and TGFrame derives from it. The application does not use it directly. It creates and registers a new window within the system. This window has common characteristics: existing parent, location, size in height and width (it has a default minimum size 1, 1 under which it cannot shrink), border with particular view, state, specific attributes. If there are no specified arguments their values will be taken from the parent. It receives events from the window system and can paint a representation of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1149092,interface,interface,1149092,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['depend', 'interface']","['depending', 'interface']"
Integrability,"and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is computed (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also done. ; Make the expected plot and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is drawn (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn The first band is drawn in green while the second in yellow THe return result is a TMultiGraph object.; The first band is drawn in green while the second in yellow The plot (expected value + bands) is returned as a TMultiGraph object ; Definition at line 149 of file HypoTestInverterPlot.cxx. ◆ MakePlot(). TGraphErrors * HypoTestInverterPlot::MakePlot ; (; Option_t * ; opt = """"). return a TGraphErrors with the obtained observed p-values resultinf from the scan By default (Option = """") return CLs or CLsb depending if the flag UseCLs is set If Option = ""CLb"" return CLb plot = ""CLs+b"" return CLs+b plot independently of the flag = ""CLs"" return CLs plot independently of the flag ; Make the plot of the result of the scan using the observed data.; By default plot CLs or CLsb depending if the flag UseCLs is set for the results that are passed to this instance.; Parameters. optOptions according to following list:; Empty: Return CLs or CLs+b depending on the value of UseCLs.ƒ; ""CLB"": return CLb plot; ""CLS+B"" / ""CLSPLUSB"": return CLs+b plot independently of the flag; ""CLS"": return CLs plot independently of the flag . Definition at line 80 of file HypoTestInverterPlot.cxx. ◆ MakeTestStatPlot(). SamplingDistPlot * HypoTestInverterPlot::MakeTestStatPlot ; (; int ; index, . int ; type = 0, . int ; nbins = 100 . ). Plot the test statistic distributions. ; Parameters. indexIndex of the result stored in HypoTestInverterResult ; typeType of the test (see below) ; nbinsNumber of bins; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B) . Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html:16444,depend,depending,16444,doc/master/classRooStats_1_1HypoTestInverterPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html,1,['depend'],['depending']
Integrability,"and vertical) combination of TPadLengths ;  CTPadPainterAbstract interface for object painting on the pad/canvas ;  CTPadUserAxisBaseBase class for user coordinates (e.g ;  ►CTUniWeakPtr;  CAccessorGives transparent access to the shared or unique pointer ;  ►CTVirtualCanvasPainterAbstract interface for painting a canvas ;  CGenerator;  ►CTAxisBaseHistogram axis base class ;  Cconst_iteratorRandom const_iterator through bins ;  ►CTAxisConfigObjects used to configure the different axis types ;  CGrow_tTag type signalling that an axis should be able to grow; used for calling the appropriate constructor ;  CTAxisEquidistantAxis with equidistant bin borders ;  CTAxisGrowAn axis that can extend its range, keeping the number of its bins unchanged ;  CTAxisIrregularAn axis with non-equidistant bins (also known as ""variable binning"") ;  CTAxisLabelsA TAxisGrow that has a label assigned to each bin and a bin width of 1 ;  CTAxisViewCommon view on a TAxis, no matter what its kind ;  CTBufferMergerTBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file ;  CTBufferMergerFile;  CTCanvasA window's topmost TPad ;  ►CTDirectoryKey/value store of objects ;  CToContentType;  CTDirectoryTypeMismatchObjects of this class are thrown to signal that the value known under the given name ;  CTDirectoryUnknownKeyObjects of this class are thrown to signal that no key with that name exists ;  CTDrawableBase class for drawable entities: objects that can be painted on a TPad ;  CTDrawableBase;  ►CTFileA ROOT file ;  COptions_tOptions for TFile construction ;  CTFilePtrPoints to an object that stores or reads objects in ROOT's binary format ;  CTFitResult;  ►CTFrameHolds a user coordinate system with a palette ;  CDrawingOpts;  CTFunction;  CTFutureA TFuture class. It can wrap an std::future ;  CTHistHistogram class for histograms with DIMENSIONS dimensions, where each bin count is stored by a value of type PRECISION ;  CTHist< D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:17921,interface,interface,17921,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['interface'],['interface']
Integrability,and worker information; TProofOutputFile Wrapper class to steer the merging of files produced on workers; TProofOutputList Output list specific TList derivation; TProofPerfAnalysis Set of tools to analyse the performance tree; TProofPlayer Basic PROOF player; TProofPlayerLite PROOF player running in PROOF-Lite; TProofPlayerLocal PROOF player running on client; TProofPlayerRemote PROOF player running on master server; TProofPlayerSlave PROOF player running on slave server; TProofPlayerSuperMaster PROOF player running on super master; TProofProgressDialog PROOF progress dialog; TProofProgressInfo Progress information; TProofProgressLog Class implementing a log graphic box; TProofProgressMemoryPlot PROOF progress memory plots; TProofProgressStatus Proof progress status class; TProofQueryResult Class describing a PROOF query; TProofResources Abstract class describing PROOF resources; TProofResourcesStatic Class to handle PROOF static config; TProofServ PROOF Server Application Interface; TProofServLite PROOF-Lite Server Application Interface; TProofSuperMaster PROOF control class for making submasters; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t> Class describing a vector container; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t> Class describing a vector container; TPyDispatcher Python dispatcher class; TPyMultiGenFunction Python for Math::IMultiGenFunction equivalent; TPyMultiGradFunction Python for Math::IMultiGradFunction equivalent; TPyReturn Python morphing return object; TPySelector Python equivalent base class for PROOF; TPythia8 Interface class of Pythia8; TPythia8Decayer Particle Decayer using Pythia8; TPython Access to the python interpreter; TQApplication creates ROOT environment with the Qt windowing system; TQCanvasImp ABC describing Qt GUI independent main window; TQCanvasMenu interface to Qt based context sensitive popup menus; TQClass Class with connections; TQCommand encapsulates the information for undo/redo a single action.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:124740,interface,interface,124740,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['interface'],['interface']
Integrability,"and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; unsigned long RndmInt (unsigned long max) const;  Generate an integer number between [0,max-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; void SetSeed (unsigned int seed) const;  set the random generator seed ;  ; unsigned int Size () const;  return the state size of generator ;  ; void Terminate ();  delete pointer to contained rng ;  . Friends; class GSLMCIntegrator;  . Random Distributions; Implemented using the GSL Random number Distributions . GSLRngWrapper * fRng;  ; unsigned int fCurTime;  ; double Gaussian (double sigma) const;  Gaussian distribution - default method is Box-Muller (polar method) ;  ; double GaussianZig (double sigma) const;  Gaussian distribution - Ziggurat method. ;  ; double GaussianRatio (double sigma) const;  Gaussian distribution - Ratio method. ;  ; double GaussianTail (double a, double sigma) const;  Gaussian Tail distribution. ;  ; void Gaussian2D (double sigmaX, double sigmaY, double rho, double &x, double &y) const;  Bivariate Gaussian distribution with correlation. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html:2471,message,message,2471,doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html,1,['message'],['message']
Integrability,"and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; unsigned long RndmInt (unsigned long max) const;  Generate an integer number between [0,max-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; void SetSeed (unsigned int seed) const;  set the random generator seed ;  ; unsigned int Size () const;  return the state size of generator ;  ; void Terminate ();  delete pointer to contained rng ;  ; double Gaussian (double sigma) const;  Gaussian distribution - default method is Box-Muller (polar method) ;  ; double GaussianZig (double sigma) const;  Gaussian distribution - Ziggurat method. ;  ; double GaussianRatio (double sigma) const;  Gaussian distribution - Ratio method. ;  ; double GaussianTail (double a, double sigma) const;  Gaussian Tail distribution. ;  ; void Gaussian2D (double sigmaX, double sigmaY, double rho, double &x, double &y) const;  Bivariate Gaussian distribution with correlation. ;  ; void GaussianND (size_t dim, const double *pars, const double *covmat, double *genpars, double *lmat=nullptr) const;  Multivariate Gaussian distribution. ;  ; doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html:2270,message,message,2270,doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html,14,['message'],['message']
Integrability,"anda distribution and sigma is not the standard deviation of the distribution which is not defined.; For mu =0 and sigma=1, the mpv = -0.22278; The Landau random number generation is implemented using the function landau_quantile(x,sigma), which provides the inverse of the landau cumulative distribution. landau_quantile has been converted from CERNLIB ranlan(G110). ; Definition at line 191 of file RandomFunctions.cxx. ◆ Poisson(). Int_t ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Poisson ; (; double ; mean). Generates a random integer N according to a Poisson law. ; Prob(N) = exp(-mean)*mean^N/Factorial(N); Prob(N) = exp(-mean)*mean^N/Factorial(N); Use a different procedure according to the mean value. The algorithm is the same used by CLHEP. For lower value (mean < 25) use the rejection method based on the exponential. For higher values use a rejection method comparing with a Lorentzian distribution, as suggested by several authors. This routine since is returning 32 bits integer will not work for values larger than 2*10**9. One should then use the Trandom::PoissonD for such large values. ; Definition at line 213 of file RandomFunctions.cxx. ◆ PoissonD(). Double_t ROOT::Math::RandomFunctionsImpl< TRandomEngine >::PoissonD ; (; double ; mean). Generates a random number according to a Poisson law. ; Prob(N) = exp(-mean)*mean^N/Factorial(N); This function is a variant of RandomFunctionsImpl<TRandomEngine>::Poisson returning a double instead of an integer. ; Definition at line 265 of file RandomFunctions.cxx. ◆ Rannor(). void ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Rannor ; (; double & ; a, . double & ; b . ). Generate numbers distributed following a gaussian with mean=0 and sigma=1. ; Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.; Using the Box-Muller method ; Definition at line 312 of file RandomFunctions.cxx. ◆ Rndm(). double ROOT::Math::RandomFunctionsImpl< TRandomEngine >::Rndm ; (; ). inlineprivate . Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1RandomFunctionsImpl_3_01TRandomEngine_01_4.html:5687,rout,routine,5687,doc/master/classROOT_1_1Math_1_1RandomFunctionsImpl_3_01TRandomEngine_01_4.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1RandomFunctionsImpl_3_01TRandomEngine_01_4.html,1,['rout'],['routine']
Integrability,"andard constructor for the H-Matrix method. MethodHMatrix(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. void Init( void ); default initialization called by all constructors. ~MethodHMatrix( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); MethodHMatrix options: none (apart from those implemented in MethodBase). void ProcessOptions(); process user options. void Train( void ); computes H-matrices for signal and background samples. void ComputeCovariance(Bool_t , TMatrixD* ); compute covariance matrix. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the H-matrix signal estimator. Double_t GetChi2(TMVA::Types::ESBType ); compute chi2-estimator for event according to type (signal/background). void AddWeightsXMLTo(void* parent) const; create XML description for HMatrix classification. void ReadWeightsFromXML(void* wghtnode); read weights from XML file. void ReadWeightsFromStream(istream& istr); read variable names and min/max; NOTE: the latter values are mandatory for the normalisation; in the reader application !!!. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodHMatrix.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodHMatrix.html:18697,message,message,18697,root/html532/TMVA__MethodHMatrix.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodHMatrix.html,1,['message'],['message']
Integrability,"andau( (x-mu)/sigma ) Note that mu is not the mpv(most probable value) of the Landa distribution and sigma is not the standard deviation of the distribution which is not defined. ; For mu =0 and sigma=1, the mpv = -0.22278; The Landau random number generation is implemented using the function landau_quantile(x,sigma), which provides the inverse of the landau cumulative distribution. landau_quantile has been converted from CERNLIB ranlan(G110). ; Definition at line 381 of file TRandom.cxx. ◆ Poisson(). ULong64_t TRandom::Poisson ; (; Double_t ; mean). virtual . Generates a random integer N according to a Poisson law. ; Prob(N) = exp(-mean)*mean^N/Factorial(N); Use a different procedure according to the mean value. The algorithm is the same used by CLHEP. For lower value (mean < 25) use the rejection method based on the exponential. For higher values use a rejection method comparing with a Lorentzian distribution, as suggested by several authors. This routine returns now an unsigned 64 bit integer For large values, larger than 1.84e+19, we print an error message advising to use the Trandom::PoissonD for such large values, and return the max value UINT64_MAX ; Definition at line 404 of file TRandom.cxx. ◆ PoissonD(). Double_t TRandom::PoissonD ; (; Double_t ; mean). virtual . Generates a random number according to a Poisson law. ; Prob(N) = exp(-mean)*mean^N/Factorial(N); This function is a variant of TRandom::Poisson returning a double instead of an integer. ; Definition at line 461 of file TRandom.cxx. ◆ Rannor() [1/2]. void TRandom::Rannor ; (; Double_t & ; a, . Double_t & ; b . ). virtual . Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. ; Definition at line 522 of file TRandom.cxx. ◆ Rannor() [2/2]. void TRandom::Rannor ; (; Float_t & ; a, . Float_t & ; b . ). virtual . Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. ; Definition at line 507 of file TRandom.cxx. ◆ ReadRandom(). void TRandom::ReadRandom ; (; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom.html:31068,rout,routine,31068,doc/master/classTRandom.html,https://root.cern,https://root.cern/doc/master/classTRandom.html,1,['rout'],['routine']
Integrability,"andler (protected). ;  ; void MakeZombie ();  . Inheritance diagram for TIconBoxThumb:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TIconBoxThumb(). TIconBoxThumb::TIconBoxThumb ; (; const char * ; name, . const TGPicture * ; spic, . const TGPicture * ; pic . ). inline . Definition at line 244 of file TRootBrowserLite.cxx. Member Function Documentation. ◆ GetName(). const char * TIconBoxThumb::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 250 of file TRootBrowserLite.cxx. ◆ Hash(). ULong_t TIconBoxThumb::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TIconBoxThumb::HashULong_t Hash() const overrideReturn hash value for this object.Definition TRootBrowserLite.cxx:249; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid Recu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTIconBoxThumb.html:10485,rout,routine,10485,doc/master/classTIconBoxThumb.html,https://root.cern,https://root.cern/doc/master/classTIconBoxThumb.html,1,['rout'],['routine']
Integrability,andler (protected). ;  ; void MakeZombie ();  . Protected Attributes; ROOT::R::TRFunctionImport asfactor;  ; ROOT::R::TRFunctionImport C50;  ; ROOT::R::TRFunctionImport C50Control;  ; UInt_t fControlBands;  ; Double_t fControlCF;  ; Bool_t fControlEarlyStopping;  ; Bool_t fControlFuzzyThreshold;  ; UInt_t fControlMinCases;  ; Bool_t fControlNoGlobalPruning;  ; Double_t fControlSample;  ; Int_t fControlSeed;  ; Bool_t fControlSubset;  ; Bool_t fControlWinnow;  ; ROOT::R::TRObject * fModel;  ; ROOT::R::TRObject fModelControl;  ; UInt_t fMvaCounter;  ; UInt_t fNTrials;  ; Bool_t fRules;  ; std::vector< TString > ListOfVariables;  ; ROOT::R::TRFunctionImport predict;  ;  Protected Attributes inherited from TMVA::RMethodBase; ROOT::R::TRDataFrame fDfSpectators;  ; ROOT::R::TRDataFrame fDfTest;  ; ROOT::R::TRDataFrame fDfTrain;  ; std::vector< std::string > fFactorTest;  ; std::vector< std::string > fFactorTrain;  ; TVectorD fWeightTest;  ; TVectorD fWeightTrain;  ; ROOT::R::TRInterface & r;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Bool_t IsM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodC50.html:25933,message,message,25933,doc/master/classTMVA_1_1MethodC50.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodC50.html,1,['message'],['message']
Integrability,"andling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:9214,synchroniz,synchronize,9214,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,1,['synchroniz'],['synchronize']
Integrability,"andling. More...;  ; class  OptionMap;  class to storage options for the differents methods More...;  ; class  PDEFoam;  Implementation of PDEFoam. More...;  ; class  PDEFoamCell;  ; class  PDEFoamDecisionTree;  This PDEFoam variant acts like a decision tree and stores in every cell the discriminant. More...;  ; class  PDEFoamDecisionTreeDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  PDEFoamDensityBase;  This is an abstract class, which provides an interface for a PDEFoam density estimator. More...;  ; class  PDEFoamDiscriminant;  This PDEFoam variant stores in every cell the discriminant. More...;  ; class  PDEFoamDiscriminantDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  PDEFoamEvent;  This PDEFoam variant stores in every cell the sum of event weights and the sum of the squared event weights. More...;  ; class  PDEFoamEventDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  PDEFoamKernelBase;  This class is the abstract kernel interface for PDEFoam. More...;  ; class  PDEFoamKernelGauss;  This PDEFoam kernel estimates a cell value for a given event by weighting all cell values with a gauss function. More...;  ; class  PDEFoamKernelLinN;  This PDEFoam kernel estimates a cell value for a given event by weighting with cell values of the nearest neighbor cells. More...;  ; class  PDEFoamKernelTrivial;  This class is a trivial PDEFoam kernel estimator. More...;  ; class  PDEFoamMultiTarget;  This PDEFoam variant is used to estimate multiple targets by creating an event density foam (PDEFoamEvent), which has dimension: More...;  ; class  PDEFoamTarget;  This PDEFoam variant stores in every cell the average target fTarget (see the Constructor) as well as the statistical error on the target fTarget. More...;  ; class  PDEFoamTargetDensity;  This is a concrete implementation of PDEFoam. More...;  ; class  PDEFoamVect;  ; class  PDF;  PDF wrapper for histograms; uses user-defined spline interpola",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:9023,interface,interface,9023,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['interface'],['interface']
Integrability,"andom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIntegral(Bool_t onlyPositive); 2540{; 2541 if (fBuffer) BufferEmpty();; 2542 ; 2543 // delete previously computed integral (if any); 2544 if (fIntegral) delete [] fIntegral;; 2545 ; 2546 // - Allocate space to store the integral and compute integral; 2547 Int_t nbinsx = GetNbinsX();; 2548 Int_t nbinsy = GetNbinsY();; 2549 Int_t nbinsz = GetNbinsZ();; 2550 Int_t nbins = nbinsx * nbinsy * nbinsz;; 2551 ; 2552 fIntegral = new Double_t[nbins + 2];; 2553 Int_t ibin = 0; fIntegral[ibin] = 0;; 2554 ; 2555 for (Int_t binz=1; binz <= nbinsz; ++binz) {; 2556 for (Int_t biny=1; biny <= nbinsy; ++biny) {; 2557 for (Int_t binx=1; binx <= nbinsx; ++binx) {; 2558 ++ibin;; 2559 Double_t y = RetrieveBinContent(GetBin(binx, biny, binz));; 2560 if (onlyPositive && y < 0) {; 2561 Error(""ComputeIntegral"",""Bin content is negative - return a NaN value"");; 2562 fIntegral[nbins] = TMath::QuietNaN();; 2563 break;; 2564 }; 2565 fIntegral[ibin] = fIntegral[ibin - 1] + y;; 2566 }; 2567 }; 2568 }; 2569 ; 2570 // - Normalize integral to 1; 2571 if (fIntegral[nbins] == 0 ) {; 2572 Error(""ComputeIntegral"", ""Integral = 0, no hits in histogram bins (excluding over/underflow)."");; 2573 return 0;; 2574 }; 2575 for (Int_t bin=1; bin <= nbins; ++bin) fIntegral[bin] /= fIntegral[nbins];; 2576 fIntegral[nbins+1] = fEntries;; 2577 return fIntegral[nbins];; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:100808,rout,routine,100808,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['rout'],['routine']
Integrability,"ands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is drawn (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn The first band is drawn in green while the second in yellow THe return result is a TMultiGraph object.; The first band is drawn in green while the second in yellow The plot (expected value + bands) is returned as a TMultiGraph object ; Definition at line 149 of file HypoTestInverterPlot.cxx. ◆ MakePlot(). TGraphErrors * HypoTestInverterPlot::MakePlot ; (; Option_t * ; opt = """"). return a TGraphErrors with the obtained observed p-values resultinf from the scan By default (Option = """") return CLs or CLsb depending if the flag UseCLs is set If Option = ""CLb"" return CLb plot = ""CLs+b"" return CLs+b plot independently of the flag = ""CLs"" return CLs plot independently of the flag ; Make the plot of the result of the scan using the observed data.; By default plot CLs or CLsb depending if the flag UseCLs is set for the results that are passed to this instance.; Parameters. optOptions according to following list:; Empty: Return CLs or CLs+b depending on the value of UseCLs.ƒ; ""CLB"": return CLb plot; ""CLS+B"" / ""CLSPLUSB"": return CLs+b plot independently of the flag; ""CLS"": return CLs plot independently of the flag . Definition at line 80 of file HypoTestInverterPlot.cxx. ◆ MakeTestStatPlot(). SamplingDistPlot * HypoTestInverterPlot::MakeTestStatPlot ; (; int ; index, . int ; type = 0, . int ; nbins = 100 . ). Plot the test statistic distributions. ; Parameters. indexIndex of the result stored in HypoTestInverterResult ; typeType of the test (see below) ; nbinsNumber of bins; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B) . Definition at line 395 of file HypoTestInverterPlot.cxx. ◆ Streamer(). void RooStats::HypoTestInverterPlot::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html:16714,depend,depending,16714,doc/master/classRooStats_1_1HypoTestInverterPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html,1,['depend'],['depending']
Integrability,"ange settings on z-axis. ; Definition at line 2934 of file TFitEditor.cxx. ◆ DoUpdate(). void TFitEditor::DoUpdate ; (; ). virtual . Easy here! ; Definition at line 1971 of file TFitEditor.cxx. ◆ DoUseFuncRange(). void TFitEditor::DoUseFuncRange ; (; ). virtual . Definition at line 1916 of file TFitEditor.cxx. ◆ DoUserDialog(). void TFitEditor::DoUserDialog ; (; ). virtual . Open a dialog for getting a user defined method. ; Definition at line 2941 of file TFitEditor.cxx. ◆ DrawSelection(). void TFitEditor::DrawSelection ; (; bool ; restore = false). protected . Draws the square around the object showing where the limits for fitting are. ; Definition at line 2808 of file TFitEditor.cxx. ◆ FillDataSetList(). void TFitEditor::FillDataSetList ; (; ). protected . Create a combo box with all the possible objects to be fitted. ; Definition at line 1824 of file TFitEditor.cxx. ◆ FillFunctionList(). void TFitEditor::FillFunctionList ; (; Int_t ; selected = -1). Fills the list of functions depending on the type of fit selected. ; Definition at line 1611 of file TFitEditor.cxx. ◆ FillMinMethodList(). void TFitEditor::FillMinMethodList ; (; Int_t ; selected = -1). Fills the list of methods depending on the minimization library selected. ; Definition at line 1740 of file TFitEditor.cxx. ◆ FindFunction(). TF1 * TFitEditor::FindFunction ; (; ). protected . This method looks among the functions stored by the fitpanel, the one that is currently selected in the fFuncList. ; Definition at line 179 of file TFitEditor.cxx. ◆ GetDrawOption(). Option_t * TFitEditor::GetDrawOption ; (; ); const. overridevirtual . Get draw options of the selected object. ; Reimplemented from TObject.; Definition at line 3117 of file TFitEditor.cxx. ◆ GetFitFunction(). TF1 * TFitEditor::GetFitFunction ; (; ). protected . Definition at line 3596 of file TFitEditor.cxx. ◆ GetFitObjectListOfFunctions(). TList * TFitEditor::GetFitObjectListOfFunctions ; (; ). protected . Definition at line 3500 of file TFitEdito",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:56864,depend,depending,56864,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['depend'],['depending']
Integrability,"ange without notice. It might trigger earthquakes. Feedback; 6/// is welcome!; 7 ; 8/*************************************************************************; 9 * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; 10 * All rights reserved. *; 11 * *; 12 * For the licensing terms see $ROOTSYS/LICENSE. *; 13 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 14 *************************************************************************/; 15 ; 16#ifndef ROOT7_RLogger; 17#define ROOT7_RLogger; 18 ; 19#include <atomic>; 20#include <list>; 21#include <memory>; 22#include <mutex>; 23#include <sstream>; 24#include <string>; 25#include <utility>; 26 ; 27namespace ROOT {; 28namespace Experimental {; 29 ; 30class RLogEntry;; 31class RLogManager;; 32 ; 33/**; 34 Kinds of diagnostics.; 35 */; 36enum class ELogLevel : unsigned char {; 37 kUnset,; 38 kFatal, ///< An error which causes further processing to be unreliable; 39 kError, ///< An error; 40 kWarning, ///< Warnings about likely unexpected behavior; 41 kInfo, ///< Informational messages; used for instance for tracing; 42 kDebug ///< Debug information; only useful for developers; can have added verbosity up to 255-kDebug.; 43};; 44 ; 45inline ELogLevel operator+(ELogLevel severity, int offset); 46{; 47 return static_cast<ELogLevel>(static_cast<int>(severity) + offset);; 48}; 49 ; 50/**; 51 Keep track of emitted errors and warnings.; 52 */; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:1427,message,messages,1427,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['message'],['messages']
Integrability,"ange; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_t_recursiveFlag indicating is fractions are treated recursively; RooSetProxy_refCoefNormReference observable set for coefficient interpretation; TNamed*_refCoefRangeNameReference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:46507,integrat,integrator,46507,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['integrat'],['integrator']
Integrability,"ange; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedPdf.html:41574,integrat,integrator,41574,root/html532/RooCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooCachedPdf.html,1,['integrat'],['integrator']
Integrability,"angeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxybeta; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxygamma; RooRealProxymu; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGamma.html:39271,integrat,integrator,39271,root/html530/RooGamma.html,https://root.cern,https://root.cern/root/html530/RooGamma.html,1,['integrat'],['integrator']
Integrability,"angevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TF2::Classstatic TClass * Class(); TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:53156,rout,routine,53156,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['rout'],['routine']
Integrability,"angle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; and the value in the BranchCount corresponding to that entry (can be obtained from branch->GetBranchCount()).; NoteThis interface is not meant to be exposed to end users, but rather it should be wrapped by higher-level interfaces. See TBranch::GetEntriesSerialized() for an alternative that does not perform byte swapping (useful to save one pass over data in some cases). ; Definition at line 1472 of file TBranch.cxx. ◆ GetBulkRead(). ROOT::Experimental::Internal::TBulkBranchRead & TBranch::GetBulkRead ; (; ). inline . Definition at line 218 of file TBranch.h. ◆ GetClassName(). const char * TBranch::GetClassName ; (; ); const. virtual . Return the name of the user class whose content is stored in this branch, if any. ; If this branch was created using the 'leaflist' technique, this function returns an empty string. ; Reimplemented in TBranchClones, TBranchElement, TBranchObject, and TBranchSTL.; Definition at line 1324 of file TBranch.cxx. ◆ GetCompressionAlgorithm(). Int_t TBranch::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 299 of file TBranch.h. ◆ GetCompressionLevel(). Int_t TBranch::GetCompressionLevel ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:44514,interface,interface,44514,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,3,"['interface', 'wrap']","['interface', 'interfaces', 'wrapped']"
Integrability,"anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static RooNumGenFactory*_instance; map<string,RooAbsNumGenerator*>_map. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumGenFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumGenFactory(); Destructor. RooNumGenFactory(const RooNumGenFactory& other); Copy constructor. RooNumGenFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoSampler(RooAbsNumGenerator* proto, const RooArgSet& defConfig); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsNumGenerator* getProtoSampler(const char* name); Return prototype integrator with given (class) name. RooAbsNumGenerator* createSampler(RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, RooAbsReal* maxFuncVal = 0); Construct a numeric integrator instance that operates on function 'func' and is configured; with 'config'. If ndimPreset is greater than zero that number is taken as the dimensionality; of the integration, otherwise it is queried from 'func'. This function iterators over list; of available prototyp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumGenFactory.html:6965,rout,routine,6965,root/html602/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html602/RooNumGenFactory.html,2,['rout'],['routine']
Integrability,"anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TStatus. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. TStatus(). virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-02 16:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStatus.html:7336,message,messages,7336,root/html604/TStatus.html,https://root.cern,https://root.cern/root/html604/TStatus.html,2,['message'],"['message', 'messages']"
Integrability,"anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TStatus. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. TStatus(). virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatus.html:7336,message,messages,7336,root/html602/TStatus.html,https://root.cern,https://root.cern/root/html602/TStatus.html,2,['message'],"['message', 'messages']"
Integrability,"ans. There are two different definitions used for the elliptic integral of the third kind:. \[; P(\phi,k,n) = \int_0^\phi \frac{dt}{(1 + n \sin^2{t})\sqrt{1 - k^2 \sin^2{t}}}; \]. and. \[; P(\phi,k,n) = \int_0^\phi \frac{dt}{(1 - n \sin^2{t})\sqrt{1 - k^2 \sin^2{t}}}; \]. the former is adopted by. GSL http://www.gnu.org/software/gsl/manual/gsl-ref_7.html#SEC95; Planetmath http://planetmath.org/encyclopedia/EllipticIntegralsAndJacobiEllipticFunctions.html; CERNLIB https://cern-tex.web.cern.ch/cern-tex/shortwrupsdir/c346/top.html; while the latter is used by. Abramowitz and Stegun; Mathematica http://mathworld.wolfram.com/EllipticIntegraloftheThirdKind.html; C++ standard http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf; in order to be C++ compliant, we decided to use the latter, hence the change of the sign in the function call to GSL. . Definition at line 276 of file SpecFuncMathMore.cxx. ◆ erf(). double ROOT::Math::erf ; (; double ; x). Error function encountered in integrating the normal distribution. . \[ erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt \]. For detailed description see Mathworld. The implementation used is that of GSL. This function is provided only for convenience, in case your standard C++ implementation does not support it. If it does, please use these standard version! ; Definition at line 59 of file SpecFuncMathCore.cxx. ◆ erfc(). double ROOT::Math::erfc ; (; double ; x). Complementary error function. . \[ erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt \]. For detailed description see Mathworld. The implementation used is that of Cephes from S. Moshier. ; Definition at line 44 of file SpecFuncMathCore.cxx. ◆ expint(). double ROOT::Math::expint ; (; double ; x). Calculates the exponential integral. . \[ Ei(x) = - \int_{-x}^{\infty} \frac{e^{-t}}{t} dt \]. For detailed description see Mathworld. The implementation used is that of GSL. ; Definition at line 287 of file SpecFuncMathMore.cxx. ◆ expin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__SpecFunc.html:20673,integrat,integrating,20673,doc/master/group__SpecFunc.html,https://root.cern,https://root.cern/doc/master/group__SpecFunc.html,1,['integrat'],['integrating']
Integrability,"ansformBase::Spectators(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events, Int_t maxCls); voidCalcSQRMats(const vector<TMVA::Event*,allocator<TMVA::Event*> >&, Int_t maxCls). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::DataSetInfo*TMVA::VariableTransformBase::fDsiOutput; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fGetget variables/targets/spectators; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::VariableTransformBase::VectorOfCharAndIntTMVA::VariableTransformBase::fPutput variables/targets/spectators; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableDecorrTransform.html:8991,message,message,8991,root/html530/TMVA__VariableDecorrTransform.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableDecorrTransform.html,2,['message'],['message']
Integrability,"ansient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:36037,integrat,integration,36037,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,2,['integrat'],['integration']
Integrability,"ansient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:44139,integrat,integration,44139,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,2,['integrat'],['integration']
Integrability,"ansient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstVar(const char* name, const char* title, Double_t value); Constructor with value; _fast = kTRUE ;. RooConstVar(const RooConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstVar.html:32881,integrat,integrator,32881,root/html532/RooConstVar.html,https://root.cern,https://root.cern/root/html532/RooConstVar.html,1,['integrat'],['integrator']
Integrability,"ant to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html:7785,message,message,7785,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html,6,['message'],['message']
Integrability,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:219213,message,message,219213,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['message'],['message']
Integrability,"ant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tfChisquareFunction fit chisquare; void*fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaximumMaximum value for plotting; TMethodCall*fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tfMinimumMinimum value for plotting; Int_tfNDFNumber of degrees of freedom in the fit; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:23709,wrap,wrap,23709,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['wrap'],['wrap']
Integrability,"anualIntegration = kTRUE. staticprivate . manual integration (sum over bins) or DGAUSS ; Definition at line 162 of file PDF.h. ◆ fgNbin_PdfHist. const Int_t TMVA::PDF::fgNbin_PdfHist = 10000. staticprivate . number of bins in high-binned reference histogram ; Definition at line 161 of file PDF.h. ◆ fGraph. TGraph* TMVA::PDF::fGraph. private . ! needed to create PDF from histogram ; Definition at line 177 of file PDF.h. ◆ fHist. TH1* TMVA::PDF::fHist. private . copy of input histogram ; Definition at line 175 of file PDF.h. ◆ fHistAvgEvtPerBin. Int_t TMVA::PDF::fHistAvgEvtPerBin. private . avg event per source hist bin ; Definition at line 180 of file PDF.h. ◆ fHistDefinedNBins. Int_t TMVA::PDF::fHistDefinedNBins. private . source hist bin num set by user ; Definition at line 181 of file PDF.h. ◆ fHistOriginal. TH1* TMVA::PDF::fHistOriginal. private . the input histogram ; Definition at line 176 of file PDF.h. ◆ fIGetVal. TF1* TMVA::PDF::fIGetVal. private . integration interface ; Definition at line 178 of file PDF.h. ◆ fInterpolateString. TString TMVA::PDF::fInterpolateString. private . Definition at line 186 of file PDF.h. ◆ fInterpolMethod. TMVA::PDF::EInterpolateMethod TMVA::PDF::fInterpolMethod. private . interpolation method ; Definition at line 172 of file PDF.h. ◆ fKDEborder. KDEKernel::EKernelBorder TMVA::PDF::fKDEborder. private . The method to take care about ""border"" effects (string) ; Definition at line 190 of file PDF.h. ◆ fKDEiter. KDEKernel::EKernelIter TMVA::PDF::fKDEiter. private . Number of iterations (adaptive or not) ; Definition at line 189 of file PDF.h. ◆ fKDEiterString. TString TMVA::PDF::fKDEiterString. private . Definition at line 184 of file PDF.h. ◆ fKDEtype. KDEKernel::EKernelType TMVA::PDF::fKDEtype. private . Kernel type to use for KDE. ; Definition at line 188 of file PDF.h. ◆ fKDEtypeString. TString TMVA::PDF::fKDEtypeString. private . strings used to read definitions ; Definition at line 183 of file PDF.h. ◆ fLogger. MsgLogger* TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDF.html:29391,integrat,integration,29391,doc/master/classTMVA_1_1PDF.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDF.html,2,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"anup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooTFoamBinding*_bindingBinding of RooAbsReal to TFoam function interface; RooDataSet*RooAbsNumGenerator::_cacheDataset holding generared values of observables; RooArgSetRooAbsNumGenerator::_catVars; RooArgSet*RooAbsNumGenerator::_cloneSetSet owning clone of input function; RooAbsReal*RooAbsNumGenerator::_funcClonePointer to top level node of cloned function; const RooAbsReal*RooAbsNumGenerator::_funcMaxValContainer for maximum function value; RooRealVar*RooAbsNumGenerator::_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*RooAbsNumGenerator::_funcValStore; Bool_tRooAbsNumGenerator::_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; Double_t*_rangeRange of observables to be generated ;; RooArgSetRooAbsNumGenerator::_realVarsSets of discrete and real valued observabeles; TIterator*_rvIterIteratator over _realVars ;; TFoam*_tfoamInstance of TFOAM generator; Double_t*_vecTransfer array for FOAM output; Bool_tRooAbsNumGenerator::_verbose; Double_t*_xminLower bound of observables to be generated ;; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerSampler(RooNumGenFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). ~RooFoamGenerator(); Destructor. const RooArgSet * gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFoamGenerator.html:7838,interface,interface,7838,root/html526/RooFoamGenerator.html,https://root.cern,https://root.cern/root/html526/RooFoamGenerator.html,5,['interface'],['interface']
Integrability,"anvas pixels to pad world coordinates; 5693 ; 5694 // Resize all sub-pads; 5695 TObject *obj;; 5696 if (!fPrimitives) fPrimitives = new TList;; 5697 TIter next(GetListOfPrimitives());; 5698 while ((obj = next())) {; 5699 if (obj->InheritsFrom(TPad::Class())); 5700 ((TPad*)obj)->ResizePad(option);; 5701 }; 5702 ; 5703 // Reset all current sizes; 5704 if (gPad->IsBatch()); 5705 fPixmapID = 0;; 5706 else {; 5707 if (GetPainter()){; 5708 GetPainter()->SetLineWidth(-1);; 5709 GetPainter()->SetTextSize(-1);; 5710 }; 5711 // create or re-create off-screen pixmap; 5712 if (fPixmapID) {; 5713 int w = TMath::Abs(XtoPixel(fX2) - XtoPixel(fX1));; 5714 int h = TMath::Abs(YtoPixel(fY2) - YtoPixel(fY1));; 5715 //protection in case of wrong pad parameters.; 5716 //without this protection, the OpenPixmap or ResizePixmap crashes with; 5717 //the message ""Error in <RootX11ErrorHandler>: BadValue (integer parameter out of range for operation)""; 5718 //resulting in a frozen xterm; 5719 if ( !(TMath::Finite(fX1)) || !(TMath::Finite(fX2)); 5720 || !(TMath::Finite(fY1)) || !(TMath::Finite(fY2)); 5721 || (TMath::IsNaN(fX1)) || (TMath::IsNaN(fX2)); 5722 || (TMath::IsNaN(fY1)) || (TMath::IsNaN(fY2))); 5723 Warning(""ResizePad"", ""Inf/NaN propagated to the pad. Check drawn objects."");; 5724 if (w <= 0 || w > 10000) {; 5725 Warning(""ResizePad"", ""%s width changed from %d to %d\n"",GetName(),w,10);; 5726 w = 10;; 5727 }; 5728 if (h <= 0 || h > 10000) {; 5729 Warning(""ResizePad"", ""%s height changed from %d to %d\n"",GetName(),h,10);; 5730 h = 10;; 5731 }; 5732 if (fPixmapID == -1) { // this case is handled via the ctor; 5733 if (GetPainter()) fPixmapID = GetPainter()->CreateDrawable(w, h);; 5734 } else {; 5735 if (gVirtualX) {; 5736 if (gVirtualX->ResizePixmap(fPixmapID, w, h)) {; 5737 Resized();; 5738 Modified(kTRUE);; 5739 }; 5740 }; 5741 }; 5742 }; 5743 }; 5744 if (fView) {; 5745 if (gPad == this) {; 5746 fView->ResizePad();; 5747 } else {; 5748 TContext ctxt(this, kTRUE);; 5749 fView->ResizePad();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:185609,message,message,185609,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['message'],['message']
Integrability,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2346,inject,inject,2346,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['inject'],['inject']
Integrability,"anvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TColorThe color creation and management class.Definition TColor.h:21; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDirectoryFile::GetFileTFile * GetFile() const overrideDefinition TDirectoryFile.h:92; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:22912,interface,interface,22912,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['interface'],['interface']
Integrability,any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; B,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:37977,integrat,integrated,37977,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['integrat'],['integrated']
Integrability,any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:38604,integrat,integrated,38604,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['integrat'],['integrated']
Integrability,"any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Attributes; Int_t fActive;  active color index ;  ; Pixel_t fCurrentColor;  currently selected color value ;  ; Int_t fLaunchDialog;  flag used for launching color dialog ;  ; const TGWindow * fMsgWindow;  window handling container messages ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGColorPopup.html:25469,message,messages,25469,doc/master/classTGColorPopup.html,https://root.cern,https://root.cern/doc/master/classTGColorPopup.html,1,['message'],['messages']
Integrability,"ap G3 TRAP shape; TGeoTrapEditor TGeoTrap editor; TGeoTrd1 TRD1 shape class; TGeoTrd1Editor TGeoTrd1 editor; TGeoTrd2 TRD2 shape class; TGeoTrd2Editor TGeoTrd2 editor; TGeoTreeDialog List-Tree based dialog; TGeoTube cylindrical tube class; TGeoTubeEditor TGeoTube editor; TGeoTubeSeg cylindrical tube segment class; TGeoTubeSegEditor TGeoTubeSeg editor; TGeoUniformMagField Uniform magnetic field; TGeoUnion union node; TGeoVolume geometry volume descriptor; TGeoVolumeAssembly an assembly of volumes; TGeoVolumeDialog List-Tree based volume dialog; TGeoVolumeEditor TGeoVolume editor; TGeoVolumeMulti class to handle multiple volumes in one step; TGeoVoxelFinder voxel finder class; TGeoXtru extruded polygon class; TGeometry Structure for Matrices, Shapes and Nodes; TGlobal Global variable class; TGondzioSolver Gondzio Qp Solver class; TGraph Graph graphics class; TGraph2D Set of n x[n],y[n],z[n] points with 3-d graphics including Delaunay triangulation; TGraph2DErrors A 2D graph with error bars; TGraph2DPainter TGraph2D painter; TGraphAsymmErrors A graph with asymmetric error bars; TGraphBentErrors A graph with bent, asymmetric error bars; TGraphDelaunay Delaunay triangulation; TGraphEdge Graph edge class; TGraphEditor graph editor; TGraphErrors A graph with error bars; TGraphNode Graph node class; TGraphPainter TGraph painter; TGraphPolar Polar graph; TGraphPolargram Polar axis; TGraphQQ to create and to draw quantile-quantile plots; TGraphSmooth Graph Smoother; TGraphStruct Graph structure class; TGraphTime An array of objects evolving with time; TGrid ABC defining interface to GRID services; TGridCollection ABC managing collection of files on the Grid; TGridJDL ABC defining interface JDL generator; TGridJob ABC defining interface to a GRID job; TGridJobStatus ABC defining status of a Grid job; TGridJobStatusList ABC defining interface to a list of GRID jobs; TGridResult ABC defining interface to GRID result set; TGroupButton A user interface button in a group of buttons.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:92441,interface,interface,92441,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,12,['interface'],['interface']
Integrability,"apTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:47811,message,message,47811,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['message'],['message']
Integrability,"apTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:47811,message,message,47811,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['message'],['message']
Integrability,"ap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;  . Detailed Description; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ClassImp for building the THtml documentation of the class.; To build the THtml documentation.; Class RooRealSumFunc implements a PDF constructed from a sum of functions:; Namespace for new ROOT classes and functions.; VSD Structures.; Sum(i=1,n-1) coef_i * func_i(x) + [ 1 - (Sum(i=1,n-1) coef_i ] * func_n(x); pdf(x) = ------------------------------------------------------------------------------; Sum(i=1,n-1) coef_i * Int(func_i)dx + [ 1 - (Sum(i=1,n-1) coef_i ] * Int(func_n)dx; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; where coef_i and func_i are RooAbsReal objects, and x is the collection of dependents. In the present version coef_i may not depend on x, but this limitation may be removed in the future. Difference between RooAddPdf / RooRealSum{Func|Pdf}. RooAddPdf is a PDF of PDFs, i.e. its components need to be normalised and non-negative.; RooRealSumPdf is a PDF of functions, i.e., its components can be negative, but their sum cannot be. The normalisation is computed automatically, unless the PDF is extended (see above).; RooRealSumFunc is a sum of functions. It is neither normalised, nor need it be positive. . Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 1546 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 112 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 111 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition at line 113 of file Rtypes.h. ◆ DirAutoAdd_t. typedef void(* ROOT::DirAutoAdd_t) (void *, TDirecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:20092,depend,depend,20092,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['depend'],['depend']
Integrability,"ape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channel. This significantly increase a performance, especially when several clients are connected.; Better security for THttpServer with webgui; If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will provide access to the widgets via websocket connection - any other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according to the WLCG Bearer Token Discovery specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:26945,protocol,protocol,26945,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['protocol'],['protocol']
Integrability,apesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsAr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:37380,integrat,integration,37380,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['integrat'],['integration']
Integrability,apesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:38007,integrat,integration,38007,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['integrat'],['integration']
Integrability,"aph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a polygonal arc of short vectors.; The data points can represent open curves, P(1) != P(N) or closed; curves P(2) == P(N). If a tangential discontinuity at P(I) is; required, then set P(I)=P(I+1). Loops are also allowed.; ; Reference Marlow and Powell, Harwell report No.R.7092.1972; MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; . npoints : Number of data points.; x : Abscissa; y : Ordinate; ; . TGraphPainter(). » Author: Olivier Couet » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id: TGraphPainter.h,v 1.00 » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphPainter.html:24800,rout,routine,24800,root/html532/TGraphPainter.html,https://root.cern,https://root.cern/root/html532/TGraphPainter.html,2,['rout'],['routine']
Integrability,"aph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a polygonal arc of short vectors.; The data points can represent open curves, P(1) != P(N) or closed; curves P(2) == P(N). If a tangential discontinuity at P(I) is; required, then set P(I)=P(I+1). Loops are also allowed.; ; Reference Marlow and Powell, Harwell report No.R.7092.1972; MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; . npoints : Number of data points.; x : Abscissa; y : Ordinate; ; . TGraphPainter(). » Author: Olivier Couet » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id: TGraphPainter.h,v 1.00 » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphPainter.html:24628,rout,routine,24628,root/html534/TGraphPainter.html,https://root.cern,https://root.cern/root/html534/TGraphPainter.html,2,['rout'],['routine']
Integrability,"aph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a polygonal arc of short vectors.; The data points can represent open curves, P(1) != P(N) or closed; curves P(2) == P(N). If a tangential discontinuity at P(I) is; required, then set P(I)=P(I+1). Loops are also allowed.; ; Reference Marlow and Powell, Harwell report No.R.7092.1972; MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; . npoints : Number of data points.; x : Abscissa; y : Ordinate; ; . TGraphPainter(). » Author: Olivier Couet » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id: TGraphPainter.h,v 1.00 » Last generated: 2015-06-02 16:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraphPainter.html:25087,rout,routine,25087,root/html604/TGraphPainter.html,https://root.cern,https://root.cern/root/html604/TGraphPainter.html,2,['rout'],['routine']
Integrability,"aph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code is from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; The curve is approximated by a polygonal arc of short vectors.; The data points can represent open curves, P(1) != P(N) or closed; curves P(2) == P(N). If a tangential discontinuity at P(I) is; required, then set P(I)=P(I+1). Loops are also allowed.; ; Reference Marlow and Powell, Harwell report No.R.7092.1972; MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; . npoints : Number of data points.; x : Abscissa; y : Ordinate; ; . TGraphPainter(). » Author: Olivier Couet » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id: TGraphPainter.h,v 1.00 » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphPainter.html:25087,rout,routine,25087,root/html602/TGraphPainter.html,https://root.cern,https://root.cern/root/html602/TGraphPainter.html,2,['rout'],['routine']
Integrability,"aph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1074 }; 1075 } else {; 1076 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1077 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1078 if (theGraph->InheritsFrom(""TCutG"")) {; 1079 //make sure first and last point are the same; 1080 if (ipoint == 0) {; 1081 theX[theNpoints-1] = theX[0];; 1082 theY[theNpoints-1] = theY[0];; 1083 }; 1084 if (ipoint == theNpoints-1) {; 1085 theX[0] = theX[th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:39060,rout,routines,39060,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['rout'],['routines']
Integrability,"aph2DGraphics object made of three arrays X, Y and Z with the same number of points each ;  CTGraph2DErrorsGraph 2D class with errors ;  CTGraph2DPainterThe TGraphDelaunay painting class ;  CTGraphAsymmErrorsTGraph with asymmetric error bars ;  CTGraphBentErrorsA TGraphBentErrors is a TGraph with bent, assymetric error bars ;  CTGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D ;  CTGraphDelaunay2DTGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D ;  CTGraphEdgeAn edge object connecting two nodes which can be added in a TGraphStruct ;  CTGraphEditor;  CTGraphErrorsA TGraphErrors is a TGraph with error bars ;  CTGraphNodeA graph node object which can be added in a TGraphStruct ;  CTGraphPainterThe graph painter class ;  CTGraphPolarTo draw a polar graph ;  CTGraphPolargramTo draw polar axis ;  CTGraphQQThis class allows to draw quantile-quantile plots ;  CTGraphSmoothA helper class to smooth TGraph ;  CTGraphStructThe Graph Structure is an interface to the graphviz package ;  CTGraphTimeTGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax ;  CTGRecorder;  CTGRectangle;  CTGRectMap;  CTGRedirectOutputGuard;  CTGRegion;  CTGRegionWithId;  CTGResourcePool;  CTGrid;  CTGridCollection;  CTGridJDL;  CTGridJob;  CTGridJobStatus;  CTGridJobStatusList;  CTGridResult;  CTGroupButtonA specialized TButton used in a group of Buttons ;  CTGRowLayout;  CTGScrollBar;  CTGScrollBarElement;  CTGSearchDialog;  CTGSearchType;  CTGSelectBoxThis class represent a specialized expression editor for TTVLVEntry 'true name' and 'alias' data members ;  CTGSelectedPicture;  CTGShapedFrame;  CTGShutter;  CTGShutterItem;  CTGSimpleTable;  CTGSimpleTableInterface;  CTGSlider;  CTGSpeedo;  CTGSplitButton;  CTGSplitFrame;  CTGSplitter;  CTGSplitTool;  CTGStatusBar;  CTGString;  CTGTab;  CTGTabElement;  CTGTabLayout;  CTGTable;  CTGTableCell;  CTGTableFrame;  CTGTableHeader;  CTGTableHeaderFrame;  ►CTGTableLayout;  CTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:158276,interface,interface,158276,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['interface'],['interface']
Integrability,"aphics object made of two arrays X and Y with npoints each ;  CTGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each ;  CTGraph2DErrorsGraph 2D class with errors ;  CTGraph2DPainterThe TGraphDelaunay painting class ;  CTGraphAsymmErrorsTGraph with assymetric error bars ;  CTGraphBentErrorsA TGraphBentErrors is a TGraph with bent, assymetric error bars ;  CTGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D ;  CTGraphDelaunay2D;  CTGraphEdgeAn edge object connecting two nodes which can be added in a TGraphStruct ;  CTGraphEditor;  CTGraphErrorsA TGraphErrors is a TGraph with error bars ;  CTGraphNodeA graph node object which can be added in a TGraphStruct ;  CTGraphPainterThe graph painter class ;  CTGraphPolarTo draw a polar graph ;  CTGraphPolargramTo draw polar axis ;  CTGraphQQThis class allows to draw quantile-quantile plots ;  CTGraphSmoothA helper class to smooth TGraph ;  CTGraphStructThe Graph Structure is an interface to the graphviz package ;  CTGraphTimeTGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax ;  CTGRecorder;  CTGRectangle;  CTGRectMap;  CTGRedirectOutputGuard;  CTGRegion;  CTGRegionWithId;  CTGResourcePool;  CTGrid;  CTGridCollection;  CTGridJDL;  CTGridJob;  CTGridJobStatus;  CTGridJobStatusList;  CTGridResult;  CTGroupButtonA specialized TButton used in a group of Buttons ;  CTGRowLayout;  CTGScrollBar;  CTGScrollBarElement;  CTGSearchDialog;  CTGSearchType;  CTGSelectBoxThis class represent a specialized expression editor for TTVLVEntry 'true name' and 'alias' data members ;  CTGSelectedPicture;  CTGShapedFrame;  CTGShutter;  CTGShutterItem;  CTGSimpleTable;  CTGSimpleTableInterface;  CTGSlider;  CTGSpeedo;  CTGSplitButton;  CTGSplitFrame;  CTGSplitter;  CTGSplitTool;  CTGStatusBar;  CTGString;  CTGTab;  CTGTabElement;  CTGTabLayout;  CTGTable;  CTGTableCell;  CTGTableFrame;  CTGTableHeader;  CTGTableHeaderFrame;  ►CTGTableLayout;  CTa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:131679,interface,interface,131679,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['interface'],['interface']
Integrability,"aptive Gauss-Kronrod technique; // for closed 1D integrals; RooNumIntConfig customConfig(*RooAbsReal::defaultIntegratorConfig());; #ifdef R__HAS_MATHMORE; customConfig.method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D"");; #else; Warning(""rf901_numintconfig"",""ROOT is built without Mathmore (GSL) support. Cannot use RooAdaptiveGaussKronrodIntegrator1D"");; #endif; ; // Calculate integral over landau with custom integral specification; std::unique_ptr<RooAbsReal> intLandau2{landau.createIntegral(x, NumIntConfig(customConfig))};; double val2 = intLandau2->getVal();; cout << "" [2] int_dx landau(x) = "" << val2 << endl;; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom numeric integration configuration as default for object 'landau'; landau.setIntegratorConfig(customConfig);; ; // Calculate integral over landau custom numeric integrator specified as object default; std::unique_ptr<RooAbsReal> intLandau3{landau.createIntegral(x)};; double val3 = intLandau3->getVal();; cout << "" [3] int_dx landau(x) = "" << val3 << endl;; ; // Another possibility: Change global default for 1D numeric integration strategy on finite domains; #ifdef R__HAS_MATHMORE; RooAbsReal::defaultIntegratorConfig()->method1D().setLabel(""RooAdaptiveGaussKronrodIntegrator1D"");; ; // A d j u s t i n g p a r a m e t e r s o f a s p e c i f i c t e c h n i q u e; // ---------------------------------------------------------------------------------------; ; // Adjust maximum number of steps of RooIntegrator1D in the global default configuration; RooAbsReal::defaultIntegratorConfig()->getConfigSection(""RooIntegrator1D"").setRealValue(""maxSteps"", 30);; ; // Example of how to change the parameters of a numeric integrator; // (Each config section is a RooArgSet with RooRealVars holding real-valued parameters; // and RooCategories holding parameters with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf901__numintconfig_8C.html:3607,integrat,integrator,3607,doc/master/rf901__numintconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf901__numintconfig_8C.html,1,['integrat'],['integrator']
Integrability,"apvoid ResetMap() overrideDelete existing fMap and reset map counter.Definition TBufferIO.cxx:288; TBufferJSON::ExportToFilestatic Int_t ExportToFile(const char *filename, const TObject *obj, const char *option=nullptr)Convert object into JSON and store in text file Returns size of the produce file Used in TObject::Sav...Definition TBufferJSON.cxx:751; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:80973,wrap,wrapper,80973,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['wrap'],['wrapper']
Integrability,"ar *&s) final;  Reads a char* string. ;  ; TClass * ReadClass (const TClass *cl=nullptr, UInt_t *objTag=nullptr) final;  suppressed function of TBuffer ;  ; void ReadDouble (Double_t &d) final;  Reads Double_t value from buffer. ;  ; void ReadFastArray (Bool_t *b, Int_t n) final;  read array of Bool_t from buffer ;  ; void ReadFastArray (Char_t *c, Int_t n) final;  read array of Char_t from buffer ;  ; void ReadFastArray (Double_t *d, Int_t n) final;  read array of Double_t from buffer ;  ; void ReadFastArray (Float_t *f, Int_t n) final;  read array of Float_t from buffer ;  ; void ReadFastArray (Int_t *i, Int_t n) final;  read array of Int_t from buffer ;  ; void ReadFastArray (Long64_t *l, Int_t n) final;  read array of Long64_t from buffer ;  ; void ReadFastArray (Long_t *l, Int_t n) final;  read array of Long_t from buffer ;  ; void ReadFastArray (Short_t *h, Int_t n) final;  read array of Short_t from buffer ;  ; void ReadFastArray (UChar_t *c, Int_t n) final;  read array of UChar_t from buffer ;  ; void ReadFastArray (UInt_t *i, Int_t n) final;  read array of UInt_t from buffer ;  ; void ReadFastArray (ULong64_t *l, Int_t n) final;  read array of ULong64_t from buffer ;  ; void ReadFastArray (ULong_t *l, Int_t n) final;  read array of ULong_t from buffer ;  ; void ReadFastArray (UShort_t *h, Int_t n) final;  read array of UShort_t from buffer ;  ; void ReadFastArray (void **startp, const TClass *cl, Int_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=nullptr, const TClass *onFileClass=nullptr) final;  redefined here to avoid warning message from gcc ;  ; void ReadFastArray (void *start, const TClass *cl, Int_t n=1, TMemberStreamer *s=nullptr, const TClass *onFileClass=nullptr) final;  Read an array of 'n' objects from the I/O buffer. ;  ; void ReadFastArrayString (Char_t *c, Int_t n) final;  read array of Char_t from buffer ;  ; void ReadFloat (Float_t &f) final;  Reads Float_t value from buffer. ;  ; void ReadInt (Int_t &i) final;  Reads Int_t value from b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:9399,message,message,9399,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,1,['message'],['message']
Integrability,"ar *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordSelect.html:11422,message,message,11422,doc/master/classTParallelCoordSelect.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordSelect.html,4,['message'],['message']
Integrability,"ar *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:7786,message,message,7786,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,30,['message'],['message']
Integrability,"ar *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TProfileProfile Histogram.Definition TProfile.h:32; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetNcodes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THbookFile_8cxx_source.html:43002,message,message,43002,doc/master/THbookFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html,1,['message'],['message']
Integrability,"ar *path, EAccessMode mode) override;  Returns FALSE if one can access a file using the specified access mode. ;  ; void FreeDirectory (void *dirp) override;  Free directory via httpd. ;  ; const char * GetDirEntry (void *dirp) override;  Get directory entry via httpd. Returns 0 in case no more entries. ;  ; Int_t GetPathInfo (const char *path, FileStat_t &buf) override;  Get info about a file. ;  ; TClass * IsA () const override;  ; Int_t MakeDirectory (const char *name) override;  Make a directory via httpd. Not supported. ;  ; void * OpenDirectory (const char *name) override;  Open a directory via httpd. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unlink (const char *path) override;  Unlink, i.e. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual void AddTimer (TTimer *t);  Add timer to list of system timers. ;  ; virtual int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1);  An",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebSystem.html:1526,interface,interface,1526,doc/master/classTWebSystem.html,https://root.cern,https://root.cern/doc/master/classTWebSystem.html,1,['interface'],['interface']
Integrability,"ar * ; t, . int ; rwmode, . const cling::Interpreter & ; interp, . const char * ; tcl = nullptr . ). Definition at line 821 of file TClingUtils.cxx. ◆ EndsWith(). bool ROOT::TMetaUtils::EndsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5077 of file TClingUtils.cxx. ◆ Error(). void ROOT::TMetaUtils::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). inline . Definition at line 817 of file TClingUtils.h. ◆ ExtractAttrIntPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrIntPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . int & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1672 of file TClingUtils.cxx. ◆ ExtractAttrPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . std::string & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1649 of file TClingUtils.cxx. ◆ extractAttrString(). int ROOT::TMetaUtils::extractAttrString ; (; clang::Attr * ; attribute, . std::string & ; attrString . ). Extract attr string. ; Definition at line 1608 of file TClingUtils.cxx. ◆ ExtractCtxtEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractCtxtEnclosingNameSpaces ; (; const clang::DeclContext & ; ctxt, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract enclosing namespaces recursively. ; Definition at line 4930 of file TClingUtils.cxx. ◆ ExtractEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractEnclosingNameSpaces ; (; const clang::Decl & ; decl, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract the immediately outer namespace and then launch the recursion. ; Definition at line 4910 of file TClingUtils.cxx. ◆ ExtractEnclosingScopes(). const clang::RecordDecl * ROOT::TMetaUtils::ExtractEnclosingScopes ; (; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:24647,rout,routine,24647,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['rout'],['routine']
Integrability,"ar * ; t, . int ; rwmode, . const cling::Interpreter & ; interp, . const char * ; tcl = nullptr . ). Definition at line 861 of file TClingUtils.cxx. ◆ EndsWith(). bool ROOT::TMetaUtils::EndsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5124 of file TClingUtils.cxx. ◆ Error(). void ROOT::TMetaUtils::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). inline . Definition at line 840 of file TClingUtils.h. ◆ ExtractAttrIntPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrIntPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . int & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1712 of file TClingUtils.cxx. ◆ ExtractAttrPropertyFromName(). bool ROOT::TMetaUtils::ExtractAttrPropertyFromName ; (; const clang::Decl & ; decl, . const std::string & ; propName, . std::string & ; propValue . ). This routine counts on the ""propName<separator>propValue"" format. ; Definition at line 1689 of file TClingUtils.cxx. ◆ extractAttrString(). int ROOT::TMetaUtils::extractAttrString ; (; clang::Attr * ; attribute, . std::string & ; attrString . ). Extract attr string. ; Definition at line 1648 of file TClingUtils.cxx. ◆ ExtractCtxtEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractCtxtEnclosingNameSpaces ; (; const clang::DeclContext & ; ctxt, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract enclosing namespaces recursively. ; Definition at line 4977 of file TClingUtils.cxx. ◆ ExtractEnclosingNameSpaces(). void ROOT::TMetaUtils::ExtractEnclosingNameSpaces ; (; const clang::Decl & ; decl, . std::list< std::pair< std::string, bool > > & ; enclosingNamespaces . ). Extract the immediately outer namespace and then launch the recursion. ; Definition at line 4957 of file TClingUtils.cxx. ◆ ExtractEnclosingScopes(). const clang::RecordDecl * ROOT::TMetaUtils::ExtractEnclosingScopes ; (; cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:24644,rout,routine,24644,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['rout'],['routine']
Integrability,"ar * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of the Poisson distribution. ;  ; double evaluate () const override;  Implementation in terms of the TMath::Poisson() function. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPoisson.html:59703,rout,routine,59703,doc/master/classRooPoisson.html,https://root.cern,https://root.cern/doc/master/classRooPoisson.html,1,['rout'],['routine']
Integrability,"ar * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Forward redirectServers call to our basis function, which is not connected to either resolution model or the physics model. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:62623,rout,routine,62623,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['rout'],['routine']
Integrability,"ar ; (; const char * ; name, . const char * ; title, . const char * ; inFormula, . const RooArgList & ; dependents, . bool ; checkVariables = true . ). Constructor with formula expression and list of input variables. ; Parameters. [in]nameName of the formula. ; [in]titleTitle of the formula. ; [in]inFormulaExpression to be evaluated. ; [in]dependentsVariables that should be passed to the formula. ; [in]checkVariablesCheck that all variables from dependents are used in the expression. . Definition at line 79 of file RooFormulaVar.cxx. ◆ RooFormulaVar() [3/4]. RooFormulaVar::RooFormulaVar ; (; const char * ; name, . const char * ; title, . const RooArgList & ; dependents, . bool ; checkVariables = true . ). Constructor with formula expression, title and list of input variables. ; Parameters. [in]nameName of the formula. ; [in]titleFormula expression. Will also be used as the title. ; [in]dependentsVariables that should be passed to the formula. ; [in]checkVariablesCheck that all variables from dependents are used in the expression. . Definition at line 102 of file RooFormulaVar.cxx. ◆ RooFormulaVar() [4/4]. RooFormulaVar::RooFormulaVar ; (; const RooFormulaVar & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 122 of file RooFormulaVar.cxx. Member Function Documentation. ◆ binBoundaries(). std::list< double > * RooFormulaVar::binBoundaries ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Forward the plot sampling hint from the p.d.f. that defines the observable obs. ; Reimplemented from RooAbsReal.; Definition at line 237 of file RooFormulaVar.cxx. ◆ Class(). static TClass * RooFormulaVar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooFormulaVar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooFormulaVar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:63898,depend,dependents,63898,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['depend'],['dependents']
Integrability,"ar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);; 220 return (const_cast<TFormula *>(df))->EvalPar(x); // derivatives should not depend on parameters since; 221 // function is linear; 222 }; 223 };; 224 ; 225 // implementations for WrappedMultiTF1Templ<T>; 226 template<class T>; 227 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(TF1 &f, unsigned int dim) :; 228 fLinear(false),; 229 fPolynomial(false),; 230 fOwnFunc(false),; 231 fFunc(&f),; 232 fDim(dim); 233 //fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); 234 {; 235 // constructor of WrappedMultiTF1Templ<T>; 236 // pass a dimension if dimension specified in TF1 does not correspond to real dimension; 237 // for example in case of multi-dimensional TF1 objects defined as TF1 (i.e. for functions with dims > 3 ); 238 if (fDim == 0) fDim = fFunc->GetNdim();; 239 ; 240 // check that in case function is linear the lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7618,wrap,wrappedFunc,7618,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,3,"['depend', 'wrap']","['depend', 'wrappedFunc']"
Integrability,"ar to the ones used in the raster graphics community. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:21114,rout,routine,21114,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['rout'],['routine']
Integrability,"ar to the ones used in the raster graphics community. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:20505,rout,routine,20505,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['rout'],['routine']
Integrability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Mon Jul 4 15:24:52 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:43036,integrat,integration,43036,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Sat Oct 9 06:58:49 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:42038,integrat,integration,42038,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Thu Nov 3 20:10:10 2011 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:43797,integrat,integration,43797,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"ar* filename); Process an additional configuration file. int fReadFile(const char* fileName, bool is_included = false); Parses the configuration file. The objects can be specified following; the rules of the RooFactoryWSTool, plus some more flexibility. The official format for the datacards is "".rs"". All the instructions end with a "";"" (like in C++). Carriage returns and white lines are irrelevant but adviced since they; improve readability (like in C++). The (Roo)ClassName::objname(description) can be replaced with the more; ""pythonic"" objname = (Roo)ClassName(description). The comments can be specified with a ""//"" if on a single line or with; /* */ if on multiple lines (like in C++). The ""#include path/to/file.rs"" statement triggers the inclusion of a; configuration fragment. The ""import myobject:myworkspace:myrootfile"" will add to the Workspace; the object myobject located in myworkspace recorded in myrootfile.; Alternatively, one could choose the ""import myobject:myrootfile"" in case; no Workspace is present. The ""echo"" statement prompts a message on screen. void fCreateCategory(); Builds the category necessary for the mutidimensional models. Its name; will be <HLFactory name>_category and the types are specified by the; model labels. bool fNamesListsConsistent(); Check the number of entries in each list. If not the same and the list; is not empty prompt an error. int fParseLine(TString& line); Parse a single line and puts the content in the RooWorkSpace. void DumpCfg(const char* ); Dump the Workspace content as configuration file; It needs some workspace object list or something.. { /* t.b.i. */ }. RooWorkspace* GetWs(); Get the RooWorkspace containing the models and variables. {return fWs;}. » Last changed: root/roostats:$Id: HLFactory.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HLFactory.html:9046,message,message,9046,root/html530/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html530/RooStats__HLFactory.html,1,['message'],['message']
Integrability,"ar* filename); Process an additional configuration file. int fReadFile(const char* fileName, bool is_included = false); Parses the configuration file. The objects can be specified following; the rules of the RooFactoryWSTool, plus some more flexibility. The official format for the datacards is "".rs"". All the instructions end with a "";"" (like in C++). Carriage returns and white lines are irrelevant but adviced since they; improve readability (like in C++). The (Roo)ClassName::objname(description) can be replaced with the more; ""pythonic"" objname = (Roo)ClassName(description). The comments can be specified with a ""//"" if on a single line or with; /* */ if on multiple lines (like in C++). The ""#include path/to/file.rs"" statement triggers the inclusion of a; configuration fragment. The ""import myobject:myworkspace:myrootfile"" will add to the Workspace; the object myobject located in myworkspace recorded in myrootfile.; Alternatively, one could choose the ""import myobject:myrootfile"" in case; no Workspace is present. The ""echo"" statement prompts a message on screen. void fCreateCategory(); Builds the category necessary for the mutidimensional models. Its name; will be <HLFactory name>_category and the types are specified by the; model labels. bool fNamesListsConsistent(); Check the number of entries in each list. If not the same and the list; is not empty prompt an error. int fParseLine(TString& line); Parse a single line and puts the content in the RooWorkSpace. void DumpCfg(const char* ); Dump the Workspace content as configuration file; It needs some workspace object list or something.. { /* t.b.i. */ }. RooWorkspace* GetWs(); Get the RooWorkspace containing the models and variables. {return fWs;}. » Last changed: root/roostats:$Id: HLFactory.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HLFactory.html:9046,message,message,9046,root/html532/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HLFactory.html,1,['message'],['message']
Integrability,"ar* indent = """", const char* namePat = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:32813,interface,interface,32813,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,3,['interface'],['interface']
Integrability,"ar* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , RooFit::MPSplit , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Tue Jun 30 14:38:19 2015 » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:49693,integrat,integration,49693,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"ar* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , RooFit::MPSplit , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Tue Mar 10 17:21:20 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:48066,integrat,integration,48066,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,1,['integrat'],['integration']
Integrability,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooRealSumPdf with cache-and-track. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& arg) const; { return arg.isFundamental() ; }. const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:46197,integrat,integrations,46197,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,9,['integrat'],"['integration', 'integrations', 'integrators']"
Integrability,"ar* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::getAnalyticalIntegralWN:""<<GetName()<<""(""<<allVars<<"",analVars,""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; cout << ""RooRealSumPdf::analyticalIntegralWN:""<<GetName()<<""(""<<code<<"",""<<(normSet2?*normSet2:RooArgSet())<<"",""<<(rangeName?rangeName:""<none>"") << endl;; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const; return getNorm(nset) ;. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealSumPdf.html:44478,integrat,integrations,44478,root/html532/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html532/RooRealSumPdf.html,3,['integrat'],"['integration', 'integrations', 'integrators']"
Integrability,"ar* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0); Constructor of an empty data set from a RooArgSet defining the dimensions; of the data space. RooDataSet(const char *name, const char *title, RooDataSet *dset, 		 const RooArgSet& vars, const char *cuts, const char* wgtVarName); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cuts' string is an optional RooFormula; expression and can be used to select the subset of the data; points in 'dset' to be copied. The cut expression can refer to; any variable in the source dataset. For cuts involving variables; other than those contained in the source data set, such as; intermediate formula objects, use the equivalent constructor; accepting RooFormulaVar reference as cut specification. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, RooDataSet *dset, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, const char* wgtVarName); Constructor of a data set from (part of) an existing data; set. The dimensions of the data set are defined by the 'vars'; RooArgSet, which can be identical to 'dset' dimensions, or a; subset thereof. The 'cutVar' formula variable is used to select; the subset of data points to be copied. For subsets without; selection on the data points, or involving cuts operating; exclusively and directly on the data set dimensions, the; equivalent constructor with a string based cut expression is; recommended. For most uses the RooAbsData::reduce() wrapper function, which; uses this constructor, is the most convenient way to create a; subset of an existing data. RooDataSet(const char *name, const char *title, TTree *intree, 		 const RooArgSet& vars, const RooFormulaVar& cutVar, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:20383,wrap,wrapper,20383,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,1,['wrap'],['wrapper']
Integrability,"ar*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level and algorithm; Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosList of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message leng",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMessage.html:22968,message,message,22968,root/html534/TMessage.html,https://root.cern,https://root.cern/root/html534/TMessage.html,6,['message'],['message']
Integrability,"ar, RooRealIntegral, and RooRealVar.; Definition at line 453 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 443 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 424 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooAbsTestStatistic, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, and RooProjectedPdf.; Definition at line 4550 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 384 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:144830,inject,inject,144830,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,"['depend', 'inject']","['dependent', 'inject']"
Integrability,"ar, RooRealIntegral, and RooRealVar.; Definition at line 455 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 426 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsTestStatistic, and RooProjectedPdf.; Definition at line 4474 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 377 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:142993,inject,inject,142993,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,"['depend', 'inject']","['dependent', 'inject']"
Integrability,"arAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double,allocator<double> >::iterator begin, vector<double,allocator<double> >::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write FDA-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. void CheckSetup(); no check of options at this place. {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005-2010: *; » Last changed: root/tmva $Id: MethodFDA.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodFDA.html:20375,message,message,20375,root/html532/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodFDA.html,1,['message'],['message']
Integrability,"arIterator over variables to be generated; UInt_t_realSampleDimNumber of real and discrete dimensions to be samplesd; RooArgSetRooAbsNumGenerator::_realVarsSets of discrete and real valued observabeles; UInt_t_totalEventsTotal number of function samples; Bool_tRooAbsNumGenerator::_verboseVerbose and valid flag; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerSampler(RooNumGenFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAcceptReject.html:11103,depend,dependents,11103,root/html602/RooAcceptReject.html,https://root.cern,https://root.cern/root/html602/RooAcceptReject.html,2,['depend'],['dependents']
Integrability,"arPackages(). Int_t TProof::ClearPackages ; (; ). Remove all packages. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7840 of file TProof.cxx. ◆ Close(). void TProof::Close ; (; Option_t * ; opt = """"). Close all open slave servers. ; Client can decide to shutdown the remote session by passing option is 'S' or 's'. Default for clients is detach, if supported. Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2669 of file TProof.cxx. ◆ Collect() [2/4]. Int_t TProof::Collect ; (; ESlaves ; list = kActive, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2727 of file TProof.cxx. ◆ Collect() [3/4]. Int_t TProof::Collect ; (; TList * ; slaves, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). protected . Collect responses from the slave servers. ; Returns the number of slaves that responded. If timeout >= 0, wait at most timeout seconds (timeout = -1 by default, which means wait forever). If defined (>= 0) endtype is the message that stops this collection. ; Definition at line 2696 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:77291,message,message,77291,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['message']
Integrability,"ar_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Tue Mar 10 17:14:13 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:37805,depend,depends,37805,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,1,['depend'],['depends']
Integrability,"aracters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr};  ; Bool_t fDone {kFALSE};  ; TSeqCollection * fFileHandler {nullptr};  ; TString fFlagsDebug;  ; TString fFlagsOpt;  ; TSeqCollection * fHelpers {nullptr};  ; TString fHostname;  ; TString fIncludePath;  ; Bool_t fInControl {kFALSE};  ; std::atomic< Bool_t > fInsideNotify {kFALSE};  ; Int_t fLevel {0};  ; TString fLinkdefSuffix;  ; TString fLinkedLibs;  ; TString fListLibs;  ; TString fListPaths;  ; TString fMakeExe;  ; TString fMakeSharedLib;  ; Int_t fMaxrfd {-1};  ; Int_t fMaxwfd {-1};  ; Int_t fNfd {0};  Signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:31748,protocol,protocol,31748,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,4,['protocol'],['protocol']
Integrability,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:9636,integrat,integration,9636,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,12,['integrat'],['integration']
Integrability,"aramFunctionAdapter() [3/3]. ROOT::Math::MultiDimParamFunctionAdapter::MultiDimParamFunctionAdapter ; (; const MultiDimParamFunctionAdapter & ; rhs). inline . Copy constructor. ; Different behaviour according if function is owned or not ; Definition at line 71 of file MultiDimParamFunctionAdapter.h. ◆ ~MultiDimParamFunctionAdapter(). ROOT::Math::MultiDimParamFunctionAdapter::~MultiDimParamFunctionAdapter ; (; ). inlineoverride . Destructor (no operations) ; Definition at line 84 of file MultiDimParamFunctionAdapter.h. Member Function Documentation. ◆ Clone(). BaseFunc * ROOT::Math::MultiDimParamFunctionAdapter::Clone ; (; ); const. inlineoverridevirtual . clone ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition at line 108 of file MultiDimParamFunctionAdapter.h. ◆ DoEvalPar(). double ROOT::Math::MultiDimParamFunctionAdapter::DoEvalPar ; (; const double * ; x, . const double * ; p . ); const. inlineoverrideprivatevirtual . needed by the interface ; Implements ROOT::Math::IParametricFunctionMultiDimTempl< double >.; Definition at line 140 of file MultiDimParamFunctionAdapter.h. ◆ NDim(). unsigned int ROOT::Math::MultiDimParamFunctionAdapter::NDim ; (; ); const. inlineoverridevirtual . Retrieve the dimension of the function. ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition at line 131 of file MultiDimParamFunctionAdapter.h. ◆ NPar(). unsigned int ROOT::Math::MultiDimParamFunctionAdapter::NPar ; (; ); const. inlineoverridevirtual . Return the number of Parameters. ; Implements ROOT::Math::IBaseParam.; Definition at line 126 of file MultiDimParamFunctionAdapter.h. ◆ operator=(). MultiDimParamFunctionAdapter & ROOT::Math::MultiDimParamFunctionAdapter::operator= ; (; const MultiDimParamFunctionAdapter & ; rhs). inline . Assignment operator. ; Definition at line 93 of file MultiDimParamFunctionAdapter.h. ◆ Parameters(). const double * ROOT::Math::MultiDimParamFunctionAdapter::Parameters ; (; ); const. inlineoverridevirtual . Access the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html:5634,interface,interface,5634,doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MultiDimParamFunctionAdapter.html,1,['interface'],['interface']
Integrability,"aram[in] model The model to be considered to build the new return value.; 2305 /// \param[in] v1Name The name of the column that will fill the x axis.; 2306 /// \param[in] v2Name The name of the column that will fill the y axis.; 2307 /// \return the monodimensional profile wrapped in a RResultPtr.; 2308 ///; 2309 /// This action is *lazy*: upon invocation of this method the calculation is; 2310 /// booked but not executed. Also see RResultPtr.; 2311 ///; 2312 /// ### Example usage:; 2313 /// ~~~{.cpp}; 2314 /// // Deduce column types (this invocation needs jitting internally); 2315 /// auto myProf1 = myDf.Profile1D({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; 2316 /// // Explicit column types; 2317 /// auto myProf2 = myDf.Graph<int, float>({""profName"", ""profTitle"", 64u, -4., 4.}, ""xValues"", ""yValues"");; 2318 /// ~~~; 2319 ///; 2320 /// \note Differently from other ROOT interfaces, the returned profile is not associated to gDirectory; 2321 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 2322 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 2323 template <typename V1 = RDFDetail::RInferredType, typename V2 = RDFDetail::RInferredType>; 2324 RResultPtr<::TProfile>; 2325 Profile1D(const TProfile1DModel &model, std::string_view v1Name = """", std::string_view v2Name = """"); 2326 {; 2327 std::shared_ptr<::TProfile> h(nullptr);; 2328 {; 2329 ROOT::Internal::RDF::RIgnoreErrorLevelRAII iel(kError);; 2330 h = model.GetProfile();; 2331 }; 2332 ; 2333 if (!RDFInternal::HistoUtils<::TProfile>::HasAxisLimits(*h)) {; 2334 throw std::runtime_error(""Profiles with no axes limits are not supported yet."");; 2335 }; 2336 const std::vector<std::string_view> columnViews = {v1Name, v2Name};; 2337 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2338 ? ColumnNames_t(); 2339 : ColumnNames_t(columnViews.begin(), columnViews.end());; 234",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:130265,interface,interfaces,130265,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['interface'],['interfaces']
Integrability,"arameters and capabilities with RooNumIntFactory. RooIntegrator1D(); coverity[UNINIT_CTOR]; Default constructor. RooIntegrator1D(const RooAbsFunc& function, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding, using specified summation; rule, maximum number of steps and conversion tolerance. The integration; limits are taken from the function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding for given range,; using specified summation rule, maximum number of steps and; conversion tolerance. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegrator1D.html:8953,integrat,integration,8953,root/html530/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html530/RooIntegrator1D.html,5,['integrat'],['integration']
Integrability,"arameters fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params); This constructor is called for functions of type C by the C++ interpreter.; WarningA function created with this constructor cannot be Cloned. ; Definition at line 714 of file TF1.cxx. ◆ TF1() [6/15]. TF1::TF1 ; (; const char * ; name, . Double_t(*)(Double_t *, Double_t *) ; fcn, . Double_t ; xmin = 0, . Double_t ; xmax = 1, . Int_t ; npar = 0, . Int_t ; ndim = 1, . EAddToList ; addToGlobList = EAddToList::kDefault . ). Constructor using a pointer to a real function. ; Parameters. [in]nameobject name ; [in]fcnpointer to function ; [in]xmin,xmaxx axis limits ; [in]nparis the number of free parameters used by the function ; [in]ndimnumber of dimensions ; [in]addToGlobListboolean marking if it should be added to global list. This constructor creates a function of type C when invoked with the normal C++ compiler.; see test program test/stress.cxx (function stress1) for an example. note the interface with an intermediate pointer.; WarningA function created with this constructor cannot be Cloned. ; Definition at line 753 of file TF1.cxx. ◆ TF1() [7/15]. TF1::TF1 ; (; const char * ; name, . Double_t(*)(const Double_t *, const Double_t *) ; fcn, . Double_t ; xmin = 0, . Double_t ; xmax = 1, . Int_t ; npar = 0, . Int_t ; ndim = 1, . EAddToList ; addToGlobList = EAddToList::kDefault . ). Constructor using a pointer to (const) real function. ; Parameters. [in]nameobject name ; [in]fcnpointer to function ; [in]xmin,xmaxx axis limits ; [in]nparis the number of free parameters used by the function ; [in]ndimnumber of dimensions ; [in]addToGlobListboolean marking if it should be added to global list. This constructor creates a function of type C when invoked with the normal C++ compiler.; see test program test/stress.cxx (function stress1) for an example. note the interface with an intermediate pointer.; WarningA function created with this constructor cannot be Cloned. ; Definition at line 775 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:53047,interface,interface,53047,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['interface'],['interface']
Integrability,"arameters with variable bin sizes.Definition TProfile3D.h:83; TProfile3D::~TProfile3D~TProfile3D() overrideDefault destructor for Profile3D histograms.Definition TProfile3D.cxx:86; TProfile3D::ExtendAxisvoid ExtendAxis(Double_t x, TAxis *axis) overrideProfile histogram is resized along axis such that x is in the axis range.Definition TProfile3D.cxx:1206; TProfile3D::fTminDouble_t fTminLower limit in T (if set)Definition TProfile3D.h:36; TProfile3D::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile2D by a constant c1.Definition TProfile3D.cxx:1280; TProfile3D::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/Delete structure to store sum of squares of weights per bin This is needed to compute the corr...Definition TProfile3D.cxx:1379; TProfile3D::LabelsInflatevoid LabelsInflate(Option_t *axis=""X"") overrideDouble the number of bins for axis.Definition TProfile3D.cxx:857; TProfile3D::Project3DProfileTProfile2D * Project3DProfile(Option_t *option=""xy"") const overrideProject a 3-D profile into a 2D-profile histogram depending on the option parameter.Definition TProfile3D.cxx:1054; TProfile3D::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile3D.cxx:1288; TProfile3D::BufferFillInt_t BufferFill(Double_t, Double_t, Double_t, Double_t) overrideAccumulate arguments in buffer.Definition TProfile3D.h:46; TProfile3D::BuildOptionsvoid BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8h_source.html:15517,depend,depending,15517,doc/master/TProfile3D_8h_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8h_source.html,1,['depend'],['depending']
Integrability,"arametricStepFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooParametricStepFunction. class RooParametricStepFunction: public RooAbsPdf. The Parametric Step Function PDF is a binned distribution whose parameters; are the heights of each bin. This PDF was first used in BaBar's B0->pi0pi0; paper BABAR Collaboration (B. Aubert et al.) Phys.Rev.Lett.91:241801,2003. This PDF may be used to describe oddly shaped distributions. It differs; from a RooKeysPdf or a RooHistPdf in that a RooParametricStepFunction; has free parameters. In particular, any statistical uncertainty in; sample used to model this PDF may be understood with these free parameters;; this is not possible with non-parametric PDFs. The RooParametricStepFunction has Nbins-1 free parameters. Note that; the limits of the dependent varaible must match the low and hi bin limits. An example of usage is:. Int_t nbins(10);; TArrayD limits(nbins+1);; limits[0] = 0.0; //etc...; RooArgList* list = new RooArgList(""list"");; RooRealVar* binHeight0 = new RooRealVar(""binHeight0"",""bin 0 Value"",0.1,0.0,1.0);; list->add(binHeight0); // up to binHeight8, ie. 9 parameters. RooParametricStepFunction aPdf = (""aPdf"",""PSF"",*x,; *list,limits,nbins);. Function Members (Methods); public:. RooParametricStepFunction(); RooParametricStepFunction(const RooParametricStepFunction& other, const char* name = 0); RooParametricStepFunction(const char* name, const char* title, RooAbsReal& x, const RooArgList& coefList, TArrayD& limits, Int_t nBins = 1); virtual~RooParametricStepFunction(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParametricStepFunction.html:993,depend,dependent,993,root/html534/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html534/RooParametricStepFunction.html,1,['depend'],['dependent']
Integrability,"arametricStepFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooParametricStepFunction. class RooParametricStepFunction: public RooAbsPdf. The Parametric Step Function PDF is a binned distribution whose parameters; are the heights of each bin. This PDF was first used in BaBar's B0->pi0pi0; paper BABAR Collaboration (B. Aubert et al.) Phys.Rev.Lett.91:241801,2003. This PDF may be used to describe oddly shaped distributions. It differs; from a RooKeysPdf or a RooHistPdf in that a RooParametricStepFunction; has free parameters. In particular, any statistical uncertainty in; sample used to model this PDF may be understood with these free parameters;; this is not possible with non-parametric PDFs. The RooParametricStepFunction has Nbins-1 free parameters. Note that; the limits of the dependent varaible must match the low and hi bin limits. An example of usage is:. Int_t nbins(10);; TArrayD limits(nbins+1);; limits[0] = 0.0; //etc...; RooArgList* list = new RooArgList(""list"");; RooRealVar* binHeight0 = new RooRealVar(""binHeight0"",""bin 0 Value"",0.1,0.0,1.0);; list->add(binHeight0); // up to binHeight8, ie. 9 parameters. RooParametricStepFunction aPdf = (""aPdf"",""PSF"",*x,; *list,limits,nbins);. Function Members (Methods); public:. RooParametricStepFunction(const RooParametricStepFunction& other, const char* name = 0); RooParametricStepFunction(const char* name, const char* title, RooAbsReal& x, const RooArgList& coefList, TArrayD& limits, Int_t nBins = 1); virtual~RooParametricStepFunction(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooParametricStepFunction.html:993,depend,dependent,993,root/html526/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html526/RooParametricStepFunction.html,4,['depend'],['dependent']
Integrability,"arametricStepFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFIT; » RooParametricStepFunction. class RooParametricStepFunction: public RooAbsPdf. The Parametric Step Function PDF is a binned distribution whose parameters; are the heights of each bin. This PDF was first used in BaBar's B0->pi0pi0; paper BABAR Collaboration (B. Aubert et al.) Phys.Rev.Lett.91:241801,2003. This PDF may be used to describe oddly shaped distributions. It differs; from a RooKeysPdf or a RooHistPdf in that a RooParametricStepFunction; has free parameters. In particular, any statistical uncertainty in; sample used to model this PDF may be understood with these free parameters;; this is not possible with non-parametric PDFs. The RooParametricStepFunction has Nbins-1 free parameters. Note that; the limits of the dependent varaible must match the low and hi bin limits. An example of usage is:. Int_t nbins(10);; TArrayD limits(nbins+1);; limits[0] = 0.0; //etc...; RooArgList* list = new RooArgList(""list"");; RooRealVar* binHeight0 = new RooRealVar(""binHeight0"",""bin 0 Value"",0.1,0.0,1.0);; list->add(binHeight0); // up to binHeight8, ie. 9 parameters. RooParametricStepFunction aPdf = (""aPdf"",""PSF"",*x,; *list,limits,nbins);. Function Members (Methods); public:. virtual~RooParametricStepFunction(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParametricStepFunction.html:993,depend,dependent,993,root/html602/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html602/RooParametricStepFunction.html,2,['depend'],['dependent']
Integrability,"aramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:45433,integrat,integrator,45433,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,2,['integrat'],['integrator']
Integrability,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddModel.html:9522,depend,dependentOverlaps,9522,root/html528/RooAddModel.html,https://root.cern,https://root.cern/root/html528/RooAddModel.html,2070,['depend'],"['dependentOverlaps', 'dependsOn', 'dependsOnValue']"
Integrability,"arching...; No Matches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngRanLuxS1 Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Second generation of Ranlux generator for single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here ; Definition at line 369 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngRanLuxS1 ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html:1269,message,message,1269,doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html,1,['message'],['message']
Integrability,"ards. void paintEvent(QPaintEvent* ); Custom handler of the Qt paint event; A paint event is a request to repaint all or part of the widget.; It can happen as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtWidget.html:13277,wrap,wrapper,13277,root/html528/TQtWidget.html,https://root.cern,https://root.cern/root/html528/TQtWidget.html,5,['wrap'],['wrapper']
Integrability,"are both matched; 3259 if (isMatched && int(matched.size())!=nameList.GetSize()) {; 3260 isMatched = false ;; 3261 }; 3262 ; 3263 if(isMatched) matchedArgs.add(matched);; 3264 return isMatched;; 3265}; 3266 ; 3267 ; 3268 ; 3269////////////////////////////////////////////////////////////////////////////////; 3270/// Returns the default numeric integration configuration for all RooAbsReals; 3271 ; 3272RooNumIntConfig* RooAbsReal::defaultIntegratorConfig(); 3273{; 3274 return &RooNumIntConfig::defaultConfig() ;; 3275}; 3276 ; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3280/// If this object has no specialized configuration, a null pointer is returned.; 3281 ; 3282RooNumIntConfig* RooAbsReal::specialIntegratorConfig() const; 3283{; 3284 return _specIntegratorConfig.get();; 3285}; 3286 ; 3287 ; 3288////////////////////////////////////////////////////////////////////////////////; 3289/// Returns the specialized integrator configuration for _this_ RooAbsReal.; 3290/// If this object has no specialized configuration, a null pointer is returned,; 3291/// unless createOnTheFly is true in which case a clone of the default integrator; 3292/// configuration is created, installed as specialized configuration, and returned; 3293 ; 3294RooNumIntConfig* RooAbsReal::specialIntegratorConfig(bool createOnTheFly); 3295{; 3296 if (!_specIntegratorConfig && createOnTheFly) {; 3297 _specIntegratorConfig = std::make_unique<RooNumIntConfig>(*defaultIntegratorConfig()) ;; 3298 }; 3299 return _specIntegratorConfig.get();; 3300}; 3301 ; 3302 ; 3303 ; 3304////////////////////////////////////////////////////////////////////////////////; 3305/// Return the numeric integration configuration used for this object. If; 3306/// a specialized configuration was associated with this object, that configuration; 3307/// is returned, otherwise the default configuration for all Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:141897,integrat,integrator,141897,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['integrat'],['integrator']
Integrability,"are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:146; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:216; . TTree::Draw ROOT::RDataFrame . auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); h#define h(i)Definition RSha256.hxx:106; . tree->Draw(""jet_eta"", ""weight*(event == 1)"");; df.Filter(""event == 1"").Histo1D(""jet_eta"", ""weight"");; // or the fully compiled version:; df.Filter([] (ULong64_t e) { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:11942,interface,interface,11942,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['interface'],['interface']
Integrability,"are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff);; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; . TTree::Draw ROOT::RDataFrame . auto *tree = file->Get<TTree>(""myTree"");; tree->Draw(""x"", ""y > 2"");; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; ROOT::RDataFrame df(""myTree"", file);; auto h = df.Filter(""y > 2"").Histo1D(""x"");; h->Draw(); h#define h(i)Definition RSha256.hxx:106; . tree->Draw(""jet_eta"", ""weight*(event == 1)"");; df.Filter(""event == 1"").Histo1D(""jet_eta"", ""weight"");; // or the fully compiled version:; df.Filter([] (ULong64_t e) { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:12331,interface,interface,12331,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['interface'],['interface']
Integrability,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:9273,message,message,9273,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,6,['message'],['message']
Integrability,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:2165,depend,dependents,2165,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,12,['depend'],['dependents']
Integrability,"are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:23098,message,message,23098,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,5,['message'],['message']
Integrability,"are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip algorithm; (only if message is > 256 bytes). TMessage(void* buf, Int_t bufsize); Create a TMessage object for reading objects. The objects will be; read from buf. Use the What() method to get the message type. ~TMessage(); Clean up compression buffer. void EnableSchemaEvolutionForAll(Bool_t enable = kTRUE); Static function enabling or disabling the automatic schema evolution.; By default schema evolution support is off. Bool_t UsesSchemaEvolutionForAll(); Static function returning status of global schema evolution. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); Force writing the TStreamerInfo to the message. void Forward(); Change a buffer that was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Int_t Compress(); Compress the message. The message will only be compressed if the; compression level",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMessage.html:21987,message,message,21987,root/html528/TMessage.html,https://root.cern,https://root.cern/root/html528/TMessage.html,1,['message'],['message']
Integrability,"areOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~Simulated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html:7546,depend,depends,7546,root/html528/TMVA__SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html,4,['depend'],['depends']
Integrability,"arg5 = {}, . const RooCmdArg & ; arg6 = {} . ). Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ; NoteThis method does not perform any generation. To generate according to generations specification call RooAbsPdf::generate(RooAbsPdf::GenSpec&) const. Details copied from RooAbsPdf::generate():; Generate the specified number of events or expectedEvents() if not specified. Parameters. [in]whatVarsChoose variables in which to generate events. Variables not listed here will remain constant and not be used for event generation. ; [in]arg1,arg2,arg3,arg4,arg5,arg6Optional RooCmdArg() to change behaviour of generate(). . ReturnsRooDataSet *, owned by caller.; Any variables of this PDF that are not in whatVars will use their current values and be treated as fixed parameters. Returns zero in case of an error. Type of CmdArg Effect on generate . Name(const char* name) Name of the output dataset . Verbose(bool flag) Print informational messages during event generation . NumEvents(int nevt) Generate specified number of events . Extended() If no number of events to be generated is given, use expected number of events from extended likelihood term. This evidently only works for extended PDFs. . GenBinned(const char* tag) Use binned generation for all component pdfs that have 'setAttribute(tag)' set . AutoBinned(bool flag) Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc) NoteDatasets that are generated in binned mode are returned as weighted unbinned datasets. This means that for each bin, there will be one event in the dataset with a weight corresponding to the (possibly randomised) bin content. AllBinned() As above, but for all components. NoteThe notion of components is only meaningful for simultaneous PDFs as binned generation is always executed at the top-level node for a regular PDF, so for those it only mattes that the top-level node is tagg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:147400,message,messages,147400,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['message'],['messages']
Integrability,"arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:9765,message,message,9765,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,6,['message'],['message']
Integrability,"arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for messag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:9650,message,message,9650,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['message'],['message']
Integrability,"arg6={});  Add a message logging stream for message with given RooFit::MsgLevel or higher. ;  ; void clearErrorCount ();  ; Int_t & debugCode ();  ; RooWorkspace * debugWorkspace ();  ; void deleteStream (Int_t id);  Delete stream with given unique ID code. ;  ; Int_t errorCount () const;  ; StreamConfig & getStream (Int_t id);  ; bool getStreamStatus (Int_t id) const;  Get activation status of stream with given unique ID. ;  ; RooFit::MsgLevel globalKillBelow () const;  ; TClass * IsA () const override;  ; template<class T > ; bool isActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level);  Check if logging is active for given object/topic/RooFit::MsgLevel combination. ;  ; std::ostream & log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with RooAbsArg object self at given level and topic. ;  ; std::ostream & log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with TObject object self at given level and topic. ;  ; std::ostream & log (std::nullptr_t, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  ; Int_t numStreams () const;  ; void Print (Option_t *options=nullptr) const override;  Print configuration of message service. ;  ; void reset ();  ; void restoreState ();  Restore last saved state of message service. ;  ; void saveState ();  Save current state of message service. ;  ; void setGlobalKillBelow (RooFit::MsgLevel level);  ; void setSilentMode (bool flag);  ; void setStreamStatus (Int_t id, bool active);  (De)Activate stream with given unique ID ;  ; void showPid (bool flag);  ; bool silentMode () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:3809,message,message,3809,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['message'],['message']
Integrability,"arguments. RooPlot* plotOn(RooPlot *frame, PlotOpt o); Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:50969,interface,interface,50969,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['interface'],['interface']
Integrability,"ariable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class ;  CMinOpSubtraction Operation Class ;  CMinusUnary Minus Operation Class ;  CMinusEqualsEvaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) ;  CMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix -= general : NOT Allowed operation ;  CMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices ;  CMiserParametersStructures collecting parameters for MISER multidimensional integration ;  CMixMaxEngineMIXMAX Random number generator ;  CMulOpMultiplication (element-wise) Operation Class ;  CMultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimensional parameteric function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a multi dimensional parameteric gradient function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiNumGradFunctionMultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:38616,interface,interface,38616,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['interface'],['interface']
Integrability,"ariable size, return a pointer to the TLeaf that stores such size. ;  ; virtual TLeaf * GetLeafCounter (Int_t &countval) const;  Return a pointer to the counter of this leaf (if any) or store the number of elements that the leaf contains in countval. ;  ; virtual const Counts_t * GetLeafCountValues (Long64_t start, Long64_t len);  If this branch is a branch count, return the set of collection size for the entry range requested start: first entry to read and return information about len: number of entries to read. ;  ; virtual Int_t GetLen () const;  Return the number of effective elements of this leaf, for the current entry. ;  ; virtual Int_t GetLenStatic () const;  Return the fixed length of this leaf. ;  ; virtual Int_t GetLenType () const;  ; virtual Int_t GetNdata () const;  ; virtual Int_t GetOffset () const;  ; template<typename T > ; T GetTypedValue (Int_t i=0) const;  ; virtual Long64_t GetValueLong64 (Int_t i=0) const;  ; virtual LongDouble_t GetValueLongDouble (Int_t i=0) const;  ; virtual bool IsOnTerminalBranch () const;  ; virtual bool IsRange () const;  ; virtual bool IsUnsigned () const;  ; virtual bool ReadBasketSerialized (TBuffer &, Long64_t);  ; Int_t ResetAddress (void *add, bool calledFromDestructor=false);  Helper routine for TLeafX::SetAddress. ;  ; virtual void SetBranch (TBranch *branch);  ; virtual void SetLeafCount (TLeaf *leaf);  Set the leaf count of this leaf. ;  ; virtual void SetLen (Int_t len=1);  ; virtual void SetOffset (Int_t offset=0);  ; virtual void SetRange (bool range=true);  ; virtual void SetUnsigned ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafB.html:4062,rout,routine,4062,doc/master/classTLeafB.html,https://root.cern,https://root.cern/doc/master/classTLeafB.html,4,['rout'],['routine']
Integrability,"ariable type must be 1 character. (Characters; 142/// after the first are legal and will be appended to the visible; 143/// name of the leaf, but have no effect.) If no type is given, the; 144/// type of the variable is assumed to be the same as the previous; 145/// variable. If the first variable does not have a type, it is; 146/// assumed of type F by default. The list of currently supported; 147/// types is given below:; 148/// - `C` : a character string terminated by the 0 character; 149/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an array.; 150/// - `b` : an 8 bit unsigned integer (`UChar_t`); 151/// - `S` : a 16 bit signed integer (`Short_t`); 152/// - `s` : a 16 bit unsigned integer (`UShort_t`); 153/// - `I` : a 32 bit signed integer (`Int_t`); 154/// - `i` : a 32 bit unsigned integer (`UInt_t`); 155/// - `F` : a 32 bit floating point (`Float_t`); 156/// - `f` : a 24 bit floating point with truncated mantissa (`Float16_t`); 157/// - `D` : a 64 bit floating point (`Double_t`); 158/// - `d` : a 24 bit truncated floating point (`Double32_t`); 159/// - `L` : a 64 bit signed integer (`Long64_t`); 160/// - `l` : a 64 bit unsigned integer (`ULong64_t`); 161/// - `G` : a long signed integer (`Long_t`, which `sizeof` is platform dependent), stored as a 64 bit integer but usually held in memory as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 162/// - `g` : a long unsigned integer (`ULong_t`, which `sizeof` is platform dependent), stored as a 64 bit unsigned integer but held in memory usually as a 64 bit integer on 64 bit machines and 32 bit on 32 bit machines. Due to this difference, this data type is **not cross-platform**.; 163/// - `O` : [the letter `o`, not a zero] a boolean (`bool`); 164///; 165/// Arrays of values are supported with the following syntax:; 166/// - If leaf name has the form var[nelem], where nelem is alphanumeric, then; 167///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:5188,depend,dependent,5188,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['depend'],['dependent']
Integrability,"ariable> := name; <parameter> := [number]; <name> := String containing lower and upper letters, numbers, underscores; <number> := Integer number Operators are omitted. . Definition at line 1832 of file TFormula.cxx. ◆ FillDefaults(). void TFormula::FillDefaults ; (; ). private . Fill structures with default variables, constants and function shortcuts. ; Definition at line 902 of file TFormula.cxx. ◆ FillParametrizedFunctions(). void TFormula::FillParametrizedFunctions ; (; std::map< std::pair< TString, Int_t >, std::pair< TString, TString > > & ; functions). private . Fill map with parametrized functions. ; Definition at line 2417 of file TFormula.cxx. ◆ FillVecFunctionsShurtCuts(). void TFormula::FillVecFunctionsShurtCuts ; (; ). private . Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin. ; Definition at line 970 of file TFormula.cxx. ◆ GenerateGradientPar(). bool TFormula::GenerateGradientPar ; (; ). Generate gradient computation routine with respect to the parameters. ; returns true on success.; Returnstrue if a gradient was generated and GradientPar can be called. ; Definition at line 3192 of file TFormula.cxx. ◆ GenerateHessianPar(). bool TFormula::GenerateHessianPar ; (; ). Generate hessian computation routine with respect to the parameters. ; returns true on success.; Returnstrue if a hessian was generated and HessianPar can be called. ; Definition at line 3256 of file TFormula.cxx. ◆ GetExpFormula(). TString TFormula::GetExpFormula ; (; Option_t * ; option = """"); const. Return the expression formula. . If option = ""P"" replace the parameter names with their values; If option = ""CLING"" return the actual expression used to build the function passed to cling; If option = ""CLINGP"" replace in the CLING expression the parameter with their values . Definition at line 3524 of file TFormula.cxx. ◆ GetGradientFormula(). TString TFormula::GetGradientFormula ; (; ); const. Definition at line 3594 of file TFormula.cxx. ◆ G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:35401,rout,routine,35401,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['rout'],['routine']
Integrability,"ariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); vector<Float_t>X2P(const vector<Float_t>&, Int_t cls) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components using the ROOT class TPrincipal; and the normalization. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the principal component an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariablePCATransform.html:7770,message,message,7770,root/html528/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html,1,['message'],['message']
Integrability,"ariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, he has to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, he can fix a parameter or put limits on another one before handing them over to Minit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply his own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in form of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:37572,interface,interface,37572,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"ariance matrix as input using the class MnUserCovariance. More information can be found in [api:covariance].; 4.2.4 MnUserParameterState; The MnUserParameterState contains the parameters (MnUserParameters) and covariance (MnUserCovariance). The MnUserParameterState has to main purposes:. It can be used as input to minimization.; The result of the minimization is transformed into the user representable format by M . For more explanations see [api:state].; 4.3 Input to M; The following input combinations to M are possible:. \(\mbox{FCN}\) + parameters + uncertainties; \(\mbox{FCN}\) with gradient + parameters + uncertainties; \(\mbox{FCN}\) + parameters + covariance; \(\mbox{FCN}\) with gradient + parameters + covariance. For each of these combinations the user can chose between a minimal required interface (using std::vector containers) for the parameters and uncertainties or a more functional one provided by M . If the user wants to interact with the parameters before minimization (fixing, adding/removing limits), the minimal required interface cannot be used.; 4.3.1 What the user must supply; The user must supply to M. a valid implementation of the FCNBase base class; parameters with their starting values; expected uncertainties on the parameters. The input parameters can be simply defined via an std::vector\(<\)double\(>\), which means that all parameters are variables. If the user wants fix a parameter or put limits on it before minimization, they have to instantiate a MnUserParameters object and then add parameters one by one, giving them a name, value, uncertainty. Once all parameters are added to MnUserParameters, they can fix a parameter or put limits on another one before handing them over to Minuit for minimization.; 4.3.2 What the user can supply; Optionally the user can supply their own gradient calculator by implementing the FCNGradientBase interface or supply a full covariance matrix for input if one is available. The covariance matrix can be supplied in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:33556,interface,interface,33556,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['interface'],['interface']
Integrability,"ariesForPairElements(). void TClass::GetMissingDictionariesForPairElements ; (; TCollection & ; result, . TCollection & ; visited, . bool ; recurse . ). protected . Definition at line 3973 of file TClass.cxx. ◆ GetMissingDictionariesWithRecursionCheck(). void TClass::GetMissingDictionariesWithRecursionCheck ; (; TCollection & ; result, . TCollection & ; visited, . bool ; recurse . ). protected . From the second level of recursion onwards it is different state check. ; Definition at line 3990 of file TClass.cxx. ◆ GetNdata(). Int_t TClass::GetNdata ; (; ). Return the number of data members of this class Note that in case the list of data members is not yet created, it will be done by GetListOfDataMembers(). ; Definition at line 4554 of file TClass.cxx. ◆ GetNew(). ROOT::NewFunc_t TClass::GetNew ; (; ); const. Return the wrapper around new ThisClass(). ; Definition at line 7447 of file TClass.cxx. ◆ GetNewArray(). ROOT::NewArrFunc_t TClass::GetNewArray ; (; ); const. Return the wrapper around new ThisClass[]. ; Definition at line 7455 of file TClass.cxx. ◆ GetNmethods(). Int_t TClass::GetNmethods ; (; ). Return the number of methods of this class Note that in case the list of methods is not yet created, it will be done by GetListOfMethods(). ; This will also load/populate the list of methods, to get 'just' the number of currently loaded methods use: cl->GetListOfMethods(false)->GetSize(); ; Definition at line 4573 of file TClass.cxx. ◆ GetPersistentRef(). TClass *const * TClass::GetPersistentRef ; (; ); const. inline . Definition at line 481 of file TClass.h. ◆ GetRealData(). TRealData * TClass::GetRealData ; (; const char * ; name); const. Return pointer to TRealData element with name ""name"". ; Name can be a data member in the class itself, one of its base classes, or a member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built. ; Definition at line 3503 of file TClass.cxx. ◆ GetReferenceProxy(). TVirtualRefProxy * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:88645,wrap,wrapper,88645,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['wrap'],['wrapper']
Integrability,"ariesForPairElements(). void TClass::GetMissingDictionariesForPairElements ; (; TCollection & ; result, . TCollection & ; visited, . bool ; recurse . ). protected . Definition at line 4040 of file TClass.cxx. ◆ GetMissingDictionariesWithRecursionCheck(). void TClass::GetMissingDictionariesWithRecursionCheck ; (; TCollection & ; result, . TCollection & ; visited, . bool ; recurse . ). protected . From the second level of recursion onwards it is different state check. ; Definition at line 4057 of file TClass.cxx. ◆ GetNdata(). Int_t TClass::GetNdata ; (; ). Return the number of data members of this class Note that in case the list of data members is not yet created, it will be done by GetListOfDataMembers(). ; Definition at line 4621 of file TClass.cxx. ◆ GetNew(). ROOT::NewFunc_t TClass::GetNew ; (; ); const. Return the wrapper around new ThisClass(). ; Definition at line 7514 of file TClass.cxx. ◆ GetNewArray(). ROOT::NewArrFunc_t TClass::GetNewArray ; (; ); const. Return the wrapper around new ThisClass[]. ; Definition at line 7522 of file TClass.cxx. ◆ GetNmethods(). Int_t TClass::GetNmethods ; (; ). Return the number of methods of this class Note that in case the list of methods is not yet created, it will be done by GetListOfMethods(). ; This will also load/populate the list of methods, to get 'just' the number of currently loaded methods use: cl->GetListOfMethods(false)->GetSize(); ; Definition at line 4640 of file TClass.cxx. ◆ GetPersistentRef(). TClass *const * TClass::GetPersistentRef ; (; ); const. inline . Definition at line 481 of file TClass.h. ◆ GetRealData(). TRealData * TClass::GetRealData ; (; const char * ; name); const. Return pointer to TRealData element with name ""name"". ; Name can be a data member in the class itself, one of its base classes, or a member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built. ; Definition at line 3570 of file TClass.cxx. ◆ GetReferenceProxy(). TVirtualRefProxy * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:88646,wrap,wrapper,88646,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['wrap'],['wrapper']
Integrability,"arity vector-matrix product ;  SMatrix Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  VecOps;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte Carlo ;  ▼PROOFClasses defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees ;  PROOF kernel LibrariesThe PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e ;  PROOF benchmark utilitiesSet of utilities to benchmark a PROOF facility ;  XProofD client LibraryThe XProofD client library, libProofx, contain the classes providing the client to interact with the XRootD-based xproofd daemon ;  TMVAThe Multi Variate Analysis package ;  RooFitRooFit toolkit classes ;  RooFitCoreCore RooFit classes ;  RooStatsRooStats toolkit classes ;  DataFrameROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface ;  Tree LibraryTo store large quantities of same-class objects, ROOT provides the TTree and TNtuple classes ;  ▼TutorialsA collection of macros helping to learn ROOT by example ;  Tutorials specific to Mac/CocoaVarious examples showing graphics done with the Mac graphics system Cocoa. These examples run only on Mac/Os ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Data Frame tutorialsThese examples show the functionalities of the RDataFrame class ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files interface tutorialsExamples showing the FITS file interface ;  FOAM tutorialsExamples showing how to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/modules.html:8803,interface,interface,8803,doc/v614/modules.html,https://root.cern,https://root.cern/doc/v614/modules.html,1,['interface'],['interface']
Integrability,"arker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the SVG is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y; Int_tfYsizeSVGPage's Y size in SVG units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVG(); Default SVG constructor. TSVG(const char* filename, Int_t type = -113); Initialize the SVG interface. fname : SVG file name; wtype : SVG workstation type. Not used in the SVG driver. But as TSVG; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the SVG case). void Open(const char* filename, Int_t type = -111); Open a SVG file. ~TSVG(); Default SVG destructor. void Close(Option_t* opt = """"); Close a SVG file. void On(); Activate an already open SVG file. void Off(); Deactivate an already open SVG file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed SVG units dark is the; color for the dark part of the fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVG.html:12075,interface,interface,12075,root/html528/TSVG.html,https://root.cern,https://root.cern/root/html528/TSVG.html,3,['interface'],['interface']
Integrability,"arning(""RScanner::TreatRecordDeclOrTypeNameDecl"",; 636 ""Could not cast typeDecl either to RecordDecl or could not get RecordDecl underneath typedef.\n"");; 637 return true;; 638 }; 639 ; 640 // Do not select unnamed records.; 641 if (!recordDecl->getIdentifier()); 642 return true;; 643 ; 644 // Do not select dependent types.; 645 if (recordDecl->isDependentType()); 646 return true;; 647 ; 648 if (fScanType == EScanType::kOnePCM && ROOT::TMetaUtils::IsStdClass(*recordDecl)); 649 return true;; 650 ; 651 ; 652 // At this point, recordDecl must be a RecordDecl pointer.; 653 ; 654 if (fRecordDeclCallback) {; 655 // Pass on any declaration. This is usually used to record dependency.; 656 // Since rootcint see C++ compliant header files, we can assume that; 657 // if a forward declaration or declaration has been inserted, the; 658 // classes for which we are creating a dictionary will be using; 659 // them either directly or indirectly. Any false positive can be; 660 // resolved by removing the spurrious dependency in the (user) header; 661 // files.; 662 fRecordDeclCallback(recordDecl);; 663 }; 664 ; 665 // in case it is implicit or a forward declaration, we are not interested.; 666 if(recordDecl->isImplicit() || !recordDecl->isCompleteDefinition()) {; 667 return true;; 668 }; 669 ; 670 // Never select the class templates themselves.; 671 const clang::CXXRecordDecl *cxxdecl = llvm::dyn_cast<clang::CXXRecordDecl>(recordDecl);; 672 if (cxxdecl && cxxdecl->getDescribedClassTemplate ()) {; 673 return true;; 674 }; 675 ; 676 const ClassSelectionRule *selectedFromTypedef = typedefNameDecl ? fSelectionRules.IsDeclSelected(typedefNameDecl) : nullptr;; 677 ; 678 const ClassSelectionRule *selectedFromRecDecl = fSelectionRules.IsDeclSelected(recordDecl, false /* exclude typedef rules*/);; 679 ; 680 const ClassSelectionRule *selected = typedefNameDecl ? selectedFromTypedef : selectedFromRecDecl;; 681 ; 682 if (! selected) return true; // early exit. Nothing more to be done.; 683 ; 684",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:22213,depend,dependency,22213,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['depend'],['dependency']
Integrability,"array of pointers to objects to read into.; 850 pp[ndx] = (char *)new char *[vlen];; 851 if (!pp[ndx]) {; 852 Error(""ReadBuffer"", ""Memory allocation failed!\n"");; 853 continue;; 854 }; 855 // And set each pointer to null.; 856 memset(pp[ndx], 0, vlen * sizeof(char *)); // This is the right size we really have a char**: pp[ndx]; 857 // = (char*) new char*[vlen];; 858 }; 859 if (!isPtrPtr) {; 860 // -- We are a varying-length array of objects.; 861 // Loop over the elements of the varying length array.; 862 for (Int_t v = 0; v < vlen; ++v) {; 863 // Read the object from the buffer.; 864 cl->Streamer(pp[ndx] + (v * cl->Size()), buf);; 865 } // v; 866 } else {; 867 // -- We are a varying-length array of object pointers.; 868 // Get a pointer to the object pointer array.; 869 char **r = (char **)pp[ndx];; 870 // Loop over the elements of the varying length array.; 871 for (Int_t v = 0; v < vlen; ++v) {; 872 // Allocate an object to read into.; 873 r[v] = (char *)cl->New();; 874 if (!r[v]) {; 875 // Do not print a second error message here.; 876 // Error(""ReadBuffer"", ""Memory allocation failed!\n"");; 877 continue;; 878 }; 879 // Read the object from the buffer.; 880 cl->Streamer(r[v], buf);; 881 } // v; 882 } // isPtrPtr; 883 } // ndx; 884 // } // k; 885 } // fileVersion; 886 buf.CheckByteCount(start, count, config->fCompInfo->fElem->GetFullName());; 887 return 0;; 888 }; 889 ; 890 class TConfWithFactor : public TConfiguration {; 891 // Configuration object for the Float16/Double32 where a factor has been specified.; 892 public:; 893 Double_t fFactor;; 894 Double_t fXmin;; 895 TConfWithFactor(TVirtualStreamerInfo *info, UInt_t id, TCompInfo_t *compinfo, Int_t offset, Double_t factor, Double_t xmin) : TConfiguration(info,id,compinfo,offset),fFactor(factor),fXmin(xmin) {};; 896 TConfiguration *Copy() override { return new TConfWithFactor(*this); }; 897 };; 898 ; 899 template <typename T>; 900 INLINE_TEMPLATE_ARGS Int_t ReadBasicType_WithFactor(TBuffer &buf, void *addr, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:35580,message,message,35580,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['message'],['message']
Integrability,"ars Dependent variables over which to normalise, \f$ \{x\} \f$.; 808/// \param[in] projectedVars Variables to project out, \f$ \{ y \} \f$.; 809/// \param[out] cloneSet Will be set to a RooArgSet*, which will contain a clone of *this plus its projection integral object.; 810/// The latter will also be returned. The caller takes ownership of this set.; 811/// \param[in] rangeName Optional range for projection integrals; 812/// \param[in] condObs Conditional observables, which are not integrated for normalisation, even if they; 813/// are in `dependentVars` or `projectedVars`.; 814/// \return A pointer to the newly created object, or zero in case of an; 815/// error. The caller is responsible for deleting the `cloneSet` (which includes the returned projection object).; 816const RooAbsReal *RooAbsReal::createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,; 817 RooArgSet *&cloneSet, const char* rangeName, const RooArgSet* condObs) const; 818{; 819 // Get the set of our leaf nodes; 820 RooArgSet leafNodes;; 821 RooArgSet treeNodes;; 822 leafNodeServerList(&leafNodes,this);; 823 treeNodeServerList(&treeNodes,this) ;; 824 ; 825 ; 826 // Check that the dependents are all fundamental. Filter out any that we; 827 // do not depend on, and make substitutions by name in our leaf list.; 828 // Check for overlaps with the projection variables.; 829 for (const auto arg : dependentVars) {; 830 if(!arg->isFundamental() && !dynamic_cast<const RooAbsLValue*>(arg)) {; 831 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: variable \"""" << arg->GetName(); 832 << ""\"" of wrong type: "" << arg->ClassName() << std::endl;; 833 return nullptr;; 834 }; 835 ; 836 RooAbsArg *found= treeNodes.find(arg->GetName());; 837 if(!found) {; 838 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":createPlotProjection: \"""" << arg->GetName(); 839 << ""\"" is not a dependent and will be ignored."" << std::endl;; 840 continue;; 841 }; 842 if(found != ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:32628,depend,dependentVars,32628,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['depend'],"['dependentVars', 'dependents']"
Integrability,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:34540,depend,dependents,34540,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,1,['depend'],['dependents']
Integrability,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist(); Return RooDataHist that is represented. void setInterpolation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:34299,depend,dependents,34299,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,1,['depend'],['dependents']
Integrability,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:35736,depend,dependents,35736,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,1,['depend'],['dependents']
Integrability,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. void Streamer(TBuffer& b); Stream an object of class RooHistFunc. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:35057,depend,dependents,35057,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['depend'],['dependents']
Integrability,"arsVariables; Bool_t_verboseClient; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_verboseServer; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); Construct front-end object for object 'arg' whose evaluation will be calculated; asynchronously in a separate process. If calcInline is true the value of 'arg'; is calculate synchronously in the current process. RooRealMPFE(const RooRealMPFE& other, const char* name = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. Double_t getCarry() const. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:38209,message,message,38209,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,3,['message'],['message']
Integrability,"articles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGenerator.html:1753,interface,interfaces,1753,root/html528/TGenerator.html,https://root.cern,https://root.cern/root/html528/TGenerator.html,3,['interface'],['interfaces']
Integrability,"arting at the right place; 2193 mninex(fX);; 2194 nparx = fNpar;; 2195 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 2196 if (fs1 != fAmin) {; 2197 df = fAmin - fs1;; 2198 mnwarn(""D"", ""MNDERI"", TString::Format(""function value differs from AMIN by %12.3g"",df));; 2199 fAmin = fs1;; 2200 }; 2201 Printf("" FIRST DERIVATIVE DEBUG PRINTOUT. MNDERI"");; 2202 Printf("" PAR DERIV STEP MINSTEP OPTSTEP D1-D2 2ND DRV"");; 2203 }; 2204 dfmin = fEpsma2*8*(TMath::Abs(fAmin) + fUp);; 2205 if (fIstrat <= 0) {; 2206 ncyc = 2;; 2207 tlrstp = .5;; 2208 tlrgrd = .1;; 2209 } else if (fIstrat == 1) {; 2210 ncyc = 3;; 2211 tlrstp = .3;; 2212 tlrgrd = .05;; 2213 } else {; 2214 ncyc = 5;; 2215 tlrstp = .1;; 2216 tlrgrd = .02;; 2217 }; 2218// loop over variable parameters; 2219 for (i = 1; i <= fNpar; ++i) {; 2220 epspri = fEpsma2 + TMath::Abs(fGrd[i-1]*fEpsma2);; 2221// two-point derivatives always assumed necessary; 2222// maximum number of cycles over step size depends on strategy; 2223 xtf = fX[i-1];; 2224 stepb4 = 0;; 2225// loop as little as possible here!/; 2226 for (icyc = 1; icyc <= ncyc; ++icyc) {; 2227// theoretically best step; 2228 optstp = TMath::Sqrt(dfmin / (TMath::Abs(fG2[i-1]) + epspri));; 2229// step cannot decrease by more than a factor of ten; 2230 step = TMath::Max(optstp,TMath::Abs(fGstep[i-1]*.1));; 2231// but if parameter has limits, max step size = 0.5; 2232 if (fGstep[i-1] < 0 && step > .5) step = .5;; 2233// and not more than ten times the previous step; 2234 stpmax = TMath::Abs(fGstep[i-1])*10;; 2235 if (step > stpmax) step = stpmax;; 2236// minimum step size allowed by machine precision; 2237 stpmin = TMath::Abs(fEpsma2*fX[i-1])*8;; 2238 if (step < stpmin) step = stpmin;; 2239// end of iterations if step change less than factor 2; 2240 if (TMath::Abs((step - stepb4) / step) < tlrstp) goto L50;; 2241// take step positive; 2242 stepb4 = step;; 2243 if (fGstep[i-1] > 0) fGstep[i-1] = TMath::Abs(step);; 2244 else fGstep[i-1] = -TMath::Abs(step);; 2245 stepb4 = step;; 2246 fX[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:73991,depend,depends,73991,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['depend'],['depends']
Integrability,"arxiv.org/abs/1911.01303).; 1026 This option even correctly implements the case of extended likelihood fits; 1027 (see this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that complements the paper linked before).; 1028 * <tr><td> `PrefitDataFraction(double fraction)`; 1029 * <td> Runs a prefit on a small dataset of size fraction*(actual data size). This can speed up fits; 1030 * by finding good starting values for the parameters for the actual fit.; 1031 * \warning Prefitting may give bad results when used in binned analysis.; 1032 *; 1033 * <tr><th><th> Options to control informational output; 1034 * <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit).; 1035 * <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default.; 1036 * <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 to 3, default is 1). At -1 all RooFit informational messages are suppressed as well.; 1037 * See RooMinimizer::PrintLevel for the meaning of the levels.; 1038 * <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); 1039 * <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printed per likelihood evaluation.; 1040 * A negative value suppresses output completely, a zero value will only print the error count per p.d.f component,; 1041 * a positive value will print details of each error up to `numErr` messages per p.d.f component.; 1042 * <tr><td> `Parallelize(Int_t nWorkers)` <td> Control global parallelization settings. Arguments 1 and above enable the use of RooFit's parallel minimization; 1043 * backend and uses the number given as the number of workers to use in the parallelization. -1 also enables; 1044 * RooFit's parallel minimization backend, and sets the number of workers to the number of available processes.; 1045 * 0 disables this feature.; 1046 * In case p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:50142,message,messages,50142,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['message'],['messages']
Integrability,ary abs Operation Class ;  CFactoryFactory class holding static functions to create the interfaces like ROOT::Math::Minimizer via the Plugin Manager ;  CFastInverterFast Matrix Inverter class Class to specialize calls to Dinv ;  CFastInverter< 3 >3x3 direct matrix inversion using Cramer Rule use only for FastInverter ;  CFastInverter< 4 >4x4 matrix inversion using Cramers rule ;  CFastInverter< 5 >5x5 Matrix inversion using Cramers rule ;  CFunctorDocumentation for class Functor class ;  CFunctor1DFunctor1D class for one-dimensional functions ;  CFunctorGradHandlerFunctor Handler class for gradient functions where both callable objects are provided for the function evaluation (type Func) and for the gradient (type GradFunc) ;  CFunctorHandlerFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFunctorImplFunctorImpl is a base class for the functor handler implementation class ;  CGaussIntegratorUser class for performing function integration ;  CGaussLegendreIntegratorUser class for performing function integration ;  CGenAlgoOptionsClass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs ;  CGeneralLinearFunctionDerivationAuxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar ;  CGeneralLinearFunctionDerivation< double >;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the nu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:36623,integrat,integration,36623,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['integrat'],['integration']
Integrability,ary abs Operation Class ;  CFactoryFactory class holding static functions to create the interfaces like ROOT::Math::Minimizer via the Plugin Manager ;  CFastInverterFast Matrix Inverter class Class to specialize calls to Dinv ;  CFastInverter< 3 >3x3 direct matrix inversion using Cramer Rule use only for FastInverter ;  CFastInverter< 4 >4x4 matrix inversion using Cramers rule ;  CFastInverter< 5 >5x5 Matrix inversion using Cramers rule ;  CFunctorDocumentation for class Functor class ;  CFunctor1DFunctor1D class for one-dimensional functions ;  CFunctorGradHandlerFunctor Handler class for gradient functions where both callable objects are provided for the function evaluation (type Func) and for the gradient (type GradFunc) ;  CFunctorHandlerFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFunctorImplFunctorImpl is a base class for the functor handler implementation class ;  CGaussIntegratorUser class for performing function integration ;  CGaussLegendreIntegratorUser class for performing function integration ;  CGenAlgoOptionsClass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs ;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ) ;  CGSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:29822,integrat,integration,29822,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,3,['integrat'],['integration']
Integrability,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); -*-*-*-*-*-*-*-*Increment bin with abscissa X by 1*-*-*-*-*-*-*-*-*-*-*. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t Fill(Double_t x, Double_t w); -*-*-*-*-*-*Increment bin with abscis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:65276,depend,depending,65276,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['depend'],['depending']
Integrability,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); Increment bin with abscissa X by 1. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. The function returns the corresponding bin number which has its content incremented by 1. Int_t Fill(Double_t x, Double_t w); Increment bin with abscissa X with a weight w. if x is les",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:71110,depend,depending,71110,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['depend'],['depending']
Integrability,"as RooDataHist object found in workspace. ;  ; double asDOUBLE (const char *);  CINT constructor interface, return constructor string argument #idx as double. ;  ; RooDataSet & asDSET (const char *);  CINT constructor interface, return constructor string argument #idx as RooDataSet object found in workspace. ;  ; RooAbsReal & asFUNC (const char *);  CINT constructor interface, return constructor string argument #idx as RooAbsReal reference found in workspace. ;  ; Int_t asINT (const char *);  CINT constructor interface, return constructor string argument #idx as Int_t. ;  ; RooArgList asLIST (const char *);  CINT constructor interface, return constructor string argument #idx as RooArgList of objects found in workspace. ;  ; TObject & asOBJ (const char *);  ; RooAbsPdf & asPDF (const char *);  CINT constructor interface, return constructor string argument #idx as RooAbsPdf reference found in workspace. ;  ; RooResolutionModel & asRMODEL (const char *);  CINT constructor interface, return constructor string argument #idx as RooResolutionModel reference found in workspace. ;  ; RooArgSet asSET (const char *);  CINT constructor interface, return constructor string argument #idx as RooArgSet of objects found in workspace. ;  ; const char * asSTRING (const char *);  CINT constructor interface, return constructor string argument #idx as const char*. ;  ; RooRealVar & asVAR (const char *);  CINT constructor interface, return constructor string argument #idx as RooRealVar reference found in workspace. ;  ; RooAbsRealLValue & asVARLV (const char *);  CINT constructor interface, return constructor string argument #idx as RooAbsRealLValue reference found in workspace. ;  ; const char * autoClassNamePostFix () const;  ; RooAbsArg * createArg (const char *className, const char *objName, const char *varList);  Low-level factory interface for creating a RooAbsPdf of a given class with a given list of input variables The variable list varList should be of the form ""a,b,c"" where the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:2879,interface,interface,2879,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['interface'],['interface']
Integrability,"as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;; ; // Access the array of taus.; if (!taus.IsEmpty()) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; float currentWeight = *weight;; for (const Tau& tau: taus) {; hist->Fill(tau.eta(), currentWeight);; }; }; } // TTree entry / event loop; ; // Return true if we have iterated through all entries.; return reader.GetEntryStatus() == TTreeReader::kEntryBeyondEnd;; }; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TH1.h; TTreeReaderArray.h; ROOT::Internal::TTreeReaderValueBaseBase class of TTreeReaderValue.Definition TTreeReaderValue.h:45; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReader::kEntryBeyondEnd@ kEntryBeyondEndlast entry loop has reached its endDefinition TTreeReader.h:160. Definition at line 46 of file TTreeReader.h. Classes; class  Iterator_t;  Iterate through the entries of a TTree. More...;  . Public Types; enum  EEntryStatus { ;   kEntryValid = 0; , kEntryNotLoaded; , kEntryNoTree; , kEntryNotFound; , ;   kEntryChainSetupError; , kEntryChainFileError; , kEntryDictionaryError; , kEntryBeyondEnd; , ;   kEntryBadReader; , kIndexedFriendNoMatch; , kMissingBranchWhenSwitchingTree; , kEntryUnknownError. };  ; enum  ELoadTreeStatus { ;   kNoTree = 0; , kLoadTreeNone; , kInternalLoadTree; , kExternalLoadTree; , ;   kMissingBranchFromTree. };  ; typedef Iterator_t iterator;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:6136,interface,interface,6136,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['interface'],['interface']
Integrability,"as been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function); static ROOT::Math::FitMethodFunction*fgFunc; static ROOT::Math::FitMethodGradFunction*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFumiliMinimizer.html:6753,interface,interface,6753,root/html602/TFumiliMinimizer.html,https://root.cern,https://root.cern/root/html602/TFumiliMinimizer.html,2,['interface'],['interface']
Integrability,"as documented in the table below. This function takes the following named arguments (for more arguments, see also RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; const RooCmdArg&) const ). Type of argument Controlling normalisation . NormRange(const char* name) Calculate curve normalization w.r.t. specified range[s]. See the tutorial rf212_plottingInRanges_blinding.C NoteSetting a Range() by default also sets a NormRange() on the same range, meaning that the PDF is plotted and normalised in the same range. Overriding this can be useful if the PDF was fit in limited range[s] such as side bands, NormRange(""sidebandLeft,sidebandRight""), but the PDF should be drawn in the full range, Range(""""). Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code: RooAbsReal::Relative: relative adjustment factor RooAbsReal::NumEvent: scale to match given number of events. Type of argument Misc control . Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later . Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category \( \frac{F(+)-F(-)}{F(+)+F(-)} \) rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. . ShiftToZero(bool flag) Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting -log(L) or \( \chi^2 \) distributions . AddTo(const char* name, double_t wgtSelf, double_t wgtOther) Create a projection of this PDF onto the x-axis, but instead of plotting it directly, add it to an existing curve with given name (and relative weight factors). . Components(const char* names) When plotting sums of PDFs, plot only the named components (e.g. only the signal of a signal+background model). . Compon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:92416,depend,depends,92416,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,2,['depend'],['depends']
Integrability,"as operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104870,depend,dependent,1104870,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['depend'],['dependent']
Integrability,"as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (choosen randomly) at each step ;  CSimpleInterval;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:8393,interface,interface,8393,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['interface'],['interface']
Integrability,"as three args, these are interpreted as xinit,xmin,xmax; If list has one arg, this is interpreted as xinit and the variable is set as constant. string processCreateArg(string& func, vector<string>& args); Glue function between high-level syntax and low-level factory call to createArg:; Process a parsed call to create a p.d.f named func. The func arg is interpreted as ClassName::ObjectName and the arglist is passed; verbatim to createArg. The received arglist is expected to be fully reduced (i.e.; all inline object creations must have been compiled). std::string processMetaArg(string& func, vector<string>& args); Concatenate list of args into comma separated string. vector<string> splitFunctionArgs(const char* funcExpr); Allocate and fill work buffer. Bool_t checkSyntax(const char* arg); Perform basic syntax on given factory expression. If function returns; true syntax errors are found. void checkIndex(UInt_t index). RooAbsArg& asARG(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsArg reference found in workspace. RooAbsReal& asFUNC(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsReal reference found in workspace. RooAbsRealLValue& asVARLV(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsRealLValue reference found in workspace. RooRealVar& asVAR(const char* ); CINT constructor interface, return constructor string argument #idx as RooRealVar reference found in workspace. RooAbsPdf& asPDF(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsPdf reference found in workspace. RooResolutionModel& asRMODEL(const char* ); CINT constructor interface, return constructor string argument #idx as RooResolutionModel reference found in workspace. RooAbsCategory& asCATFUNC(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsCategory reference found in workspace. RooAbsCategory",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFactoryWSTool.html:20719,interface,interface,20719,root/html602/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html602/RooFactoryWSTool.html,2,['interface'],['interface']
Integrability,"asMethod( const TString& datasetname, const TString& title ) const;; 133 ; 134 Bool_t Verbose( void ) const { return fVerbose; }; 135 void SetVerbose( Bool_t v=kTRUE );; 136 ; 137 // make ROOT-independent C++ class for classifier response; 138 // (classifier-specific implementation); 139 // If no classifier name is given, help messages for all booked; 140 // classifiers are printed; 141 virtual void MakeClass(const TString& datasetname , const TString& methodTitle = """" ) const;; 142 ; 143 // prints classifier-specific help messages, dedicated to; 144 // help with the optimisation and configuration options tuning.; 145 // If no classifier name is given, help messages for all booked; 146 // classifiers are printed; 147 void PrintHelpMessage(const TString& datasetname , const TString& methodTitle = """" ) const;; 148 ; 149 TDirectory* RootBaseDir() { return (TDirectory*)fgTargetFile; }; 150 ; 151 Bool_t IsSilentFile() const { return fSilentFile;}; 152 Bool_t IsModelPersistence() const { return fModelPersistence; }; 153 ; 154 Double_t GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass = 0,; 155 Types::ETreeType type = Types::kTesting);; 156 Double_t GetROCIntegral(TString datasetname, TString theMethodName, UInt_t iClass = 0,; 157 Types::ETreeType type = Types::kTesting);; 158 ; 159 // Methods to get a TGraph for an indicated method in dataset.; 160 // Optional title and axis added with fLegend=kTRUE.; 161 // Argument iClass used in multiclass settings, otherwise ignored.; 162 TGraph *GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles = kTRUE, UInt_t iClass = 0,; 163 Types::ETreeType type = Types::kTesting);; 164 TGraph *GetROCCurve(TString datasetname, TString theMethodName, Bool_t setTitles = kTRUE, UInt_t iClass = 0,; 165 Types::ETreeType type = Types::kTesting);; 166 ; 167 // Methods to get a TMultiGraph for a given class and all methods in dataset.; 168 TMultiGraph *GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:5966,message,messages,5966,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['message'],['messages']
Integrability,"aseFunc;  ; typedef IGradientFunctionOneDim BaseGrad;  . Public Member Functions;  WrappedTF1 (const WrappedTF1 &rhs);  Copy constructor. ;  ;  WrappedTF1 (TF1 &f);  constructor from a TF1 function pointer. ;  ;  ~WrappedTF1 () override;  Destructor (no operations). ;  ; WrappedTF1 & operator= (const WrappedTF1 &rhs);  Assignment operator. ;  ; interface inherited from IFunction; ROOT::Math::IGenFunction * Clone () const override;  Clone the wrapper but not the original function. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:2464,interface,interface,2464,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,1,['interface'],['interface']
Integrability,aseRefCount ; (; ). inline . Definition at line 40 of file RooSharedProperties.h. ◆ inSharedList(). bool RooSharedProperties::inSharedList ; (; ); const. inline . Definition at line 45 of file RooSharedProperties.h. ◆ IsA(). TClass * RooSharedProperties::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 66 of file RooSharedProperties.h. ◆ operator=() [1/2]. RooSharedProperties & RooSharedProperties::operator= ; (; const RooSharedProperties & ; ). delete . ◆ operator=() [2/2]. RooSharedProperties & RooSharedProperties::operator= ; (; RooSharedProperties && ; ). delete . ◆ operator==(). bool RooSharedProperties::operator== ; (; const RooSharedProperties & ; other); const. Return true of unique id of this property is equal to that of other. ; Definition at line 69 of file RooSharedProperties.cxx. ◆ Print(). void RooSharedProperties::Print ; (; Option_t * ; opts = nullptr); const. overridevirtual . Printing interface. ; Reimplemented from TObject.; Definition at line 78 of file RooSharedProperties.cxx. ◆ refCount(). Int_t RooSharedProperties::refCount ; (; ); const. inline . Definition at line 42 of file RooSharedProperties.h. ◆ setInSharedList(). void RooSharedProperties::setInSharedList ; (; ). inline . Definition at line 44 of file RooSharedProperties.h. ◆ Streamer(). void RooSharedProperties::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooSharedProperties::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 66 of file RooSharedProperties.h. ◆ uuid(). UUID RooSharedProperties::uuid ; (; ); const. inline . Definition at line 58 of file RooSharedProperties.h. Member Data Documentation. ◆ _inSharedList. Int_t RooSharedProperties::_inSharedList. protected . ! Is in shared list ; Definition at line 64 of file RooSharedProperties.h. ◆ _refCount. Int_t Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSharedProperties.html:13596,interface,interface,13596,doc/master/classRooSharedProperties.html,https://root.cern,https://root.cern/doc/master/classRooSharedProperties.html,1,['interface'],['interface']
Integrability,"ashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTableIter.html:2224,depend,depending,2224,root/html534/THashTableIter.html,https://root.cern,https://root.cern/root/html534/THashTableIter.html,1,['depend'],['depending']
Integrability,"ashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 338 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 999 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1129 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 269 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 226 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::sna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:57643,message,messages,57643,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['message'],['messages']
Integrability,"ashTableSize(). void RooAbsCollection::setHashTableSize ; (; Int_t ; number). inline . Set the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ; Definition at line 106 of file RooAbsCollection.h. ◆ setName(). void RooAbsCollection::setName ; (; const char * ; name). inline . Definition at line 361 of file RooAbsCollection.h. ◆ setRealValue(). bool RooAbsCollection::setRealValue ; (; const char * ; name, . double ; newVal = 0.0, . bool ; verbose = false . ). Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed unless the verbose flag is set. ; Definition at line 989 of file RooAbsCollection.cxx. ◆ setStringValue(). bool RooAbsCollection::setStringValue ; (; const char * ; name, . const char * ; newVal = """", . bool ; verbose = false . ). Set string value of a RooStringVar stored in set with given name to newVal. ; No error messages are printed unless the verbose flag is set ; Definition at line 1119 of file RooAbsCollection.cxx. ◆ size(). Storage_t::size_type RooAbsCollection::size ; (; ); const. inline . Definition at line 292 of file RooAbsCollection.h. ◆ snapshot() [1/2]. RooAbsCollection * RooAbsCollection::snapshot ; (; bool ; deepCopy = true); const. Take a snap shot of current collection contents. ; An owning collection is returned containing clones of; Elements in this collection; External dependents of all elements and recursively any dependents of those dependents (if deepCopy flag is set). This is useful to save the values of variables or parameters. It doesn't require deep copying if the parameters are direct members of the collection.; If deepCopy is specified, the client-server links between the cloned list elements and the cloned external dependents are reconnected to each other, making the snapshot a completely self-contained entity. ; Definition at line 219 of file RooAbsCollection.cxx. ◆ snapshot() [2/2]. bool RooAbsCollection::sna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:59426,message,messages,59426,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['message'],['messages']
Integrability,"asic canvas. ; Order is significant. Delete in reverse order of creation. ; Definition at line 621 of file TRootCanvas.cxx. Member Function Documentation. ◆ Activated(). void TRootCanvas::Activated ; (; Int_t ; id). Slot handling tab switching in the browser, to properly set the canvas and the model to the editor. ; Definition at line 2072 of file TRootCanvas.cxx. ◆ AdjustSize(). void TRootCanvas::AdjustSize ; (; ). Keep the same canvas size while docking/undocking toolbar. ; Definition at line 1706 of file TRootCanvas.cxx. ◆ Class(). static TClass * TRootCanvas::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TRootCanvas::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TRootCanvas::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 150 of file TRootCanvas.h. ◆ Close(). void TRootCanvas::Close ; (; ). overridevirtual . Called via TCanvasImp interface by TCanvas. ; Reimplemented from TCanvasImp.; Definition at line 671 of file TRootCanvas.cxx. ◆ CloseWindow(). void TRootCanvas::CloseWindow ; (; ). overridevirtual . In case window is closed via WM we get here. ; Reimplemented from TGMainFrame.; Definition at line 714 of file TRootCanvas.cxx. ◆ CreateCanvas(). void TRootCanvas::CreateCanvas ; (; const char * ; name). private . Create the actual canvas. ; Definition at line 332 of file TRootCanvas.cxx. ◆ CreateEditor(). void TRootCanvas::CreateEditor ; (; ). private . Create embedded editor. ; Definition at line 1560 of file TRootCanvas.cxx. ◆ DeclFileName(). static const char * TRootCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 150 of file TRootCanvas.h. ◆ EventInfo(). void TRootCanvas::EventInfo ; (; Int_t ; event, . Int_t ; px, . Int_t ; py, . TObject * ; selected . ). Display a tooltip with infos about the primitive below the cursor. ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:44084,interface,interface,44084,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['interface'],['interface']
Integrability,"asisList! List of created basis functions; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:42166,integrat,integration,42166,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,1,['integrat'],['integration']
Integrability,"ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t Echo(const TObject* obj); Sends an object to master and workers and expect them to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, instead of; being sent back at the end in one go. This may help debugging or monitoring; in some cases, but, depending on the amount of log, it may have significant; consequencies on the load over the network, so it must be used with care. Int_t SetParallelSilent(Int_t nodes, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. If random is TRUE a random; selection is done (if nodes is less than the available nodes).; Returns the number of parallel slaves. Returns -1 in case of error. Int_t SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); Tell PROOF how many slaves to use in parallel. Returns the number of; parallel slaves. Returns -1 in case of error. Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:66963,message,message,66963,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['message'],['message']
Integrability,"ass ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void InitializeContext ();  Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ;  ; virtual void OnValidateError (const TString &message);  This function is called when an error from the parser has occurred. ;  ; virtual void OnValidateWarning (const TString &message);  This function is called when a warning from the parser has occurred. ;  ; virtual void ReleaseUnderlying ();  To release any existing document. ;  ; virtual void SetParseCode (Int_t code);  Set the parse code: ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; _xmlParserCtxt * fContext;  Parse the xml file. ;  ; Int_t fParseCode;  To keep track of the errorcodes. ;  ; Bool_t fRep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:13427,message,messages,13427,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['message'],['messages']
Integrability,"ass ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate the raw value of this p.d.f which is the effFunc value if cat==1 and it is (1-effFunc) if cat==0. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEfficiency.html:60088,rout,routine,60088,doc/master/classRooEfficiency.html,https://root.cern,https://root.cern/doc/master/classRooEfficiency.html,1,['rout'],['routine']
Integrability,"ass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 2887 }; 2888 if (expectedClass && expectedClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(expectedClass->GetCollectionProxy())) {; 2889 Error(""SetBranchAddress"", ""Unable to determine the type given for the address for \""%s\"". ""; 2890 ""The class expected (%s) refers to an stl collection and do not have a compiled CollectionProxy. ""; 2891 ""Please generate the dictionary for this class (%s)"",; 2892 branch->GetName(), expectedClass->GetName(), expectedClass->GetName());; 2893 return kMissingComp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:113733,message,message,113733,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['message'],['message']
Integrability,"ass ; Definition at line 77 of file TEveTriangleSet.h. ◆ ComputeBBox(). void TEveTriangleSet::ComputeBBox ; (; ). overridevirtual . Compute bounding box. ; Virtual from TAttBBox. ; Implements TAttBBox.; Definition at line 126 of file TEveTriangleSet.cxx. ◆ DeclFileName(). static const char * TEveTriangleSet::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 77 of file TEveTriangleSet.h. ◆ GenerateRandomColors(). void TEveTriangleSet::GenerateRandomColors ; (; ). Assign random colors to all triangles. ; Definition at line 86 of file TEveTriangleSet.cxx. ◆ GenerateTriangleNormals(). void TEveTriangleSet::GenerateTriangleNormals ; (; ). Generate triangle normals via cross product of triangle edges. ; Definition at line 63 of file TEveTriangleSet.cxx. ◆ GenerateZNormalColors(). void TEveTriangleSet::GenerateZNormalColors ; (; Float_t ; fac = 20, . Int_t ; min = -20, . Int_t ; max = 20, . Bool_t ; interp = kFALSE, . Bool_t ; wrap = kFALSE . ). Generate triangle colors by the z-component of the normal. ; Current palette is taken from gStyle. ; Definition at line 105 of file TEveTriangleSet.cxx. ◆ GetNTrings(). Int_t TEveTriangleSet::GetNTrings ; (; ); const. inline . Definition at line 51 of file TEveTriangleSet.h. ◆ GetNVerts(). Int_t TEveTriangleSet::GetNVerts ; (; ); const. inline . Definition at line 50 of file TEveTriangleSet.h. ◆ IsA(). TClass * TEveTriangleSet::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveElementList.; Definition at line 77 of file TEveTriangleSet.h. ◆ operator=(). TEveTriangleSet & TEveTriangleSet::operator= ; (; const TEveTriangleSet & ; ). private . ◆ Paint(). void TEveTriangleSet::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint this object. Only direct rendering is supported. ; Reimplemented from TObject.; Definition at line 142 of file TEveTriangleSet.cxx. ◆ ReadTrivialFile(). TEveTriangleSet * TEveTriangl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTriangleSet.html:38397,wrap,wrap,38397,doc/master/classTEveTriangleSet.html,https://root.cern,https://root.cern/doc/master/classTEveTriangleSet.html,1,['wrap'],['wrap']
Integrability,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0); init PDEFoam objects. MethodPDEFoam(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDEFoam can handle classification with 2 classes and regression; with one or more regression-targets. void Init( void ); default initialization called by all constructors. void DeclareOptions(). Declare MethodPDEFoam options. void DeclareCompatibilityOptions(). void ProcessOptions(); process user options. ~MethodPDEFoam( void ); destructor. void CalcXminXmax(); Determine foam range [fXmin, fXmax] for all dimensions, such; that fFrac events lie outside the foam. void Train( void ); Train PDE-Foam depending on the set options. void TrainSeparatedClassification(); Creation of 2 separated foams: one for signal events, one for; backgound events. void TrainUnifiedClassification(); Create only one unified foam which contains discriminator; (N_sig)/(N_sig + N_bg). void TrainMonoTargetRegression(); Training mono target regression foam; - foam density = average Target(0); - dimension of foam = number of non-targets; - cell content = average target 0. void TrainMultiTargetRegression(); Training multi target regression foam; - foam density = Event density; - dimension of foam = number of non-targets + number of targets; - cell content = event density. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' return; the cell content (D = N_sig/(N_bg+N_sig)). In case of; 'fSigBgSeparated==false' return D =; Density_sig/(Density_sig+Density_bg). In both cases the error; of the discriminant is stored in 'err'. void SetXminXmax(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDEFoam.html:18464,depend,depending,18464,root/html528/TMVA__MethodPDEFoam.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html,1,['depend'],['depending']
Integrability,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete all global object upon program termination. RooMsgService(); Constructor. Defines names of message levels; and mapping of topic codes to topic names; Install default message streams. ~RooMsgService(); Destructor. Bool_t anyDebug(); Returns true if any debug level stream is active. RooWorkspace* debugWorkspace(). Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(ostream&) -- Send output to given C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:9033,message,messages,9033,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,6,['message'],['messages']
Integrability,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooIntegrator1D(); Default constructor. RooIntegrator1D(const RooAbsFunc& function, SummationRule rule,				 Int_t maxSteps, Double_t eps); Construct integrator on given function binding, using specified summation; rule, maximum number of steps and conversion tolerance. The integration; limits are taken from the function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding for given range,; using specified summation rule, maximum number of steps and; conversion tolerance. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax,				const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegrator1D.html:8761,integrat,integrator,8761,root/html526/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooIntegrator1D.html,1,['integrat'],['integrator']
Integrability,"ass ReferenceThe Geometry Package » Geometry classes. ; Special pool of reusable nodes. ; Definition at line 56 of file TGeoCache.h. Public Member Functions;  TGeoNodeCache ();  Dummy constructor. ;  ;  TGeoNodeCache (TGeoNode *top, Bool_t nodeid=kFALSE, Int_t capacity=30);  Default constructor. ;  ;  ~TGeoNodeCache () override;  Destructor. ;  ; void BuildIdArray ();  Builds node id array. ;  ; void BuildInfoBranch ();  Builds info branch. Navigation is possible only after this step. ;  ; Bool_t CdDown (Int_t index);  Make daughter INDEX of current node the active state. Compute global matrix. ;  ; Bool_t CdDown (TGeoNode *node);  Make daughter INDEX of current node the active state. Compute global matrix. ;  ; void CdNode (Int_t nodeid);  Change current path to point to the node having this id. ;  ; void CdTop ();  ; void CdUp ();  Make mother of current node the active state. ;  ; void FillIdBranch (const Int_t *br, Int_t startlevel=0);  ; void * GetBranch () const;  ; void GetBranchNames (Int_t *names) const;  Fill names with current branch volume names (4 char - used by GEANT3 interface). ;  ; void GetBranchNumbers (Int_t *copyNumbers, Int_t *volumeNumbers) const;  Fill copy numbers of current branch nodes. ;  ; void GetBranchOnlys (Int_t *isonly) const;  Fill copy numbers of current branch nodes. ;  ; TGeoHMatrix * GetCurrentMatrix () const;  ; Int_t GetCurrentNodeId () const;  Returns a fixed ID for current physical node. ;  ; const Int_t * GetIdBranch () const;  ; TGeoStateInfo * GetInfo ();  Get next state info pointer. ;  ; Int_t GetLevel () const;  ; TGeoStateInfo * GetMakePWInfo (Int_t nd);  Get the PW info, if none create one. ;  ; void * GetMatrices () const;  ; TGeoNode * GetMother (Int_t up=1) const;  ; TGeoHMatrix * GetMotherMatrix (Int_t up=1) const;  ; TGeoNode * GetNode () const;  ; Int_t GetNodeId () const;  Get unique node id. ;  ; const char * GetPath ();  Returns the current geometry path. ;  ; Int_t GetStackLevel () const;  ; TGeoNode * GetTo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNodeCache.html:1391,interface,interface,1391,doc/master/classTGeoNodeCache.html,https://root.cern,https://root.cern/doc/master/classTGeoNodeCache.html,1,['interface'],['interface']
Integrability,"ass RooIntegratorBinding: public RooAbsFunc. Function binding representing the output of a RooAbsIntegrator; . Function Members (Methods); public:. RooIntegratorBinding(RooAbsIntegrator& integrator); RooIntegratorBinding(const RooIntegratorBinding&); virtual~RooIntegratorBinding(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t index) const; virtual Double_tgetMinLimit(UInt_t index) const; virtual const char*RooAbsFunc::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooIntegratorBinding&operator=(const RooIntegratorBinding&); virtual list<Double_t>*RooAbsFunc::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooAbsFunc::restoreXVec() const; virtual voidRooAbsFunc::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_tRooAbsFunc::_dimensionNumber of observables; RooAbsIntegrator*_integratorNumeric integrator; Int_tRooAbsFunc::_ncallFunction call counter; Bool_tRooAbsFunc::_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooIntegratorBinding(RooAbsIntegrator& integrator); {}. virtual ~RooIntegratorBinding(); {}. Double_t operator()(const Double_t* xvector) const; { _ncall++ ; return _integrator->integral(xvector) ; }. Double_t getMinLimit(UInt_t index) const; { return _integrator->integrand()->getMinLimit(index+1); }. Double_t getMaxLimit(UInt_t index) const; { return _integrator->integrand()->getMaxLimit(index+1); }. » Last changed: Thu Sep 23 19:59:59 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegratorBinding.html:1449,integrat,integrator,1449,root/html528/RooIntegratorBinding.html,https://root.cern,https://root.cern/root/html528/RooIntegratorBinding.html,2,['integrat'],['integrator']
Integrability,ass charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TActivationChooser.html:1203,message,message,1203,root/html528/TMVA__TActivationChooser.html,https://root.cern,https://root.cern/root/html528/TMVA__TActivationChooser.html,1,['message'],['message']
Integrability,"ass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according to the matrix representations ;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CRichardsonDerivatorUser class for calculating the derivatives of a function ;  CRMinimizerRMinimizer class ;  CRootFinderUser Class to find the Root of one dimensional functions ;  CRotation3DRotation class with the (3D) rotation represented by a 3x3 orthogonal matrix ;  CRotationTraits;  CRotationTraits< AxisAngle >;  CRotationTraits< EulerAngles >;  CRotationTraits< LorentzRotation >;  CRotationTraits< Quaternion >;  CRotationTraits< Rotation3D >;  CRotationTraits< RotationX >;  CRotationTraits< RotationY >;  CRotationTraits< RotationZ >;  CRotationXRotation class representing a 3D rotation about th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:47114,interface,interface,47114,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['interface'],['interface']
Integrability,"ass describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+) ;  CPxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E) ;  CPxPyPzM4DClass describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M) ;  CQuasiRandomUser class for MathMore random numbers template on the Engine type ;  CQuaternionRotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k) ;  CRandomDocumentation for the Random class ;  CRandomFunctions;  CRandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >Specialized implementation of the Random functions based on the GSL library ;  CRandomFunctionsImplDefinition of the generic impelmentation class for the RandomFunctions ;  CRandomFunctionsImpl< TRandomEngine >Implementation class for the RandomFunction for all the engined that derives from TRandomEngine class, which defines an interface which has TRandomEngine::Rndm() In this way we can have a common implementation for the RandomFunctions ;  CRetrieveMatrixStructure for getting sub matrices We have different cases according to the matrix representations ;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepStd< T, D3, D4 > >;  CRetrieveMatrix< T, D1, D2, D3, D4, MatRepSym< T, D1 >, MatRepSym< T, D3 > >;  CRichardsonDerivatorUser class for calculating the derivatives of a function ;  CRMinimizerRMinimizer class ;  CRootFinderUser Class to find the Root of one dimensional functions ;  CRotation3DRotation class with the (3D) rotation represented by a 3x3 orthogonal matrix ;  CRotationXRotation class representing a 3D rotation about the X axis by the angle of rotation ;  CRotationYRotation class representing a 3D rotation about the Y axis by the angle of rotation ;  CRotationZRotation class representing a 3D rotation about the Z axis by the angle of rotation ;  CRotationZYXRotation class with the (3D) rota",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:54276,interface,interface,54276,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['interface'],['interface']
Integrability,ass for Unuran distribution wrappers; TUnuranContDist Wrapper class for one dimensional continuous distribution; TUnuranDiscrDist Wrapper class for one dimensional discrete distribution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> Template of Vector class; TVectorT<float> Template of Vector class; TView 3-D View abstract interface for 3-D views; TView3D 3-D View; TViewer3DPad A 3D Viewer painter for TPads; TViewerX3D Interface to the X3D viewer; TVirtualArray ; TVirtualAuth client auth interface; TVirtualBranchBrowsable Base class for helper objects used for browsing; TVirtualCollectionProxy ; TVirtualDragManager drag and drop manager; TVirtualFFT abstract interface for FFT calculations; TVirtualFitter Abstract interface for fitting; TVirtualGLManip Interface for GL manipulator; TVirtualGLPainter Interface for OpenGL painter; TVirtualGeoPainter Abstract interface for geometry painters; TVirtualGeoTrack virtual geometry tracks; TVirtualGraphPainter Abstract interface for histogram painters; TVirtualHistPainter Abstract interface for histogram painters; TVirtualIndex Abstract interface for Tree Index; TVirtualIsAProxy ; TVirtualMC Interface to Monte Carlo; TVirtualMCApplication Interface to MonteCarlo application; TVirtualMCDecayer Particle Decayer Base Class; TVirtualMCGeometry Interface to Monte Carlo geometry construction; TVirtualMCStack Interface to a particles stack; TVirtualMagField Abstract base field class; TVirtualMonitoringReader ABC for Reading Monitoring Information; TVirtualMonitoringWriter ABC for Sending Monitoring Information; TVirtualMutex Virtual mutex lock class; TVirtualObject ; TVirtualPS Abstract interface to a PostScript driver; TVirtualPacketizer Generate work packets for pa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:127884,interface,interface,127884,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,4,['interface'],['interface']
Integrability,"ass for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtvoid AddAt(TObject *obj, Int_t idx) overrideAdd object at position ids.Definition TObjArray.cxx:254; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TVirtualGeoPainterAbstract class for geometry painters.Definition TVirtualGeoPainter.h:32; bool; double; int. geomgeomsrcTGeoPhysicalNode.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:34609,message,message,34609,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,4,['message'],['message']
Integrability,"ass for performing a simulated annealing search of a multidimensional function ;  CGSLSimAnParamsStructure holding the simulated annealing parameters ;  CGSLVegasIntegrationWorkspaceWorkspace for VEGAS ;  CIBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim ;  CIBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evaluate the function given a value (simple double) by implementing operator() (const double ) ;  CIBaseParamDocumentation for the abstract class IBaseParam ;  CIGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation ;  CIGradientFunctionOneDimInterface (abstract class) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimTemplGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:44216,interface,interface,44216,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['interface'],['interface']
Integrability,ass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; struct  GeneralHessianCalc;  ; struct  GeneralHessianCalc< double >;  ; struct  GeneralLinearFunctionDerivation;  Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...;  ; struct  GeneralLinearFunctionDerivation< double >;  ; class  GeneticMinimizer;  GeneticMinimizer. More...;  ; struct  GeneticMinimizerParameters;  ; class  GenVector_exception;  ; class  GlobalCoordinateSystemTag;  Tag for identifying vectors based on a global coordinate system. More...;  ; class  GoFTest;  GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. More...;  ; class  GradFunctor;  GradFunctor class for Multidimensional gradient functions. More...;  ; class  GradFunctor1D;  GradFunctor1D class for one-dimensional gradient functions. More...;  ; class  GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  GSLChebSeries;  wrapper class for C struct gsl_cheb_series More...;  ; class  GSLDerivator;  Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). More...;  ; class  GSLError;  class to change GSL Error handler to use ROOT one. More...;  ; class  GSLFunctionAdapter;  Class for adapting any C++ functor class to C function pointers used by GSL. More...;  ; class  GSLFunctionDerivWrapper;  class to wrap a gsl_function_fdf (with derivatives) More...;  ; class  GSLFunctionWrapper;  Wrapper class to the gsl_function C structure. More...;  ; class  GSLIntegrationWorkspace;  ; class  GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  GSLMC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:8796,wrap,wrapper,8796,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['wrap'],['wrapper']
Integrability,"ass objects, ROOT provides the TTree and TNtuple classes ;  DataFrameROOT's TDataFrame allows to analyse data stored in TTrees with a high level interface ;  ▼TutorialsA collection of macros illustrating many aspect of ROOT ;  Tutorials specific to Mac/CocoaVarious examples showing graphics done with the Mac graphics system Cocoa. These examples run only on Mac/Os ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Data Frame tutorialsThese examples show the functionalities of the TDataFrame class ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files interface tutorialsExamples showing the FITS file interface ;  FOAM tutorialsExamples showing how to use FOAM ;  Geometry tutorialsVarious ROOT geometry package examples ;  OpenGL tutorialsVarious examples showing the OpenGL graphics in ROOT ;  Graphics tutorialsVarious examples showing the basic ROOT graphics ;  Graphs tutorialsExamples showing the ""graphs classes"" usage. ;  GUI tutorialsExample code which illustrates how to use the ROOT GUI ;  Histograms tutorialsExamples showing the ""histograms' classes"" usage. ;  HTTP tutorialsExamples showing the HTTP interface ;  Image tutorialsExamples showing the TImage class usage ;  IO tutorialsThese tutorials illustrate some of the capabilities of the ROOT IO subsystem ;  Math tutorialsExamples showing the Math classes ;  Matrix tutorialsExamples showing how to use TMatrix ;  Monte Carlo tutorialsMonte Carlo examples ;  TMemStat tutorialsExamples showing the TMemStat class ;  Multi Layer Perceptron tutorialsExamples showing the Multi Layer Perceptron classes ;  Multicore tutorialsThese examples aim to illustrate the multicore features of ROOT, such as thread awareness and safety, multi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/modules.html:9607,interface,interface,9607,doc/v612/modules.html,https://root.cern,https://root.cern/doc/v612/modules.html,2,['interface'],['interface']
Integrability,"ass with a library. void StreamerStreamerInfo(void* object, TBuffer& b, const TClass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:45248,wrap,wrapper,45248,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,2,['wrap'],['wrapper']
Integrability,"ass  ROpaqueTaskArena;  ; class  RRangeCast;  Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:2969,interface,interfaces,2969,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['interface'],['interfaces']
Integrability,"ass"" if needed and return true if it has been added or if it is known to not be needed. ; (I.e. return false if a container of this class can not have a ""pragma C++ class"" ; Definition at line 1564 of file TTreeProxyGenerator.cxx. ◆ ReleaseDefaultErrorHandler(). void ROOT::Internal::ReleaseDefaultErrorHandler ; (; ). Destructs resources that are taken by using the default error handler. ; This function is called during the destruction of gROOT. ; Definition at line 47 of file TErrorDefaultHandler.cxx. ◆ RequiresCleanup(). Bool_t ROOT::Internal::RequiresCleanup ; (; TObject & ; obj). inline . Definition at line 386 of file TROOT.h. ◆ ResetReadEntry(). void ROOT::Internal::ResetReadEntry ; (; TFriendProxy * ; fp). Helper function to call SetReadEntry on all TFriendProxy. ; Definition at line 39 of file TBranchProxyDirector.cxx. ◆ SetErrorSystemMsgHandler(). ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler ; (; ErrorSystemMsgHandlerFunc_t ; h). Returns the previous system error message handler. ; Definition at line 56 of file TError.cxx. ◆ SetRequireCleanup(). void ROOT::Internal::SetRequireCleanup ; (; TObject & ; obj). inline . Definition at line 381 of file TROOT.h. ◆ Sha256(). void ROOT::Internal::Sha256 ; (; const unsigned char * ; data, . int ; len, . ULong64_t * ; fDigest . ). Definition at line 267 of file RSha256.hxx. Variable Documentation. ◆ gFreeIfTMapFile. ROOT::Internal::FreeIfTMapFile_t * ROOT::Internal::gFreeIfTMapFile = nullptr. Definition at line 141 of file TStorage.h. ◆ gGetMapFileMallocDesc. ROOT::Internal::GetMapFileMapllocDesc_t * ROOT::Internal::gGetMapFileMallocDesc = nullptr. Definition at line 142 of file TStorage.h. ◆ gGetROOT. GetROOTFun_t ROOT::Internal::gGetROOT = &GetROOT1. static . Definition at line 399 of file TROOT.cxx. ◆ gMmallocDesc. void * ROOT::Internal::gMmallocDesc = nullptr. Definition at line 143 of file TStorage.h. ◆ gROOTLocal. TROOT * ROOT::Internal::gROOTLocal = ROOT::GetROOT(). Definition at line 379 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:40424,message,message,40424,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['message'],['message']
Integrability,"ass"" if needed and return true if it has been added or if it is known to not be needed. ; (I.e. return false if a container of this class can not have a ""pragma C++ class"" ; Definition at line 1564 of file TTreeProxyGenerator.cxx. ◆ ReleaseDefaultErrorHandler(). void ROOT::Internal::ReleaseDefaultErrorHandler ; (; ). Destructs resources that are taken by using the default error handler. ; This function is called during the destruction of gROOT. ; Definition at line 47 of file TErrorDefaultHandler.cxx. ◆ RequiresCleanup(). Bool_t ROOT::Internal::RequiresCleanup ; (; TObject & ; obj). inline . Definition at line 386 of file TROOT.h. ◆ ResetReadEntry(). void ROOT::Internal::ResetReadEntry ; (; TFriendProxy * ; fp). Helper function to call SetReadEntry on all TFriendProxy. ; Definition at line 39 of file TBranchProxyDirector.cxx. ◆ SetErrorSystemMsgHandler(). ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler ; (; ErrorSystemMsgHandlerFunc_t ; h). Returns the previous system error message handler. ; Definition at line 56 of file TError.cxx. ◆ SetRequireCleanup(). void ROOT::Internal::SetRequireCleanup ; (; TObject & ; obj). inline . Definition at line 381 of file TROOT.h. ◆ Sha256(). void ROOT::Internal::Sha256 ; (; const unsigned char * ; data, . int ; len, . ULong64_t * ; fDigest . ). Definition at line 267 of file RSha256.hxx. ◆ SwapWithObjAtAddr(). template<class T > . void ROOT::Internal::SwapWithObjAtAddr ; (; T & ; a, . std::intptr_t ; b . ). inline . Definition at line 39 of file TPython.h. Variable Documentation. ◆ gFreeIfTMapFile. ROOT::Internal::FreeIfTMapFile_t * ROOT::Internal::gFreeIfTMapFile = nullptr. Definition at line 141 of file TStorage.h. ◆ gGetMapFileMallocDesc. ROOT::Internal::GetMapFileMapllocDesc_t * ROOT::Internal::gGetMapFileMallocDesc = nullptr. Definition at line 142 of file TStorage.h. ◆ gGetROOT. GetROOTFun_t ROOT::Internal::gGetROOT = &GetROOT1. static . Definition at line 399 of file TROOT.cxx. ◆ gMmallocDesc. void * ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:41005,message,message,41005,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['message'],['message']
Integrability,"ass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::InsertTString & Insert(Ssiz_t pos, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:167295,message,message,167295,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['message'],['message']
Integrability,"ass* onfile_class) const; Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulated:; case kInstrumented|kEmulated:; case kEmulated:. void StreamerDefault(void* object, TBuffer& b, const TClass* onfile_class) const; Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:44318,wrap,wrapper,44318,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,1,['wrap'],['wrapper']
Integrability,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:61173,wrap,wrapper,61173,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['wrap'],['wrapper']
Integrability,"ass, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TImagePlugin.h:37; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 37 of file TImagePlugin.h. ◆ IsA(). TClass * TImagePlugin::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 39 of file TImagePlugin.h. ◆ ReadFile(). virtual unsigned char * TImagePlugin::ReadFile ; (; const char * ; filename, . UInt_t & ; w, . UInt_t & ; h . ). pure virtual . Implemented in TASImagePlugin. ◆ Streamer(). void TImagePlugin::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TImagePlugin::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 39 of file TImagePlugin.h. ◆ WriteFile(). virtual Bool_t TImagePlugin::WriteFile ; (; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePlugin.html:12302,message,message,12302,doc/master/classTImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTImagePlugin.html,1,['message'],['message']
Integrability,"ass. Swiches perspective or orthographic camera.; TEveLine An arbitrary polyline with fixed line and marker attributes.; TEveLineEditor Editor for TEveLine class.; TEveLineGL GL-renderer for TEveLine class.; TEveLineProjected Projected replica of a TEveLine.; TEveListTreeItem Special llist-tree-item for Eve.; TEveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD).; TEveMCTrack Monte Carlo track (also used in VSD).; TEveMacro TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).; TEveMagField Abstract interface to magnetic field; TEveMagFieldConst Interface to constant magnetic field.; TEveMagFieldDuo Interface to magnetic field with two different values depending of radius.; TEveManager Eve application manager.; TEveManager::TExceptionHandler Exception handler for Eve exceptions.; TEvePad Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.; TEvePadHolder Exception-safe wrapper for temporary setting of gPad variable.; TEveParamList Eve element to store generic configuration information.; TEveParamList::BoolConfig_t ; TEveParamList::FloatConfig_t ; TEveParamList::IntConfig_t ; TEveParamListEditor GUI editor for TEveParamList.; TEvePathMark Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).; TEvePointSelector TSelector for direct extraction of point-like data from a Tree.; TEvePointSelectorConsumer Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.; TEvePointSet Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.; TEvePointSetArray Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.; TEvePointSetArrayEditor Editor for TEvePointSetArray class.; TEvePointSetProjected Projec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:59251,wrap,wrapper,59251,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['wrap'],['wrapper']
Integrability,ass; TMatrixTFlat_const<double> Template of General Matrix Flat Representation class; TMatrixTFlat_const<float> Template of General Matrix Flat Representation class; TMatrixTLazy<double> Template of Lazy Matrix class; TMatrixTLazy<float> Template of Lazy Matrix class; TMatrixTRow<double> Template of General Matrix Row Access class; TMatrixTRow<float> Template of General Matrix Row Access class; TMatrixTRow_const<double> Template of General Matrix Row Access class; TMatrixTRow_const<float> Template of General Matrix Row Access class; TMatrixTSparse<double> Template of Sparse Matrix class; TMatrixTSparse<float> Template of Sparse Matrix class; TMatrixTSparseDiag<double> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag<float> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag_const<double> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseDiag_const<float> Template of Sparse Matrix Diagonal Access class; TMatrixTSparseRow<double> Template of Sparse Matrix Row Access class; TMatrixTSparseRow<float> Template of Sparse Matrix Row Access class; TMatrixTSparseRow_const<double> Template of Sparse Matrix Row Access class; TMatrixTSparseRow_const<float> Template of Sparse Matrix Row Access class; TMatrixTSub<double> Template of Sub Matrix Access class; TMatrixTSub<float> Template of Sub Matrix Access class; TMatrixTSub_const<double> Template of Sub Matrix Access class; TMatrixTSub_const<float> Template of Sub Matrix Access class; TMatrixTSym<double> Template of Symmetric Matrix class; TMatrixTSym<float> Template of Symmetric Matrix class; TMatrixTSymCramerInv ; TMatrixTSymLazy<double> Template of Lazy Symmeytric class; TMatrixTSymLazy<float> Template of Lazy Symmeytric class; TMehrotraSolver Mehrotra Qp Solver class; TMemStat a user interface class of memstat; TMemStatCodeInfo a code information structure; TMemStatDepend ; TMemStatDrawDlg ; TMemStatInfoStamp information about stamps; TMemStatManager a manager of memstat sessions.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:102433,interface,interface,102433,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,2,['interface'],['interface']
Integrability,"assCode (CallWriteStreamer_t WriteStreamerFunc, const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, std::ostream &finalString, const RConstructorTypes &ctorTypes, bool isGenreflex);  Generate the code of the class If the requestor is genreflex, request the new streamer format. ;  ; void WriteClassInit (std::ostream &finalString, const AnnotatedRecordDecl &cl, const clang::CXXRecordDecl *decl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, const RConstructorTypes &ctorTypes, bool &needCollectionProxy);  FIXME: a function of 450+ lines! ;  ; int WriteNamespaceHeader (std::ostream &, const clang::DeclContext *);  Write all the necessary opening part of the namespace and return the number of closing brackets needed For example for Space1::Space2 we write: namespace Space1 { namespace Space2 { and return 2. ;  ; int WriteNamespaceHeader (std::ostream &, const clang::RecordDecl *);  ; void WritePointersSTL (const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt);  Write interface function for STL members. ;  . Variables; const int kError = 2000;  ; const int kFatal = 4000;  ; const int kInfo = 0;  ; const int kMaxLen = 1024;  ; const int kNote = 500;  ; const int kSysError = 3000;  ; const int kWarning = 1000;  . Typedef Documentation. ◆ CallWriteStreamer_t. typedef void(* ROOT::TMetaUtils::CallWriteStreamer_t) (const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, std::ostream &dictStream, bool isAutoStreamer). Definition at line 120 of file TClingUtils.h. ◆ RConstructorTypes. typedef std::list<RConstructorType> ROOT::TMetaUtils::RConstructorTypes. Definition at line 321 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:18325,interface,interface,18325,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['interface'],['interface']
Integrability,"assCode (CallWriteStreamer_t WriteStreamerFunc, const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, std::ostream &finalString, const RConstructorTypes &ctorTypes, bool isGenreflex);  Generate the code of the class If the requestor is genreflex, request the new streamer format. ;  ; void WriteClassInit (std::ostream &finalString, const AnnotatedRecordDecl &cl, const clang::CXXRecordDecl *decl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, const RConstructorTypes &ctorTypes, bool &needCollectionProxy);  FIXME: a function of 450+ lines! ;  ; int WriteNamespaceHeader (std::ostream &, const clang::DeclContext *);  Write all the necessary opening part of the namespace and return the number of closing brackets needed For example for Space1::Space2 we write: namespace Space1 { namespace Space2 { and return 2. ;  ; int WriteNamespaceHeader (std::ostream &, const clang::RecordDecl *);  ; void WritePointersSTL (const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt);  Write interface function for STL members. ;  . Variables; const int kError = 2000;  ; const int kFatal = 4000;  ; const int kInfo = 0;  ; const int kMaxLen = 1024;  ; const int kNote = 500;  ; const int kSysError = 3000;  ; const int kWarning = 1000;  . Typedef Documentation. ◆ CallWriteStreamer_t. typedef void(* ROOT::TMetaUtils::CallWriteStreamer_t) (const AnnotatedRecordDecl &cl, const cling::Interpreter &interp, const TNormalizedCtxt &normCtxt, std::ostream &dictStream, bool isAutoStreamer). Definition at line 120 of file TClingUtils.h. ◆ RConstructorTypes. typedef std::list<RConstructorType> ROOT::TMetaUtils::RConstructorTypes. Definition at line 344 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:18321,interface,interface,18321,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['interface'],['interface']
Integrability,"assDef_StreamerNVirtual_b). inline . Definition at line 81 of file MetropolisHastings.h. Member Data Documentation. ◆ fChainParams. RooArgSet RooStats::MetropolisHastings::fChainParams. protected . RooRealVars that are stored in the chain. ; Definition at line 70 of file MetropolisHastings.h. ◆ fFunction. RooAbsReal* RooStats::MetropolisHastings::fFunction = nullptr. protected . function that will generate likelihood values ; Definition at line 68 of file MetropolisHastings.h. ◆ fNumBurnInSteps. Int_t RooStats::MetropolisHastings::fNumBurnInSteps = 0. protected . number of iterations to discard as burn-in, starting from the first ; Definition at line 73 of file MetropolisHastings.h. ◆ fNumIters. Int_t RooStats::MetropolisHastings::fNumIters = 0. protected . number of iterations to run metropolis algorithm ; Definition at line 72 of file MetropolisHastings.h. ◆ fParameters. RooArgSet RooStats::MetropolisHastings::fParameters. protected . RooRealVars that define all parameter space. ; Definition at line 69 of file MetropolisHastings.h. ◆ fPropFunc. ProposalFunction* RooStats::MetropolisHastings::fPropFunc = nullptr. protected . Proposal function for MCMC integration. ; Definition at line 71 of file MetropolisHastings.h. ◆ fSign. enum FunctionSign RooStats::MetropolisHastings::fSign = kSignUnset. protected . whether the likelihood is negative (like NLL) or positive ; Definition at line 74 of file MetropolisHastings.h. ◆ fType. enum FunctionType RooStats::MetropolisHastings::fType = kTypeUnset. protected . whether the likelihood is on a regular, log, (or other) scale ; Definition at line 75 of file MetropolisHastings.h. Libraries for RooStats::MetropolisHastings:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/MetropolisHastings.h; roofit/roostats/src/MetropolisHastings.cxx. RooStatsMetropolisHastings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:55 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MetropolisHastings.html:19353,integrat,integration,19353,doc/master/classRooStats_1_1MetropolisHastings.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MetropolisHastings.html,1,['integrat'],['integration']
Integrability,"assFactoryRooClassFactory is a clase like TTree::MakeClass() that generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names ;  CClassFacIFace;  CRooCmdArgRooCmdArg is a named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods ;  CRooCmdConfigClass RooCmdConfig is a configurable parser for RooCmdArg named arguments ;  CRooCompositeDataStoreRooCompositeDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CRooConstraintSumRooConstraintSum calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions ;  CRooConstVarRooConstVar represent a constant real-valued object ;  CRooConvCoefVarRooConvCoefVar is an auxilary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism ;  CRooConvGenContextRooConvGenContext is an efficient implementation of the generator context specific for RooAbsAnaConvPdf objects ;  CRooConvIntegrandBindingImplementation of RooAbsFunc that represent the the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator ;  CRooCurveA RooCurve is a one-dimensional graphical representation of a real-valued function ;  ►CRooCustomizer;  CCustIFace;  CRooDataHistRooDataSet is a container class to hold N-dimensional binned data ;  CRooDataHistSliceIterRooDataHistSliceIter iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet ;  CRooDataProjBindingAdaptor that projects a real function via summation of states provided in a dataset ;  CRooDataSetRooDataSet is a container class to hold unbinned data ;  CRooDataWeightedAverageClass RooDataWeightedAverage calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:95392,interface,interface,95392,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['interface'],['interface']
Integrability,"assName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginHandlerDefinition TPluginManager.h:103; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TString",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:140451,message,message,140451,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['message'],['message']
Integrability,"assStreamer(). TClassStreamer * TStreamerInfo::GenExplicitClassStreamer ; (; const ::ROOT::Detail::TCollectionProxyInfo & ; info, . TClass * ; cl . ). overridevirtual . Generate class streamer from static functions. ; Implements TVirtualStreamerInfo.; Definition at line 5685 of file TStreamerInfo.cxx. ◆ GenExplicitProxy(). TVirtualCollectionProxy * TStreamerInfo::GenExplicitProxy ; (; const ::ROOT::Detail::TCollectionProxyInfo & ; info, . TClass * ; cl . ). overridevirtual . Generate proxy from static functions. ; Implements TVirtualStreamerInfo.; Definition at line 5676 of file TStreamerInfo.cxx. ◆ GetActualClass(). TClass * TStreamerInfo::GetActualClass ; (; const void * ; obj); const. overridevirtual . Assuming that obj points to (the part of) an object that is of the type described by this streamerInfo, return the actual type of the object (i.e. ; the type described by this streamerInfo is a base class of the actual type of the object. This routine should only be called if the class described by this StreamerInfo is 'emulated'. ; Implements TVirtualStreamerInfo.; Definition at line 3255 of file TStreamerInfo.cxx. ◆ GetCheckSum() [1/2]. UInt_t TStreamerInfo::GetCheckSum ; (; ); const. inlineoverridevirtual . Implements TVirtualStreamerInfo.; Definition at line 159 of file TStreamerInfo.h. ◆ GetCheckSum() [2/2]. UInt_t TStreamerInfo::GetCheckSum ; (; TClass::ECheckSum ; code); const. Recalculate the checksum of this TStreamerInfo based on its code. ; The class ckecksum is used by the automatic schema evolution algorithm to uniquely identify a class version. The check sum is built from the names/types of base classes and data members. The valid range of code is determined by ECheckSum.; kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo.html:44260,rout,routine,44260,doc/master/classTStreamerInfo.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo.html,1,['rout'],['routine']
Integrability,"assTClass()Internal, default constructor.Definition TClass.cxx:1065; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4573; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4841; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2914; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7001; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:1966; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7447; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2655; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3477; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4554; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:54341,wrap,wrapper,54341,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['wrap'],['wrapper']
Integrability,"assTClass()Internal, default constructor.Definition TClass.cxx:1132; TClass::fDeclFileLineShort_t fDeclFileLineDefinition TClass.h:215; TClass::GetNmethodsInt_t GetNmethods()Return the number of methods of this class Note that in case the list of methods is not yet created,...Definition TClass.cxx:4640; TClass::fIsOffsetStreamerSetstd::atomic< Bool_t > fIsOffsetStreamerSetIndicates whether the ClassInfo is supposed to be available.Definition TClass.h:261; TClass::IgnoreTObjectStreamervoid IgnoreTObjectStreamer(Bool_t ignore=kTRUE)When the class kIgnoreTObjectStreamer bit is set, the automatically generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetIdMapstatic IdMap_t * GetIdMap()Definition TClass.cxx:469; TClass::GetInstanceCountUInt_t GetInstanceCount() constDefinition TClass.h:466; TClass::SetDeletevoid SetDelete(ROOT::DelFunc_t deleteFunc)Install a new wrapper around 'delete'.Definition TClass.cxx:7068; TClass::SetLastReadInfovoid SetLastReadInfo(TVirtualStreamerInfo *info)Definition TClass.h:445; TClass::AutoBrowsestatic Int_t AutoBrowse(TObject *obj, TBrowser *browser)Browse external object inherited from TObject.Definition TClass.cxx:2033; TClass::GetNewROOT::NewFunc_t GetNew() constReturn the wrapper around new ThisClass().Definition TClass.cxx:7514; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::GetNdataInt_t GetNdata()Return the number of data members of this class Note that in case the list of data members is not yet...Definition TClass.cxx:4621; TClass::SetDestructorvoid SetDestructor(ROOT::DesFunc_t destructorFunc)Install a new wrapper around the destructor.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:54169,wrap,wrapper,54169,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['wrap'],['wrapper']
Integrability,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUrl.html:9688,protocol,protocols,9688,root/html534/TUrl.html,https://root.cern,https://root.cern/root/html534/TUrl.html,6,['protocol'],"['protocol', 'protocols']"
Integrability,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { return fAnchor; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUrl.html:9560,protocol,protocols,9560,root/html528/TUrl.html,https://root.cern,https://root.cern/root/html528/TUrl.html,6,['protocol'],"['protocol', 'protocols']"
Integrability,"associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1., RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 0.001, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:48740,integrat,integration,48740,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['integrat'],['integration']
Integrability,"associated; with every single state. The normalization in such cases is taken; from the number of registered PDFs, but getVal() will assert if; when called for an unregistered index state. PDFs may not overlap (i.e. share any variables) with the index category (function). RooAbsPdf::ExtendMode extendMode() const; WVE NEEDS FIX. Double_t evaluate() const; Return the current value:; the value of the PDF associated with the current index category state. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events: If the index is in nset,; then return the sum of the expected events of all components,; otherwise return the number of expected events of the PDF; associated with the current index category state. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to component p.d.f.s; A unique code is assigned to the combined integration capabilities of all associated; p.d.f.s. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration defined by given code. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Back-end for plotOn() implementation on RooSimultaneous which; needs special handling because a RooSimultaneous PDF cannot; project out its index category via integration, plotOn() will; abort if this is requested without providing a projection dataset. RooPlot* plotOn(RooPlot* frame, Option_t* drawOptions, Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0, const RooArgSet* projSet = 0, Double_t precision = 1e-3, Bool_t shiftToZero = kFALSE, const RooArgSet* projDataSet = 0, Double_t rangeLo = 0, Double_t rangeHi = 0, RooCurve::WingMode wmode = RooCurve::Extended) const; OBSOLETE -- Retained for backward compatibility. void selectNormalization(const RooArgSet* depSet = 0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:43994,integrat,integration,43994,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,4,['integrat'],['integration']
Integrability,"ast Integral calculation ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 390 of file GSLIntegrator.cxx. ◆ GetType(). IntegrationOneDim::Type ROOT::Math::GSLIntegrator::GetType ; (; ); const. inline . get type name ; Definition at line 362 of file GSLIntegrator.h. ◆ GetTypeName(). const char * ROOT::Math::GSLIntegrator::GetTypeName ; (; ); const. return the name ; Definition at line 459 of file GSLIntegrator.cxx. ◆ Integral() [1/9]. double ROOT::Math::GSLIntegrator::Integral ; (; ). overridevirtual . evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. ; Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 274 of file GSLIntegrator.cxx. ◆ Integral() [2/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const IGenFunction & ; f). evaluate the Integral of a function f over the infinite interval (-inf,+inf) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface . Definition at line 329 of file GSLIntegrator.cxx. ◆ Integral() [3/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const IGenFunction & ; f, . const std::vector< double > & ; pts . ). evaluate the Integral of a function f with known singular points over the defined Integral (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; ptsvector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( a) and last element the upper value. . Definition at line 347 of file GSLIntegrator.cxx. ◆ Integral() [4/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const IGenFunction & ; f, . double ; a, . double ; b . ). evaluate the Integral of a function f over the defined interval (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:11474,interface,interface,11474,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,1,['interface'],['interface']
Integrability,"ast one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the ""Volumes"" category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to ""General"" category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:; add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the ""General"" category. . Modules;  GDML tools;  GDML tools for geometry classes. ;  ;  Geometry classes;  The Geometry related classes. ;  ;  Materials;  ;  Shapes;  Shapes are geometrical objects that provide the basic modeling functionality. ;  ;  Geometry builder;  The Geometry builder related classes. ;  ;  Geometry painter;  The Geometry painter, checker, overlap and track related classes. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:145464,interface,interface,145464,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['interface'],['interface']
Integrability,"aster = kFALSE); const. inline . Definition at line 63 of file TStatus.h. ◆ GetVirtMemMax(). Long_t TStatus::GetVirtMemMax ; (; Bool_t ; master = kFALSE); const. inline . Definition at line 64 of file TStatus.h. ◆ IsA(). TClass * TStatus::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 69 of file TStatus.h. ◆ IsOk(). Bool_t TStatus::IsOk ; (; ); const. inline . Definition at line 54 of file TStatus.h. ◆ Merge(). Int_t TStatus::Merge ; (; TCollection * ; list). virtual . PROOF Merge() function. ; Definition at line 65 of file TStatus.cxx. ◆ NextMesg(). const char * TStatus::NextMesg ; (; ). Return the next message or 0. ; Definition at line 150 of file TStatus.cxx. ◆ Print(). void TStatus::Print ; (; Option_t * ; option = """"); const. overridevirtual . Standard print function. ; Reimplemented from TNamed.; Definition at line 110 of file TStatus.cxx. ◆ Reset(). void TStatus::Reset ; (; ). Reset the iterator on the messages. ; Definition at line 142 of file TStatus.cxx. ◆ SetExitStatus(). void TStatus::SetExitStatus ; (; Int_t ; est). inline . Definition at line 66 of file TStatus.h. ◆ SetMemValues(). void TStatus::SetMemValues ; (; Long_t ; vmem = -1, . Long_t ; rmem = -1, . Bool_t ; master = kFALSE . ). Set max memory values. ; Definition at line 160 of file TStatus.cxx. ◆ Streamer(). void TStatus::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TStatus. ; Reimplemented from TNamed.; Definition at line 174 of file TStatus.cxx. ◆ StreamerNVirtual(). void TStatus::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 69 of file TStatus.h. Member Data Documentation. ◆ fExitStatus. Int_t TStatus::fExitStatus. private . Definition at line 44 of file TStatus.h. ◆ fInfoMsgs. THashList TStatus::fInfoMsgs. private . iterator in messages ; Definition at line 42 of file TStatus.h. ◆ fIter. TIter TStatus::fIter. private . Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatus.html:14630,message,messages,14630,doc/master/classTStatus.html,https://root.cern,https://root.cern/doc/master/classTStatus.html,1,['message'],['messages']
Integrability,aster. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; ROOT::Math::BaseIntegratorOptions Class ReferenceabstractMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. ; Definition at line 35 of file IntegratorOptions.h. Public Member Functions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; virtual std::string Integrator () const =0;  name of 1D integrator ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace size ;  ; unsigned int WKSize () const;  size of the workspace ;  . Protected Member Functions;  BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; void ClearExtra ();  . Protected Attributes; double fAbsTolerance;  absolute tolerance ;  ; ROOT::Math::IOptions * fExtraOptions;  ; int fIntegType;  Integrator type (value converted from enum) ;  ; unsigned int fNCalls;  (max) function calls ;  ; double fRelTolerance;  relative tolerance ;  ; unsigned int fWKSize;  workspace size ;  . #include <Math/IntegratorOptions.h>. Inheritance diagram for ROOT::Math::BaseIntegrator,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:995,integrat,integrator,995,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['integrat'],['integrator']
Integrability,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:55229,interface,interface,55229,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,3,['interface'],['interface']
Integrability,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:56744,interface,interface,56744,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,4,['interface'],['interface']
Integrability,"at ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TGeoManager (const TGeoManager &)=delete;  Default units in GDML if not explicit in some tags. ;  ; TGeoManager & operator= (const TGeoManager &)=delete;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Attributes; static EDefaultUnits fgDefaultUnits = TGeoManager::kRootUnits;  Precision to be used in ASCII exports. ;  ; static UInt_t fgExportPrecision = 17;  Maximum number of Xtru vertices. ;  ; static Bool_t fgLock = kFALSE;  mutex for navigator booking in MT mode ;  ; static Int_t fgMaxDaughters = 1;  Maximum level in geometry. ;  ; static Int_t fgMaxLevel = 1;  Verbosity level for Info messages (no IO). ;  ; static Int_t fgMaxXtruVert = 1;  Maximum number of daughters. ;  ; static std::mutex fgMutex;  ; static Int_t fgVerboseLevel = 1;  Lock preventing a second geometry to be loaded. ;  . Private Types; typedef std::map< std::string, Double_t > ConstPropMap_t;  ; typedef std::map< std::thread::id, TGeoNavigatorArray * > NavigatorsMap_t;  bits used for voxelization ;  ; typedef NavigatorsMap_t::iterator NavigatorsMapIt_t;  ; typedef std::map< std::thread::id, Int_t > ThreadsMap_t;  ; typedef ThreadsMap_t::const_iterator ThreadsMapIt_t;  . Private Member Functions; void Init ();  Initialize manager class. ;  ; Bool_t InitArrayPNE () const;  Initialize PNE array for fast access via index and unique-id. ;  ; Bool_t InsertPNEId (Int_t uid, Int_t ientry);  Insert a PN entry in the sorted array of indexes. ;  ; Bool_t IsLoopingVolumes () const;  ; void SetLoopVolumes (Bool_t flag=kTRUE);  ; void UpdateElements ();  Update element flags when geometry is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:62405,message,messages,62405,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['message'],['messages']
Integrability,"at (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void Create (const char *url, TSocket *sock=nullptr);  Create a TNetSystem object. ;  ; void InitRemoteEntity (const char *url);  Parse and save coordinates of the remote entity (user, host, port, ...) ;  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fIsLocal;  ; TString fLocalPrefix;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr};  ; Bool_t fDone {kFALSE};  ; TSeqCollection * fFileHandler {nullptr};  ; TString fFlagsDebug;  ; TString fFlagsOpt; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:30694,message,message,30694,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,1,['message'],['message']
Integrability,"at combines several other sources horizontally. More...;  ; class  RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  RProjectedFields;  The projected fields of a RNTupleModel More...;  ; class  RRDFCardinalityField;  An artificial field that transforms an RNTuple column that contains the offset of collections into collection sizes. More...;  ; struct  RSealedPageMergeData;  ; struct  RTestFutureColumn;  ; struct  RTFileControlBlock;  If a TFile container is written by a C stream (simple file), on dataset commit, the file header and the TFile record need to be updated. More...;  ; struct  RVirtualBinsToLocalBins;  Recursively converts zero-based virtual bins where the underflow bin has index 0 and the overflow bin has index N+1 where N is the axis' number of regular bins, to the standard kUnderflowBin/kOverflowBin for under/overflow bin indexing convention. More...;  ; struct  RVirtualBinsToLocalBins<-1, NDIMS, BINS, AXES >;  ; class  RVirtualCanvasPainter;  Abstract interface for painting a canvas. More...;  ; class  RWritePageMemoryManager;  Helper to maintain a memory budget for the write pages of a set of columns. More...;  ; class  TBulkBranchRead;  Helper class for reading many branch entries at once to optimize throughput. More...;  ; class  TTreeReaderValueFastBase;  . Typedefs; using ntuple_index_t = std::uint32_t;  ; using RIOSharedVector_t = std::vector< RIOSharedBase * >;  . Enumerations; enum class  EColumnCppType { ;   kChar; , kBool; , kByte; , kUint8; , ;   kUint16; , kUint32; , kUint64; , kInt8; , ;   kInt16; , kInt32; , kInt64; , kFloat; , ;   kDouble; , kClusterSize; , kColumnSwitch; , kMax. };  ; enum  EDaosLocatorFlags { kCagedPage = 0x01; };  ; enum class  ENTupleMergeErrBehavior { kAbort; , kSkip; };  ; enum class  ENTupleMergingMode { kFilter; , kStrict; , kUnion; };  ; enum class  EPageStorageType { kSink; , kSource; };  ; Histogram traits; Helper traits for histogram operations. . enum c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html:10019,interface,interface,10019,doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental_1_1Internal.html,1,['interface'],['interface']
Integrability,"at give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 342 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 978 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 287 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1107 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1642 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in the collection. ; Definition at line 965 of file RooAbsCollection.cxx. ◆ index() [2/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg & ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 309 of file RooAbsCollection.h. ◆ index() [3/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg * ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 303 of file RooAbsCollection.h. ◆ insert(). void RooAbsCollection::insert ; (; RooAbsArg * ; it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:42977,message,messages,42977,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['message'],['messages']
Integrability,"at give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 365 of file RooAbsCollection.h. ◆ getRealValue(). double RooAbsCollection::getRealValue ; (; const char * ; name, . double ; defVal = 0.0, . bool ; verbose = false . ); const. Get value of a RooAbsReal stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 968 of file RooAbsCollection.cxx. ◆ getSize(). Int_t RooAbsCollection::getSize ; (; ); const. inline . Return the number of elements in the collection. ; Definition at line 310 of file RooAbsCollection.h. ◆ getStringValue(). const char * RooAbsCollection::getStringValue ; (; const char * ; name, . const char * ; defVal = """", . bool ; verbose = false . ); const. Get string value of a RooStringVar stored in set with given name. ; If none is found, value of defVal is returned. No error messages are printed unless the verbose flag is set ; Definition at line 1097 of file RooAbsCollection.cxx. ◆ hasSameLayout(). bool RooAbsCollection::hasSameLayout ; (; const RooAbsCollection & ; other); const. Check that all entries where the collections overlap have the same name. ; Definition at line 1629 of file RooAbsCollection.cxx. ◆ index() [1/3]. Int_t RooAbsCollection::index ; (; const char * ; name); const. Return index of item with given name, or -1 in case it's not in the collection. ; Definition at line 955 of file RooAbsCollection.cxx. ◆ index() [2/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg & ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 332 of file RooAbsCollection.h. ◆ index() [3/3]. Int_t RooAbsCollection::index ; (; const RooAbsArg * ; arg); const. inline . Returns index of given arg, or -1 if arg is not in the collection. ; Definition at line 326 of file RooAbsCollection.h. ◆ insert(). void RooAbsCollection::insert ; (; RooAbsArg * ; it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:44524,message,messages,44524,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['message'],['messages']
Integrability,"at line 1173 of file RooRealIntegral.cxx. ◆ getCacheNumeric(). bool RooRealIntegral::getCacheNumeric ; (; ). inline . Definition at line 60 of file RooRealIntegral.h. ◆ getValV(). double RooRealIntegral::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Return value of object. ; If the cache is clean, return the cached value, otherwise recalculate on the fly and refill the cache ; Reimplemented from RooAbsReal.; Definition at line 780 of file RooRealIntegral.cxx. ◆ initNumIntegrator(). bool RooRealIntegral::initNumIntegrator ; (; ); const. protected . (Re)Initialize numerical integration engine if necessary. ; Return true if successful, or otherwise false. ; Definition at line 658 of file RooRealIntegral.cxx. ◆ integrand(). const RooAbsReal & RooRealIntegral::integrand ; (; ); const. inline . Definition at line 53 of file RooRealIntegral.h. ◆ integrate(). double RooRealIntegral::integrate ; (; ); const. protectedvirtual . Perform hybrid numerical/analytical integration over all real-valued dependents. ; Definition at line 965 of file RooRealIntegral.cxx. ◆ intRange(). const char * RooRealIntegral::intRange ; (; ); const. inline . Definition at line 52 of file RooRealIntegral.h. ◆ intVars(). RooArgSet RooRealIntegral::intVars ; (; ); const. inline . Definition at line 51 of file RooRealIntegral.h. ◆ IsA(). TClass * RooRealIntegral::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 150 of file RooRealIntegral.h. ◆ isValid(). bool RooRealIntegral::isValid ; (; ); const. inlineoverridevirtual . Check if current value is valid. ; Reimplemented from RooAbsReal.; Definition at line 42 of file RooRealIntegral.h. ◆ isValidReal(). bool RooRealIntegral::isValidReal ; (; double ; value, . bool ; printError = false . ); const. overrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsReal.; Definition at line 1016 of file RooRealIntegral.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:70294,integrat,integration,70294,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability,"at line 132 of file IntegratorOptions.cxx. ◆ ~BaseIntegratorOptions(). virtual ROOT::Math::BaseIntegratorOptions::~BaseIntegratorOptions ; (; ). inlinevirtual . protected constructor to avoid user creating this class ; Definition at line 52 of file IntegratorOptions.h. Member Function Documentation. ◆ AbsTolerance(). double ROOT::Math::BaseIntegratorOptions::AbsTolerance ; (; ); const. inline . non-static methods for retrieving options ; absolute tolerance ; Definition at line 61 of file IntegratorOptions.h. ◆ ClearExtra(). void ROOT::Math::BaseIntegratorOptions::ClearExtra ; (; ). protected . Definition at line 161 of file IntegratorOptions.cxx. ◆ ExtraOptions(). IOptions * ROOT::Math::BaseIntegratorOptions::ExtraOptions ; (; ); const. inline . return extra options ; Definition at line 71 of file IntegratorOptions.h. ◆ Integrator(). virtual std::string ROOT::Math::BaseIntegratorOptions::Integrator ; (; ); const. pure virtual . name of 1D integrator ; Implemented in ROOT::Math::IntegratorOneDimOptions, and ROOT::Math::IntegratorMultiDimOptions. ◆ operator=(). BaseIntegratorOptions & ROOT::Math::BaseIntegratorOptions::operator= ; (; const BaseIntegratorOptions & ; opt). assignment operators ; Definition at line 137 of file IntegratorOptions.cxx. ◆ RelTolerance(). double ROOT::Math::BaseIntegratorOptions::RelTolerance ; (; ); const. inline . absolute tolerance ; Definition at line 64 of file IntegratorOptions.h. ◆ SetAbsTolerance(). void ROOT::Math::BaseIntegratorOptions::SetAbsTolerance ; (; double ; tol). inline . non-static methods for setting options ; set the abs tolerance ; Definition at line 77 of file IntegratorOptions.h. ◆ SetExtraOptions(). void ROOT::Math::BaseIntegratorOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 167 of file IntegratorOptions.cxx. ◆ SetRelTolerance(). void ROOT::Math::BaseIntegratorOptions::SetRelTolerance ; (; double ; tol). inline . set the relative toleranc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:3598,integrat,integrator,3598,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['integrat'],['integrator']
Integrability,"at line 321 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of file TClingUtils.h. ◆ EIOCtorCategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 359 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2852 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5088 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1079 of file TClingUtils.cxx. ◆ CheckDefaultCons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:20063,depend,dependences,20063,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['depend'],['dependences']
Integrability,"at line 344 of file TClingUtils.h. Enumeration Type Documentation. ◆ DataMemberInfo__ValidArrayIndex_error_code. enum ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex_error_code. EnumeratorVALID ; NOT_INT ; NOT_DEF ; IS_PRIVATE ; UNKNOWN . Definition at line 118 of file TClingUtils.h. ◆ EIOCtorCategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 382 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2892 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5135 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1119 of file TClingUtils.cxx. ◆ CheckDefaultCons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:20059,depend,dependences,20059,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['depend'],['dependences']
Integrability,"at line 35 of file RooParametricStepFunction.h. ◆ DeclFileName(). static const char * RooParametricStepFunction::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 55 of file RooParametricStepFunction.h. ◆ evaluate(). double RooParametricStepFunction::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 189 of file RooParametricStepFunction.cxx. ◆ getAnalyticalIntegral(). Int_t RooParametricStepFunction::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 127 of file RooParametricStepFunction.cxx. ◆ getLimits(). double * RooParametricStepFunction::getLimits ; (; ). inline . Definition at line 40 of file RooParametricStepFunction.h. ◆ getnBins(). Int_t RooParametricStepFunction::getnBins ; (; ); const. inline . Definition at line 39 of file RooParametricStepFunction.h. ◆ IsA(). TClass * RooParametricStepFunction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooParametricStepFunction.h. ◆ lastBinValue(). double RooParametricStepFunction::lastBinValue ; (; ); const. protected . Definition at line 174 of file RooParametricStepFunction.cxx. ◆ plotSamplingHint(). std::list< double > * RooParametricStepFunction::plotSamplingHint ; (; RooAbsRealLValu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParametricStepFunction.html:80346,depend,dependents,80346,doc/master/classRooParametricStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooParametricStepFunction.html,3,"['depend', 'integrat']","['dependents', 'integrate', 'integration']"
Integrability,"at line 456 of file Integrator.h. ◆ Result(). double ROOT::Math::IntegratorOneDim::Result ; (; ); const. inline . return the Result of the last Integral calculation ; Definition at line 411 of file Integrator.h. ◆ SetAbsTolerance(). void ROOT::Math::IntegratorOneDim::SetAbsTolerance ; (; double ; absTolerance). inline . set the desired absolute Error ; Definition at line 441 of file Integrator.h. ◆ SetFunction() [1/3]. void ROOT::Math::IntegratorOneDim::SetFunction ; (; const IGenFunction & ; f, . bool ; copy = false . ). inline . set one dimensional function for 1D integration ; Definition at line 202 of file Integrator.h. ◆ SetFunction() [2/3]. void ROOT::Math::IntegratorOneDim::SetFunction ; (; const IMultiGenFunction & ; f, . unsigned int ; icoord, . const double * ; x . ). Set integration function from a multi-dim function type. ; Can be used in case of having 1D function implementing the generic interface Parameters. fintegration function ; icoordindex of coordinate on which the integration is performed ; xarray of the passed variables values. In case of dim=1 a 0 can be passed . Definition at line 100 of file Integrator.cxx. ◆ SetFunction() [3/3]. template<class Function > . void ROOT::Math::IntegratorOneDim::SetFunction ; (; Function & ; f). inline . method to set the a generic integration function ; Parameters. fintegration function. The function type must implement the assignment operator, double operator() ( double x ) . Definition at line 492 of file Integrator.h. ◆ SetOptions(). void ROOT::Math::IntegratorOneDim::SetOptions ; (; const ROOT::Math::IntegratorOneDimOptions & ; opt). inline . set the options ; Definition at line 451 of file Integrator.h. ◆ SetRelTolerance(). void ROOT::Math::IntegratorOneDim::SetRelTolerance ; (; double ; relTolerance). inline . set the desired relative Error ; Definition at line 435 of file Integrator.h. ◆ Status(). int ROOT::Math::IntegratorOneDim::Status ; (; ); const. inline . return the Error Status of the last Integral",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:20664,integrat,integration,20664,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['integrat'],['integration']
Integrability,"at line 53 of file Integrator.cxx. ◆ Integral() [1/8]. double ROOT::Math::IntegratorOneDim::Integral ; (; ). inline . evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with Integrator::SetFunction method. ; Definition at line 364 of file Integrator.h. ◆ Integral() [2/8]. double ROOT::Math::IntegratorOneDim::Integral ; (; const IGenFunction & ; f). inline . evaluate the Integral of a function f over the infinite interval (-inf,+inf) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface . Definition at line 258 of file Integrator.h. ◆ Integral() [3/8]. double ROOT::Math::IntegratorOneDim::Integral ; (; const IGenFunction & ; f, . const std::vector< double > & ; pts . ). inline . evaluate the Integral of a function f with known singular points over the defined Integral (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; ptsvector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( a) and last element the upper value. . Definition at line 316 of file Integrator.h. ◆ Integral() [4/8]. double ROOT::Math::IntegratorOneDim::Integral ; (; const IGenFunction & ; f, . double ; a, . double ; b . ). inline . evaluate the Integral of a function f over the defined interval (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; alower value of the integration interval ; bupper value of the integration interval . Definition at line 241 of file Integrator.h. ◆ Integral() [5/8]. double ROOT::Math::IntegratorOneDim::Integral ; (; const std::vector< double > & ; pts). inline . evaluate the Integral over the defined interval (a,b) using the function previously set with Integrator::SetFunction method. ; The function has known singular points. Parameters. ptsv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:13039,interface,interface,13039,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['interface'],['interface']
Integrability,at line 60 of file RooNumGenConfig.h. ◆ _method1DCondCat. RooCategory RooNumGenConfig::_method1DCondCat. protected . Selects integration method for 1D conditional p.d.f.s with categories. ; Definition at line 61 of file RooNumGenConfig.h. ◆ _method2D. RooCategory RooNumGenConfig::_method2D. protected . Selects integration method for 2D p.d.f.s. ; Definition at line 63 of file RooNumGenConfig.h. ◆ _method2DCat. RooCategory RooNumGenConfig::_method2DCat. protected . Selects integration method for 2D p.d.f.s with categories. ; Definition at line 64 of file RooNumGenConfig.h. ◆ _method2DCond. RooCategory RooNumGenConfig::_method2DCond. protected . Selects integration method for 2D conditional p.d.f.s. ; Definition at line 65 of file RooNumGenConfig.h. ◆ _method2DCondCat. RooCategory RooNumGenConfig::_method2DCondCat. protected . Selects integration method for 2D conditional p.d.f.s with categories. ; Definition at line 66 of file RooNumGenConfig.h. ◆ _methodND. RooCategory RooNumGenConfig::_methodND. protected . Selects integration method for ND p.d.f.s. ; Definition at line 68 of file RooNumGenConfig.h. ◆ _methodNDCat. RooCategory RooNumGenConfig::_methodNDCat. protected . Selects integration method for ND p.d.f.s with categories. ; Definition at line 69 of file RooNumGenConfig.h. ◆ _methodNDCond. RooCategory RooNumGenConfig::_methodNDCond. protected . Selects integration method for ND conditional p.d.f.s. ; Definition at line 70 of file RooNumGenConfig.h. ◆ _methodNDCondCat. RooCategory RooNumGenConfig::_methodNDCondCat. protected . Selects integration method for ND conditional p.d.f.s with categories. ; Definition at line 71 of file RooNumGenConfig.h. Libraries for RooNumGenConfig:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooNumGenConfig.h; roofit/roofitcore/src/RooNumGenConfig.cxx. RooNumGenConfig. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:03 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenConfig.html:21376,integrat,integration,21376,doc/master/classRooNumGenConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumGenConfig.html,4,['integrat'],['integration']
Integrability,"at line 643 of file TTF.cxx. ◆ GetSmoothing(). Bool_t TTF::GetSmoothing ; (; ). static . Definition at line 608 of file TTF.cxx. ◆ GetTextAdvance(). void TTF::GetTextAdvance ; (; UInt_t & ; a, . char * ; text . ). static . Get advance (a) when text is horizontal. ; Definition at line 170 of file TTF.cxx. ◆ GetTextExtent() [1/2]. void TTF::GetTextExtent ; (; UInt_t & ; w, . UInt_t & ; h, . char * ; text . ). static . Get width (w) and height (h) when text is horizontal. ; Definition at line 154 of file TTF.cxx. ◆ GetTextExtent() [2/2]. void TTF::GetTextExtent ; (; UInt_t & ; w, . UInt_t & ; h, . wchar_t * ; text . ). static . Get width (w) and height (h) when text is horizontal. ; Definition at line 183 of file TTF.cxx. ◆ GetTrailingBlanksWidth(). Int_t TTF::GetTrailingBlanksWidth ; (; ). static . Definition at line 650 of file TTF.cxx. ◆ GetWidth(). Int_t TTF::GetWidth ; (; ). static . Definition at line 622 of file TTF.cxx. ◆ Init(). void TTF::Init ; (; ). static . Initialise the TrueType fonts interface. ; Definition at line 65 of file TTF.cxx. ◆ IsA(). virtual TClass * TTF::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 130 of file TTF.h. ◆ IsInitialized(). Bool_t TTF::IsInitialized ; (; ). static . Definition at line 615 of file TTF.cxx. ◆ LayoutGlyphs(). void TTF::LayoutGlyphs ; (; ). static . Compute the glyphs positions, fgAscent and fgWidth (needed for alignment). ; Perform the Glyphs transformation. Compute the string control box. If required take the ""kerning"" into account. SetRotation and PrepareString should have been called before. ; Definition at line 203 of file TTF.cxx. ◆ PrepareString() [1/2]. void TTF::PrepareString ; (; const char * ; string). static . Put the characters in ""string"" in the ""glyphs"" array. ; Definition at line 272 of file TTF.cxx. ◆ PrepareString() [2/2]. void TTF::PrepareString ; (; const wchar_t * ; string). static . Put the characters in ""string"" in the ""glyphs"" array. ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTF.html:7507,interface,interface,7507,doc/master/classTTF.html,https://root.cern,https://root.cern/doc/master/classTTF.html,1,['interface'],['interface']
Integrability,"at line 700 of file TRootSniffer.cxx. ◆ ScanRoot(). void TRootSniffer::ScanRoot ; (; TRootSnifferScanRec & ; rec). protectedvirtual . scan complete ROOT objects hierarchy For the moment it includes objects in gROOT directory and list of canvases and files Also all registered objects are included. ; One could re-implement this method to provide alternative scan methods or to extend some collection kinds ; Definition at line 965 of file TRootSniffer.cxx. ◆ SetAutoLoad(). void TRootSniffer::SetAutoLoad ; (; const char * ; scripts = """"). When specified, _autoload attribute will be always add to top element of h.json/h.hml requests Used to instruct browser automatically load special code. ; Definition at line 482 of file TRootSniffer.cxx. ◆ SetCurrentCallArg(). THttpCallArg * TRootSniffer::SetCurrentCallArg ; (; THttpCallArg * ; arg). set current http arguments, which then used in different process methods For instance, if user authorized with some user name, depending from restrictions some objects will be invisible or user get full access to the element Returns previous argument which was set before ; Definition at line 435 of file TRootSniffer.cxx. ◆ SetItemField(). Bool_t TRootSniffer::SetItemField ; (; const char * ; fullname, . const char * ; name, . const char * ; value . ). Set field for specified item. ; Definition at line 1795 of file TRootSniffer.cxx. ◆ SetReadOnly(). void TRootSniffer::SetReadOnly ; (; Bool_t ; on = kTRUE). inline . When readonly on (default), sniffer is not allowed to change ROOT structures For instance, it is not allowed to read new objects from files. ; Definition at line 190 of file TRootSniffer.h. ◆ SetScanGlobalDir(). void TRootSniffer::SetScanGlobalDir ; (; Bool_t ; on = kTRUE). inline . When enabled (default), sniffer scans gROOT for files, canvases, histograms. ; Definition at line 206 of file TRootSniffer.h. ◆ Streamer(). void TRootSniffer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:39236,depend,depending,39236,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['depend'],['depending']
Integrability,"at line 91 of file Fitter.h. ◆ IGradModelFunction_v. typedef ROOT::Math::IParamMultiGradFunction ROOT::Fit::Fitter::IGradModelFunction_v. Definition at line 89 of file Fitter.h. ◆ IModel1DFunction. typedef ROOT::Math::IParamFunction ROOT::Fit::Fitter::IModel1DFunction. Definition at line 92 of file Fitter.h. ◆ IModelFunction. typedef ROOT::Math::IParamMultiFunction ROOT::Fit::Fitter::IModelFunction. Definition at line 81 of file Fitter.h. ◆ IModelFunction_v. typedef ROOT::Math::IParamMultiFunction ROOT::Fit::Fitter::IModelFunction_v. Definition at line 88 of file Fitter.h. ◆ IModelFunctionTempl. template<class T > . using ROOT::Fit::Fitter::IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>. Definition at line 83 of file Fitter.h. ◆ MinuitFCN_t. typedef void(* ROOT::Fit::Fitter::MinuitFCN_t) (int &npar, double *gin, double &f, double *u, int flag). fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters are specified in the parameter settings created before For the options same consideration as in the previous method ; Definition at line 339 of file Fitter.h. Constructor & Destructor Documentation. ◆ Fitter() [1/3]. ROOT::Fit::Fitter::Fitter ; (; ). inline . Default constructor. ; Definition at line 102 of file Fitter.h. ◆ Fitter() [2/3]. ROOT::Fit::Fitter::Fitter ; (; const std::shared_ptr< FitResult > & ; result). Constructor from a result. ; Definition at line 51 of file Fitter.cxx. ◆ ~Fitter(). virtual ROOT::Fit::Fitter::~Fitter ; (; ). inlinevirtual . Destructor. ; Make it virtual in case users derive from Fitter class to extend it by adding new methods. This is needed to avoid a warning seen when doing from Python (see ROOT issue #12391 ). Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes. ; Definition at line 117 of file Fitter.h. ◆ Fitter() [3/3]. ROOT::Fit::Fitter::Fitter ; (; const Fitter & ; ). delete . Copy constructor (disabled, class is not copya",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:15735,interface,interface,15735,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['interface'],['interface']
Integrability,"at line 96 of file BayesianCalculator.h. ◆ SetIntegrationType(). void RooStats::BayesianCalculator::SetIntegrationType ; (; const char * ; type). set the integration type (possible type are) : . 1D integration ( used when only one nuisance and when the posterior is scanned): adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration The parameter numIters (settable with SetNumIters) is the max number of function calls. It can be reduced to make the integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC: evaluate posterior by generating toy MC for the nuisance parameters. It is a MC integration, where the function is sampled according to the nuisance. It is convenient to use when all the nuisance are uncorrelated and it is efficient to generate them The toy are generated by default for each poi values (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for each poi value. It can be convenient when the generation time is much larger than the evaluation time, otherwise it is recommended to re-generate the toy for each poi scanned point of the posterior function; ROOFIT: use roofit default integration methods which will produce a nested integral (not recommended for more than 1 nuisance parameters) . Definition at line 1073 of file BayesianCalculator.cxx. ◆ SetLeftSideTailFraction(). void RooStats::BayesianCalculator::SetLeftSideTailFraction ; (; double ; leftSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:31202,integrat,integration,31202,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['integrat'],['integration']
Integrability,"at represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10563,integrat,integration,10563,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['integrat'],['integration']
Integrability,"at should be plotted,; 1434/// find all nodes that (in)directly depend on these selected; 1435/// nodes. Mark all directly and indirectly selected nodes; 1436/// as 'selected' using the selectComp() method; 1437 ; 1438void RooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; 1439{; 1440 // Get complete set of tree branch nodes; 1441 RooArgSet branchNodeSet;; 1442 branchNodeServerList(&branchNodeSet);; 1443 ; 1444 // Discard any non-PDF nodes; 1445 // Iterate by number because collection is being modified! Iterators may invalidate ...; 1446 for (unsigned int i = 0; i < branchNodeSet.size(); ++i) {; 1447 const auto arg = branchNodeSet[i];; 1448 if (!dynamic_cast<RooAbsReal*>(arg)) {; 1449 branchNodeSet.remove(*arg) ;; 1450 }; 1451 }; 1452 ; 1453 // If no set is specified, restored all selection bits to true; 1454 if (!selNodes) {; 1455 // Reset PDF selection bits to true; 1456 for (const auto arg : branchNodeSet) {; 1457 static_cast<RooAbsReal*>(arg)->selectComp(true);; 1458 }; 1459 return ;; 1460 }; 1461 ; 1462 ; 1463 // Add all nodes below selected nodes that are value servers; 1464 RooArgSet tmp;; 1465 for (const auto arg : branchNodeSet) {; 1466 for (const auto selNode : *selNodes) {; 1467 if (selNode->dependsOn(*arg, nullptr, /*valueOnly=*/true)) {; 1468 tmp.add(*arg,true);; 1469 }; 1470 }; 1471 }; 1472 ; 1473 // Add all nodes that depend on selected nodes by value; 1474 for (const auto arg : branchNodeSet) {; 1475 if (arg->dependsOn(*selNodes, nullptr, /*valueOnly=*/true)) {; 1476 tmp.add(*arg,true);; 1477 }; 1478 }; 1479 ; 1480 tmp.remove(*selNodes, true);; 1481 tmp.remove(*this);; 1482 selNodes->add(tmp);; 1483 coutI(Plotting) << ""RooAbsPdf::plotOn("" << GetName() << "") indirectly selected PDF components: "" << tmp << std::endl ;; 1484 ; 1485 // Set PDF selection bits according to selNodes; 1486 for (const auto arg : branchNodeSet) {; 1487 bool select = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:60178,depend,dependsOn,60178,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['depend'],['dependsOn']
Integrability,"at specifies the generator algorithm we will use. ;  ; const RooNumGenConfig * getGeneratorConfig () const;  Return the numeric MC generator configuration used for this object. ;  ; void getLogProbabilities (std::span< const double > pdfValues, double *output) const;  ; double getNorm (const RooArgSet &nset) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; virtual double getNorm (const RooArgSet *set=nullptr) const;  Get normalisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistConstraint.html:10104,integrat,integrating,10104,doc/master/classRooHistConstraint.html,https://root.cern,https://root.cern/doc/master/classRooHistConstraint.html,2,['integrat'],['integrating']
Integrability,at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 717 of file Minuit2Minimizer.cxx. ◆ ExamineMinimum(). bool ROOT::Minuit2::Minuit2Minimizer::ExamineMinimum ; (; const ROOT::Minuit2::FunctionMinimum & ; min). protected . examine the minimum result ; Definition at line 594 of file Minuit2Minimizer.cxx. ◆ FixVariable(). bool ROOT::Minuit2::Minuit2Minimizer::FixVariable ; (; unsigned int ; ivar). overridevirtual . fix an existing variable ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 338 of file Minuit2Minimizer.cxx. ◆ GetCovMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetCovMatrix ; (; double * ; cov); const. overridevirtual . Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ; The array will be filled as cov[i *ndim + j] The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 755 of file Minuit2Minimizer.cxx. ◆ GetFCN(). virtual const ROOT::Minuit2::FCNBase * ROOT::Minuit2::Minuit2Minimizer::GetFCN ; (; ); const. inlineprotectedvirtual . Definition at line 287 of file Minuit2Minimizer.h. ◆ GetHessianMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetHessianMatrix ; (; double * ; h); const. overridevirtual . Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ; The array will be filled as h[i *ndim + j] ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 784 of file Minuit2Minimizer.cxx. ◆ GetMinimizer(). virtual const ROOT::Minuit2::ModularFunctionMinimizer * ROOT::Minuit2::Minuit2Minimizer::GetMinimizer ; (; ); const. inlineprotectedvirtual . Definition at line 281,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:16483,interface,interface,16483,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['interface'],['interface']
Integrability,"at the user specifies the number of intermediate function points used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration. We can use the example above, but replacing the creation of a ROOT::Math::GaussIntegrator object with ROOT::Math::GaussLegendreIntegrator.; 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integrati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:706356,interface,interface,706356,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"at was received into one that can be send, i.e.; forward a just received message. void TagStreamerInfo(TVirtualStreamerInfo* info); Remember that the StreamerInfo is being used in writing. void Reset(); Reset the message buffer so we can use (i.e. fill) it again. void SetLength() const; Set the message length at the beginning of the message buffer.; This method is only called by TSocket::Send(). void SetWhat(UInt_t what); Using this method one can change the message type a-posteriory.; In case you OR ""what"" with kMESS_ACK, the message will wait for; an acknowledgement from the remote side. This makes the sending; process synchronous. void SetCompressionAlgorithm(Int_t algorithm = 0). void SetCompressionLevel(Int_t level = 1). void SetCompressionSettings(Int_t settings = 1). Int_t Compress(); Compress the message. The message will only be compressed if the; compression level > 0 and the if the message is > 256 bytes.; Returns -1 in case of error (when compression fails or; when the message increases in size in some pathological cases),; otherwise returns 0. Int_t Uncompress(); Uncompress the message. The message will only be uncompressed when; kMESS_ZIP is set. Returns -1 in case of error, 0 otherwise. void WriteObject(const TObject* obj); Write object to message buffer.; When support for schema evolution is enabled the list of TStreamerInfo; used to stream this object is kept in fInfos. This information is used; by TSocket::Send that sends this list through the socket. This list is in; turn used by TSocket::Recv to store the TStreamerInfo objects in the; relevant TClass in case the TClass does not know yet about a particular; class version. This feature is implemented to support clients and servers; with either different ROOT versions or different user classes versions. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the message.; If not, then:; - mark bit 0 of fBitsPIDs to indicate that a ProcessID has been found; - mark bit uid+1 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMessage.html:24021,message,message,24021,root/html530/TMessage.html,https://root.cern,https://root.cern/root/html530/TMessage.html,5,['message'],['message']
Integrability,"at we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IntervalCalculator(); {}. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. Double_t Size() const; Get the size of the test (eg. rate of Type I error). Double_t ConfidenceLevel() const; Get the Confidence level for the test. void SetData(RooAbsData& ); Set the DataSet ( add to the the workspace if not already there ?). void SetModel(const RooStats::ModelConfig& ); Set the Model. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g. 0.95 for a 95% Confidence Interval). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: IntervalCalculator.h 31276 2009-11-18 15:06:42Z moneta $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__IntervalCalculator.html:2305,interface,interface,2305,root/html528/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__IntervalCalculator.html,1,['interface'],['interface']
Integrability,"at we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IntervalCalculator(); {}. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. Double_t Size() const; Get the size of the test (eg. rate of Type I error). Double_t ConfidenceLevel() const; Get the Confidence level for the test. void SetData(RooAbsData& ); Set the DataSet ( add to the the workspace if not already there ?). void SetModel(const RooStats::ModelConfig& ); Set the Model. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g. 0.95 for a 95% Confidence Interval). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: IntervalCalculator.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__IntervalCalculator.html:2307,interface,interface,2307,root/html530/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__IntervalCalculator.html,1,['interface'],['interface']
Integrability,"at we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IntervalCalculator(); {}. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. Double_t Size() const; Get the size of the test (eg. rate of Type I error). Double_t ConfidenceLevel() const; Get the Confidence level for the test. void SetData(RooAbsData& ); Set the DataSet ( add to the the workspace if not already there ?). void SetModel(const RooStats::ModelConfig& ); Set the Model. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g. 0.95 for a 95% Confidence Interval). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: IntervalCalculator.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__IntervalCalculator.html:2307,interface,interface,2307,root/html532/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html532/RooStats__IntervalCalculator.html,1,['interface'],['interface']
Integrability,"at>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::Experimental::RStandardScalerDefinition RStandardScaler.hxx:16; TMVA::Experimental::RStandardScaler::Fitvoid Fit(const RTensor< T > &x)Definition RStandardScaler.hxx:52; TMVA::Experimental::RStandardScaler::Computestd::vector< T > Com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html:1551,interface,interface,1551,doc/master/tmva004__RStandardScaler_8C.html,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html,1,['interface'],['interface']
Integrability,"atMax length of compiled pattern. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRegexp(const char* re, Bool_t wildcard = kFALSE); Create a regular expression from the input string. If wildcard is; true then the input string will first be interpreted as a wildcard; expression by MakeWildcard(), and the result then interpreted as a; regular expression. TRegexp(const TString& re); Create a regular expression from a TString. TRegexp(const TRegexp& re); Copy ctor. ~TRegexp(); Destructor. TRegexp& operator=(const TRegexp& re); Assignment operator. TRegexp& operator=(const char* re); Assignment operator taking a char* and assigning it to a regexp. TRegexp& operator=(const TString& re); Assignment operator taking a TString. void GenPattern(const char* re); Generate the regular expression pattern. void CopyPattern(const TRegexp& re); Copy the regular expression pattern. const char * MakeWildcard(const char* re); This routine transforms a wildcarding regular expression into; a general regular expression used for pattern matching.; When using wildcards the regular expression is assumed to be; preceded by a ""^"" (BOL) and terminated by a ""$"" (EOL). Also, all; ""*""'s and ""?""'s (closures) are assumed to be preceded by a ""."" (i.e. any; character, except ""/""'s) and all .'s are escaped (so *.ps is different; from *.eps). The special treatment of ""/"" allows the easy matching of; pathnames, e.g. ""*.root"" will match ""aap.root"", but not ""pipo/aap.root"". Ssiz_t Index(const TString& str, Ssiz_t* len, Ssiz_t start = 0) const; Find the first occurance of the regexp in string and return the; position, or -1 if there is no match. Len is length of the matched; string and i is the offset at which the matching should start. EStatVal Status(). » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRegexp.html:2669,rout,routine,2669,root/html534/TRegexp.html,https://root.cern,https://root.cern/root/html534/TRegexp.html,1,['rout'],['routine']
Integrability,"atMax length of compiled pattern. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRegexp(const char* re, Bool_t wildcard = kFALSE); Create a regular expression from the input string. If wildcard is; true then the input string will first be interpreted as a wildcard; expression by MakeWildcard(), and the result then interpreted as a; regular expression. TRegexp(const TString& re); Create a regular expression from a TString. TRegexp(const TRegexp& re); Copy ctor. ~TRegexp(); Destructor. TRegexp& operator=(const TRegexp& re); Assignment operator. TRegexp& operator=(const char* re); Assignment operator taking a char* and assigning it to a regexp. TRegexp& operator=(const TString& re); Assignment operator taking a TString. void GenPattern(const char* re); Generate the regular expression pattern. void CopyPattern(const TRegexp& re); Copy the regular expression pattern. const char * MakeWildcard(const char* re); This routine transforms a wildcarding regular expression into; a general regular expression used for pattern matching.; When using wildcards the regular expression is assumed to be; preceded by a ""^"" (BOL) and terminated by a ""$"" (EOL). Also, all; ""*""'s and ""?""'s (closures) are assumed to be preceded by a ""."" (i.e. any; character, except ""/""'s) and all .'s are escaped (so *.ps is different; from *.eps). The special treatment of ""/"" allows the easy matching of; pathnames, e.g. ""*.root"" will match ""aap.root"", but not ""pipo/aap.root"". Ssiz_t Index(const TString& str, Ssiz_t* len, Ssiz_t start = 0) const; Find the first occurance of the regexp in string and return the; position, or -1 if there is no match. Len is length of the matched; string and i is the offset at which the matching should start. EStatVal Status(). » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRegexp.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:22; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRegexp.html:2650,rout,routine,2650,root/html532/TRegexp.html,https://root.cern,https://root.cern/root/html532/TRegexp.html,1,['rout'],['routine']
Integrability,"atTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCategory(). RooCategory(const char* name, const char* title); Constructor. Types must be defined using defineType() before variable can be used. RooCategory(const RooCategory& other, const char* name = 0); Copy constructor. ~RooCategory(); Destructor. Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Set value by specifying the index code of the desired state.; If printError is set, a message will be printed if; the specified index does not represent a valid state. Bool_t setLabel(const char* label, Bool_t printError = kTRUE); Set value by specifying the name of the desired state; If printError is set, a message will be printed if; the specified label does not represent a valid state. Bool_t defineType(const char* label); Define a state with given name, the lowest available; positive integer is assigned as index. Category; state labels may not contain semicolons.; Error status is return if state with given name; is already defined. Bool_t defineType(const char* label, Int_t index); Define a state with given name and index. Category; state labels may not contain semicolons; Error status is return if state with given name; or index is already defined. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; compact only at the moment. void clearRange(const char* name, Bool_t silent); Check that both input arguments are not null pointers. void setRange(const char* rangeName, const char* stateNameList). void addToRange(const char* rangeName, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:22835,message,message,22835,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,6,['message'],['message']
Integrability,"atVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:14869,message,messages,14869,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,3,['message'],['messages']
Integrability,"atVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:15374,message,messages,15374,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['message'],['messages']
Integrability,"ata Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static RooNumGenFactory*_instance; map<std::string,RooAbsNumGenerator*>_map. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumGenFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumGenFactory(); Destructor. RooNumGenFactory(const RooNumGenFactory& other); Copy constructor. RooNumGenFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoSampler(RooAbsNumGenerator* proto, const RooArgSet& defConfig); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsNumGenerator* getProtoSampler(const char* name); Return prototype integrator with given (class) name. RooAbsNumGenerator* createSampler(RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, RooAbsReal* maxFuncVal = 0); Construct a numeric integrator instance that operates on function 'func' and is configured; with 'config'. If ndimPreset is greater than zero that number is taken as the dimensionality; of the integration, otherwise it is queried from 'func'. This function iterators over list; of available prototype integrators and returns an clone attached to the given function of; the first class that matches the specifications of the requested integration considering; the number of dimensions, the na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumGenFactory.html:6630,integrat,integrator,6630,root/html526/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html526/RooNumGenFactory.html,20,"['depend', 'integrat']","['depends', 'integrator', 'integrators']"
Integrability,"ata Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static RooNumGenFactory*_instance; map<string,RooAbsNumGenerator*>_map. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumGenFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumGenFactory(); Destructor. RooNumGenFactory(const RooNumGenFactory& other); Copy constructor. RooNumGenFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoSampler(RooAbsNumGenerator* proto, const RooArgSet& defConfig); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsNumGenerator* getProtoSampler(const char* name); Return prototype integrator with given (class) name. RooAbsNumGenerator* createSampler(RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, RooAbsReal* maxFuncVal = 0); Construct a numeri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumGenFactory.html:6682,integrat,integrators,6682,root/html602/RooNumGenFactory.html,https://root.cern,https://root.cern/root/html602/RooNumGenFactory.html,2,['integrat'],['integrators']
Integrability,"ata record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84920,message,message,84920,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['message'],['message']
Integrability,"ataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< int >; ROOT::Detail::RDF::GetMergeableValuestd::unique_ptr< RMergeableVariations< T > > GetMergeableValue(ROOT::RDF::Experimental::RResultMap< T > &rmap)Retrieve mergeable values after calling ROOT::RDF::VariationsFor .Definition RResultMap.hxx:211; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; mTMarker mDefinition textangle.C:8. Definition at line 211 of file RResultMap.hxx. ◆ GetMergeableValue() [2/2]. template<typename T > . std::unique_ptr< RMergeableValue< T > > ROOT::Detail::RDF::GetMergeableValue ; (; RResultPtr< T > & ; rptr). Retrieve a mergeable value from an RDataFrame action. ; Parameters. [in]rptrlvalue reference of an RResultPtr object. . ReturnsAn RMergeableValue holding the result of the action, wrapped in an std::unique_ptr.; This function triggers the execution of the RDataFrame computation graph. Then retrieves an RMergeableValue object created with the result wrapped by the RResultPtr argument. The user obtains ownership of the mergeable, which in turn holds a copy of the result of the action. The RResultPtr is not destroyed in the process and will still retain (shared) ownership of the original result.; Example usage: using namespace ROOT::Detail::RDF;; ROOT::RDataFrame d(""myTree"", ""file_*.root"");; auto h = d.Histo1D(""Branch_A"");; auto mergeablehisto = GetMergeableValue(h);; d#define d(i)Definition RSha256.hxx:102; ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80. Definition at line 470 of file RResultPtr.hxx. ◆ MakeResultPtr(). template<typename T > . RResultPtr< T > ROOT::Detail::RDF::MakeResultPtr ; (; const std::shared_ptr< T > & ; r, . RLoopManager & ; df, . std::shared_ptr< ROOT::Internal::RDF::RActionBase > ; actionPtr . ). Create a RResultPtr and s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html:8027,wrap,wrapped,8027,doc/master/namespaceROOT_1_1Detail_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html,1,['wrap'],['wrapped']
Integrability,"ataInputHandler.h. ◆ ReadInputTree(). TTree * TMVA::DataInputHandler::ReadInputTree ; (; const TString & ; dataFile). private . create trees from these ascii files ; Definition at line 152 of file DataInputHandler.cxx. ◆ Sbegin(). std::vector< TreeInfo >::const_iterator TMVA::DataInputHandler::Sbegin ; (; ); const. inline . Definition at line 113 of file DataInputHandler.h. ◆ Send(). std::vector< TreeInfo >::const_iterator TMVA::DataInputHandler::Send ; (; ); const. inline . Definition at line 114 of file DataInputHandler.h. ◆ SignalTreeInfo(). const TreeInfo & TMVA::DataInputHandler::SignalTreeInfo ; (; Int_t ; i); const. inline . Definition at line 108 of file DataInputHandler.h. ◆ Streamer(). virtual void TMVA::DataInputHandler::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::DataInputHandler::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 134 of file DataInputHandler.h. Member Data Documentation. ◆ fExplicitTrainTest. std::map< std::string, Bool_t > TMVA::DataInputHandler::fExplicitTrainTest. private . if set to true the user has specified training and testing data explicitly ; Definition at line 130 of file DataInputHandler.h. ◆ fInputTrees. std::map< TString, std::vector<TreeInfo> > TMVA::DataInputHandler::fInputTrees. mutableprivate . list of input trees per class (classname is given as first parameter in the map) ; Definition at line 129 of file DataInputHandler.h. ◆ fLogger. MsgLogger* TMVA::DataInputHandler::fLogger. mutableprivate . ! message logger ; Definition at line 131 of file DataInputHandler.h. Libraries for TMVA::DataInputHandler:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/DataInputHandler.h; tmva/tmva/src/DataInputHandler.cxx. TMVADataInputHandler. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html:20820,message,message,20820,doc/master/classTMVA_1_1DataInputHandler.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataInputHandler.html,1,['message'],['message']
Integrability,"ataSB.Size(), True); 114result = fitter.Result(); 115result.Print(ROOT.std.cout); 116 ; 117c1 = ROOT.TCanvas(""Simfit"", ""Simultaneous fit of two histograms"", 10, 10, 700, 700); 118c1.Divide(1, 2); 119c1.cd(1); 120ROOT.gStyle.SetOptFit(1111); 121 ; 122fB.SetFitResult(result, iparB); 123fB.SetRange(rangeB().first, rangeB().second); 124fB.SetLineColor(ROOT.kBlue); 125hB.GetListOfFunctions().Add(fB); 126hB.Draw(); 127 ; 128c1.cd(2); 129fSB.SetFitResult(result, iparSB); 130fSB.SetRange(rangeSB().first, rangeSB().second); 131fSB.SetLineColor(ROOT.kRed); 132hSB.GetListOfFunctions().Add(fSB); 133hSB.Draw(); 134 ; 135c1.SaveAs(""combinedFit.png""); ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; object; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. tutorialsfitcombinedFit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py_source.html:4716,interface,interface,4716,doc/master/combinedFit_8py_source.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py_source.html,1,['interface'],['interface']
Integrability,ataTable;  ; class  REveDigitSet;  ; class  REveElement;  ; class  REveEllipsoid;  ; class  REveEllipsoidProjected;  ; class  REveException;  REveException Exception-type thrown by Eve classes. More...;  ; class  REveFrameBox;  ; class  REveGeoManagerHolder;  REveGeoManagerHolder Exception-safe global variable holders. More...;  ; class  REveGeoPolyShape;  ; class  REveGeoShape;  ; class  REveGeoShapeExtract;  ; class  REveGeoShapeProjected;  ; class  REveGeoTopNodeData;  ; class  REveGeoTopNodeViz;  ; class  REveHit;  REveHit Monte Carlo hit (also used in VSD). More...;  ; class  REveJetCone;  ; class  REveJetConeProjected;  ; class  REveLine;  REveLine An arbitrary polyline with fixed line and marker attributes. More...;  ; class  REveLineProjected;  ; class  REveMagField;  REveMagField Abstract interface to magnetic field. More...;  ; class  REveMagFieldConst;  REveMagFieldConst Interface to constant magnetic field. More...;  ; class  REveMagFieldDuo;  REveMagFieldDuo Interface to magnetic field with two different values depending on radius. More...;  ; class  REveManager;  ; class  REveMCRecCrossRef;  REveMCRecCrossRef Cross-reference of sim/rec data per particle (also used in VSD). More...;  ; class  REveMCTrack;  REveMCTrack. More...;  ; class  REvePathMarkT;  Special-point on track: More...;  ; class  REvePointSelector;  REvePointSelector TSelector for direct extraction of point-like data from a Tree. More...;  ; class  REvePointSelectorConsumer;  ; class  REvePointSet;  ; class  REvePointSetArray;  ; class  REvePointSetProjected;  ; class  REvePolygonSetProjected;  ; class  REveProjectable;  ; class  REveProjected;  ; class  REveProjection;  REveProjection Base for specific classes that implement non-linear projections. More...;  ; class  REveProjectionManager;  REveProjectionManager Manager class for steering of projections and managing projected objects. More...;  ; class  REveRecCascade;  REveRecCascade. More...;  ; class  REveRecKink;  REveRecKink Recons,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:7465,depend,depending,7465,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['depend'],['depending']
Integrability,"atamember); const. Return pointer to datamember object with name ""datamember"". ; Definition at line 3439 of file TClass.cxx. ◆ GetDataMemberOffset(). Longptr_t TClass::GetDataMemberOffset ; (; const char * ; name); const. return offset for member name. ; name can be a data member in the class itself, one of its base classes, or one member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built ; Definition at line 3477 of file TClass.cxx. ◆ GetDeclFileLine(). Short_t TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return name of the file containing the declaration of this class. ; Definition at line 3463 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7463 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7471 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7479 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3422 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3431 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7487 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:78857,wrap,wrapper,78857,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['wrap'],['wrapper']
Integrability,"atamember); const. Return pointer to datamember object with name ""datamember"". ; Definition at line 3506 of file TClass.cxx. ◆ GetDataMemberOffset(). Longptr_t TClass::GetDataMemberOffset ; (; const char * ; name); const. return offset for member name. ; name can be a data member in the class itself, one of its base classes, or one member in one of the aggregated classes.; In case of an emulated class, the list of emulated TRealData is built ; Definition at line 3544 of file TClass.cxx. ◆ GetDeclFileLine(). Short_t TClass::GetDeclFileLine ; (; ); const. inline . Definition at line 429 of file TClass.h. ◆ GetDeclFileName(). const char * TClass::GetDeclFileName ; (; ); const. Return name of the file containing the declaration of this class. ; Definition at line 3530 of file TClass.cxx. ◆ GetDeclIdMap(). DeclIdMap_t * TClass::GetDeclIdMap ; (; ). staticprivate . Definition at line 480 of file TClass.cxx. ◆ GetDelete(). ROOT::DelFunc_t TClass::GetDelete ; (; ); const. Return the wrapper around delete ThiObject. ; Definition at line 7530 of file TClass.cxx. ◆ GetDeleteArray(). ROOT::DelArrFunc_t TClass::GetDeleteArray ; (; ); const. Return the wrapper around delete [] ThiObject. ; Definition at line 7538 of file TClass.cxx. ◆ GetDestructor(). ROOT::DesFunc_t TClass::GetDestructor ; (; ); const. Return the wrapper around the destructor. ; Definition at line 7546 of file TClass.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClass::GetDict ; (; const char * ; cname). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3489 of file TClass.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClass::GetDict ; (; const std::type_info & ; info). static . Return a pointer to the dictionary loading function generated by rootcint. ; Definition at line 3498 of file TClass.cxx. ◆ GetDirectoryAutoAdd(). ROOT::DirAutoAdd_t TClass::GetDirectoryAutoAdd ; (; ); const. Return the wrapper around the directory auto add function. ; Definition at line 7554 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:78858,wrap,wrapper,78858,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['wrap'],['wrapper']
Integrability,"atchSize));; }; }; }; }; ; // use BDT in case not using Keras or TMVA DL; if (!useKeras || !useTMVA_BDT); useTMVA_BDT = true;; ; /**; ## Book TMVA BDT; **/; ; if (useTMVA_BDT) {; ; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=100:MinNodeSize=2.5%:BoostType=Grad:Shrinkage=0.10:UseBaggedBoost:""; ""BaggedSampleFraction=0.5:nCuts=20:""; ""MaxDepth=2"");; ; }; ; /// Train all methods; factory->TrainAllMethods();; ; std::cout << ""nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; // ---- Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // ----- Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // check method; ; // plot ROC curve; auto c1 = factory->GetROCCurve(dataloader);; c1->Draw();; ; if (outputFile) outputFile->Close();; }; DataLoader.h; DataSetInfo.h; MethodDL.h; f#define f(i)Definition RSha256.hxx:104; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TFile.h; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TF11-Dim function classDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:71772,message,messages,71772,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['message'],['messages']
Integrability,"atches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngRanLuxD1 Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Double precision (48 bits) version of Second generation of Ranlux generator with luxury level of 1 (It throws away 202 value for every 12 used) see here ; Definition at line 399 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngRanLuxD1 ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD1.html:1285,message,message,1285,doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD1.html,1,['message'],['message']
Integrability,"atches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngRanLuxD2 Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Double precision (48 bits) version of Second generation of Ranlux generator with luxury level of 2 (It throws away 397 value for every 12 used) see here ; Definition at line 413 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngRanLuxD2 ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD2.html:1285,message,message,1285,doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD2.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxD2.html,1,['message'],['message']
Integrability,"ate . linear term importance ; Definition at line 349 of file RuleEnsemble.h. ◆ fLinNorm. std::vector< Double_t > TMVA::RuleEnsemble::fLinNorm. private . norm of ditto, see after eq 26 in ref 2 ; Definition at line 346 of file RuleEnsemble.h. ◆ fLinPDFB. std::vector< TH1F* > TMVA::RuleEnsemble::fLinPDFB. private . pdfs for each variable, background ; Definition at line 347 of file RuleEnsemble.h. ◆ fLinPDFS. std::vector< TH1F* > TMVA::RuleEnsemble::fLinPDFS. private . pdfs for each variable, signal ; Definition at line 348 of file RuleEnsemble.h. ◆ fLinQuantile. Double_t TMVA::RuleEnsemble::fLinQuantile. private . quantile cut to remove outliers ; Definition at line 339 of file RuleEnsemble.h. ◆ fLinTermOK. std::vector< Char_t > TMVA::RuleEnsemble::fLinTermOK. private . flags linear terms with sufficient strong importance <– stores boolean ; Definition at line 342 of file RuleEnsemble.h. ◆ fLogger. MsgLogger* TMVA::RuleEnsemble::fLogger. mutableprivate . ! message logger ; Definition at line 381 of file RuleEnsemble.h. ◆ fNRulesGenerated. UInt_t TMVA::RuleEnsemble::fNRulesGenerated. private . number of rules generated, before cleanup ; Definition at line 366 of file RuleEnsemble.h. ◆ fOffset. Double_t TMVA::RuleEnsemble::fOffset. private . offset in discriminator function ; Definition at line 340 of file RuleEnsemble.h. ◆ fRuleFit. const RuleFit* TMVA::RuleEnsemble::fRuleFit. private . pointer to rule fit object ; Definition at line 379 of file RuleEnsemble.h. ◆ fRuleFSig. Double_t TMVA::RuleEnsemble::fRuleFSig. private . N(sig)/N(sig)+N(bkg) ; Definition at line 361 of file RuleEnsemble.h. ◆ fRuleMap. std::vector< std::vector<UInt_t> > TMVA::RuleEnsemble::fRuleMap. private . map of rule responses ; Definition at line 374 of file RuleEnsemble.h. ◆ fRuleMapEvents. const std::vector<const TMVA::Event *>* TMVA::RuleEnsemble::fRuleMapEvents. private . pointer to vector of events used ; Definition at line 377 of file RuleEnsemble.h. ◆ fRuleMapInd0. UInt_t TMVA::RuleEnsem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleEnsemble.html:35595,message,message,35595,doc/master/classTMVA_1_1RuleEnsemble.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleEnsemble.html,1,['message'],['message']
Integrability,"ate Attributes |; List of all members ; TASLogHandler Class Reference. . Definition at line 101 of file TApplicationServer.h. Public Types; enum  EStatusBits { kFileIsPipe = (1ULL << ( 23 )); };  ;  Public Types inherited from TFileHandler; enum  { kRead = 1; , kWrite = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TASLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TASLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ; virtual ~TASLogHandler ();  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASLogHandler.html:1305,message,messages,1305,doc/master/classTASLogHandler.html,https://root.cern,https://root.cern/doc/master/classTASLogHandler.html,1,['message'],['messages']
Integrability,"ate Member Functions |; Private Attributes |; Friends |; List of all members ; RooBinSamplingPdf Class Reference. ; The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned distribution. ; When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is correct only if the second derivative of the function vanishes, though. This is shown in the plots below.; For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside using integrator(). This can be used to change the integration rules, so less/more function evaluations are performed. The target precision of the integrator can be set in the constructor. How to use it; There are two ways to use this class:; Manually wrap a PDF: RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; binSampler.fitTo(data);; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefinition RooBinSamplingPdf.h:111; When a PDF is wrapped with a RooBinSamplingPDF, just u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:1236,integrat,integrator,1236,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability,"ate an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:46179,depend,depends,46179,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['depend'],['depends']
Integrability,"ate projection of signal and total likelihood on (y,z) observables; // i.e. integrate signal and composite model over x; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; ; // Construct the log of the signal / signal+background probability; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // P l o t d a t a w i t h a L L r a t i o c u t; // -------------------------------------------------------; ; // Calculate the llratio value for each event in the dataset; data->addColumn(llratio_func);; ; // Extract the subset of data with large signal likelihood; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame; RooPlot *frame2 = x.frame(Title(""Same projection on X with LLratio(y,z)>0.7""), Bins(40));; ; // Plot select data on frame; dataSel->plotOn(frame2);; ; // M a k e M C p r o j e c t i o n o f p d f w i t h s a m e L L r a t i o c u t; // ---------------------------------------------------------------------------------------------; ; // Generate large number of events for MC integration of pdf projection; std::unique_ptr<RooDataSet> mcprojData{model.generate({x, y, z}, 10000)};; ; // Calculate LL ratio for each generated event and select MC events with llratio)0.7; mcprojData->addColumn(llratio_func);; std::unique_ptr<RooAbsData> mcprojDataSel{mcprojData->reduce(Cut(""llratio>0.7""))};; ; // Project model on x, integrating projected observables (y,z) with Monte Carlo technique; // on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData(*mcprojDataSel));; ; TCanvas *c = new TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataSet.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8C.html:3153,integrat,integration,3153,doc/master/rf316__llratioplot_8C.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8C.html,1,['integrat'],['integration']
Integrability,"ate propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimultaneous.html:40763,integrat,integrator,40763,root/html530/RooSimultaneous.html,https://root.cern,https://root.cern/root/html530/RooSimultaneous.html,1,['integrat'],['integrator']
Integrability,"ate system. More...;  ; class  GoFTest;  GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. More...;  ; class  GradFunctor;  GradFunctor class for Multidimensional gradient functions. More...;  ; class  GradFunctor1D;  GradFunctor1D class for one-dimensional gradient functions. More...;  ; class  GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  GSLChebSeries;  wrapper class for C struct gsl_cheb_series More...;  ; class  GSLDerivator;  Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). More...;  ; class  GSLError;  class to change GSL Error handler to use ROOT one. More...;  ; class  GSLFunctionAdapter;  Class for adapting any C++ functor class to C function pointers used by GSL. More...;  ; class  GSLFunctionDerivWrapper;  class to wrap a gsl_function_fdf (with derivatives) More...;  ; class  GSLFunctionWrapper;  Wrapper class to the gsl_function C structure. More...;  ; class  GSLIntegrationWorkspace;  ; class  GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  GSLMCIntegrationWorkspace;  ; class  GSLMCIntegrator;  ; class  GSLMinimizer;  GSLMinimizer class. More...;  ; class  GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  GSLMiserIntegrationWorkspace;  Workspace for MISER. More...;  ; struct  GSLMonteFunctionAdapter;  ; class  GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; class  GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  GSLMultiFitFunctionAdapter;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:9410,wrap,wrap,9410,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['wrap'],['wrap']
Integrability,"ate the integral of the ROC curve, also known as the area under curve (AUC), for a given method. ;  ; Bool_t HasMethod (const TString &datasetname, const TString &title) const;  Checks whether a given method name is defined for a given dataset. ;  ; virtual TClass * IsA () const;  ; Bool_t IsModelPersistence () const;  ; Bool_t IsSilentFile () const;  ; virtual void MakeClass (const TString &datasetname, const TString &methodTitle="""") const;  ; std::map< TString, Double_t > OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  Iterates through all booked methods and sees if they use parameter tuning and if so does just that, i.e. calls ""Method::Train()"" for different parameter settings and keeps in mind the ""optimal one""... and that's the one that will later on be used in the main training loop. ;  ; void OptimizeAllMethodsForClassification (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  ; void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  ; void PrintHelpMessage (const TString &datasetname, const TString &methodTitle="""") const;  Print predefined help message of classifier. ;  ; TDirectory * RootBaseDir ();  ; void SetVerbose (Bool_t v=kTRUE);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TestAllMethods ();  Evaluates all booked methods on the testing data and adds the output to the Results in the corresponiding DataSet. ;  ; void TrainAllMethods ();  Iterates through all booked methods and calls training. ;  ; void TrainAllMethodsForClassification (void);  ; void TrainAllMethodsForRegression (void);  ; Bool_t Verbose (void) const;  ;  Public Member Functions inherited from TMVA::Configurable;  Configurable (const TString &theOption="""");  constructor ;  ; virtual ~Configurable ();  default destructor ;  ; void AddOptionsXMLTo (void *parent) const;  write options to XML file ;  ; templat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:5248,message,message,5248,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['message'],['message']
Integrability,ate the interfaces like ROOT::Math::Minimizer via the Plugin Manager. More...;  ; class  FastInverter;  Fast Matrix Inverter class Class to specialize calls to Dinv. More...;  ; class  FastInverter< 3 >;  3x3 direct matrix inversion using Cramer Rule use only for FastInverter More...;  ; class  FastInverter< 4 >;  4x4 matrix inversion using Cramers rule. More...;  ; class  FastInverter< 5 >;  5x5 Matrix inversion using Cramers rule. More...;  ; class  FitTransformFunction;  Internal class used by GSLNLSMinimizer to implement the transformation of the chi2 function used by GSL Non-linear Least-square fitting The class is template on the FitMethodFunction type to support both gradient and non gradient functions. More...;  ; class  Functor;  Documentation for class Functor class. More...;  ; class  Functor1D;  Functor1D class for one-dimensional functions. More...;  ; class  GaussIntegrator;  User class for performing function integration. More...;  ; class  GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; struct  GeneralHessianCalc;  ; struct  GeneralHessianCalc< double >;  ; struct  GeneralLinearFunctionDerivation;  Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...;  ; struct  GeneralLinearFunctionDerivation< double >;  ; class  GeneticMinimizer;  GeneticMinimizer. More...;  ; struct  GeneticMinimizerParameters;  ; class  GenVector_exception;  ; class  GlobalCoordinateSystemTag;  Tag for identifying vectors based on a global coordinate system. More...;  ; class  GoFTest;  GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. More...;  ; class  GradFunctor;  GradFunctor class for Multidimensional gradient functions. More...;  ; class  GradFunctor1D;  GradFunctor1D class for one-di,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:7753,integrat,integration,7753,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['integrat'],['integration']
Integrability,"ate: Fri Jul 19 2002 - 13:18:48 MEST. Next message: Ed Oltman: ""[ROOT] Performance question: Updating a colz histogram""; Previous message: Arkadiusz Bubak: ""[ROOT] TThread and TMapFile together""; In reply to: Rene Brun: ""Re: [ROOT] error calc. in TProfile"". Messages sorted by:; [ date ]; [ thread ]; [ subject ]; [ author ]. Hi Rene,. RB>I agree with your theory. In the practical case of TProfile; RB>with low statistics in one bin and very small weights, do you have a; RB>better algorithm to propose? I mean an algorithm really working,; RB>and for example, not subject to rounding problems?; RB>Let me know. I will be happy to include it. I thought a little bit about this problem and arrived at the following; conclusion / suggestion:. Is it possible to use a user-supplied error calculation function? In addition; of course to the other options (error-of-the-mean and spread option). It is always the user's own responsibility to calculate their errors; correctly, as well as judging the outcome of a fit they make. What should be; the job of ROOT (IMHO), is to provide the tools to fit data points; even if; the fit is bad and the chi^2 is large, this is telling something. A user cannot expect ROOT to take care for any ill-posed fit, it is necessary; to give a bad result in that case. There is more to fitting distributions than; just to run a program: when fits do not work well, the users may be advised to; think about the model they are fitting and not to complain to ROOT developers; about their (physics or) statistics problem. just another $0.02 from me -- I am curious for other opinions. Best Regards,. Martin. Next message: Ed Oltman: ""[ROOT] Performance question: Updating a colz histogram""; Previous message: Arkadiusz Bubak: ""[ROOT] TThread and TMapFile together""; In reply to: Rene Brun: ""Re: [ROOT] error calc. in TProfile"". Messages sorted by:; [ date ]; [ thread ]; [ subject ]; [ author ]. This archive was generated by hypermail 2b29 ; : Sat Jan 04 2003 - 23:51:00 MET. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/roottalk/roottalk02/2916.html:1761,message,message,1761,root/roottalk/roottalk02/2916.html,https://root.cern,https://root.cern/root/roottalk/roottalk02/2916.html,2,['message'],['message']
Integrability,"ate<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:9127,integrat,integration,9127,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,6,['integrat'],['integration']
Integrability,"ate<std::size_t N, typename T , typename F > . auto ROOT::Internal::RDF::PassAsVec ; (; F && ; f); -> PassAsVecHelper<std::make_index_sequence<N>, T, F>. Definition at line 63 of file RDFHelpers.hxx. ◆ PrettyPrintAddr(). std::string ROOT::Internal::RDF::PrettyPrintAddr ; (; const void *const ; addr). Definition at line 648 of file RDFInterfaceUtils.cxx. ◆ RDataFrameTake(). template<typename T > . ROOT::RDF::RResultPtr< std::vector< T > > ROOT::Internal::RDF::RDataFrameTake ; (; ROOT::RDF::RNode ; df, . std::string_view ; column . ). Definition at line 67 of file PyROOTHelpers.hxx. ◆ RemoveDuplicates(). void ROOT::Internal::RDF::RemoveDuplicates ; (; ColumnNames_t & ; columnNames). Definition at line 1038 of file RDFInterfaceUtils.cxx. ◆ ReplaceDotWithUnderscore(). std::vector< std::string > ROOT::Internal::RDF::ReplaceDotWithUnderscore ; (; const std::vector< std::string > & ; columnNames). Replace occurrences of '. ; ' with '_' in each string passed as argument. An Info message is printed when this happens. Dots at the end of the string are not replaced. An exception is thrown in case the resulting set of strings would contain duplicates. ; Definition at line 314 of file RDFUtils.cxx. ◆ ResizeResults() [1/2]. template<typename T > . void ROOT::Internal::RDF::ResizeResults ; (; ROOT::RVec< T > & ; results, . std::size_t ; , . std::size_t ; nVariations . ). Definition at line 62 of file RVariation.hxx. ◆ ResizeResults() [2/2]. template<typename T > . void ROOT::Internal::RDF::ResizeResults ; (; std::vector< ROOT::RVec< T > > & ; results, . std::size_t ; nCols, . std::size_t ; nVariations . ). Definition at line 103 of file RVariation.hxx. ◆ ResolveAlias(). std::string ROOT::Internal::RDF::ResolveAlias ; (; const std::string & ; col, . const std::map< std::string, std::string > & ; aliasMap . ). Definition at line 398 of file RDFInterfaceUtils.cxx. ◆ ResultsSizeEq() [1/2]. template<typename T > . bool ROOT::Internal::RDF::ResultsSizeEq ; (; const T & ; results, . std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:39154,message,message,39154,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['message'],['message']
Integrability,"ateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TCollectionProxyInfo.h:515; ROOT::Detail::TCollectionProxyInfo::fValueOffsetint fValueOffsetDefinition TCollectionProxyInfo.h:502; ROOT::Detail::TCollectionProxyInfo::Generatestatic TCollectionProxyInfo * Generate(const T &)Generate proxy from template.Definition TCollectionProxyInfo.h:569; ROOT::Detail::TCollectionProxyInfo::fNextvoid *(* fNext)(void *iter, const void *end)Definition TCollectionProxyInfo.h:525; ROOT::Detail::TCollectionProxyInfo::fCreateEnvvoid *(* fCreateEnv)()Definition TCollectionProxyInfo.h:512; ROOT::Detail::TCollectionProxyInfo::fInfoconst std::type_info & fInfoDefinition TCollectionProxyInfo.h:499; ROOT::Internal::TStdBitsetHelperDefinition TCollectionProxyInfo.h:48; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; bool; object; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMVA_SOFIE_GNN.startstartDefinition TMVA_SOFIE_GNN.py:200; TMVA_SOFIE_GNN.endendDefinition TMVA_SOFIE_GNN.py:207; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Detail::TCollectionProxyInfo::AddressDefinition TCollectionProxyInfo.h:264; ROOT::Detail::TCollectionProxyInfo::Address::~Addressvirtual ~Address()Definition TCollectionProxyInfo.h:265; ROOT::Detail::TCollectionProxyInfo::Address::addressstatic void * address(T ref)Definition TCollectionProxyInfo.h:266; ROOT::Detail::TCollectionProxyInfo::EnvironBaseDefinition TCollectionProxyInfo.h:223; ROOT::Detail::TCollectionProxyInfo::EnvironBase::fIdxsize_t fIdxDefinition TCollectionProxyInfo.h:232; ROOT::Detail::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:35744,interface,interface,35744,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['interface'],['interface']
Integrability,"ateOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a 2-D \( \chi^2 \) fit using a series of x ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:16642,interface,interface,16642,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['interface'],['interface']
Integrability,"ateOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables and parameters. ;  ; RooFit::OwningPtr< RooAbsFunc > bindVars (const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) const;  Create an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order). ;  ; virtual std::string buildCallToAnalyticIntegral (Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const;  This function defines the analytical integral translation for the class. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Perform a \( \chi^2 \) fit to given histogram. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataHist &data, const RooLinkedList &cmdList);  Calls RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList) and returns fit result. ;  ; virtual RooFit::OwningPtr< RooFitResult > chi2FitTo (RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={},",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:15649,interface,interface,15649,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,2,['interface'],['interface']
Integrability,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManagerEditor.html:29288,interface,interface,29288,root/html534/TGeoManagerEditor.html,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html,5,['interface'],['interface']
Integrability,"ated itself over z results in a maximum value of 1. To construct such a cdf pass z as argument to the optional nset argument ; Definition at line 2468 of file RooAbsPdf.cxx. ◆ createCdf() [2/2]. RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over; The following named arguments are accepted . Type of CmdArg Effect on CDF . SupNormSet(const RooArgSet&) Observables over which should be normalized in addition to the integration observables . ScanNumCdf() Apply scanning technique if cdf integral involves numeric integration [ default ] . ScanAllCdf() Always apply scanning technique . ScanNoCdf() Never apply scanning technique . ScanParameters(Int_t nbins, Int_t intOrder) Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf . PyROOT; The RooAbsPdf::createCdf() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2490 of file RooAbsPdf.cxx. ◆ createExpectedEventsFunc(). std::unique_ptr< RooAbsReal > RooAbsPdf::createExpectedEventsFunc ; (; const RooArgSet * ; nset); const. virtual . Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ; This is used to build the computation graph for the fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:85573,integrat,integration,85573,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integration']
Integrability,"ated with the plotable object,; it is always 1 for curves. Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Return the number of events associated with the plotable object,; in the given range. It is always 1 for curves. Double_t getFitRangeBinW() const; Get the bin width associated with this plotable object.; It is alwats zero for curves. void printName(ostream& os) const. Print the name of this curve. void printTitle(ostream& os) const; Print the title of this curve. void printClassName(ostream& os) const; Print the class name of this curve. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the details of this curve. Double_t chiSquare(const RooHist& hist, int nFitParam) const; Calculate the chi^2/NDOF of this curve with respect to the histogram; 'hist' accounting nFitParam floating parameters in case the curve; was the result of a fit. Double_t average(Double_t lo, Double_t hi) const; Return average curve value in [xFirst,xLast] by integrating curve between points; and dividing by xLast-xFirst. Int_t findPoint(Double_t value, Double_t tolerance = 1.0E-10) const; Find the nearest point to xvalue. Return -1 if distance; exceeds tolerance. Double_t interpolate(Double_t x, Double_t tolerance = 1.0E-10) const; Return linearly interpolated value of curve at xvalue. If distance; to nearest point is less than tolerance, return nearest point value; instead. RooCurve* makeErrorBand(const vector<RooCurve*>& variations, Double_t Z = 1) const; Construct filled RooCurve represented error band that captures alpha% of the variations; of the curves passed through argument variations, where the percentage alpha corresponds to; the central interval fraction of a significance Z. RooCurve* makeErrorBand(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z = 1) const; Construct filled RooCurve represented error band represent the error added in quadrature defined by the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCurve.html:23343,integrat,integrating,23343,root/html602/RooCurve.html,https://root.cern,https://root.cern/root/html602/RooCurve.html,2,['integrat'],['integrating']
Integrability,"ated with the plotable object,; it is always 1 for curves. Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Return the number of events associated with the plotable object,; in the given range. It is always 1 for curves. Double_t getFitRangeBinW() const; Get the bin width associated with this plotable object.; It is alwats zero for curves. void printName(ostream& os) const. Print the name of this curve. void printTitle(ostream& os) const; Print the title of this curve. void printClassName(ostream& os) const; Print the class name of this curve. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the details of this curve. Double_t chiSquare(const RooHist& hist, int nFitParam) const; Calculate the chi^2/NDOF of this curve with respect to the histogram; 'hist' accounting nFitParam floating parameters in case the curve; was the result of a fit. Double_t average(Double_t lo, Double_t hi) const; Return average curve value in [xFirst,xLast] by integrating curve between points; and dividing by xLast-xFirst. Int_t findPoint(Double_t value, Double_t tolerance = 1e-10) const; Find the nearest point to xvalue. Return -1 if distance; exceeds tolerance. Double_t interpolate(Double_t x, Double_t tolerance = 1e-10) const; Return linearly interpolated value of curve at xvalue. If distance; to nearest point is less than tolerance, return nearest point value; instead. RooCurve* makeErrorBand(const vector<RooCurve*>& variations, Double_t Z = 1) const; Construct filled RooCurve represented error band that captures alpha% of the variations; of the curves passed through argument variations, where the percentage alpha corresponds to; the central interval fraction of a significance Z. RooCurve* makeErrorBand(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z = 1) const; Construct filled RooCurve represented error band represent the error added in quadrature defined by the curve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCurve.html:21762,integrat,integrating,21762,root/html526/RooCurve.html,https://root.cern,https://root.cern/root/html526/RooCurve.html,5,['integrat'],['integrating']
Integrability,"ategory dependents to be integrated. ; Definition at line 939 of file RooRealIntegral.cxx. ◆ translate(). void RooRealIntegral::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 1035 of file RooRealIntegral.cxx. Member Data Documentation. ◆ _anaList. RooSetProxy RooRealIntegral::_anaList. protected . Set of observables over which is integrated/summed analytically. ; Definition at line 119 of file RooRealIntegral.h. ◆ _cacheAllNDim. Int_t RooRealIntegral::_cacheAllNDim. staticprotected . ! Cache all integrals with given numeric dimension ; Definition at line 145 of file RooRealIntegral.h. ◆ _cacheNum. bool RooRealIntegral::_cacheNum = false. protected . Cache integral if numeric. ; Definition at line 144 of file RooRealIntegral.h. ◆ _facList. RooSetProxy RooRealIntegral::_facList. protected . Set of observables on which function does not depends, which are integrated nevertheless. ; Definition at line 121 of file RooRealIntegral.h. ◆ _funcNormSet. std::unique_ptr<RooArgSet> RooRealIntegral::_funcNormSet. protected . Optional normalization set passed to function. ; Definition at line 124 of file RooRealIntegral.h. ◆ _function. RooRealProxy RooRealIntegral::_function. protected . Function being integrated. ; Definition at line 123 of file RooRealIntegral.h. ◆ _iconfig. RooNumIntConfig* RooRealIntegral::_iconfig = nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:75527,integrat,integrated,75527,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['integrat'],['integrated']
Integrability,"ategory reference found in workspace. RooAbsCategoryLValue& asCATLV(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsCategoryLValue reference found in workspace. RooCategory& asCAT(const char* ); CINT constructor interface, return constructor string argument #idx as RooCategory reference found in workspace. RooArgSet asSET(const char* ); CINT constructor interface, return constructor string argument #idx as RooArgSet of objects found in workspace. RooArgList asLIST(const char* ); CINT constructor interface, return constructor string argument #idx as RooArgList of objects found in workspace. RooAbsData& asDATA(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsData object found in workspace. RooDataHist& asDHIST(const char* ); CINT constructor interface, return constructor string argument #idx as RooDataHist object found in workspace. RooDataSet& asDSET(const char* ); CINT constructor interface, return constructor string argument #idx as RooDataSet object found in workspace. TObject& asOBJ(const char* ). const char* asSTRING(const char* ); CINT constructor interface, return constructor string argument #idx as const char*. Int_t asINT(const char* ); CINT constructor interface, return constructor string argument #idx as Int_t. Double_t asDOUBLE(const char* ); CINT constructor interface, return constructor string argument #idx as Double_t. void registerSpecial(const char* typeName, RooFactoryWSTool::IFace* iface); Register foreign special objects in factory. RooFactoryWSTool(RooWorkspace& ws); Constructors, assignment etc. RooWorkspace& ws(); { return *_ws ; }. RooAbsArg& as_ARG(UInt_t idx); --- Internal stuff that must be public so that CINT can access it ---; CINT constructor interface. { checkIndex(idx) ; return _of->_of->asARG(_of->_args[idx].c_str()) ; }. RooAbsPdf& as_PDF(UInt_t idx); { checkIndex(idx) ; return _of->asPDF(_of->_args[idx].c_str()) ; }. RooAbsReal& as_FUNC(UInt_t idx)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:21055,interface,interface,21055,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,2,['interface'],['interface']
Integrability,"ategory reference found in workspace. RooAbsCategoryLValue& asCATLV(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsCategoryLValue reference found in workspace. RooCategory& asCAT(const char* ); CINT constructor interface, return constructor string argument #idx as RooCategory reference found in workspace. RooArgSet asSET(const char* ); CINT constructor interface, return constructor string argument #idx as RooArgSet of objects found in workspace. RooArgList asLIST(const char* ); CINT constructor interface, return constructor string argument #idx as RooArgList of objects found in workspace. RooAbsData& asDATA(const char* ); CINT constructor interface, return constructor string argument #idx as RooAbsData object found in workspace. RooDataHist& asDHIST(const char* ); CINT constructor interface, return constructor string argument #idx as RooDataHist object found in workspace. RooDataSet& asDSET(const char* ); CINT constructor interface, return constructor string argument #idx as RooDataSet object found in workspace. TObject& asOBJ(const char* ). const char* asSTRING(const char* ); CINT constructor interface, return constructor string argument #idx as const char*. Int_t asINT(const char* ); CINT constructor interface, return constructor string argument #idx as Int_t. Double_t asDOUBLE(const char* ); CINT constructor interface, return constructor string argument #idx as Double_t. void registerSpecial(const char* typeName, RooFactoryWSTool::IFace* iface); Register foreign special objects in factory. RooFactoryWSTool* of(). RooFactoryWSTool(RooWorkspace& ws); Constructors, assignment etc. RooWorkspace& ws(); { return *_ws ; }. RooAbsArg& as_ARG(UInt_t idx); --- Internal stuff that must be public so that CINT can access it ---; CINT constructor interface. { checkIndex(idx) ; return of()->of()->asARG(of()->_args[idx].c_str()) ; }. RooAbsPdf& as_PDF(UInt_t idx); { checkIndex(idx) ; return of()->asPDF(of()->_args[idx].c_str()) ; }. Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFactoryWSTool.html:21689,interface,interface,21689,root/html530/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html530/RooFactoryWSTool.html,5,['interface'],['interface']
Integrability,"ategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 359 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2852 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5088 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1079 of file TClingUtils.cxx. ◆ CheckDefaultConstructor(). bool ROOT::TMetaUtils::CheckDefaultConstructor ; (; const clang::CXXRecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Checks if default constructor exists and accessible. ; Definition at line 999 of file TClingUtils.cxx. ◆ CheckIOConstructor(). ROOT::TMetaUtils::EIOCtorCat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:20191,depend,depend,20191,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['depend'],['depend']
Integrability,"ategory. enum class ROOT::TMetaUtils::EIOCtorCategory : short. strong . EnumeratorkAbsent ; kDefault ; kIOPtrType ; kIORefType . Definition at line 382 of file TClingUtils.h. Function Documentation. ◆ AddDefaultParameters(). clang::QualType ROOT::TMetaUtils::AddDefaultParameters ; (; clang::QualType ; instanceType, . const cling::Interpreter & ; interpreter, . const TNormalizedCtxt & ; normCtxt . ). Add any unspecified template parameters to the class template instance, mentioned anywhere in the type. ; Note: this does not strip any typedef but could be merged with cling::utils::Transform::GetPartiallyDesugaredType if we can safely replace TClassEdit::IsStd with a test on the declaring scope and if we can resolve the fact that the added parameter do not take into account possible use/dependences on Double32_t and if we decide that adding the default is the right long term solution or not. Whether it is or not depend on the I/O on whether the default template argument might change or not and whether they (should) affect the on disk layout (for STL containers, we do know they do not). ; Definition at line 2892 of file TClingUtils.cxx. ◆ BeginsWith(). bool ROOT::TMetaUtils::BeginsWith ; (; const std::string & ; theString, . const std::string & ; theSubstring . ). Definition at line 5135 of file TClingUtils.cxx. ◆ CheckConstructor(). ROOT::TMetaUtils::EIOCtorCategory ROOT::TMetaUtils::CheckConstructor ; (; const clang::CXXRecordDecl * ; cl, . const RConstructorType & ; ioctortype, . const cling::Interpreter & ; interp . ). Check if class has constructor of provided type - either default or with single argument. ; Definition at line 1119 of file TClingUtils.cxx. ◆ CheckDefaultConstructor(). bool ROOT::TMetaUtils::CheckDefaultConstructor ; (; const clang::CXXRecordDecl * ; cl, . const cling::Interpreter & ; interp . ). Checks if default constructor exists and accessible. ; Definition at line 1039 of file TClingUtils.cxx. ◆ CheckIOConstructor(). ROOT::TMetaUtils::EIOCtorCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html:20187,depend,depend,20187,doc/master/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TMetaUtils.html,1,['depend'],['depend']
Integrability,"ategory::_typesArray of allowed values; Long_t_userArgs[1]Placeholder for user function arguments; TMethodCall*_userFuncCINT pointer to user function; TString_userFuncNameName of user function; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenCategory(const char* name, const char* title, void* userFunc, RooArgSet& catList); Constructor with pointer to a CINT user mapping function and list of input categories; on which the user mapping function can operate. RooGenCategory(const RooGenCategory& other, const char* name = 0); Copy constructor. void initialize(); Initialization function. ~RooGenCategory(); Destructor. TString evalUserFunc(RooArgSet* vars); Utility function to evaluate (interpreted) user function. void updateIndexList(); Loop over all input state permutations and recalculate the mapped output; state for each input state and store these in the lookup table. evaluate() const; Calculate current value of object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooGenCategory(); Constructors etc. TObject* clone(const char* newname) const; { return new RooGenCategory(*this,newname); }. » Last changed: Tue Mar 10 17:17:03 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:24287,interface,interface,24287,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,1,['interface'],['interface']
Integrability,"ategoryLValue &asymCat, PlotOpt o) constDefinition RooAbsReal.cxx:2199; RooAbsReal::operator==bool operator==(double value) constEquality operator comparing to a double.Definition RooAbsReal.cxx:250; RooAbsReal::evalErrorLoggingModestatic ErrorLoggingMode evalErrorLoggingMode()Return current evaluation error logging mode.Definition RooAbsReal.cxx:4302; RooAbsReal::redirectServersHookbool redirectServersHook(const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) overrideFunction that is called at the end of redirectServers().Definition RooAbsReal.cxx:4474; RooAbsReal::minTrialSamplesvirtual Int_t minTrialSamples(const RooArgSet &) constDefinition RooAbsReal.h:241; RooAbsReal::isValidRealvirtual bool isValidReal(double, bool printError=false) constInterface function to check if given value is a valid value for this object. Returns true unless over...Definition RooAbsReal.h:447; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::syncCachevoid syncCache(const RooArgSet *set=nullptr) overrideDefinition RooAbsReal.h:456; RooAbsReal::printValuevoid printValue(std::ostream &os) const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:41899,integrat,integration,41899,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['integrat'],['integration']
Integrability,"aterial properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “Only” will allow drawing only the edited volume. The check button “Raytrace” will just draw the current selection in solid mode using the ray-tracing algorit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037849,interface,interface,1037849,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"aterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. TGeoManagerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGeoManagerEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManagerEditor.html:1471,interface,interface,1471,root/html528/TGeoManagerEditor.html,https://root.cern,https://root.cern/root/html528/TGeoManagerEditor.html,4,['interface'],['interface']
Integrability,"aterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. virtual~TGeoManagerEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoManagerEditor.html:1471,interface,interface,1471,root/html602/TGeoManagerEditor.html,https://root.cern,https://root.cern/root/html602/TGeoManagerEditor.html,2,['interface'],['interface']
Integrability,"ates plots ;  CTParallelCoordSelectA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolManagerA manager for the sche",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:200476,interface,interface,200476,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['interface'],['interface']
Integrability,"ates plots ;  CTParallelCoordSelectA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPoolPlayer;  CTPoolProcessor;  CT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:175194,interface,interface,175194,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['interface'],['interface']
Integrability,"ates plots ;  CTParallelCoordSelectA TParallelCoordSelect is a specialised TList to hold TParallelCoordRanges used by TParallelCoord ;  CTParallelCoordVarTParallelCoord axes ;  CTParallelMergingFile;  CTParameterNamed parameter, streamable and storable ;  CTParticleDescription of the dynamic properties of a particle ;  CTParticleClassPDGUtility class used internally by TDatabasePDG ;  CTParticlePDGDescription of the static properties of a particle ;  CTPaveA TBox with a bordersize and a shadow option ;  CTPaveClassA TPaveLabel specialized to process classes inside a TClassTree ;  CTPaveLabelA Pave (see TPave) with a text centered in the Pave ;  CTPaveStatsThe histogram statistics painter class ;  CTPaveStatsEditor;  CTPavesTextA PaveText (see TPaveText) with several stacked paves ;  CTPaveTextA Pave (see TPave) with text, lines or/and boxes inside ;  CTPBHandleDSType;  CTPBHistType;  CTPBReadType;  CTPCONA polycone ;  CTPDFInterface to PDF ;  CTPerfEvent;  CTPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTPGONA polygon ;  CTPgSQLResult;  CTPgSQLRow;  CTPgSQLServer;  CTPgSQLStatement;  CTPickerStackGuard;  CTPieDraw a Pie Chart, ;  CTPieEditor;  CTPieSliceA slice of a piechart, see the TPie class ;  CTPieSliceEditor;  CTPluginHandler;  CTPluginManagerThis class implements a plugin library manager ;  CTPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions) ;  CTPoint;  CTPoints2-D graphics point (world coordinates) ;  CTPoints3D;  CTPoints3DABCAbstract class to define Arrays of 3D points ;  CTPointsArray3D;  CTPointSet3DTPolyMarker3D using TPointSet3DGL for direct OpenGL rendering ;  CTPointSet3DGLDirect OpenGL renderer for TPointSet3D ;  CTPolyLineDefined by an array on N points in a 2-D space ;  CTPolyLine3DA 3-dimensional polyline ;  CTPolyLineShape;  CTPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space ;  CTPolyMarker3DA 3D polymarker ;  CTPosixCondition;  CTPosixMutex;  C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:184444,interface,interface,184444,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,3,['interface'],['interface']
Integrability,"ates the complete elliptic integral of the third kind. ;  ; double ROOT::Math::expint (double x);  Calculates the exponential integral. ;  ; double ROOT::Math::hyperg (double a, double b, double c, double x);  Calculates Gauss' hypergeometric function. ;  ; double ROOT::Math::laguerre (unsigned n, double x);  Calculates the Laguerre polynomials. ;  ; double ROOT::Math::lambert_W0 (double x);  Calculates the Lambert W function on branch 0. ;  ; double ROOT::Math::lambert_Wm1 (double x);  Calculates the Lambert W function on branch -1. ;  ; double ROOT::Math::legendre (unsigned l, double x);  Calculates the Legendre polynomials. ;  ; double ROOT::Math::riemann_zeta (double x);  Calculates the Riemann zeta function. ;  ; double ROOT::Math::sph_bessel (unsigned n, double x);  Calculates the spherical Bessel functions of the first kind (also called regular spherical Bessel functions). ;  ; double ROOT::Math::sph_legendre (unsigned l, unsigned m, double theta);  Computes the spherical (normalized) associated Legendre polynomials, or spherical harmonic without azimuthal dependence ( \(e^(im\phi)\)). ;  ; double ROOT::Math::sph_neumann (unsigned n, double x);  Calculates the spherical Bessel functions of the second kind (also called irregular spherical Bessel functions or spherical Neumann functions). ;  ; double ROOT::Math::airy_Ai (double x);  Calculates the Airy function Ai. ;  ; double ROOT::Math::airy_Bi (double x);  Calculates the Airy function Bi. ;  ; double ROOT::Math::airy_Ai_deriv (double x);  Calculates the derivative of the Airy function Ai. ;  ; double ROOT::Math::airy_Bi_deriv (double x);  Calculates the derivative of the Airy function Bi. ;  ; double ROOT::Math::airy_zero_Ai (unsigned int s);  Calculates the zeroes of the Airy function Ai. ;  ; double ROOT::Math::airy_zero_Bi (unsigned int s);  Calculates the zeroes of the Airy function Bi. ;  ; double ROOT::Math::airy_zero_Ai_deriv (unsigned int s);  Calculates the zeroes of the derivative of the Airy functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__SpecFunc.html:4729,depend,dependence,4729,doc/master/group__SpecFunc.html,https://root.cern,https://root.cern/doc/master/group__SpecFunc.html,1,['depend'],['dependence']
Integrability,"ath/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; 13.8 Numerical Integration; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. ROOT::Math::VirtualIntegrator defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in ROOT::Math::VirtualIntegratorOneDim and ROOT::Math::VirtualIntegratorMultiDim. These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance. These methods must be implemented in the concrete classes existing for the different integration algorithms. The user cannot create directly these virtual integrator interfaces. He needs to create the ROOT::Math::IntegratorOneDim class for integrating one-dimensional functions and ROOT::Math::IntegratorMultiDim for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize ROOT::Math::IntegratorOneDim or ROOT::Math::IntegratorMultiDim with any of the concrete integration classes without dealing with them directly. These two classes provide the same interface as in VirtualIntegratorOneDim and VirtualIntegratorMultiDim, but with the possibility to choose in the constructor, which method will be used to perform the integration.; The method to set the function to be integrated, must be of the function interface type described before. ROOT::Math::IBaseFunctionOneDimFunction is used for ROOT::Math::IBaseFunctionMultiDim and The only difference between the ROOT::Math::IntegratorOneDim and ROOT::Math::IntegratorMultiDim resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:700435,integrat,integrating,700435,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['integrat'],['integrating']
Integrability,"ath::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. ROOT::Math::BaseIntegratorOptionsROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions(); voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html:3452,integrat,integrator,3452,root/html602/ROOT__Math__IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html,2,['integrat'],['integrator']
Integrability,"ath::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:2377,interface,interface,2377,root/html534/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html,1,['interface'],['interface']
Integrability,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__Fitter.html:6618,interface,interface,6618,root/html534/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html,1,['interface'],['interface']
Integrability,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:6618,interface,interface,6618,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,1,['interface'],['interface']
Integrability,"ath::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:87; ROOT::Math::PDFIntegral::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:110; ROOT::Math::PDFIntegral::fNormDouble_t fNormDefinition GoFTest.cxx:80; ROOT::Math::PDFIntegral::fPDFconst IGenFunction * fPDFDefinition GoFTest.cxx:82; ROOT::Math::PDFIntegral::fXminDouble_t fXminDefinition GoFTest.cxx:78; ROOT::Math::PDFIntegral::fXmaxDouble_t fXmaxDefinition GoFTest.cxx:79; ROOT::Math::PDFIntegral::~PDFIntegral~PDFIntegral() overrideDefinition GoFTest.cxx:85; ROOT::Math::PDFIntegral::fIntegralIntegratorOneDim fIntegralDefinition GoFTest.cxx:81; ROOT::Math::PDFIntegral::CloneIGenFunction * Clone() const overrideClone a function.Definition GoFTest.cxx:119; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; bool; double; int; ROOT::Math::normal_cdfdouble normal_cdf(double x, double sigma=1, double x0=0)Cumulative distribution function of the normal (Gaussian) distribution (lower tail).Definition ProbFuncMathCore.cxx:234; ROOT::Math::exponential_cdfdouble exponential_cdf(double x, double lambda, double x0=0)Cumulative distribution function of the exponential distribution (lower tail).Definition ProbFuncMathCore.cxx:161; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; F#define F(x, y, z); H#define H(x, y, z); MathNamespace for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GoFTest_8cxx_source.html:45080,wrap,wrap,45080,doc/master/GoFTest_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html,1,['wrap'],['wrap']
Integrability,"ath::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5532,interface,interface,5532,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,1,['interface'],['interface']
Integrability,"ath::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5532,interface,interface,5532,root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,1,['interface'],['interface']
Integrability,"ath::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5532,interface,interface,5532,root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,1,['interface'],['interface']
Integrability,"ath::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5532,interface,interface,5532,root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,1,['interface'],['interface']
Integrability,"ath::WrappedParamFunction< FuncPtr >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ WrappedParamFunction() [1/2]. template<typename FuncPtr = FreeParamMultiFunctionPtr> . ROOT::Math::WrappedParamFunction< FuncPtr >::WrappedParamFunction ; (; FuncPtr ; func, . unsigned int ; dim = 1, . unsigned int ; npar = 0, . double * ; par = nullptr . ). inline . Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters which are set to zero by default. ; Definition at line 52 of file WrappedParamFunction.h. ◆ WrappedParamFunction() [2/2]. template<typename FuncPtr = FreeParamMultiFunctionPtr> . template<class Iterator > . ROOT::Math::WrappedParamFunction< FuncPtr >::WrappedParamFunction ; (; FuncPtr ; func, . unsigned int ; dim, . Iterator ; begin, . Iterator ; end . ). inline . Constructor a wrapped function from a pointer to a callable object, the function dimension and an iterator specifying begin and end of parameters. ; Definition at line 78 of file WrappedParamFunction.h. Member Function Documentation. ◆ Clone(). template<typename FuncPtr = FreeParamMultiFunctionPtr> . IMultiGenFunction * ROOT::Math::WrappedParamFunction< FuncPtr >::Clone ; (; ); const. inlineoverridevirtual . clone the function ; Implements ROOT::Math::IBaseFunctionMultiDimTempl< T >.; Definition at line 96 of file WrappedParamFunction.h. ◆ DoEvalPar(). template<typename FuncPtr = FreeParamMultiFunctionPtr> . double ROOT::Math::WrappedParamFunction< FuncPtr >::DoEvalPar ; (; const double * ; x, . const double * ; p . ); const. inlineoverrideprivatevirtual . evaluate the function given values and parameters (requested interface) ; Implements ROOT::Math::IParametricFunctionMultiDimTempl< double >.; Definition at line 116 of file WrappedParamFunction.h. ◆ NDim(). template<typename FuncPtr = FreeParamMultiFunctionPtr> . unsigned int ROOT::Math::WrappedParamFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunction.html:4224,wrap,wrapped,4224,doc/master/classROOT_1_1Math_1_1WrappedParamFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedParamFunction.html,1,['wrap'],['wrapped']
Integrability,"ath::WrappedTF1& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const; virtual doubleDoParameterDerivative(double x, const double* p, unsigned int ipar) const. Data Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html:2888,wrap,wrapper,2888,root/html528/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html,4,['wrap'],['wrapper']
Integrability,atic . ReturnsName of the file containing the class declaration ; Definition at line 151 of file TUDPSocket.h. ◆ GetBytesRecv(). UInt_t TUDPSocket::GetBytesRecv ; (; ); const. inline . Definition at line 107 of file TUDPSocket.h. ◆ GetBytesSent(). UInt_t TUDPSocket::GetBytesSent ; (; ); const. inline . Definition at line 106 of file TUDPSocket.h. ◆ GetCompressionAlgorithm(). Int_t TUDPSocket::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 155 of file TUDPSocket.h. ◆ GetCompressionLevel(). Int_t TUDPSocket::GetCompressionLevel ; (; ); const. inline . Definition at line 161 of file TUDPSocket.h. ◆ GetCompressionSettings(). Int_t TUDPSocket::GetCompressionSettings ; (; ); const. inline . Definition at line 167 of file TUDPSocket.h. ◆ GetDescriptor(). virtual Int_t TUDPSocket::GetDescriptor ; (; ); const. inlinevirtual . Definition at line 99 of file TUDPSocket.h. ◆ GetErrorCode(). Int_t TUDPSocket::GetErrorCode ; (; ); const. Returns error code. ; Meaning depends on context where it is called. If no error condition returns 0 else a value < 0. For example see TServerSocket ctor. ; Definition at line 1005 of file TUDPSocket.cxx. ◆ GetInetAddress(). TInetAddress TUDPSocket::GetInetAddress ; (; ); const. inline . Definition at line 100 of file TUDPSocket.h. ◆ GetLastUsage(). TTimeStamp TUDPSocket::GetLastUsage ; (; ). inline . Definition at line 116 of file TUDPSocket.h. ◆ GetLocalInetAddress(). TInetAddress TUDPSocket::GetLocalInetAddress ; (; ). virtual . Return internet address of local host to which the socket is bound. ; In case of error TInetAddress::IsValid() returns kFALSE. ; Definition at line 373 of file TUDPSocket.cxx. ◆ GetLocalPort(). Int_t TUDPSocket::GetLocalPort ; (; ). virtual . Return the local port # to which the socket is bound. ; In case of error return -1. ; Definition at line 387 of file TUDPSocket.cxx. ◆ GetOption() [1/2]. Option_t * TUDPSocket::GetOption ; (; ); const. inlineoverrideprivatevirtual . Reimplemented from TObject.; D,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:22753,depend,depends,22753,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['depend'],['depends']
Integrability,"atic Int_t _nameLength;  . #include <RooBinSamplingPdf.h>. Inheritance diagram for RooBinSamplingPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinSamplingPdf() [1/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; ). inline . Definition at line 31 of file RooBinSamplingPdf.h. ◆ RooBinSamplingPdf() [2/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const char * ; name, . const char * ; title, . RooAbsRealLValue & ; observable, . RooAbsPdf & ; inputPdf, . double ; epsilon = 1.E-4 . ). Construct a new RooBinSamplingPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]observableObservable to integrate over (the one that is binned). ; [in]inputPdfA PDF whose bins should be sampled with higher precision. ; [in]epsilonRelative precision for the integrator, which is used to sample the bins. Note that ROOT's default is to use an adaptive integrator, which in its first iteration usually reaches relative precision of 1.E-4 or better. Therefore, asking for lower precision rarely has an effect. . Definition at line 113 of file RooBinSamplingPdf.cxx. ◆ RooBinSamplingPdf() [3/3]. RooBinSamplingPdf::RooBinSamplingPdf ; (; const RooBinSamplingPdf & ; other, . const char * ; name = nullptr . ). Copy a RooBinSamplingPdf. ; Parameters. [in]otherPDF to copy. ; [in]nameOptionally rename the copy. . Definition at line 131 of file RooBinSamplingPdf.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooBinSamplingPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsReal.; Definition at line 60 of file RooBinSamplingPdf.h. ◆ analyticalIntegralWN(). double RooBinSamplingPdf::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName . ); const. inlineoverridevirtual . Forwa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:78600,integrat,integrator,78600,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability,"atic Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TAttImage; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; EImageFileTypes GetFileType (const char *ext);  Return file type depending on specified extension. ;  ; void MapFileTypes (EImageFileTypes &type, UInt_t &astype, Bool_t toas=kTRUE);  Map file type to/from AfterImage types. ;  ; void MapQuality (EImageQuality &quality, UInt_t &asquality, Bool_t toas=kTRUE);  Map quality to/from AfterImage quality. ;  ;  Protected Member Functions inherited from TImage;  TImage ();  ;  TImage (const char *file);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static Bool_t InitVisual ();  Static function to initialize the ASVisual. ;  . Protected Attributes; Bool_t fEditable;  ! kTRUE image can be resized, moved by resizing/moving gPad ;  ; ASImage * fGrayImage;  ! gray image ;  ; ASImage * fImage;  ! pointer to image structure of original image ;  ; Bool_t fIsGray;  ! kTRUE if image is gray",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:26479,depend,depending,26479,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['depend'],['depending']
Integrability,"atic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kygaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kylandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kypol; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFormula(); Default constructor; coverity[UNINIT_CTOR]. RooFormula(const char* name, const char* formula, const RooArgList& varList); Constructor with expression string and list of RooAbsArg variables. RooFormula(const RooFormula& other, const char* name = 0); Copy constructor. Bool_t reCompile(const char* newFormula); Recompile formula with new expression. ~RooFormula(); Destructor. RooArgSet& actualDependents() const; Return list of RooAbsArg dependents that is actually used by formula expression. void dump(); DEBUG: Dump state information. Bool_t changeDependents(const RooAbsCollection& newDeps, Bool_t mustReplaceAll, Bool_t nameChange); Change used variables to those with the same name in given list; If mustReplaceAll is true and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate ROOT::v5::TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to ROOT::v5::TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to ROOT::v5::TFormula. If name passed by ROOT::v5::TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooFormula.html:22308,depend,dependents,22308,root/html604/RooFormula.html,https://root.cern,https://root.cern/root/html604/RooFormula.html,1,['depend'],['dependents']
Integrability,"atic RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedList_configSetsList of configuration sets for individual integration methods; static RooNumGenConfig*_default; RooCategory_method1DSelects integration method for 1D p.d.f.s; RooCategory_method1DCatSelects integration method for 1D p.d.f.s with categories; RooCategory_method1DCondSelects integration method for 1D conditional p.d.f.s; RooCategory_method1DCondCatSelects integration method for 1D conditional p.d.f.s with categories; RooCategory_method2DSelects integration method for 2D p.d.f.s; RooCategory_method2DCatSelects integration method for 2D p.d.f.s with categories; RooCategory_method2DCondSelects integration method for 2D conditional p.d.f.s; RooCategory_method2DCondCatSelects integration method for 2D conditional p.d.f.s with categories; RooCategory_methodNDSelects integration method for ND p.d.f.s; RooCategory_methodNDCatSelects integration method for ND p.d.f.s with categories; RooCategory_methodNDCondSelects integration method for ND conditional p.d.f.s; RooCategory_methodNDCondCatSelects integration method for ND conditional p.d.f.s with categories; static Int_tRooPrintable::_nameLength. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Function called by atexit() handler installed by RooSentinel to; cleanup global objects at end of job. RooNumGenConfig& defaultConfig(); Return reference to instance of default numeric integrator configuration object. RooNumGenConfig(); Constructor. ~RooNumGenConfig(); Destructor. RooNumGenConfig(const RooNumGenConfig& other); Copy constructor. RooNumGenConfig& operator=(const RooNumGenConfig& other); Assignment operator from other RooNumGenConfig. RooCategory& method1D(Bool_t cond, Bool_t cat). RooCategory& method2D(Bool_t cond, Bool_t cat). Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumGenConfig.html:8938,integrat,integration,8938,root/html602/RooNumGenConfig.html,https://root.cern,https://root.cern/root/html602/RooNumGenConfig.html,2,['integrat'],['integration']
Integrability,"atic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1061; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:791; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:961; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::AdoptStreamervoid AdoptStreamer(TMemberStreamer *p)Definition TRealData.cxx:67; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TRealData::SetIsObjectvoid SetIsObject(Bool_t isObject)Definition TRealData.h:57; TRefArray::Classstatic TClass * Class(); TRef::Classstatic TClass * Class(); TStreamerBaseDefinition TStreamerElement.h:150; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:362002,message,message,362002,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['message'],['message']
Integrability,"atic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::GetObjectStatstatic Bool_t GetObjectStat()Get status of object stat flag.Definition TObject.cxx:1067; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPairClass used by TMap to store (key,value) pairs.Definition TMap.h:102; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturns name of object.Definition TRealData.h:52; TRealData::AdoptStreamervoid AdoptStreamer(TMemberStreamer *p)Definition TRealData.cxx:67; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TRealData::SetIsObjectvoid SetIsObject(Bool_t isObject)Definition TRealData.h:57; TRefArray::Classstatic TClass * Class(); TRef::Classstatic TClass * Class(); TStreamerBaseDefinition TStreamerElement.h:150; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:364640,message,message,364640,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['message'],['message']
Integrability,"atic TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TList*fBaseList of base classes; Int_tfCanSplitWhether this class can be split; Long_tfClassPropertyClass C++ properties, see EClassProperties; vector<TDataMember*>fDatacollection of data members; vector<TString>fDepClasseslist of dependent classes; TList*fEnumsList of enums in this scope; Long_tfOffsetStreamerOffset to streamer function; vector<TProtoClass::TProtoRealData>fPRealDataList of TProtoRealData; Long_tfPropertyClass properties, see EProperties; Int_tfSizeofSize of the class; Int_tfStreamerTypeWhich streaming method to use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProtoClass(TClass* cl); Initialize a TProtoClass from a TClass. ~TProtoClass(); Destructor. void Delete(Option_t* opt = """"); Delete the containers that are usually owned by their TClass.; if (fPRealData) fPRealData->Delete(opt);; delete fPRealData; fPRealData = 0;. Bool_t FillTClass(TClass* pcl); Move data from this TProtoClass into cl. Int_t DataMemberIndex(TClass* cl, const char* name). TDataMember * FindDataMember(TClass* cl, Int_t index). TProtoClass(const TProtoClass& ). TProtoClass & operator=(const TProtoClass& ). const char * GetClassName(Int_t index) const; { return (index >= 0) ? fDepClasses[index].Data() : 0; }. TProto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProtoClass.html:6605,depend,dependent,6605,root/html602/TProtoClass.html,https://root.cern,https://root.cern/root/html602/TProtoClass.html,2,['depend'],['dependent']
Integrability,"atic TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_int_.html:39054,integrat,integrator,39054,root/html528/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_int_.html,1,['integrat'],['integrator']
Integrability,"atic bool Dinv (MatRepSym< T, idim > &rhs);  symmetric matrix inversion using Bunch-kaufman pivoting method implementation in Math/MatrixInversion.icc ;  ; template<class MatrixRep > ; static bool Dinv (MatrixRep &rhs);  matrix inversion for a generic square matrix using LU factorization (code originally from CERNLIB and then ported in C++ for CLHEP) implementation is in file Math/MatrixInversion.icc ;  ; template<class T > ; static void InvertBunchKaufman (MatRepSym< T, idim > &rhs, int &ifail);  Bunch-Kaufman method for inversion of symmetric matrices. ;  . #include <Math/Dinv.h>; Member Function Documentation. ◆ DfactMatrix(). template<unsigned int idim, unsigned int n> . template<class T > . int ROOT::Math::Inverter< idim, n >::DfactMatrix ; (; MatRepStd< T, idim, n > & ; rhs, . T & ; det, . unsigned int * ; work . ). static . LU Factorization method for inversion of general square matrices (see implementation in Math/MatrixInversion.icc) ; LU factorization : code originally from CERNLIB dfact routine and ported in C++ for CLHEP. ; Definition at line 447 of file MatrixInversion.icc. ◆ DfinvMatrix(). template<unsigned int idim, unsigned int n> . template<class T > . int ROOT::Math::Inverter< idim, n >::DfinvMatrix ; (; MatRepStd< T, idim, n > & ; rhs, . unsigned int * ; ir . ). static . LU inversion of general square matrices. ; Inversion for General square matrices.; To be called after DFactMatrix (see implementation in Math/MatrixInversion.icc); Code from dfinv routine from CERNLIB Assumed first the LU decomposition via DfactMatrix function; taken from CLHEP : L. Moneta May 2006 ; Definition at line 577 of file MatrixInversion.icc. ◆ Dinv() [1/2]. template<unsigned int idim, unsigned int n = idim> . template<class T > . static bool ROOT::Math::Inverter< idim, n >::Dinv ; (; MatRepSym< T, idim > & ; rhs). inlinestatic . symmetric matrix inversion using Bunch-kaufman pivoting method implementation in Math/MatrixInversion.icc ; Definition at line 98 of file Dinv.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Inverter.html:2272,rout,routine,2272,doc/master/classROOT_1_1Math_1_1Inverter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Inverter.html,1,['rout'],['routine']
Integrability,"atic const char * RooAbsCachedReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 120 of file RooAbsCachedReal.h. ◆ disableCache(). void RooAbsCachedReal::disableCache ; (; bool ; flag). inline . Definition at line 51 of file RooAbsCachedReal.h. ◆ fillCacheObject(). virtual void RooAbsCachedReal::fillCacheObject ; (; FuncCacheElem & ; cache); const. protectedpure virtual . Implemented in RooCachedReal, RooNumCdf, and RooNumRunningInt. ◆ forceAnalyticalInt(). bool RooAbsCachedReal::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 43 of file RooAbsCachedReal.h. ◆ getAnalyticalIntegralWN(). Int_t RooAbsCachedReal::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. ; Reimplemented from RooAbsReal.; Definition at line 306 of file RooAbsCachedReal.cxx. ◆ getCache(). RooAbsCachedReal::FuncCacheElem * RooAbsCachedReal::getCache ; (; const RooArgSet * ; nset); const. protected . Retrieve cache corresponding to observables in nset. ; Definition at line 113 of file RooAbsCachedReal.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedReal::getInterpolationOrder ; (; ); const. inline . Definition at line 38 of file RooAbsCachedReal.h. ◆ getValV(). double RooAbsCachedReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Implementation of getVal() overriding default implementation of RooAbsReal. ; Return value stored in cache p.d.f rather than return value of evaluate() which is undefined for RooAbsCachedReal ; Reimplemented from RooAbsReal.; Definition at line 77 of file RooAbsCachedReal.cxx. ◆ inputBaseName(). virtual const char * RooAbsCachedReal::inputBaseName ; (; ); co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:66008,integrat,integration,66008,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['integrat'],['integration']
Integrability,"atic const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; double lastBinValue () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParametricStepFunction.html:63597,rout,routine,63597,doc/master/classRooParametricStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooParametricStepFunction.html,1,['rout'],['routine']
Integrability,"atic const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TRFunctionImport (const Rcpp::Function &fun);  TRFunctionImport constructor for Rcpp::DataFrame. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Rcpp::Function * f;  . Friends; TRFunctionImport Rcpp::as (SEXP);  ; SEXP Rcpp::wrap (const TRFunctionImport &f);  ; class TRInterface;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TRFunctionImport.h>. Inheritance diagram for ROOT::R::TRFunctionImport:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html:14291,wrap,wrap,14291,doc/master/classROOT_1_1R_1_1TRFunctionImport.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRFunctionImport.html,1,['wrap'],['wrap']
Integrability,"atic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; typedef std::atomic< TListOfEnums * > AListOfEnums_t;  ;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TROOT ();  Only used by Dictionary. ;  ; TListOfFunctions * GetGlobalFunctions ();  Internal routine returning, and creating if necessary, the list of global function. ;  ; void InitInterpreter ();  Initialize interpreter (cling) ;  ; void InitSystem ();  Operating System interface. ;  ; void InitThreads ();  Initialize threads library. ;  ; void * operator new (size_t l);  ; void * operator new (size_t l, void *ptr);  ; void ReadGitInfo ();  Read Git commit SHA1 and branch name. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void RegisterContext (TContext *ctxt);  Register a TContext pointing to this TDirectory object. ;  ; void RegisterGDirectory (SharedGDirectory_t &ptr);  Register a std::atomic<TDirectory*> that will ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:32493,interface,interface,32493,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['interface'],['interface']
Integrability,"atic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; Bool_t fMakeFoldDataSet;  ; UInt_t fNumFolds;  ; std::vector< std::vector< TMVA::Event * > > fTestEvents;  ; std::vector< std::vector< TMVA::Event * > > fTrainEvents;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TMVA::Configu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplit.html:12619,message,message,12619,doc/master/classTMVA_1_1CvSplit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplit.html,1,['message'],['message']
Integrability,"atic std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of Gaussian distribution. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussian.html:59709,rout,routine,59709,doc/master/classRooGaussian.html,https://root.cern,https://root.cern/doc/master/classRooGaussian.html,1,['rout'],['routine']
Integrability,"atic std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of Voigtian distribution. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVoigtian.html:60492,rout,routine,60492,doc/master/classRooVoigtian.html,https://root.cern,https://root.cern/doc/master/classRooVoigtian.html,1,['rout'],['routine']
Integrability,"aticconstexpr . ReturnsVersion of this class ; Definition at line 351 of file RooAbsPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooAbsPdf::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, and RooSimultaneous.; Definition at line 2788 of file RooAbsPdf.cxx. ◆ createCdf() [1/2]. RooFit::OwningPtr< RooAbsReal > RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset = RooArgSet() . ). Create a cumulative distribution function of this p.d.f in terms of the observables listed in iset. ; If no nset argument is given the c.d.f normalization is constructed over the integrated observables, so that its maximum value is precisely 1. It is also possible to choose a different normalization for multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can construct a partial cdf c(x,y) that only when integrated itself over z results in a maximum value of 1. To construct such a cdf pass z as argument to the optional nset argument ; Definition at line 2468 of file RooAbsPdf.cxx. ◆ createCdf() [2/2]. RooAbsPdf::createCdf ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over; The following named arguments are accepted . Type of CmdArg Effect on CDF . SupNormSet(const RooArgSet&) Observables ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:84533,integrat,integrated,84533,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integrated']
Integrability,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPolyVar.html:32920,integrat,integrator,32920,root/html532/RooPolyVar.html,https://root.cern,https://root.cern/root/html532/RooPolyVar.html,1,['integrat'],['integrator']
Integrability,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_int_int_.html:32240,integrat,integrator,32240,root/html526/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_int_int_.html,2,['integrat'],['integrator']
Integrability,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRangeBoolean.html:32635,integrat,integrator,32635,root/html532/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html532/RooRangeBoolean.html,1,['integrat'],['integrator']
Integrability,"atiolikelihood ratio function used to make contours (managed internally); map<string,double>fLowerLimitsmap with cached lower bound values; shared_ptr<ROOT::Math::IMultiGenFunction>fMinFunc! transient pointer to the minimization function; shared_ptr<ROOT::Math::Minimizer>fMinimizer! transient pointer to minimizer class used to find limits and contour; RooArgSetfParametersparameters of interest for this interval; map<string,double>fUpperLimitsmap with cached upper bound values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LikelihoodInterval(const char* name = 0); Default constructor with name and title. LikelihoodInterval(const char* name, RooAbsReal* , const RooArgSet* , RooArgSet* = 0); Alternate constructor taking a pointer to the profile likelihood ratio, parameter of interest and; optionally a snaphot of best parameter of interest for interval. ~LikelihoodInterval(); Destructor. Bool_t IsInInterval(const RooArgSet& ) const; This is the main method to satisfy the RooStats::ConfInterval interface.; It returns true if the parameter point is in the interval. RooArgSet* GetParameters() const; returns list of parameters. Bool_t CheckParameters(const RooArgSet& ) const; check that the parameters are correct. Double_t LowerLimit(const RooRealVar& param, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__LikelihoodInterval.html:9606,interface,interface,9606,root/html602/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__LikelihoodInterval.html,2,['interface'],['interface']
Integrability,"ation ; Definition at line 91 of file TGMsgBox.h. ◆ HandleKey(). Bool_t TGMsgBox::HandleKey ; (; Event_t * ; event). overridevirtual . Handle enter and escape keys (used as Ok and Cancel for now). ; Reimplemented from TGMainFrame.; Definition at line 384 of file TGMsgBox.cxx. ◆ IsA(). TClass * TGMsgBox::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 91 of file TGMsgBox.h. ◆ operator=(). TGMsgBox & TGMsgBox::operator= ; (; const TGMsgBox & ; ). privatedelete . ◆ PMsgBox(). void TGMsgBox::PMsgBox ; (; const char * ; title, . const char * ; msg, . const TGPicture * ; icon, . Int_t ; buttons, . Int_t * ; ret_code, . Int_t ; text_align . ). protected . Protected, common message dialog box initialization. ; Definition at line 118 of file TGMsgBox.cxx. ◆ ProcessMessage(). Bool_t TGMsgBox::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ; parm2 . ). overridevirtual . Process message dialog box event. ; Reimplemented from TGCompositeFrame.; Definition at line 361 of file TGMsgBox.cxx. ◆ Streamer(). void TGMsgBox::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGMainFrame. ◆ StreamerNVirtual(). void TGMsgBox::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 91 of file TGMsgBox.h. Member Data Documentation. ◆ fAppend. TGButton * TGMsgBox::fAppend. protected . Definition at line 58 of file TGMsgBox.h. ◆ fApply. TGButton * TGMsgBox::fApply. protected . buttons in dialog box ; Definition at line 55 of file TGMsgBox.h. ◆ fButtonFrame. TGHorizontalFrame* TGMsgBox::fButtonFrame. protected . frame containing buttons ; Definition at line 60 of file TGMsgBox.h. ◆ fCancel. TGButton * TGMsgBox::fCancel. protected . buttons in dialog box ; Definition at line 56 of file TGMsgBox.h. ◆ fClose. TGButton* TGMsgBox::fClose. protected . Definition at line 57 of file TGMsgBox.h. ◆ fDis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMsgBox.html:41321,message,message,41321,doc/master/classTGMsgBox.html,https://root.cern,https://root.cern/doc/master/classTGMsgBox.html,1,['message'],['message']
Integrability,"ation AddTo(). RooDataSet * read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); Read given list of ascii files, and construct a data set, using the given; ArgList as structure definition. Multiple file names in fileList should be comma separated. Each; file is optionally prefixed with 'commonPath' if such a path is; provided. The arglist specifies the dimensions of the dataset to be built; and describes the order in which these dimensions appear in the; ascii files to be read. Each line in the ascii file should contain N white space separated; tokens, with N the number of args in 'variables'. Any text beyond; N tokens will be ignored with a warning message.; [ NB: This format is written by RooArgList::writeToStream() ]. If the value of any of the variables on a given line exceeds the; fit range associated with that dimension, the entire line will be; ignored. A warning message is printed in each case, unless the; 'Q' verbose option is given. (Option 'D' will provide additional; debugging information) The number of events read and skipped; is always summarized at the end. When multiple files are read, a RooCategory arg in 'variables' can; optionally be designated to hold information about the source file; of each data point. This feature is enabled by giving the name; of the (already existing) category variable in 'indexCatName'. If no further information is given a label name 'fileNNN' will; be assigned to each event, where NNN is the sequential number of; the source file in 'fileList'. Alternatively it is possible to override the default label names; of the index category by specifying them in the fileList string:; When instead of ""file1.txt,file2.txt"" the string; ""file1.txt:FOO,file2.txt:BAR"" is specified, a state named ""FOO""; is assigned to the index category for each event originating from; file1.txt. The labels FOO,BAR may be predefined in the index; category via defineType()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:31055,message,message,31055,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,7,['message'],['message']
Integrability,"ation Documentation. ◆ IntOperMode. enum RooRealIntegral::IntOperMode. protected . EnumeratorHybrid ; Analytic ; PassThrough . Definition at line 92 of file RooRealIntegral.h. Constructor & Destructor Documentation. ◆ RooRealIntegral() [1/3]. RooRealIntegral::RooRealIntegral ; (; ). Definition at line 282 of file RooRealIntegral.cxx. ◆ RooRealIntegral() [2/3]. RooRealIntegral::RooRealIntegral ; (; const char * ; name, . const char * ; title, . const RooAbsReal & ; function, . const RooArgSet & ; depList, . const RooArgSet * ; funcNormSet = nullptr, . const RooNumIntConfig * ; config = nullptr, . const char * ; rangeName = nullptr . ). Construct integral of 'function' over observables in 'depList' in range 'rangeName' with normalization observables 'funcNormSet' (for p.d.f.s). ; In the integral is performed to the maximum extent possible the internal (analytical) integrals advertised by function. The other integrations are performed numerically. The optional config object prescribes how these numeric integrations are configured.; \Note If pdf component selection was globally overridden to always include all components (either with RooAbsReal::globalSelectComp(bool) or a RooAbsReal::GlobalSelectComponentRAII), then any created integral will ignore component selections during its lifetime. This is especially useful when creating normalization or projection integrals. ; Definition at line 300 of file RooRealIntegral.cxx. ◆ RooRealIntegral() [3/3]. RooRealIntegral::RooRealIntegral ; (; const RooRealIntegral & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 710 of file RooRealIntegral.cxx. ◆ ~RooRealIntegral(). RooRealIntegral::~RooRealIntegral ; (; ). override . Definition at line 739 of file RooRealIntegral.cxx. Member Function Documentation. ◆ actualFuncNormSet(). RooArgSet const * RooRealIntegral::actualFuncNormSet ; (; ); const. inlineprotected . Definition at line 112 of file RooRealIntegral.h. ◆ addNumIntDep(). void RooRealIntegr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:64760,integrat,integrations,64760,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['integrat'],['integrations']
Integrability,"ation LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:8963,synchroniz,synchronize,8963,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,2,['synchroniz'],['synchronize']
Integrability,"ation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information .  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgressStatusContainer class for processing statistics ;  CTProofQueryResultTQueryResult version adapted to PROOF neeeds ;  CTProofResources;  CTProofResourcesStaticThe purpose of this class is to provide a standard interface to static config files ;  CTProofServClass providing the PROOF server ;  CTProofServLiteVersion of the PROOF worker server for local running ;  CTProofServLogHandler;  CTProofServLogHandlerGuard;  CTProofSuperMasterImplementation of TProof controlling PROOF federated clusters ;  CTProofVectorContainer;  ►CTProtoClassPersistent version of a TClass ;  CTProtoRealData;  CTPServerSocket;  CTPSocket;  CTPwdCtx;  CTPyArg;  CTPyClassGenerator;  CTPyDispatcher;  CTPyMultiGenFunction;  CTPyMultiGradFunction;  CTPyReturn;  CTPySelector;  ►CTPythia6TPythia is an interface class to F77 version of Pythia 6.2 .  CTPythia6CleanerUtility class to manage the TPythia6 instance ;  CTPythia6DecayerThis class implements the TVirtualMCDecayer interface ;  CTPythia8TPythia8 is an interface class to C++ version of Pythia 8.1 ; event generators, written by T.Sjostrand ;  CTPythi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:205204,interface,interface,205204,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['interface'],['interface']
Integrability,"ation including; 97 ; 98 ; 99 In addition to provide the API for function minimization (via ROOT::Math::Minimizer::Minimize) the Minimizer class provides:; 100 - the interface for setting the function to be minimized. The objective function passed to the Minimizer must implement the multi-dimensional generic interface; 101 ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (e.g. implementing the ROOT::Math::IGradientFunctionMultiDim interface); 102 the gradient will be used by the Minimizer class, when needed. There are convenient classes for the users to wrap their own functions in this required interface for minimization.; 103 These are the `ROOT::Math::Functor` class and the `ROOT::Math::GradFunctor` class for wrapping functions providing both evaluation and gradient. Some methods, like Fumili, Fumili2 and GSLMultiFit are; 104 specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition; 105 the `ROOT::Math::FitMethodFunction` interface.; 106 - The interface for setting the initial values for the function variables (which are the parameters in; 107 of the model function in case of solving for fitting) and specifying their limits.; 108 - The interface to set and retrieve basic minimization parameters. These parameter are controlled by the class `ROOT::Math::MinimizerOptions`.; 109 When no parameters are specified the default ones are used. Specific Minimizer options can also be passed via the `MinimizerOptions` class.; 110 For the list of the available option parameter one must look at the documentation of the corresponding derived class.; 111 - The interface to retrieve the result of minimization ( minimum X values, function value, gradient, error on the minimum, etc...); 112 - The interface to perform a Scan, Hesse or a Contour plot (for the minimizers that support this, i.e. Minuit and Minuit2); 113 ; 114 An example on how to use this interface is the tutoria",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:4272,interface,interface,4272,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['interface'],['interface']
Integrability,"ation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxymsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:42154,integrat,integrator,42154,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,1,['integrat'],['integrator']
Integrability,"ation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:3631,rout,routine,3631,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,3,['rout'],['routine']
Integrability,"ation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctor1DPdfBinding;  CRooFunctorBindingRooCFunction1Binding is a templated implementation of class RooAbsReal that binds generic C(++) functions to a RooAbsReal argument thus allowing generic C++ functions to be used as RooFit functions ;  CRooFunctorPdfBinding;  CRooGammaImplementation of the Gamma PDF for RooFit/RooStats ;  CRooGaussianPlain Gaussian p.d.f ;  CRooGaussKronrodIntegrator1DRooGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooGaussModelClass RooGaussModel implements a RooResolutionModel that models a Gaussian distribution ;  CRooGenContextClass RooGenContext implement a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context ;  CRooGenericPdfRooGenericPdf is a concrete implementation of a probability density function, which takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers ;  CRooGenFitStudyRooGenFitStudy is an abstract base class for RooStudyManager modules ;  CRooGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IGenFunction ;  CRooGenProdProjRooGenProdProj is an auxiliary class for RooProdPdf that calculates a general normalized projection of a product of non-factorizing PDFs, e.g ;  CRooGExpModelClass RooGExpModel is a RooResolutionModel implementation that models a resolution function that is the convolution of a Gaussian with a one-sided exponential ;  CRooGlobalFunc;  CRooGridRooGrid is a utility class for RooMCIntegrator which implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm ;  CRooHashTableRooHashTable implements a hash table for TObjects ;  CRooHistA RooHist is a graphical representation of binned data based on the TGraphAsymm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:99978,integrat,integration,99978,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,6,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"ation set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html:44880,integrat,integrator,44880,root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['integrat'],['integrator']
Integrability,"ation set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFunctorPdfBinding.html:39917,integrat,integrator,39917,root/html530/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html530/RooFunctorPdfBinding.html,1,['integrat'],['integrator']
Integrability,"ation settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:1677,interface,interface,1677,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,6,['interface'],['interface']
Integrability,"ation specific to integrator with given name. void setEpsAbs(Double_t newEpsAbs); Set absolute convergence criteria (convergence if abs(Err)<newEpsAbs). RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const. void setEpsRel(Double_t newEpsRel); Set relative convergence criteria (convergence if abs(Err)/abs(Int)<newEpsRel). void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent = """") const; Detailed printing interface. RooCategory& method1D(); Return selected integration techniques for 1,2,N dimensional integrals. { return _method1D ; }. RooCategory& method2D(); { return _method2D ; }. RooCategory& methodND(); { return _methodND ; }. const RooCategory& method1D() const; { return _method1D ; }. const RooCategory& method2D() const; { return _method2D ; }. const RooCategory& methodND() const; { return _methodND ; }. RooCategory& method1DOpen(); Return selected integration techniques for 1,2,N dimensional open-ended integrals. { return _method1DOpen ; }. RooCategory& method2DOpen(); { return _method2DOpen ; }. RooCategory& methodNDOpen(); { return _methodNDOpen ; }. const RooCategory& method1DOpen() const; { return _method1DOpen ; }. const RooCategory& method2DOpen() const; { return _method2DOpen ; }. const RooCategory& methodNDOpen() const; { return _methodNDOpen ; }. Double_t epsAbs() const; Set/get absolute and relative precision convergence criteria. { return _epsAbs ; }. Double_t epsRel() const; { return _epsRel ; }. Bool_t printEvalCounter() const; Set/get switch that activates printing of number of required; function evaluations for each numeric integration. { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t newVal); { _printEvalCounter = newVal ; }. void Print(Option_t* options = 0) const. » Last changed: Mon Jul 4 15:23:35 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumIntConfig.html:10837,integrat,integration,10837,root/html530/RooNumIntConfig.html,https://root.cern,https://root.cern/root/html530/RooNumIntConfig.html,1,['integrat'],['integration']
Integrability,"ation specific to integrator with given name. void setEpsAbs(Double_t newEpsAbs); Set absolute convergence criteria (convergence if abs(Err)<newEpsAbs). RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const. void setEpsRel(Double_t newEpsRel); Set relative convergence criteria (convergence if abs(Err)/abs(Int)<newEpsRel). void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent = """") const; Detailed printing interface. RooCategory& method1D(); Return selected integration techniques for 1,2,N dimensional integrals. { return _method1D ; }. RooCategory& method2D(); { return _method2D ; }. RooCategory& methodND(); { return _methodND ; }. const RooCategory& method1D() const; { return _method1D ; }. const RooCategory& method2D() const; { return _method2D ; }. const RooCategory& methodND() const; { return _methodND ; }. RooCategory& method1DOpen(); Return selected integration techniques for 1,2,N dimensional open-ended integrals. { return _method1DOpen ; }. RooCategory& method2DOpen(); { return _method2DOpen ; }. RooCategory& methodNDOpen(); { return _methodNDOpen ; }. const RooCategory& method1DOpen() const; { return _method1DOpen ; }. const RooCategory& method2DOpen() const; { return _method2DOpen ; }. const RooCategory& methodNDOpen() const; { return _methodNDOpen ; }. Double_t epsAbs() const; Set/get absolute and relative precision convergence criteria. { return _epsAbs ; }. Double_t epsRel() const; { return _epsRel ; }. Bool_t printEvalCounter() const; Set/get switch that activates printing of number of required; function evaluations for each numeric integration. { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t newVal); { _printEvalCounter = newVal ; }. void Print(Option_t* options = 0) const. » Last changed: Thu Nov 3 20:08:52 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumIntConfig.html:10837,integrat,integration,10837,root/html532/RooNumIntConfig.html,https://root.cern,https://root.cern/root/html532/RooNumIntConfig.html,1,['integrat'],['integration']
Integrability,"ation specific to integrator with given name. void setEpsAbs(Double_t newEpsAbs); Set absolute convergence criteria (convergence if abs(Err)<newEpsAbs). RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const. void setEpsRel(Double_t newEpsRel); Set relative convergence criteria (convergence if abs(Err)/abs(Int)<newEpsRel). void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent = """") const; Detailed printing interface. RooCategory& method1D(); Return selected integration techniques for 1,2,N dimensional integrals. { return _method1D ; }. RooCategory& method2D(); { return _method2D ; }. RooCategory& methodND(); { return _methodND ; }. const RooCategory& method1D() const; { return _method1D ; }. const RooCategory& method2D() const; { return _method2D ; }. const RooCategory& methodND() const; { return _methodND ; }. RooCategory& method1DOpen(); Return selected integration techniques for 1,2,N dimensional open-ended integrals. { return _method1DOpen ; }. RooCategory& method2DOpen(); { return _method2DOpen ; }. RooCategory& methodNDOpen(); { return _methodNDOpen ; }. const RooCategory& method1DOpen() const; { return _method1DOpen ; }. const RooCategory& method2DOpen() const; { return _method2DOpen ; }. const RooCategory& methodNDOpen() const; { return _methodNDOpen ; }. Double_t epsAbs() const; Set/get absolute and relative precision convergence criteria. { return _epsAbs ; }. Double_t epsRel() const; { return _epsRel ; }. Bool_t printEvalCounter() const; Set/get switch that activates printing of number of required; function evaluations for each numeric integration. { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t newVal); { _printEvalCounter = newVal ; }. void Print(Option_t* options = 0) const. » Last changed: Tue Jun 2 15:32:44 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNumIntConfig.html:11862,integrat,integration,11862,root/html604/RooNumIntConfig.html,https://root.cern,https://root.cern/root/html604/RooNumIntConfig.html,1,['integrat'],['integration']
Integrability,"ation that might be; 18891 * of interest to anyone observing a server status. */; 18892 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18893 if (conn->buf == NULL) {; 18894 mg_cry_ctx_internal(; 18895 ctx,; 18896 ""Out of memory: Cannot allocate buffer for worker %i"",; 18897 thread_index);; 18898 return;; 18899 }; 18900 conn->buf_size = (int)ctx->max_request_size;; 18901 ; 18902 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18903 ; 18904 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18905 ; 18906 conn->request_info.user_data = ctx->user_data;; 18907 /* Allocate a mutex for this connection to allow communication both; 18908 * within the request handler and from elsewhere in the application; 18909 */; 18910 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18911 mg_free(conn->buf);; 18912 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18913 return;; 18914 }; 18915 ; 18916#if defined(USE_SERVER_STATS); 18917 conn->conn_state = 1; /* not consumed */; 18918#endif; 18919 ; 18920 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18921 * signal sq_empty condvar to wake up the master waiting in; 18922 * produce_socket() */; 18923 while (consume_socket(ctx, &conn->client, thread_index)) {; 18924 ; 18925 /* New connections must start with new protocol negotiation */; 18926 tls.alpn_proto = NULL;; 18927 ; 18928#if defined(USE_SERVER_STATS); 18929 conn->conn_close_time = 0;; 18930#endif; 18931 conn->conn_birth_time = time(NULL);; 18932 ; 18933 /* Fill in IP, port info early so even if SSL setup below fails,; 18934 * error handler would have the corresponding info.; 18935 * Thanks to Johannes Winkelmann for the patch.; 18936 */; 18937 conn->request_info.remote_port =; 18938 ntohs(USA_IN_PORT_UNSAFE(&conn->client.rsa));; 18939 ; 18940 conn->request_info.server_port =; 18941 ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18942 ; 18943 sockaddr_to_string(conn->request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:563026,protocol,protocol,563026,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['protocol'],['protocol']
Integrability,"ation that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, thread_index)) {; 18925 ; 18926 /* New connections must start with new protocol negotiation */; 18927 tls.alpn_proto = NULL;; 18928 ; 18929#if defined(USE_SERVER_STATS); 18930 conn->conn_close_time = 0;; 18931#endif; 18932 conn->conn_birth_time = time(NULL);; 18933 ; 18934 /* Fill in IP, port info early so even if SSL setup below fails,; 18935 * error handler would have the corresponding info.; 18936 * Thanks to Johannes Winkelmann for the patch.; 18937 */; 18938 conn->request_info.remote_port =; 18939 ntohs(USA_IN_PORT_UNSAFE(&conn->client.rsa));; 18940 ; 18941 conn->request_info.server_port =; 18942 ntohs(USA_IN_PORT_UNSAFE(&conn->client.lsa));; 18943 ; 18944 sockaddr_to_string(conn->request",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:563059,protocol,protocol,563059,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['protocol'],['protocol']
Integrability,"ation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. UChar_tParseStagePriority(Option_t* opt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFileStager.html:6757,interface,interface,6757,root/html602/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html602/TNetXNGFileStager.html,2,['interface'],['interface']
Integrability,"ation->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char *appClassName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:4994,interface,interface,4994,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['interface'],['interface']
Integrability,"ation. If may be given in various forms, specified by mode . mode=kSysErrModeMatrix the histogram sysError corresponds to an alternative response matrix. . mode=kSysErrModeShift the content of the histogram sysError are the absolute shifts of the response matrix . mode=kSysErrModeRelative the content of the histogram sysError specifies the relative uncertainties . Internally, all three cases are transformed to the case mode=kSysErrModeMatrix. ; Definition at line 292 of file TUnfoldSys.cxx. ◆ Class(). static TClass * TUnfoldSys::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUnfoldSys::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUnfoldSys::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 146 of file TUnfoldSys.h. ◆ ClearResults(). void TUnfoldSys::ClearResults ; (; void ; ). overrideprotectedvirtual . Clear all data members which depend on the unfolding results. ; Reimplemented from TUnfold.; Definition at line 650 of file TUnfoldSys.cxx. ◆ DeclFileName(). static const char * TUnfoldSys::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 146 of file TUnfoldSys.h. ◆ DoBackgroundSubtraction(). void TUnfoldSys::DoBackgroundSubtraction ; (; void ; ). protected . perform background subtraction ; This prepares the data members for the base class TUnfold, such that the background is properly taken into account. ; Definition at line 377 of file TUnfoldSys.cxx. ◆ GetBackground(). void TUnfoldSys::GetBackground ; (; TH1 * ; bgrHist, . const char * ; bgrSource = nullptr, . const Int_t * ; binMap = nullptr, . Int_t ; includeError = 3, . Bool_t ; clearHist = kTRUE . ); const. get background into a histogram ; Parameters. [in,out]bgrHisttarget histogram, content and errors will be altered ; [in]bgrSource(default=nullptr) name of backgrond source or zero to add all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:33080,depend,depend,33080,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['depend'],['depend']
Integrability,"ationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nvecgeom;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  Cmg_callbacks;  Cmg_client_options;  Cmg_form_data_handler;  Cmg_option;  ►Cmg_request_info;  Cmg_header;  Cmg_server_ports;  CMultiDistFree functions adapter needed by UNURAN for multidimensional cont distribution ;  CMYSQL_BIND;  CMYSQL_STMT;  CNuMuToNuE_Oscillation;  ►CParamHistFunc;  CCacheElem;  CPassiveKeyGrab;  Cpasswd;  CPattern;  CPgSQL_Stmt_t;  CPictureAttributes_t;  ►CPiecew",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:88580,interface,interface,88580,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['interface'],['interface']
Integrability,"ationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming conv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725054,interface,interface,725054,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"ationZYXRotation class with the (3D) rotation represented by angles describing first a rotation of an angle phi (yaw) about the Z axis, followed by a rotation of an angle theta (pitch) about the Y axis, followed by a third rotation of an angle psi (roll) about the X axis ;  CRowOffsetsStatic structure to keep the conversion from (i,j) to offsets in the storage data for a symmetric matrix ;  CSDeterminantDsfact ;  CSinVariableTransformationSin Transformation class for dealing with double bounded variables ;  CSInverterDsinv ;  CSkipFunction;  CSkipFunction< 0 >;  ►CSMatrixSMatrix: a generic fixed size D1 x D2 Matrix class ;  CSMatrixRow;  CSMatrixRow_const;  CSMatrixIdentity;  CSMatrixNoInit;  CSqrUnary Square Operation Class ;  CSqrtUnary Square Root Operation Class ;  CSqrtLowVariableTransformationSqrt Transformation class for dealing with lower bounded variables ;  CSqrtUpVariableTransformationSqrt Transformation class for dealing with upper bounded variables ;  CStdEngineClass to wrap engines fron the C++ standard random library in the ROOT Random interface ;  CStdEngineType;  CStdEngineType< std::knuth_b >;  CStdEngineType< std::minstd_rand >;  CStdEngineType< std::mt19937 >;  CStdEngineType< std::mt19937_64 >;  CStdEngineType< std::random_device >;  CStdEngineType< std::ranlux24 >;  CStdEngineType< std::ranlux48 >;  CStdRandomEngine;  CSVectorSVector: a generic fixed size Vector class ;  CTDataPoint;  CTDataPointN;  CTensorMulOpClass for Tensor Multiplication (outer product) of two vectors giving a matrix ;  CTRandomEngine;  CTransposeOpClass for Transpose Operations ;  CTranspPolicyMatrix transpose policy ;  CTranspPolicy< T, D1, D2, MatRepSym< T, D1 > >;  CUnaryOpUnaryOperation class A class representing unary operators in the parse tree ;  CVavilovBase class describing a Vavilov distribution ;  CVavilovAccurateClass describing a Vavilov distribution ;  CVavilovAccurateCdfClass describing the Vavilov cdf ;  CVavilovAccuratePdfClass describing the Vavilov pdf ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:57385,wrap,wrap,57385,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,3,['wrap'],['wrap']
Integrability,"ations ; Multi-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes implementing algorithms for multi-dimensional minimization. . Classes; class  ROOT::Math::BasicMinimizer;  Base Minimizer class, which defines the basic functionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MultiMin.html:1113,wrap,wrapper,1113,doc/master/group__MultiMin.html,https://root.cern,https://root.cern/doc/master/group__MultiMin.html,1,['wrap'],['wrapper']
Integrability,"atisfied'. - chi2 - chisquare of the test; - ndf - number of degrees of freedom (important, when both histograms have the same; empty bins); - res - normalized residuals for further analysis. Double_t Chisquare(TF1* f1, Option_t* option = """") const; Compute and return the chisquare of this histogram with respect to a function; The chisquare is computed by weighting each histogram point by the bin error; By default the full range of the histogram is used.; Use option ""R"" for restricting the chisquare calculation to the given range of the function. Double_t ComputeIntegral(Bool_t onlyPositive = false); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1; If the routine is called with the onlyPositive flag set an error will; be produced in case of negative bin content and a NaN value returned. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. TH1 * GetCumulative(Bool_t forward = kTRUE, const char* suffix = ""_cumulative"") const; Return a pointer to an histogram containing the cumulative The; cumulative can be computed both in the forward (default) or backward; direction; the name of the new histogram is constructed from; the name of this histogram with the suffix suffix appended. The cumulative distribution is formed by filling each bin of the; resulting histogram with the sum of that bin and all previous; (forward == kTRUE) or following (forward = kFALSE) bins. note: while cumulative distributions make sense ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:59943,rout,routine,59943,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['rout'],['routine']
Integrability,"atistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  NCocoaTutorials;  ►NDetail;  ►NRDF;  ►NCustomColExtraArgs;  CNone;  CSlot;  CSlotAndEntry;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedCustomColumnA wrapper around a concrete RCustomColumn, which forwards all calls to it RJittedCustomColumn is a placeholder that is put in the collection of custom columns in place of a RCustomColumn that will be just-in-time compiled ;  CRJittedFilterA wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set at a later time, from jitted code ;  ►CRLoopManagerThe head node of a RDF computation graph ;  CTCallback;  CTOneTimeCallback;  CRNodeBaseBase class for non-leaf nodes of the computational graph ;  CRRange;  CRRangeBase;  ►NVecOps;  ►CRAdoptAllocatorRAdoptAllocator can provide a view on already allocated memory ;  Crebind;  ►CRAdoptAllocator< bool >;  Crebind;  C__integer_sequence;  C__make;  C__make< 0 >;  C__make< 1 >;  C__make< 2 >;  C__make< 3 >;  C__make< 4 >;  C__make< 5 >;  C__make< 6 >;  C__make< 7 >;  C__parity;  ►C__parity< 0 >;  C__pmake;  ►C__parity< 1 >;  C__pmake; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:16849,wrap,wrapper,16849,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['wrap'],['wrapper']
Integrability,"ative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); coverity[UNINIT_CTOR]. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Mon Jul 4 15:21:33 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAcceptReject.html:10894,depend,depends,10894,root/html530/RooAcceptReject.html,https://root.cern,https://root.cern/root/html530/RooAcceptReject.html,1,['depend'],['depends']
Integrability,"ative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); coverity[UNINIT_CTOR]. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Sat Sep 5 16:40:00 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAcceptReject.html:10913,depend,depends,10913,root/html534/RooAcceptReject.html,https://root.cern,https://root.cern/root/html534/RooAcceptReject.html,1,['depend'],['depends']
Integrability,"ative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); coverity[UNINIT_CTOR]. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Sat Sep 5 17:28:46 2015 » Last generated: 2015-09-05 17:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAcceptReject.html:12162,depend,depends,12162,root/html604/RooAcceptReject.html,https://root.cern,https://root.cern/root/html604/RooAcceptReject.html,1,['depend'],['depends']
Integrability,"ative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAcceptReject(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); Return a pointer to a generated event. The caller does not own the event and it; will be overwritten by a subsequent call. The input parameter 'remaining' should; contain your best guess at the total number of subsequent events you will request. const RooArgSet * nextAcceptedEvent(); Scan through events in the cache which have not been used yet,; looking for the first accepted one which is added to the specified; container. Return a pointer to the accepted event, or else zero; if we use up the cache before we accept an event. The caller does; not own the event and it will be overwritten by a subsequent call. void addEventToCache(); Add a trial event to our cache and update our estimates; of the function maximum value and integral. Double_t getFuncMax(); Empirically determine maximum value of function by taking a large number; of samples. The actual number depends on the number of dimensions in which; the sampling occurs. RooAcceptReject(); coverity[UNINIT_CTOR]. RooAcceptReject(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. Bool_t canSampleConditional() const; Advertisement of capabilities. { return kTRUE ; }. Bool_t canSampleCategories() const; { return kTRUE ; }. » Last changed: Thu Nov 3 20:06:52 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAcceptReject.html:10894,depend,depends,10894,root/html532/RooAcceptReject.html,https://root.cern,https://root.cern/root/html532/RooAcceptReject.html,1,['depend'],['depends']
Integrability,"atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdClient*fClientHandle to the client object; void*fInitMtxProtects fInitDone, serializes the; Bool_tfIsRootdNature of remote file server; static TFileStager*fgFileStagerStager for IsStaged checks; static Bool_tfgInitDoneAvoid initializing more than once; static Bool_tfgRootdBCControl rootd backward compatibility. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TNetFile. ←; TXNetFile. Function documentation; TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); Create a TXNetFile object. A TXNetFile object is the same as a TNetFile; (from which the former derives) except that the protocol is extended to; support dealing with new xrootd data server or xrootd load balancer; server. The ""url"" argument must be of the form. root://server1:port1[,server2:port2,...,serverN:portN]/pathfile,. Note that this means that multiple servers (>= 1) can be specified in; the url. The connection will try to connect to the first server:port; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options fiel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:26158,protocol,protocol,26158,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,1,['protocol'],['protocol']
Integrability,"ator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or transla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:724539,interface,interface,724539,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['interface'],['interface']
Integrability,"ator code stores event data in the /HEPEVT/ common block Then the default implementation of ImportParticles should suffice. ; The common block /HEPEVT/ is structed like . // C ; typedef struct { ; Int_t nevhep; // Event number ; Int_t nhep; // # of particles ; Int_t isthep[4000]; // Status flag of i'th particle ; Int_t idhep[4000]; // PDG # of particle ; Int_t jmohep[4000][2]; // 1st & 2nd mother particle # ; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle # ; Double_t phep[4000][5]; // 4-momentum and 1 word ; Double_t vhep[4000][4]; // 4-position of production ; } HEPEVT_DEF; ; ; ; C Fortran ; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000), ; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000) ; INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP ; DOUBLE PRECISION PHEP,VHEP ; The generic member functions SetParameter and GetParameter can be overloaded to set and get parameters of the event generator.; Note, if the derived class interfaces a (set of) Fortran common blocks (like TPythia, TVenus does), one better make the derived class a singleton. That is, something like; class MyGenerator : public TGenerator ; { ; public: ; static MyGenerator* Instance() ; { ; if (!fgInstance) fgInstance = new MyGenerator; ; return fgInstance; ; } ; void GenerateEvent() { ... } ; void ImportParticles(TClonesArray* a, Option_t opt="""") {...} ; Int_t ImportParticles(Option_t opt="""") { ... } ; Int_t SetParameter(const char* name, Double_t val) { ... } ; Double_t GetParameter(const char* name) { ... } ; virtual ~MyGenerator() { ... } ; protected: ; MyGenerator() { ... } ; MyGenerator(const MyGenerator& o) { ... } ; MyGenerator& operator=(const MyGenerator& o) { ... } ; static MyGenerator* fgInstance; ; ClassDefOverride(MyGenerator,0); ; }; ; Having multiple objects accessing the same common blocks is not ; safe. . Concrete TGenerator classes can be loaded in scripts and subseqent- ; ly used in compiled code: . // MyRun.h ; class MyRun : public TObject ; { ; public: ; static M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenerator.html:1846,interface,interfaces,1846,doc/master/classTGenerator.html,https://root.cern,https://root.cern/doc/master/classTGenerator.html,1,['interface'],['interfaces']
Integrability,"ator context specific for RooAddPdf PDFs ;  ►CRooAdditionRooAddition calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets ;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdfRooAddPdf is an efficient implementation of a sum of PDFs of the form ;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICRegistryRooAICRegistry is a utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets ;  CRooArgList;  CRooArgProxyRooArgProxy is the abstact interface for RooAbsArg proxy classes ;  CRooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects ;  CRooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape ;  CRooBCPEffDecayPDF describing decay time distribution of B meson including effects of standard model CP violation ;  CRooBCPGenDecayImplement standard CP physics model with S and C (no mention of lambda) Suitably stolen and modified from RooBCPEffDecay ;  CRooBDecayMost general description of B decay time distribution with effects of CP violation, mixing and life time differences ;  CRooBernsteinBernstein basis polynomials are positive-definite in the range [0,1] ;  CRooBifurGaussBifurcated Gaussian p.d.f with different widths on left and right side of maximum value ;  CRooBinIntegratorRooBinIntegrator implements an adaptive one-dimensional numerical integration algorithm ;  CRooBinnedGenContextRooBinnedGenContext is an efficient implementation of the generator context specific for binned pdfs ;  CRooBinningClass RooBinning is an implements RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes ;  CRooBinningCategoryClass RooBinningCategory provides a real-to-catego",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:104085,integrat,integration,104085,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"ator line; TGVerticalFrame Composite frame with vertical child layout; TGVerticalLayout Vertical layout manager; TGView View widget base class; TGViewFrame Frame containing the actual text; TGViewPort Viewport through which to look at a container frame; TGWidget Widget base class; TGWindow GUI Window base class; TGX11 Interface to X11; TGX11TTF Interface to X11 + TTF font handling; TGXYLayout X / Y - layout manager; TGXYLayoutHints Hits for the X / Y - layout manager; TGaxis Graphics axis; TGedEditor ROOT graphics editor; TGedFrame base editor's frame; TGedMarkerPopup marker select popup; TGedMarkerSelect Marker selection button; TGedNameFrame frame showing the selected object name; TGedPatternFrame pattern frame; TGedPatternPopup Color selector popup; TGedPatternSelect pattern selection check-button; TGedPatternSelector select pattern frame; TGedPopup popup window; TGedSelect selection check-button; TGenCollectionProxy ; TGenCollectionProxy::Method ; TGenCollectionProxy::Value ; TGenPhaseSpace Simple Phase Space Generator; TGenerator Event generator interface abstract baseclass; TGenericTable Generic array of C-structure (a'la STL vector); TGenericTable::iterator ; TGeoArb8 arbitrary trapezoid with 8 vertices; TGeoAtt class for visibility, activity and optimization attributes for volumes/nodes; TGeoBBox box primitive; TGeoBBoxEditor TGeoBBox editor; TGeoBatemanSol Solution for the Bateman equation; TGeoBoolNode a boolean node; TGeoBuilder geometry builder singleton; TGeoCacheState class storing the cache state; TGeoChecker a simple geometry checker; TGeoCombiTrans rotation + translation; TGeoCombiTransEditor TGeoCombiTrans editor; TGeoCompositeShape boolean composite shape; TGeoCone conical tube class; TGeoConeEditor TGeoCone editor; TGeoConeSeg conical tube segment class ; TGeoConeSegEditor TGeoConeSeg editor; TGeoCtub cut tube segment class ; TGeoCtubEditor TGeoCtub editor; TGeoDecayChannel Decay channel for Elements; TGeoElemIter Iterator for radionuclide chains.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:81406,interface,interface,81406,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,3,['interface'],['interface']
Integrability,"ator that relies on asymptotic properties of the Profile Likelihood Ratio; the Neyman Construction classes with this class as a test statistic; the Hybrid Calculator class with this class as a test statistic. Function Members (Methods); public:. virtual~ProfileLikelihoodTestStat(); static TClass*Class(); virtual Double_tEvaluate(RooAbsData& data, RooArgSet& paramsOfInterest); virtual const TStringGetVarName() const; virtual TClass*IsA() const; RooStats::TestStatistic&RooStats::TestStatistic::operator=(const RooStats::TestStatistic&); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(RooAbsPdf& pdf); RooStats::ProfileLikelihoodTestStatProfileLikelihoodTestStat(const RooStats::ProfileLikelihoodTestStat&); virtual boolRooStats::TestStatistic::PValueIsRightTail() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. const RooArgSet*fCachedBestFitParams; RooAbsData*fLastData; RooNLLVar*fNll; RooAbsPdf*fPdf; RooProfileLL*fProfile. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodTestStat(); Proof constructor. Do not use. ProfileLikelihoodTestStat(RooAbsPdf& pdf). virtual ~ProfileLikelihoodTestStat(); delete fRand;; delete fTestStatistic;. Double_t Evaluate(RooAbsData& data, RooArgSet& paramsOfInterest); Main interface to evaluate the test statistic on a dataset. const TString GetVarName() const; {return ""Profile Likelihood Ratio"";}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ProfileLikelihoodTestStat.h 36602 2010-11-11 16:52:13Z moneta $ » Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ProfileLikelihoodTestStat.html:2075,interface,interface,2075,root/html528/RooStats__ProfileLikelihoodTestStat.html,https://root.cern,https://root.cern/root/html528/RooStats__ProfileLikelihoodTestStat.html,1,['interface'],['interface']
Integrability,"ator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2010-11-19 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:11185,integrat,integrator,11185,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,2,['integrat'],['integrator']
Integrability,"ator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html:11187,integrat,integrator,11187,root/html530/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IntegratorOneDim.html,2,['integrat'],['integrator']
Integrability,"ator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). » Last changed: root/mathmore:$Id: Integrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:11187,integrat,integrator,11187,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,2,['integrat'],['integrator']
Integrability,"ator(RooNumIntFactory& fact); Register RooSegmentedIntegrator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Mar 10 17:18:58 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSegmentedIntegrator1D.html:8110,integrat,integration,8110,root/html534/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html534/RooSegmentedIntegrator1D.html,1,['integrat'],['integration']
Integrability,"ator1D 1-dimensional numerical integration engine; RooIntegrator2D 2-dimensional numerical integration engine; RooIntegratorBinding Function binding representing output of numeric integrator; RooInvTransform Function binding returning inverse of other function binding; RooJeffreysPrior Sum of RooAbsReal objects; RooKeysPdf One-dimensional non-parametric kernel estimation p.d.f.; RooLandau Landau Distribution PDF; RooLegendre Legendre polynomial; RooLinTransBinning Linear transformation of binning specification; RooLinearVar Lvalue linear transformation function ; RooLinkedList Doubly linked list for storage of RooAbsArg objects; RooLinkedListElem Element of RooLinkedList container class; RooLinkedListIter Iterator for RooLinkedList container class; RooList TList with extra support for Option_t associations; RooListProxy Proxy class for a RooArgList; RooLognormal log-normal PDF; RooMCIntegrator VEGAS based multi-dimensional numerical integration engine; RooMCStudy A general purpose toy Monte Carlo study manager; RooMPSentinel Singleton class that terminate MP server processes when parent exists; RooMapCatEntry Utility class, holding a map expression from a index label regexp to a RooCatType; RooMappedCategory Index variable, derived from another index using pattern-matching based mapping; RooMappedCategory::Entry Map cat entry definition; RooMath math utility routines; RooMinimizer RooFit interface to ROOT::Fit::Fitter; RooMinimizerFcn ; RooMinuit RooFit minimizer based on MINUIT; RooMoment Representation of moment in a RooAbsReal in a given RooRealVar; RooMomentMorph Your description goes here...; RooMsgService RooFit Message Service Singleton class; RooMsgService::StreamConfig ; RooMultiBinomial Simultaneous pdf of N Binomial distributions with associated efficiency functions; RooMultiCatIter Iterator over all state permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:37764,integrat,integration,37764,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,12,"['integrat', 'interface', 'rout']","['integration', 'interface', 'routines']"
Integrability,"ator1D 1-dimensional numerical integration engine; RooIntegrator2D 2-dimensional numerical integration engine; RooIntegratorBinding Function binding representing output of numeric integrator; RooInvTransform Function binding returning inverse of other function binding; RooJeffreysPrior Sum of RooAbsReal objects; RooKeysPdf One-dimensional non-parametric kernel estimation p.d.f.; RooLandau Landau Distribution PDF; RooLegendre Legendre polynomial; RooLinTransBinning Linear transformation of binning specification; RooLinearVar Lvalue linear transformation function; RooLinkedList Doubly linked list for storage of RooAbsArg objects; RooLinkedListElem Element of RooLinkedList container class; RooLinkedListIter Iterator for RooLinkedList container class; RooList TList with extra support for Option_t associations; RooListProxy Proxy class for a RooArgList; RooLognormal log-normal PDF; RooMCIntegrator VEGAS based multi-dimensional numerical integration engine; RooMCStudy A general purpose toy Monte Carlo study manager; RooMPSentinel Singleton class that terminate MP server processes when parent exists; RooMapCatEntry Utility class, holding a map expression from a index label regexp to a RooCatType; RooMappedCategory Index variable, derived from another index using pattern-matching based mapping; RooMappedCategory::Entry Map cat entry definition; RooMath math utility routines; RooMinimizer RooFit interface to ROOT::Fit::Fitter; RooMinimizerFcn ; RooMinuit RooFit minimizer based on MINUIT; RooMoment Representation of moment in a RooAbsReal in a given RooRealVar; RooMomentMorph Your description goes here...; RooMsgService RooFit Message Service Singleton class; RooMsgService::StreamConfig ; RooMultiBinomial Simultaneous pdf of N Binomial distributions with associated efficiency functions; RooMultiCatIter Iterator over all state permutations of a list of categories; RooMultiCategory Product operator for categories; RooMultiGenFunction Export RooAbsReal as functor; RooMultiVarGau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:35880,integrat,integration,35880,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,6,"['integrat', 'interface', 'rout']","['integration', 'interface', 'routines']"
Integrability,"ator1D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator1D(); Constructor. coverity[UNINIT_CTOR]. RooSegmentedIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. Bool_t initialize(); One-time integrator initialization. ~RooSegmentedIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Evaluate integral at given function binding parameter values. RooSegmentedIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); { _useIntegrandLimits = flag ; return kTRUE ; }. Bool_t canIntegrate1D() const; { return kTRUE ; }. Bool_t canIntegrate2D() const; { return kFALSE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Jun 2 15:33:40 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSegmentedIntegrator1D.html:8651,integrat,integration,8651,root/html604/RooSegmentedIntegrator1D.html,https://root.cern,https://root.cern/root/html604/RooSegmentedIntegrator1D.html,1,['integrat'],['integration']
Integrability,"atorBinding: public RooAbsFunc. Function binding representing the output of a RooAbsIntegrator; . Function Members (Methods); public:. RooIntegratorBinding(RooAbsIntegrator& integrator); RooIntegratorBinding(const RooIntegratorBinding&); virtual~RooIntegratorBinding(); static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tgetMaxLimit(UInt_t index) const; virtual Double_tgetMinLimit(UInt_t index) const; virtual const char*RooAbsFunc::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooIntegratorBinding&operator=(const RooIntegratorBinding&); virtual list<Double_t>*RooAbsFunc::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooAbsFunc::restoreXVec() const; virtual voidRooAbsFunc::saveXVec() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_tRooAbsFunc::_dimensionNumber of observables; RooAbsIntegrator*_integratorNumeric integrator; Int_tRooAbsFunc::_ncallFunction call counter; Bool_tRooAbsFunc::_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooIntegratorBinding(RooAbsIntegrator& integrator); {}. virtual ~RooIntegratorBinding(); {}. Double_t operator()(const Double_t* xvector) const; { _ncall++ ; return _integrator->integral(xvector) ; }. Double_t getMinLimit(UInt_t index) const; { return _integrator->integrand()->getMinLimit(index+1); }. Double_t getMaxLimit(UInt_t index) const; { return _integrator->integrand()->getMaxLimit(index+1); }. » Last changed: Mon Dec 7 13:48:04 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegratorBinding.html:1463,integrat,integrator,1463,root/html526/RooIntegratorBinding.html,https://root.cern,https://root.cern/root/html526/RooIntegratorBinding.html,2,['integrat'],['integrator']
Integrability,"atorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooSetProxydepsdependents of this p.d.f; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooSetProxyintobsobservables that p.d.f is integrated over; RooRealProxyintpdfp.d.f that is integrated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProjectedPdf(); Default constructor. RooProjectedPdf(const char* name, const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); Construct projection of input pdf '_intpdf' over observables 'intObs'. RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getValV(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getValF() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:43923,integrat,integrated,43923,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,1,['integrat'],['integrated']
Integrability,"atorOneDim () override;  destructor: no operation ;  ; virtual ROOT::Math::IntegrationOneDim::Type Type () const;  return type of integrator ;  ;  Public Member Functions inherited from ROOT::Math::VirtualIntegrator; virtual ~VirtualIntegrator ();  destructor: no operation ;  . Protected Attributes; int fNum;  Number of points used in the estimation of the integral. ;  ; double * fW;  Weights of the points used. ;  ; double * fX;  Abscisa of the points used. ;  ;  Protected Attributes inherited from ROOT::Math::GaussIntegrator; double fEpsAbs;  Absolute error. ;  ; double fEpsRel;  Relative error. ;  ; const IGenFunction * fFunction;  Pointer to function used. ;  ; double fLastError;  Error from the last estimation. ;  ; double fLastResult;  Result from the last estimation. ;  ; bool fUsedOnce;  Bool value to check if the function was at least called once. ;  . Private Member Functions; void CalcGaussLegendreSamplingPoints ();  Type: unsafe but fast interface filling the arrays x and w (static method) ;  ; double DoIntegral (double a, double b, const IGenFunction *func) override;  Integration surrogate method. ;  . Additional Inherited Members;  Static Protected Attributes inherited from ROOT::Math::GaussIntegrator; static bool fgAbsValue = false;  AbsValue used for the calculation of the integral. ;  . #include <Math/GaussLegendreIntegrator.h>. Inheritance diagram for ROOT::Math::GaussLegendreIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::GaussLegendreIntegrator ; (; int ; num = 10, . double ; eps = 1e-12 . ). Basic constructor of GaussLegendreIntegrator. ; @param num Number of desired points to calculate the integration. @param eps Desired relative error. ; Definition at line 23 of file GaussLegendreIntegrator.cxx. ◆ ~GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::~GaussLegendreInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:4114,interface,interface,4114,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,1,['interface'],['interface']
Integrability,"atorOptions(); voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html:3661,integrat,integrator,3661,root/html602/ROOT__Math__IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html,2,['integrat'],['integrator']
Integrability,"atrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Version_tshort Version_tDefinition RtypesCore.h:65; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; DictFuncPtr_tTClass *(* DictFuncPtr_t)()Definition Rtypes.h:85; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassEdit.h; GetClassTableMutexstatic std::mutex & GetClassTableMutex()Definition TClassTable.cxx:60; gClassTableTClassTable * gClassTableDefinition TClassTable.cxx:47; ClassCompstatic int ClassComp(const void *a, const void *b)Definition TClassTable.cxx:794; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TClass.h; TError.h; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:34918,message,messages,34918,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['message'],['messages']
Integrability,"atrixTSparseTMatrixTSparse()Definition TMatrixTSparse.h:83; It uses SetMatrixArray(..), see below; constructor from Harwell-Boeing (CSR) matrix format TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,; Int_t *rowptr, Int_t *col,Element *data);; It copies input arrays into matrix .; copy constructors; SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data) where it is expected that the irow,icol and data array contain nr entries . Only the entries with non-zero data[i] value are inserted. Be aware that the input data array will be modified inside the routine for doing the necessary sorting of indices !; SetMatrixArray(Int_t nr,Int_t nrows,Int_t ncols,Int_t *irow,; Int_t *icol,Element *data) where it is expected that the irow, icol and data array contain nr entries . It allows to reshape the matrix according to nrows and ncols. Only the entries with non-zero data[i] value are inserted. Be aware that the input data array will be modified inside the routine for doing the necessary sorting of indices !; TMatrixTSparse a(n,m); for(....) { a(i,j) = .... This is a very flexible method but expensive :; if no entry for slot (i,j) is found in the sparse index table it will be entered, which involves some memory management !; before invoking this method in a loop it is smart to first set the index table through a call to SetSparseIndex(..). SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source) the matrix to be inserted at position (row_lwb,col_lwb) can be both dense or sparse . . Definition at line 36 of file TMatrixTSparse.h. Public Types; enum  EMatrixCreatorsOp1 { kZero; , kUnit; , kTransposed; , kAtA; };  ; enum  EMatrixCreatorsOp2 { kMult; , kMultTranspose; , kPlus; , kMinus; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:3946,rout,routine,3946,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['rout'],['routine']
Integrability,"atrixTSym<float> Template of Symmetric Hilbert Matrix class; THistPainter Helper class to draw histograms; THnSparse Interfaces of sparse n-dimensional histogram; THnSparseArrayChunk chunks of linearized bins; THnSparseT<TArrayC> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayD> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayF> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDE One dimensional semi-parametric Kernel Density Estimation; TKDTree<int,double> KD tree; TKDTree<int,float> KD tree; TKDTreeBinning ; TKey Header description of a logical record on file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:96306,interface,interface,96306,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Mon Jul 4 15:21:20 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategory.html:24785,integrat,integration,24785,root/html530/RooAbsCategory.html,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html,1,['integrat'],['integration']
Integrability,"attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Sat Oct 9 22:38:28 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:24663,integrat,integration,24663,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,1,['integrat'],['integration']
Integrability,"attempts to; expand. ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to; expand. void Expand(Int_t newsize, Bool_t copy = kTRUE); Expand (or shrink) the I/O buffer to newsize bytes.; If copy is true (the default), the existing content of the; buffer is preserved, otherwise the buffer is returned zero-ed out. In order to avoid losing data, if the current length is greater than; the requested size, we only shrink down to the current length. TObject * GetParent() const; Return pointer to parent of this buffer. void SetParent(TObject* parent); Set parent owning this buffer. ReAllocCharFun_t GetReAllocFunc() const; Return the reallocation method currently used. void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0); Set which memory reallocation method to use. If reallocafunc is null,; reset it to the defaul value (TStorage::ReAlloc). void SetReadMode(); Set buffer in read mode. void SetWriteMode(); Set buffer in write mode. TClass * GetClass(const type_info& typeinfo); Forward to TROOT::GetClass()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer.html:19585,rout,routine,19585,root/html602/TBuffer.html,https://root.cern,https://root.cern/root/html602/TBuffer.html,2,['rout'],['routine']
Integrability,"attern of histograms used. ;  ; TList * fHistograms;  List of histograms. ;  ; Bool_t fIsUserFunction;  Flag for user defined function. ;  ; Bool_t fIsVerbose;  ; Double_t fMaxAngle;  Max angle for accepting new function. ;  ; Int_t fMaxFuncNV;  fMaxFunctions*fNVariables ;  ; Int_t fMaxFunctions;  max number of functions ;  ; Int_t * fMaxPowers;  [fNVariables] maximum powers ;  ; Int_t * fMaxPowersFinal;  [fNVariables] maximum powers from fit; ;  ; Double_t fMaxQuantity;  Max value of dependent quantity. ;  ; Double_t fMaxResidual;  Max residual value. ;  ; Int_t fMaxResidualRow;  Row giving max residual. ;  ; Int_t fMaxStudy;  max functions to study ;  ; Int_t fMaxTerms;  Max terms expected in final expr. ;  ; TVectorD fMaxVariables;  max value of independent variables ;  ; Double_t fMeanQuantity;  Mean of dependent quantity. ;  ; TVectorD fMeanVariables;  mean value of independent variables ;  ; Double_t fMinAngle;  Min angle for accepting new function. ;  ; Double_t fMinQuantity;  Min value of dependent quantity. ;  ; Double_t fMinRelativeError;  Min relative error accepted. ;  ; Double_t fMinResidual;  Min residual value. ;  ; Int_t fMinResidualRow;  Row giving min residual. ;  ; TVectorD fMinVariables;  min value of independent variables ;  ; Int_t fNCoefficients;  Dimension of model coefficients. ;  ; Int_t fNVariables;  Number of independent variables. ;  ; TVectorD fOrthCoefficients;  The model coefficients. ;  ; TMatrixD fOrthCurvatureMatrix;  Model matrix. ;  ; TVectorD fOrthFunctionNorms;  Norm of the evaluated functions. ;  ; TMatrixD fOrthFunctions;  As above, but orthogonalised. ;  ; Int_t fParameterisationCode;  Exit code of parameterisation. ;  ; EMDFPolyType fPolyType;  Fit object (MINUIT) ;  ; Int_t * fPowerIndex;  [fMaxTerms] Index of accepted powers ;  ; Double_t fPowerLimit;  Control parameter. ;  ; Int_t * fPowers;  [fMaxFuncNV] where fMaxFuncNV = fMaxFunctions*fNVariables ;  ; Double_t fPrecision;  Relative precision of param. ;  ; TVectorD fQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:36400,depend,dependent,36400,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['depend'],['dependent']
Integrability,"attern=0, const char *sourceExt=0);  Collect methods from the source or header file called filename. ;  ; void LocateMethodsInHeaderClassDecl (std::ostream &out);  Given fCurrentClass, look for methods in its header file's class declaration block, and extract documentation to out, while beautifying the header file in parallel. ;  ; void LocateMethodsInHeaderInline (std::ostream &out);  Given fCurrentClass, look for methods in its header file, and extract documentation to out. ;  ; void LocateMethodsInSource (std::ostream &out);  Given fCurrentClass, look for methods in its source file, and extract documentation to out, while beautifying the source file in parallel. ;  ; virtual Bool_t ProcessComment ();  Parse the current line as a comment, handling directives and re-formatting the comment: remove ""/*"", ""*&zwj;/"", ""//"", similar characters surrounding lines, etc. ;  ; void RemoveCommentContext (Bool_t cxxcomment);  remove the top-most comment context that matches cxxcomment, ;  ; void WriteClassDoc (std::ostream &out, Bool_t first=kTRUE);  Write the class description depending (among others) on fClassDocState. ;  ; void WriteMethod (std::ostream &out, TString &ret, TString &name, TString &params, Bool_t isconst, const char *file, TString &anchor, TString &codeOneLiner);  Write a method, forwarding to TClassDocOutput. ;  ; void WriteSourceLine (std::ostream &out);  Write fLineSource to out. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fAllowDirectives;  ; Bool_t fCheckForMethod;  ; TString fClassDescrTag;  ; enum TDocParser:: { ... }  fClassDocState;  ; TString fComment;  ; Bool_t fCommentAtBOL;  ; TClass * fCurrentClass;  ; TString fCurrentFile;  ; TString fCurrentMethodTag;  ; TString fCurrentModule;  ; TList fDataMembers [6];  ; Int_t fDirectiveCount;  ; TList fDirecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:15181,depend,depending,15181,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['depend'],['depending']
Integrability,"attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:42450,integrat,integration,42450,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['integrat'],['integration']
Integrability,"atures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Long_t size, void *arena);  ; typedef void *(* NewFunc_t) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:2900,interface,interface,2900,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['interface'],['interface']
Integrability,"atus of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooSetProxy_varSetNot used anymore?; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:31754,integrat,integrator,31754,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,2,['integrat'],['integrator']
Integrability,"atus of the last Integral calculation ;  . #include <Math/VirtualIntegrator.h>. Inheritance diagram for ROOT::Math::VirtualIntegratorMultiDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~VirtualIntegratorMultiDim(). ROOT::Math::VirtualIntegratorMultiDim::~VirtualIntegratorMultiDim ; (; ). inlineoverride . destructor: no operation ; Definition at line 165 of file VirtualIntegrator.h. Member Function Documentation. ◆ Integral(). virtual double ROOT::Math::VirtualIntegratorMultiDim::Integral ; (; const double * ; , . const double * ;  . ). pure virtual . evaluate multi-dim integral ; Implemented in ROOT::Math::GSLMCIntegrator, and ROOT::Math::AdaptiveIntegratorMultiDim. ◆ Options(). virtual ROOT::Math::IntegratorMultiDimOptions ROOT::Math::VirtualIntegratorMultiDim::Options ; (; ); const. pure virtual . get the option used for the integration implement by derived class otherwise return default ones ; Implemented in ROOT::Math::AdaptiveIntegratorMultiDim, and ROOT::Math::GSLMCIntegrator. ◆ SetFunction(). virtual void ROOT::Math::VirtualIntegratorMultiDim::SetFunction ; (; const IMultiGenFunction & ; ). pure virtual . setting a multi-dim function ; Implemented in ROOT::Math::AdaptiveIntegratorMultiDim, and ROOT::Math::GSLMCIntegrator. ◆ SetOptions(). virtual void ROOT::Math::VirtualIntegratorMultiDim::SetOptions ; (; const ROOT::Math::IntegratorMultiDimOptions & ; opt). inlinevirtual . set the options (if needed must be re-implemented by derived classes) ; Reimplemented in ROOT::Math::AdaptiveIntegratorMultiDim, and ROOT::Math::GSLMCIntegrator.; Definition at line 183 of file VirtualIntegrator.h. ◆ Type(). virtual ROOT::Math::IntegrationMultiDim::Type ROOT::Math::VirtualIntegratorMultiDim::Type ; (; ); const. inlinevirtual . return type of integrator ; Definition at line 178 of file VirtualIntegrator.h. Libraries for ROOT::Math::VirtualIntegratorMultiDim:. [legend]; The documen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1VirtualIntegratorMultiDim.html:3100,integrat,integration,3100,doc/master/classROOT_1_1Math_1_1VirtualIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1VirtualIntegratorMultiDim.html,1,['integrat'],['integration']
Integrability,"atusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TCondor::EStatekFree; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondor.html:6544,interface,interface,6544,root/html602/TCondor.html,https://root.cern,https://root.cern/root/html602/TCondor.html,2,['interface'],['interface']
Integrability,"atusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFoam.html:12343,integrat,integration,12343,root/html602/TFoam.html,https://root.cern,https://root.cern/root/html602/TFoam.html,2,['integrat'],['integration']
Integrability,atusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedList_configSetsList of configuration sets for individual integration methods; static RooNumGenConfig*_default; RooCategory_method1DSelects integration method for 1D p.d.f.s; RooCategory_method1DCatSelects integration method for 1D p.d.f.s with categories; RooCategory_method1DCondSelects integration method for 1D conditional p.d.f.s; RooCategory_method1DCondCatSelects integration method for 1D conditional p.d.f.s with categories; RooCategory_method2DSelects integration method for 2D p.d.f.s; RooCategory_method2DCatSelects integration method for 2D p.d.f.s with categories; RooCategory_method2DCondSelects integration method for 2D conditional p.d.f.s; RooCategory_method2DCondCatSelects integration method for 2D conditional p.d.f.s with categories; RooCategory_methodNDSelects integration method for ND p.d.f.s; RooCategory_methodNDCatSelects integration method for ND p.d.f.s with categories; RooCategory_methodNDCondSelects integration method for ND conditional p.d.f.s; RooCategory_methodNDCondCatSelects integration method for ND conditional p.d.f.s with categories; static Int_tRooPrintable::_nameLength. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentat,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumGenConfig.html:8360,integrat,integration,8360,root/html602/RooNumGenConfig.html,https://root.cern,https://root.cern/root/html602/RooNumGenConfig.html,2,['integrat'],['integration']
Integrability,"atusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TF1::(anonymous)TF1::kNotDraw; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:21063,wrap,wrap,21063,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,1,['wrap'],['wrap']
Integrability,"ault action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual UInt_t GetUniqueID () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveLine.html:26095,message,message,26095,doc/master/classTEveLine.html,https://root.cern,https://root.cern/doc/master/classTEveLine.html,8,['message'],['message']
Integrability,"ault action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual const char * GetTitle () c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPave.html:7980,message,message,7980,doc/master/classTPave.html,https://root.cern,https://root.cern/doc/master/classTPave.html,3,['message'],['message']
Integrability,"ault action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArc.html:6518,message,message,6518,doc/master/classTArc.html,https://root.cern,https://root.cern/doc/master/classTArc.html,14,['message'],['message']
Integrability,"ault action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaletteAxis.html:14012,message,message,14012,doc/master/classTPaletteAxis.html,https://root.cern,https://root.cern/doc/master/classTPaletteAxis.html,1,['message'],['message']
Integrability,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTReal.html:10046,depend,depending,10046,root/html528/TFFTReal.html,https://root.cern,https://root.cern/root/html528/TFFTReal.html,6,['depend'],['depending']
Integrability,"aults.Definition TDirectory.cxx:249; TDirectory::CurrentDirectorystatic std::atomic< TDirectory * > & CurrentDirectory()Return the current directory for the current thread.Definition TDirectory.cxx:432; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::FindObjectAnyvirtual TObject * FindObjectAny(const char *name) constReturn a pointer to the first object with name starting at this folder.Definition TFolder.cxx:343; TFolder::AddFolderTFolder * AddFolder(const char *name, const char *title, TCollection *collection=nullptr)Create a new folder and add it to the list of folders of this folder, return a pointer to the created...Definition TFolder.cxx:182; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TGlobalMappedFunction::GetEarlyRegisteredGlobalsstatic TList & GetEarlyRegisteredGlobals()Returns list collected globals Used to st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:135535,interface,interface,135535,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['interface'],['interface']
Integrability,"aussKronrodIntegrator1D(); Default constructor. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor taking a function binding and a configuration object. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor taking a function binding, an integration range and a configuration object. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor. Bool_t initialize(); Initialize integrator allocate buffers and setup GSL workspace. ~RooAdaptiveGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral at at given parameter values. RooAdaptiveGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); If flag is true, intergration limits are taken from definition in input function binding. Bool_t canIntegrate1D() const; We can integrate 1-dimensional functions. Bool_t canIntegrate2D() const; We can not integrate 2-dimensional functions. Bool_t canIntegrateND() const; We can not integrate >2-dimensional functions. Bool_t canIntegrateOpenEnded() const; We can integrate over open-ended domains. Double_t* xvec(Double_t& xx); Return contents of xx in internal array pointer. » Last changed: Mon Dec 7 13:45:52 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html:9800,integrat,integrate,9800,root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooAdaptiveGaussKronrodIntegrator1D.html,4,['integrat'],['integrate']
Integrability,"aussKronrodIntegrator1D(); Default constructor. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor taking a function binding and a configuration object. RooAdaptiveGaussKronrodIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Constructor taking a function binding, an integration range and a configuration object. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor. Bool_t initialize(); Initialize integrator allocate buffers and setup GSL workspace. ~RooAdaptiveGaussKronrodIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate and return integral at at given parameter values. RooAdaptiveGaussKronrodIntegrator1D(); Constructors, assignment etc. Bool_t setUseIntegrandLimits(Bool_t flag); If flag is true, intergration limits are taken from definition in input function binding. Bool_t canIntegrate1D() const; We can integrate 1-dimensional functions. Bool_t canIntegrate2D() const; We can not integrate 2-dimensional functions. Bool_t canIntegrateND() const; We can not integrate >2-dimensional functions. Bool_t canIntegrateOpenEnded() const; We can integrate over open-ended domains. Double_t* xvec(Double_t& xx); Return contents of xx in internal array pointer. » Last changed: Sat Oct 9 06:58:01 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAdaptiveGaussKronrodIntegrator1D.html:9786,integrat,integrate,9786,root/html528/RooAdaptiveGaussKronrodIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooAdaptiveGaussKronrodIntegrator1D.html,4,['integrat'],['integrate']
Integrability,"aussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; ; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; ; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStats::PdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface.Definition PdfProposal.h:30; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works for future versions. ; Definition at line 30 of file PdfProposal.h. Public Member Functions;  PdfProposal ();  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  PdfProposal (RooAbsPdf &pdf);  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  ~PdfProposal () override;  ; virtual void AddMapping (RooRealVar &proposalParam, RooAbsReal &update);  specify a mapping between a parameter of the proposal function and a parameter of interest. ;  ; virtual const RooAbsPdf * GetPdf () const;  Get the PDF is the proposal density function. ;  ; double GetProposalDensity (RooArgSet &x1, RooArgSet &x2) override;  Return the probability of proposing the point x1 given the starting point ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:1774,interface,interface,1774,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['interface'],['interface']
Integrability,"auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TProcessExecutor pool; auto tenOnes = pool.Map([]() { return 1; }, 10); auto ten = Reduce([](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }, tenOnes); ; Create 10 histograms and merge them into one; root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TExecutorCRTP::Mapauto Map(F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >Execute a function without arguments several times.Definition TExecutorCRTP.hxx:185; ROOT::TExecutorCRTP::ReduceT * Reduce(const std::vector< T * > &mergeObjs)""Reduce"" an std::vector into a single object by using the object's Merge method.Definition TExecutorCRTP.hxx:347; ROOT::TProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel,...Definition TProcessExecutor.hxx:37; ROOT::TProcessExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TProcessExecutor.hxx:262; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3687; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. Definition at line 103 of file TExecutorCRTP.hxx. Public Member Functions;  TExecutorCRTP ()=default;  ;  TExecutorCRTP (const TExecutorCRTP &)=delete;  ; t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html:3814,interface,interface,3814,doc/v632/classROOT_1_1TExecutorCRTP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html,1,['interface'],['interface']
Integrability,"auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TProcessExecutor pool; auto tenOnes = pool.Map([]() { return 1; }, 10); auto ten = Reduce([](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }, tenOnes); ; Create 10 histograms and merge them into one; root[] ROOT::TThreadExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TExecutorCRTP::Mapauto Map(F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >Execute a function without arguments several times.Definition TExecutorCRTP.hxx:185; ROOT::TExecutorCRTP::ReduceT * Reduce(const std::vector< T * > &mergeObjs)""Reduce"" an std::vector into a single object by using the object's Merge method.Definition TExecutorCRTP.hxx:347; ROOT::TProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel,...Definition TProcessExecutor.hxx:37; ROOT::TProcessExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TProcessExecutor.hxx:262; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. Definition at line 103 of file TExecutorCRTP.hxx. Public Member Functions;  TExecutorCRTP ()=default;  ;  TExecutorCRTP (const TExecutorCRTP &)=delete;  ; t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TExecutorCRTP.html:3815,interface,interface,3815,doc/master/classROOT_1_1TExecutorCRTP.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TExecutorCRTP.html,1,['interface'],['interface']
Integrability,"autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; AutoBinned(Bool_t flag) -- Automatically deploy binned generation for binned distributions (e.g. RooHistPdf, sums and products of RooHistPdfs etc); NB: Datasets that are generated in binned mode are returned as weighted unbinned datasets. GenBinned(const char* tag) -- Use binned generation for all component pdfs that have 'setAttribute(tag)' set; AllBinned() -- As above, but for all components. Note that the notion of components is only meaningful for simultaneous pdf; as binned generation is always executed at the top-level node for a regular; pdf, so for those it only mattes that the top-level node is tagged. ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the reques",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:59114,message,messages,59114,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,4,['message'],['messages']
Integrability,"available when ROOT is built with `mathmore` support; 85 ; 86 - Genetic (class ROOT::Math::GeneticMinimizer); 87 ; 88 - RMinimizer (class ROOT::Math::RMinimizer) available when ROOT is built with `r` support; 89 - BFGS (default); 90 - L-BFGS-S; 91 - Nelder-Mead; 92 - CG; 93 - and more methods, see the Details in the documentation of the function `optimix` of the [optmix R package](https://cran.r-project.org/web/packages/optimx/optimx.pdf); 94 ; 95 ; 96 The Minimizer class provides the interface to perform the minimization including; 97 ; 98 ; 99 In addition to provide the API for function minimization (via ROOT::Math::Minimizer::Minimize) the Minimizer class provides:; 100 - the interface for setting the function to be minimized. The objective function passed to the Minimizer must implement the multi-dimensional generic interface; 101 ROOT::Math::IBaseFunctionMultiDim. If the function provides gradient calculation (e.g. implementing the ROOT::Math::IGradientFunctionMultiDim interface); 102 the gradient will be used by the Minimizer class, when needed. There are convenient classes for the users to wrap their own functions in this required interface for minimization.; 103 These are the `ROOT::Math::Functor` class and the `ROOT::Math::GradFunctor` class for wrapping functions providing both evaluation and gradient. Some methods, like Fumili, Fumili2 and GSLMultiFit are; 104 specialized method for least-square and also likelihood minimizations. They require then that the given function implements in addition; 105 the `ROOT::Math::FitMethodFunction` interface.; 106 - The interface for setting the initial values for the function variables (which are the parameters in; 107 of the model function in case of solving for fitting) and specifying their limits.; 108 - The interface to set and retrieve basic minimization parameters. These parameter are controlled by the class `ROOT::Math::MinimizerOptions`.; 109 When no parameters are specified the default ones are used. Specific ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:3690,interface,interface,3690,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['interface'],['interface']
Integrability,"avored); Bool_tfPValueIsRightTail; Double_tfTestStatisticDataresult of the test statistic evaluated on data; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestResult(const char* name = 0); Default constructor. HypoTestResult(const char* name, Double_t nullp, Double_t altp); Alternate constructor. ~HypoTestResult(); Destructor. void Append(const RooStats::HypoTestResult* other); Add additional toy-MC experiments to the current results.; Use the data test statistics of the added object if it is not already; set (otherwise, ignore the new one). void SetAltDistribution(RooStats::SamplingDistribution* alt). void SetNullDistribution(RooStats::SamplingDistribution* null). void SetTestStatisticData(const Double_t tsd). void SetPValueIsRightTail(Bool_t pr). Bool_t HasTestStatisticData(void). Double_t NullPValueError() const; compute error on Null pvalue. Double_t CLbError() const; compute CLb error; Clb = 1 - NullPValue(); must use opposite condition that routine above. Double_t CLsplusbError() const. Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void UpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail); updates the pvalue if sufficient data is available. explicit HypoTestResult(const char* name = 0); default constructor. Double_t NullPValue() const; Return p-value for null hypothesis. { return fNullPValue; }. Double_t AlternatePValue() const; Return p-value for alternate hypothesis. { return fAlternatePValue; }. Double_t CLb() const; Convert NullPValue into a ""confidence level"". { return !fBackgroundIsAlt ? NullPValue() : AlternatePValue(); }. Double_t CLsplusb() const; Convert AlternatePValue into a ""confidence level"". { return !fBackgroundIsAlt ? AlternatePValue() : NullPValue(); }. Double_t CLs() const; CLs is simply CLs+b/CLb (not a method, but a qua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestResult.html:8773,rout,routine,8773,root/html530/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestResult.html,2,['rout'],['routine']
Integrability,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeDrawArgsParser.html:9712,message,message,9712,root/html534/TTreeDrawArgsParser.html,https://root.cern,https://root.cern/root/html534/TTreeDrawArgsParser.html,3,['message'],['message']
Integrability,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id: TTreeDra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeDrawArgsParser.html:9610,message,message,9610,root/html528/TTreeDrawArgsParser.html,https://root.cern,https://root.cern/root/html528/TTreeDrawArgsParser.html,3,['message'],['message']
Integrability,"awing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TEveElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveArrow.html:25904,interface,interface,25904,doc/master/classTEveArrow.html,https://root.cern,https://root.cern/doc/master/classTEveArrow.html,2,['interface'],['interface']
Integrability,"awing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttAxis;  TAttAxis ();  ; virtual ~TAttAxis ();  Destructor. ;  ; void Copy (TAttAxis &attaxis) const;  Copy of the object. ;  ; virtual Color_t GetAxisColor () const;  ; virtual Color_t GetLabelColor () const;  ; virtual Style_t GetLabelFont () const;  ; virtual Float_t GetLabelOffset () const;  ; virtual Float_t GetLabelSize () const;  ; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveProjectionAxes.html:27375,interface,interface,27375,doc/master/classTEveProjectionAxes.html,https://root.cern,https://root.cern/doc/master/classTEveProjectionAxes.html,1,['interface'],['interface']
Integrability,"awing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveProjectable;  TEveProjectable ();  Constructor. ;  ; virtual ~TEveProjectable ();  Destructor. ;  ; virtual void AddProjected (TEveProjected *p);  ; virtual void AddProjectedsToSet (std::set< TEveElement * > &set);  Add the projected elements to the set, dyn-casting them to TEveElement. ;  ; virtual void AnnihilateProjecteds ();  Optimized d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo2D.html:31030,interface,interface,31030,doc/master/classTEveCalo2D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo2D.html,3,['interface'],['interface']
Integrability,"awing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; virtual void ComputeBBox ()=0;  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEveProjectable;  TEveProjectable ();  Constructor. ;  ; virtual ~TEveProjectable ();  Destructor. ;  ; virtual void AddProjected (TEveProjected *p);  ; virtual void AddProjectedsToSet (std::set< TEveElement * > &set);  Add the projected elements to the set, dyn-casting them to TEveElement. ;  ; virtual void Ann",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloViz.html:28610,interface,interface,28610,doc/master/classTEveCaloViz.html,https://root.cern,https://root.cern/doc/master/classTEveCaloViz.html,1,['interface'],['interface']
Integrability,"ax Value for Contour; TGNumberEntry*fScanMinMin Value for Contour; TGComboBox*fScanParParameter for Scan; TGNumberEntry*fScanPointsNumber of points for the graph; TGTab*fTabTab containing the available methods. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAdvancedGraphicsDialog(const TGWindow* p, const TGWindow* main); Creates the Advanced Graphics Dialog. void CreateContourFrame(); Create the frame that contains all the necessary information for; the Contour method. void CreateScanFrame(); Create the frame that contains all the necessary information for; the Scan method. void CreateConfFrame(); Create the frame that contains all the necessary information for; the Confidence Level method. void AddParameters(TGComboBox* ); Add all the parameters of the VirtualFitter into a comboBox; (helper method). void ConnectSlots(); Connect the slots (buttons mainly + specific methods). void DoChangedScanPar(Int_t selected); Changes the Min and Max default values of the scan method,; depending on the selected parameter. void DoDraw(); Calls the correspoding method, depending on the selected tab. void DrawContour(); Generates all necessary data for the Contour method from its; tab. Then it call Virtual Fitter to perform it. void DrawScan(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. void DrawConfidenceLevels(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. ~TAdvancedGraphicsDialog(); Cleanup dialog. TAdvancedGraphicsDialog(const TAdvancedGraphicsDialog& ). TAdvancedGraphicsDialog & operator=(const TAdvancedGraphicsDialog& ). » Author: David Gonzalez Maline 11/12/2008 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAdvancedGraphicsDialog.html:25203,depend,depending,25203,root/html602/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html602/TAdvancedGraphicsDialog.html,1,['depend'],['depending']
Integrability,"ax Value for Contour; TGNumberEntry*fScanMinMin Value for Contour; TGComboBox*fScanParParameter for Scan; TGNumberEntry*fScanPointsNumber of points for the graph; TGTab*fTabTab containing the available methods. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAdvancedGraphicsDialog(const TGWindow* p, const TGWindow* main); Creates the Advanced Graphics Dialog. void CreateContourFrame(); Create the frame that contains all the necessary information for; the Contour method. void CreateScanFrame(); Create the frame that contains all the necessary information for; the Scan method. void CreateConfFrame(); Create the frame that contains all the necessary information for; the Confidence Level method. void AddParameters(TGComboBox* ); Add all the parameters of the VirtualFitter into a comboBox; (helper method). void ConnectSlots(); Connect the slots (buttons mainly + specific methods). void DoChangedScanPar(Int_t selected); Changes the Min and Max default values of the scan method,; depending on the selected parameter. void DoDraw(); Calls the correspoding method, depending on the selected tab. void DrawContour(); Generates all necessary data for the Contour method from its; tab. Then it call Virtual Fitter to perform it. void DrawScan(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. void DrawConfidenceLevels(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. ~TAdvancedGraphicsDialog(); Cleanup dialog. TAdvancedGraphicsDialog(const TAdvancedGraphicsDialog& ). TAdvancedGraphicsDialog & operator=(const TAdvancedGraphicsDialog& ). » Author: David Gonzalez Maline 11/12/2008 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TAdvancedGraphicsDialog.html:25147,depend,depending,25147,root/html604/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html604/TAdvancedGraphicsDialog.html,1,['depend'],['depending']
Integrability,"ax, UInt_t &hmax, UInt_t &winc, UInt_t &hinc) const;  ; EInitialState GetWMState () const;  ; Bool_t HandleButton (Event_t *event) override;  Handle mouse button events. ;  ; Bool_t HandleClientMessage (Event_t *event) override;  Handle client messages sent to this frame. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion events. ;  ; Bool_t HandleSelection (Event_t *event) override;  Handle primary selection event. ;  ; Bool_t HandleSelectionRequest (Event_t *event) override;  Handle selection request event. ;  ; virtual void RemoveBind (const TGWindow *w, Int_t keycode, Int_t modifier) const;  Remove key binding. ;  ; virtual Bool_t SaveFrameAsCodeOrImage ();  Opens dialog window allowing user to save the frame contents as a ROOT macro or as an image. ;  ; virtual Bool_t SaveFrameAsCodeOrImage (const TString &fileName);  Saves the frame contents as a ROOT macro or as an image, depending on the extension of the fileName argument. ;  ; virtual void SendCloseMessage ();  Send close message to self. ;  ; void SetClassHints (const char *className, const char *resourceName);  Set the windows class and resource name. ;  ; void SetIconName (const char *name);  Set window icon name. This is typically done via the window manager. ;  ; void SetIconPixmap (char **xpm_array);  Set window icon by xpm array. ;  ; const TGPicture * SetIconPixmap (const char *iconName);  Set window icon pixmap by name. ;  ; void SetMWMHints (UInt_t value, UInt_t funcs, UInt_t input);  Set decoration style for MWM-compatible wm (mwm, ncdwm, fvwm?). ;  ; void SetWindowName (const char *name=nullptr) override;  Set window name. This is typically done via the window manager. ;  ; void SetWMPosition (Int_t x, Int_t y);  Give the window manager a window position hint. ;  ; void SetWMSize (UInt_t w, UInt_t h);  Give the window manager a window size hint. ;  ; void SetWMSizeHints (UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc);  Give the window manager ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMsgBox.html:4527,message,message,4527,doc/master/classTGMsgBox.html,https://root.cern,https://root.cern/doc/master/classTGMsgBox.html,2,['message'],['message']
Integrability,"aximum number of steps of RooIntegrator1D in the global default configuration; RooAbsPdf::defaultGeneratorConfig()->getConfigSection(""RooAcceptReject"").setRealValue(""nTrial1D"", 2000);; ; // Example of how to change the parameters of a numeric integrator; // (Each config section is a RooArgSet with RooRealVars holding real-valued parameters; // and RooCategories holding parameters with a finite set of options); model.specialGeneratorConfig()->getConfigSection(""RooFoamGenerator"").setRealValue(""chatLevel"", 1);; ; // Generate 10Kevt using RooFoamGenerator (FOAM verbosity increased with above chatLevel adjustment for illustration; // purposes); std::unique_ptr<RooDataSet> data_foam{model.generate(x, 10000, Verbose())};; data_foam->Print();; }; RooArgSet.h; RooChebychev.h; RooDataSet.h; RooNumGenConfig.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAbsCollection::setRealValuebool setRealValue(const char *name, double newVal=0.0, bool verbose=false)Set value of a RooAbsRealLValue stored in set with given name to newVal No error messages are printed...Definition RooAbsCollection.cxx:999; RooAbsPdf::defaultGeneratorConfigstatic RooNumGenConfig * defaultGeneratorConfig()Returns the default numeric MC generator configuration for all RooAbsReals.Definition RooAbsPdf.cxx:2613; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooCategory::setLabelbool setLabel(const char *label, bool printError=true) overrideSet value by specifying the name of the desired state.Definition RooCategory.cxx:186; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooNumGenConfig::method1DRooCategory & method1D(bool cond, bool cat)Definition RooNumGenConfig.cxx:172; RooNumGenConfig::getConfigSectionconst RooArgSet & getConfigSection(const char *name) constRetrieve configuration information specific to integrator with given name.Definition RooNumGenConfig.cxx:288; RooRealVarVariable that can be changed from the outside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf902__numgenconfig_8C.html:3214,message,messages,3214,doc/master/rf902__numgenconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html,1,['message'],['messages']
Integrability,"aximum size of array xp and size of array p ; [out]xparray filled with n quantiles evaluated at p. Memory has to be preallocated by caller. ; [in]parray of cumulative probabilities where quantiles should be evaluated. It is assumed to contain at least n values. . Returnsn, the number of quantiles computed (same as input argument n); Getting quantiles from two histograms and storing results in a TGraph, a so-called QQ-plot TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX(),p);; f2->GetQuantiles(nprob,gr->GetY(),p);; gr->Draw(""alp"");; AuthorEddy Offermann ; WarningFunction leads to undefined behavior if xp or p are null or their size does not match with n ; Definition at line 1994 of file TF1.cxx. ◆ GetRandom() [1/2]. Double_t TF1::GetRandom ; (; Double_t ; xmin, . Double_t ; xmax, . TRandom * ; rng = nullptr, . Option_t * ; option = nullptr . ). virtual . Return a random number following this function shape in [xmin,xmax]. ; The distribution contained in the function fname (TF1) is integrated over the channel contents. It is normalized to 1. For each bin the integral is approximated by a parabola. The parabola coefficients are stored as non persistent data members Getting one random number implies:; Generating a random number between 0 and 1 (say r1); Look in which bin in the normalized integral r1 corresponds to; Evaluate the parabolic curve in the selected bin to find the corresponding X value. The parabolic approximation is very good as soon as the number of bins is greater than 50.; Parameters. xminminimum value for generated random numbers ; xmaxmaximum value for generated random numbers ; rng(optional) random number generator pointer ; option(optional) : LOG or LIN to force the usage of a log or linear scale for computing the cumulative integral table. IMPORTANT NOTE; The integral of the function is computed at fNpx points. If the function has sharp peaks, you should increase the number of points (SetNpx) such that the peak is correctly tabulate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:84006,integrat,integrated,84006,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['integrat'],['integrated']
Integrability,"axis bit range as; following after having called SetRange:; axis->SetRange(1, axis->GetNbins());; axis->SetBit(TAxis::kAxisRange);. void DoFillProfileProjection(TProfile2D* p2, const TAxis& a1, const TAxis& a2, const TAxis& a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const; internal function to fill the bins of the projected profile 2D histogram; called from DoProjectProfile2D. TProfile2D * DoProjectProfile2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool originalRange, bool useUF, bool useOF) const; internal method to project to a 2D Profile; called from TH3::Project3DProfile. TProfile2D * Project3DProfile(Option_t* option = ""xy"") const; Project a 3-d histogram into a 2-d profile histograms depending; on the option parameter; option may contain a combination of the characters x,y,z; option = ""xy"" return the x versus y projection into a TProfile2D histogram; option = ""yx"" return the y versus x projection into a TProfile2D histogram; option = ""xz"" return the x versus z projection into a TProfile2D histogram; option = ""zx"" return the z versus x projection into a TProfile2D histogram; option = ""yz"" return the y versus z projection into a TProfile2D histogram; option = ""zy"" return the z versus y projection into a TProfile2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + ""_p"" + option; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; The following sequence; h->Project3DProfile(""xy"");; h->Project3DProfile(""xy2"");; will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2""; So, passing ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH3.html:45932,depend,depending,45932,root/html532/TH3.html,https://root.cern,https://root.cern/root/html532/TH3.html,1,['depend'],['depending']
Integrability,"axis bit range as; following after having called SetRange:; axis->SetRange(1, axis->GetNbins());; axis->SetBit(TAxis::kAxisRange);. void DoFillProfileProjection(TProfile2D* p2, const TAxis& a1, const TAxis& a2, const TAxis& a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const; internal function to fill the bins of the projected profile 2D histogram; called from DoProjectProfile2D. TProfile2D * DoProjectProfile2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool originalRange, bool useUF, bool useOF) const; internal method to project to a 2D Profile; called from TH3::Project3DProfile. TProfile2D * Project3DProfile(Option_t* option = ""xy"") const; Project a 3-d histogram into a 2-d profile histograms depending; on the option parameter; option may contain a combination of the characters x,y,z; option = ""xy"" return the x versus y projection into a TProfile2D histogram; option = ""yx"" return the y versus x projection into a TProfile2D histogram; option = ""xz"" return the x versus z projection into a TProfile2D histogram; option = ""zx"" return the z versus x projection into a TProfile2D histogram; option = ""yz"" return the y versus z projection into a TProfile2D histogram; option = ""zy"" return the z versus y projection into a TProfile2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + _poption; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; The following sequence; h->Project3DProfile(""xy"");; h->Project3DProfile(""xy2"");; will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2"". NOTE 2: If a profil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:45164,depend,depending,45164,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,2,['depend'],['depending']
Integrability,"axisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetAxisLabelStatusUInt_t GetAxisLabelStatus() constInternal function used in TH1::Fill to see which axis is full alphanumeric, i.e.Definition TH1.cxx:6675; TH1::fIntegralDouble_t * fIntegral! Integral of bins used by GetRandomDefinition TH1.h:111; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::ResetStatsvirtual void ResetStats()Reset the statistics including the number of entries and replace with values calculated from bin cont...Definition TH1.cxx:7902; TH1::SetBuffervirtual void SetBuffer(Int_t buffersize, Option_t *option="""")Set the maximum number of entries to be kept in the buffer.Definition TH1.cxx:8458; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::UpdateBinContentvirtual void UpdateBinContent(Int_t bin, Double_t content)Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin...Definition TH1.cxx:9449; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::fXaxisTAxis fXaxisX axis descriptor.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:196894,rout,routine,196894,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['rout'],['routine']
Integrability,"ay ;  CTRefArrayProxyA container proxy, which allows to access references stored in a TRefArray from TTree::Draw ;  CTRefCntDefinitions for TRefCnt, base class for reference counted objects ;  CTRefProxy;  CTRefTableA TRefTable maintains the association between a referenced object and the parent object supporting this referenced object ;  CTRegexpRegular expression class ;  CTRemoteObjectProtocol for browsing ROOT objects from a remote ROOT session ;  CTResponseTable;  CTRFIOFileA ROOT file that reads/writes via a rfiod server ;  CTRFIOSystemDirectory handler for RFIO ;  Ctriangulateio;  CTRint;  CTRobustEstimator;  CTRolke;  CTROOTROOT top level object description ;  CTRootApplication;  CTRootAuth;  CTRootBrowser;  CTRootBrowserLite;  CTRootCanvas;  CTRootContextMenu;  CTRootControlBar;  CTRootDialog;  CTRootEmbeddedCanvas;  CTRootGuiBuilder;  CTRootGuiFactory;  CTRootHelpDialog;  CTRootIOCtor;  CTRootSecContext;  CTRootSniffer;  CTRootSnifferScanRec;  CTRootSnifferStoreAbstract interface for storage of hierarchy scan in TRootSniffer ;  CTRootSnifferStoreJsonStorage of hierarchy scan in TRootSniffer in JSON format ;  CTRootSnifferStoreXmlStorage of hierarchy scan in TRootSniffer in XML format ;  ►CTRotation;  CTRotationRow;  CTRotMatrixManages a detector rotation matrix ;  CTRSA_fun;  CTRuby;  CTRWLock;  CTS3HTTPRequest;  CTS3WebFile;  CTSapDBResult;  CTSapDBRow;  CTSapDBServer;  CTSAXParserTSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library ;  CTSecContext;  CTSecContextCleanup;  CTSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections ;  CTSelectorCintThis class is a special version of TSelector for user interpreted classes ;  CTSelectorDrawA specialized TSelector for TTree::Draw ;  CTSelectorEntriesThe class is derived from the ROOT class TSelector ;  CTSelectorListA TList derived class that makes sure that objects added to it are not linked to the currently open fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:153037,interface,interface,153037,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['interface'],['interface']
Integrability,"ay or a multi-dimensional array whose last dimension has variable size, return a pointer to the TLeaf that stores such size. ;  ; virtual TLeaf * GetLeafCounter (Int_t &countval) const;  Return a pointer to the counter of this leaf (if any) or store the number of elements that the leaf contains in countval. ;  ; virtual const Counts_t * GetLeafCountValues (Long64_t start, Long64_t len);  If this branch is a branch count, return the set of collection size for the entry range requested start: first entry to read and return information about len: number of entries to read. ;  ; virtual Int_t GetLen () const;  Return the number of effective elements of this leaf, for the current entry. ;  ; virtual Int_t GetLenStatic () const;  Return the fixed length of this leaf. ;  ; virtual Int_t GetLenType () const;  ; virtual Int_t GetNdata () const;  ; virtual Int_t GetOffset () const;  ; template<typename T > ; T GetTypedValue (Int_t i=0) const;  ; virtual bool IsOnTerminalBranch () const;  ; virtual bool IsRange () const;  ; virtual bool IsUnsigned () const;  ; virtual bool ReadBasketSerialized (TBuffer &, Long64_t);  ; Int_t ResetAddress (void *add, bool calledFromDestructor=false);  Helper routine for TLeafX::SetAddress. ;  ; virtual void SetBranch (TBranch *branch);  ; virtual void SetLeafCount (TLeaf *leaf);  Set the leaf count of this leaf. ;  ; virtual void SetLen (Int_t len=1);  ; virtual void SetOffset (Int_t offset=0);  ; virtual void SetRange (bool range=true);  ; virtual void SetUnsigned ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafG.html:4217,rout,routine,4217,doc/master/classTLeafG.html,https://root.cern,https://root.cern/doc/master/classTLeafG.html,2,['rout'],['routine']
Integrability,"ay() [1/2]. template<class Engine > . void TRandomGen< Engine >::RndmArray ; (; Int_t ; n, . Double_t * ; array . ). inlineoverridevirtual . Return an array of n random numbers uniformly distributed in ]0,1]. ; Reimplemented from TRandom.; Definition at line 66 of file TRandomGen.h. ◆ RndmArray() [2/2]. template<class Engine > . void TRandomGen< Engine >::RndmArray ; (; Int_t ; n, . Float_t * ; array . ). inlineoverridevirtual . Return an array of n random numbers uniformly distributed in ]0,1]. ; Reimplemented from TRandom.; Definition at line 63 of file TRandomGen.h. ◆ SetSeed(). template<class Engine > . void TRandomGen< Engine >::SetSeed ; (; ULong_t ; seed = 0). inlineoverridevirtual . Set the random generator seed. ; Note that default value is zero, which is different than the default value used when constructing the class. If the seed is zero the seed is set to a random value which in case of TRandom depends on the lowest 4 bytes of TUUID The UUID will be identical if SetSeed(0) is called with time smaller than 100 ns Instead if a different generator implementation is used (TRandom1, 2 or 3) the seed is generated using a 128 bit UUID. This results in different seeds and then random sequence for every SetSeed(0) call. ; Reimplemented from TRandom.; Definition at line 69 of file TRandomGen.h. ◆ Streamer(). template<class Engine > . void TRandomGen< Engine >::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TRandom. ◆ StreamerNVirtual(). template<class Engine > . void TRandomGen< Engine >::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TRandomGen.h. Member Data Documentation. ◆ fEngine. template<class Engine > . Engine TRandomGen< Engine >::fEngine. protected . Definition at line 52 of file TRandomGen.h. math/mathcore/inc/TRandomGen.h. TRandomGen. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandomGen.html:18274,depend,depends,18274,doc/master/classTRandomGen.html,https://root.cern,https://root.cern/doc/master/classTRandomGen.html,1,['depend'],['depends']
Integrability,"ay.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TClonesArrayfriend class TClonesArrayDefinition TObject.h:240; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::kTransient@ kTransientDefinition TRealData.h:44; TRealData::GetThisOffsetLong_t GetThisOffset() constDefinition TRealData.h:55; TStreamerArtificial::Classstatic TClass * Class(); TStreamerBase::Classstatic TClass * Class(); TStreamerBasicPointerDefinition TStreamerElement.h:198; TStreamerBasicPointer::Classstatic TClass * Class(); TStreamerBasicPointer::GetCountNameconst char * GetCountName() constDefinition TStreamerElement.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:291034,message,message,291034,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['message'],['message']
Integrability,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRefArray.html:1252,message,message,1252,root/html528/TRefArray.html,https://root.cern,https://root.cern/root/html528/TRefArray.html,3,['message'],['message']
Integrability,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. The number of TRef handled by a single process id is limited to; 16777215 (see TRef for more detail). When the TProcessID is full; (has seen 16777215 objects), we switch to new one TProcessID; max",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRefArray.html:1252,message,message,1252,root/html534/TRefArray.html,https://root.cern,https://root.cern/root/html534/TRefArray.html,3,['message'],['message']
Integrability,"ayer(); virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:8147,wrap,wrapperPrefix,8147,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,4,['wrap'],['wrapperPrefix']
Integrability,"ayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregator;  CFeldmanCousins(like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction ;  CFrequentistCalculatorHypothesis Test Calculator using a full frequentist procedure for sampling the test statistic distribution ;  CHeavisideRepresents the Heaviside function ;  CHLFactoryHLFactory is an High Level model Factory allows you to describe your models in a configuration file (datacards) acting as an interface with the RooFactoryWSTool ;  CHybridCalculatorThis class implements the Hypothesis test calculation using an hybrid (frequentist/bayesian) procedure ;  CHybridCalculatorOriginalHybridCalculatorOriginal class ;  CHybridPlotThis class provides the plots for the result of a study performed with the HybridCalculatorOriginal class ;  CHybridResult;  CHypoTestCalculatorHypoTestCalculator is an interface class for a tools which produce RooStats HypoTestResults ;  CHypoTestCalculatorGenericCommon base class for the Hypothesis Test Calculators ;  CHypoTestInverterHypoTestInverter class for performing an hypothesis test inversion by scanning the hypothesis test results of an HypoTestCalculator for various values of the parameter of interest ;  CHypoTestInverterOriginalThis class is now depratcated and to be replaced by the HypoTestInverter ;  CHypoTestInverterPlotClass to plot an HypoTestInverterResult, result of the HypoTestInverter calculator ;  CHypoTestInverterResultHypoTestInverterResu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:4535,interface,interface,4535,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,2,['interface'],['interface']
Integrability,"aying that the method should be overridden in a derived class), which allows a simple partial implementation for new OS'es. ; Definition at line 266 of file TSystem.h. Public Types; enum  EAclicMode { kDefault; , kDebug; , kOpt; };  ; enum  EAclicProperties { kFlatBuildDir = (1ULL << ( 0 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void Abort (int code=0);  Abort the application. ;  ; virtual int AcceptConnection (int sock);  Accept a connection. ;  ; virtual Bool_t AccessPathName (const char *path, EAccessMode mode=kFileExists);  Returns FALSE if one can access a file using the specified access mode. ;  ; virtual void AddDynamicPath (const char *pathname);  Add a new directory to the dynamic path. ;  ; virtual void AddFileHandler (TFileHandler *fh);  Add a file handler to the list of system file handlers. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddSignalHandler (TSignalHandler *sh);  Add a signal handler to list of system signal handlers. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:1743,interface,interface,1743,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['interface'],['interface']
Integrability,"ayout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. TClass(const TClass& tc). TClass& operator=(const TClass& ). void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Bool_t HasDataMemberInfo() const; { return fHasRootPcmInfo || HasInterpreterInfo(); }. Bool_t HasInterpreterInfoInMemory() const; { return 0 != fClassInfo; }. Bool_t HasInterpreterInfo() const; { return fCanLoadClassInfo || fClassInfo; }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. Int_t GetClassSize() const; { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:64121,wrap,wrapper,64121,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['wrap'],['wrapper']
Integrability,"ays for changing the active pad are:. Click the middle mouse button on a pad will set this pad as the active one.; Use the method TCanvas::cd() with the pad number, as was done in the example above:. root[] MyC->cd(3); Pads are numbered from left to right and from top to bottom. Each new pad created by TCanvas::Divide() has a name, which is the name of the canvas followed by _1, _2, etc. To apply the method cd() to the third pad, you would write:; root[] MyC_3->cd(). Third pad will be selected since you called TPad::cd() for the object MyC_3. ROOT will find the pad that was namedMyC_3when you typed it on the command line (see ROOT/Cling Extensions to C++). 2.3.6 Saving the Canvas. The SaveAs… dialog. Using the File menu / Save cascade menu users can save the canvas as one of the files from the list. Please note that saving the canvas this way will overwrite the file with the same name without a warning.; All supported file types can be saved via File menu / SaveAs… This dialog gives a choice to show or suppress the confirmation message for overwriting an existing file.; If the Overwrite check box is not selected, a message dialog appears asking the user to overwrite the file (Yes/No). The user choice is saved for the next time the Save As… dialog shows up.; 2.3.7 Printing the Canvas; The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name. Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; If the %p and %f are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).; 2.4 The ROOT Command Line; We ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:52336,message,message,52336,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['message'],['message']
Integrability,"ays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; bre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:24136,integrat,integrated,24136,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['integrat'],['integrated']
Integrability,"b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8885,interface,interface,8885,root/html534/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html,6,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"b)""); .Histo1D({""h_sig"", """", 100, 0, 1},""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; auto h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)""); .Histo1D({""h_bkg"", """", 100, 0, 1},""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; ; }; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TMVA::Experimental::SOFIE::RModel_Base::PrintGeneratedvoid PrintGenerated()Definition RModel_Base.hxx:86; TMVA::Experimental::SOFIE::RModelDefinition RModel.hxx:12; TMVA::Experimental::SOFIE::RModel::OutputGeneratedvoid OutputGenerated(std::string filename="""", bool append=false)Definition RModel.cxx:1081; TMVA::Experimental::SOFIE::RModel::Generatevoid Generate(std::underlying_type_t< Options > options, int batchSize=-1, long pos=0, bool verbose=false)Definition RModel.cxx:703; TMVA::PyMethodBase::PyInitializestatic void PyInitialize()Initialize Python interpreter.Definition PyMethodBase.cxx:153; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html:3988,interface,interface,3988,doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame__JIT_8C.html,1,['interface'],['interface']
Integrability,"b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:8612,integrat,integration,8612,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,6,['integrat'],['integration']
Integrability,"b, Bool_t quiet = kFALSE);; 486 virtual const char *FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE);; 487 virtual Func_t DynFindSymbol(const char *module, const char *entry);; 488 virtual int Load(const char *module, const char *entry = """", Bool_t system = kFALSE);; 489 virtual void Unload(const char *module);; 490 virtual UInt_t LoadAllLibraries();; 491 virtual void ListSymbols(const char *module, const char *re = """");; 492 virtual void ListLibraries(const char *regexp = """");; 493 virtual const char *GetLibraries(const char *regexp = """",; 494 const char *option = """",; 495 Bool_t isRegexp = kTRUE);; 496 ; 497 //---- RPC; 498 virtual TInetAddress GetHostByName(const char *server);; 499 virtual TInetAddress GetPeerName(int sock);; 500 virtual TInetAddress GetSockName(int sock);; 501 virtual int GetServiceByName(const char *service);; 502 virtual char *GetServiceByPort(int port);; 503 virtual int OpenConnection(const char *server, int port, int tcpwindowsize = -1, const char *protocol = ""tcp"");; 504 virtual int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1);; 505 virtual int AnnounceUdpService(int port, int backlog);; 506 virtual int AnnounceUnixService(int port, int backlog);; 507 virtual int AnnounceUnixService(const char *sockpath, int backlog);; 508 virtual int AcceptConnection(int sock);; 509 virtual void CloseConnection(int sock, Bool_t force = kFALSE);; 510 virtual int RecvRaw(int sock, void *buffer, int length, int flag);; 511 virtual int SendRaw(int sock, const void *buffer, int length, int flag);; 512 virtual int RecvBuf(int sock, void *buffer, int length);; 513 virtual int SendBuf(int sock, const void *buffer, int length);; 514 virtual int SetSockOpt(int sock, int kind, int val);; 515 virtual int GetSockOpt(int sock, int kind, int *val);; 516 ; 517 //---- System, CPU and Memory info; 518 virtual int GetSysInfo(SysInfo_t *info) const;; 519 virtual int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime = 1000) const;; 520 virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:22470,protocol,protocol,22470,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['protocol'],['protocol']
Integrability,"b, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:9096,rout,routine,9096,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,6,['rout'],['routine']
Integrability,"b.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; ROOT::RDF::MakeTrivialDataFrameRInterface< RDFDetail::RLoopManager > MakeTrivialDataFrame()Make a RDF wrapping a RTrivialDS with infinite entries, for demo purposes.Definition RTrivialDS.cxx:130; df010_trivialDataSourceDefinition df010_trivialDataSource.py:1; DateSeptember 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df010_trivialDataSource.C. tutorialsdataframedf010_trivialDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df010__trivialDataSource_8C.html:2139,interface,interface,2139,doc/master/df010__trivialDataSource_8C.html,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html,2,"['interface', 'wrap']","['interface', 'wrapping']"
Integrability,"b::IGenFunction interface . Definition at line 329 of file GSLIntegrator.cxx. ◆ Integral() [3/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const IGenFunction & ; f, . const std::vector< double > & ; pts . ). evaluate the Integral of a function f with known singular points over the defined Integral (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; ptsvector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( a) and last element the upper value. . Definition at line 347 of file GSLIntegrator.cxx. ◆ Integral() [4/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const IGenFunction & ; f, . double ; a, . double ; b . ). evaluate the Integral of a function f over the defined interval (a,b) ; Parameters. fintegration function. The function type must implement the mathlib::IGenFunction interface ; alower value of the integration interval ; bupper value of the integration interval . Definition at line 323 of file GSLIntegrator.cxx. ◆ Integral() [5/9]. double ROOT::Math::GSLIntegrator::Integral ; (; const std::vector< double > & ; pts). overridevirtual . evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. ; The function has known singular points. Parameters. ptsvector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( a) and last element the upper value. . Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 252 of file GSLIntegrator.cxx. ◆ Integral() [6/9]. double ROOT::Math::GSLIntegrator::Integral ; (; double ; a, . double ; b . ). overridevirtual . evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method ; P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:12440,interface,interface,12440,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,3,"['integrat', 'interface']","['integration', 'interface']"
Integrability,"bMatrix is the matrix and vector manipulation; libMathCore contains the core mathematics and physics vector classes; libMathMore contains additional functions, interfacing the GSL math library; libMinuit is the MINUIT fitter; libNet contains functionality related to network transfer; libNew is the special global new/delete, provides extra memory checking and interface for shared memory (optional); libPhysics contains the legacy physics classes (TLorentzVector, etc.); libPostscript is the PostScript interface; libProof is the parallel ROOT Facility classes; libPython provides the interface to Python; *libRFIO is the interface to CERN RFIO remote I/O system.; *libRGL is the interface to OpenGL.; libReflex is the runtime type database library used by Cling; libRint is the interactive interface to ROOT (provides command prompt); libRIO provides the functionality to write and read objects to and from ROOT files; libRooFit is the RooFit fitting framework; libRuby is the interface to Ruby; libSpectrum provides functionality for spectral analysis; *libThread is the interface to TThread classes; libTMVA contains the multivariate analysis toolkit; libTree is the TTree object container system; libTreePlayer is the TTree drawing classes; libTreeViewer is the graphical TTree query interface. 1.6.2.1 Library Dependencies. ROOT libraries dependencies. The libraries are designed and organized to minimize dependencies, such that you can load just enough code for the task at hand rather than having to load all libraries or one monolithic chunk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:19920,interface,interface,19920,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['interface'],['interface']
Integrability,"bName); 2177{; 2178 // If the rootmap file name does not exist, create one following the libname; 2179 // I.E. put into the directory of the lib the rootmap and within the rootmap the normalised path to the lib; 2180 if (rootmapFileName.empty()) {; 2181 size_t libExtensionPos = rootmapLibName.find_last_of(gLibraryExtension) - gLibraryExtension.size() + 1;; 2182 rootmapFileName = rootmapLibName.substr(0, libExtensionPos) + "".rootmap"";; 2183 size_t libCleanNamePos = rootmapLibName.find_last_of(gPathSeparator) + 1;; 2184 rootmapLibName = rootmapLibName.substr(libCleanNamePos, std::string::npos);; 2185 ROOT::TMetaUtils::Info(nullptr, ""Rootmap file name %s built from rootmap lib name %s"",; 2186 rootmapLibName.c_str(),; 2187 rootmapFileName.c_str());; 2188 }; 2189}; 2190 ; 2191////////////////////////////////////////////////////////////////////////////////; 2192/// Extract the proper autoload key for nested classes; 2193/// The routine does not erase the name, just updates it; 2194 ; 2195void GetMostExternalEnclosingClassName(const clang::DeclContext &theContext,; 2196 std::string &ctxtName,; 2197 const cling::Interpreter &interpreter,; 2198 bool treatParent = true); 2199{; 2200 const clang::DeclContext *outerCtxt = treatParent ? theContext.getParent() : &theContext;; 2201 // If the context has no outer context, we are finished; 2202 if (!outerCtxt) return;; 2203 // If the context is a class, we update the name; 2204 if (const clang::RecordDecl *thisRcdDecl = llvm::dyn_cast<clang::RecordDecl>(outerCtxt)) {; 2205 ROOT::TMetaUtils::GetNormalizedName(ctxtName, thisRcdDecl, interpreter);; 2206 }; 2207 // We recurse; 2208 GetMostExternalEnclosingClassName(*outerCtxt, ctxtName, interpreter);; 2209}; 2210 ; 2211////////////////////////////////////////////////////////////////////////////////; 2212 ; 2213void GetMostExternalEnclosingClassNameFromDecl(const clang::Decl &theDecl,; 2214 std::string &ctxtName,; 2215 const cling::Interpreter &interpreter); 2216{; 2217 const clang::Decl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:86906,rout,routine,86906,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['rout'],['routine']
Integrability,"bString attributes; Bool_tRooAbsCategory::_treeVar! do not persist; TIterator*RooAbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCategory(). RooCategory(const char* name, const char* title); Constructor. Types must be defined using defineType() before variable can be used. RooCategory(const RooCategory& other, const char* name = 0); Copy constructor. ~RooCategory(); Destructor. Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Set value by specifying the index code of the desired state.; If printError is set, a message will be printed if; the specified index does not represent a valid state. Bool_t setLabel(const char* label, Bool_t printError = kTRUE); Set value by specifying the name of the desired state; If printError is set, a message will be printed if; the specified label does not represent a valid state. Bool_t defineType(const char* label); Define a state with given name, the lowest available; positive integer is assigned as index. Category; state labels may not contain semicolons.; Error status is return if state with given name; is already defined. Bool_t defineType(const char* label, Int_t index); Define a state with given name and index. Category; state labels may not contain semicolons; Error status is return if state with given name; or index is already defined. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void writeToStream(ostream& os, Bool_t compact) const; compact only at the moment. void clearRange(const char* name, Bool_t silent)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:22611,message,message,22611,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,6,['message'],['message']
Integrability,"bWinparent widgets; Int_tfWidWindows Id of the Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:4828,wrap,wrapper,4828,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,3,['wrap'],['wrapper']
Integrability,"b] x [col_lwb..col_upb]); 1047 ; 1048template <class Element>; 1049TMatrixT<Element> &TMatrixT<Element>::Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Element *data); 1050{; 1051 if (gMatrixCheck) {; 1052 if (row_upb < row_lwb) {; 1053 Error(""Use"", ""row_upb=%d < row_lwb=%d"", row_upb, row_lwb);; 1054 return *this;; 1055 }; 1056 if (col_upb < col_lwb) {; 1057 Error(""Use"", ""col_upb=%d < col_lwb=%d"", col_upb, col_lwb);; 1058 return *this;; 1059 }; 1060 }; 1061 ; 1062 Clear();; 1063 this->fNrows = row_upb - row_lwb + 1;; 1064 this->fNcols = col_upb - col_lwb + 1;; 1065 this->fRowLwb = row_lwb;; 1066 this->fColLwb = col_lwb;; 1067 this->fNelems = this->fNrows * this->fNcols;; 1068 fElements = data;; 1069 this->fIsOwner = kFALSE;; 1070 ; 1071 return *this;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; 1076/// returned matrix depends on the argument option:; 1077///; 1078/// option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); 1079/// else : return [row_lwb..row_upb][col_lwb..col_upb]; 1080 ; 1081template <class Element>; 1082TMatrixTBase<Element> &TMatrixT<Element>::GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb,; 1083 TMatrixTBase<Element> &target, Option_t *option) const; 1084{; 1085 if (gMatrixCheck) {; 1086 R__ASSERT(this->IsValid());; 1087 if (row_lwb < this->fRowLwb || row_lwb > this->fRowLwb + this->fNrows - 1) {; 1088 Error(""GetSub"", ""row_lwb out of bounds"");; 1089 return target;; 1090 }; 1091 if (col_lwb < this->fColLwb || col_lwb > this->fColLwb + this->fNcols - 1) {; 1092 Error(""GetSub"", ""col_lwb out of bounds"");; 1093 return target;; 1094 }; 1095 if (row_upb < this->fRowLwb || row_upb > this->fRowLwb + this->fNrows - 1) {; 1096 Error(""GetSub"", ""row_upb out of bounds"");; 1097 return target;; 1098 }; 1099 if (col_upb < this->fColLwb || col_upb > this->fColLwb + th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:37532,depend,depends,37532,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['depend'],['depends']
Integrability,"backs; on local port 'port'; if port is already in use scan up to 'scan - 1'; ports starting from port + 1, i.e. port + 1, ... , port + scan - 1. ~TApplicationRemote(); Destructor. Int_t Broadcast(const TMessage& mess); Broadcast a message to the remote session.; Returns 0 on success, -1 in case of error. Int_t Broadcast(const char* mess, Int_t kind = kMESS_STRING, Int_t type = kRRT_Undef); Broadcast a character string buffer to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Broadcast an object to the remote session.; Use kind to set the TMessage what field.; Returns 0 on success, -1 in case of error. Int_t BroadcastRaw(const void* buffer, Int_t length); Broadcast a raw buffer of specified length to the remote session.; Returns 0 on success, -1 in case of error. Int_t Collect(Long_t timeout = -1); Collect responses from the remote server.; Returns the number of messages received.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:14577,message,messages,14577,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,7,['message'],['messages']
Integrability,"balSelectComp(). void RooAbsReal::globalSelectComp ; (; bool ; flag). staticprotected . Global switch controlling the activation of the selectComp() functionality. ; Definition at line 2966 of file RooAbsReal.cxx. ◆ gradient(). virtual void RooAbsReal::gradient ; (; double * ; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 388 of file RooAbsReal.h. ◆ hasGradient(). virtual bool RooAbsReal::hasGradient ; (; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 387 of file RooAbsReal.h. ◆ hideOffset(). bool RooAbsReal::hideOffset ; (; ). static . Definition at line 192 of file RooAbsReal.cxx. ◆ integralNameSuffix(). TString RooAbsReal::integralNameSuffix ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const char * ; rangeName = nullptr, . bool ; omitEmpty = false . ); const. protected . Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ; Definition at line 755 of file RooAbsReal.cxx. ◆ IsA(). TClass * RooAbsReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooStats::HistFactory::RooBarlowBeestonLL, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1, VI2, VI3, VI4 >, RooChebychev, RooChiSquarePdf, RooCrystalBall, RooDecay, RooDstD0BG, RooExponential, RooFunctor1DBinding, RooFunctor1DPdfBinding, RooFunctorBinding, RooFunctorPdfBinding, RooGamma, RooGaussian",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:115537,integrat,integrated,115537,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,['integrat'],"['integrated', 'integration']"
Integrability,"balSelectComp(). void RooAbsReal::globalSelectComp ; (; bool ; flag). staticprotected . Global switch controlling the activation of the selectComp() functionality. ; Definition at line 3051 of file RooAbsReal.cxx. ◆ gradient(). virtual void RooAbsReal::gradient ; (; double * ; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 395 of file RooAbsReal.h. ◆ hasGradient(). virtual bool RooAbsReal::hasGradient ; (; ); const. inlinevirtual . Reimplemented in RooFit::Experimental::RooFuncWrapper.; Definition at line 394 of file RooAbsReal.h. ◆ hideOffset(). bool RooAbsReal::hideOffset ; (; ). static . Definition at line 169 of file RooAbsReal.cxx. ◆ integralNameSuffix(). TString RooAbsReal::integralNameSuffix ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const char * ; rangeName = nullptr, . bool ; omitEmpty = false . ); const. protected . Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ; Definition at line 753 of file RooAbsReal.cxx. ◆ IsA(). TClass * RooAbsReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooStats::HistFactory::RooBarlowBeestonLL, RooArgusBG, RooBCPEffDecay, RooBCPGenDecay, RooBDecay, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooCFunction1Binding< VO, VI >, RooCFunction1PdfBinding< VO, VI >, RooCFunction2Binding< VO, VI1, VI2 >, RooCFunction2PdfBinding< VO, VI1, VI2 >, RooCFunction3Binding< VO, VI1, VI2, VI3 >, RooCFunction3PdfBinding< VO, VI1, VI2, VI3 >, RooCFunction4Binding< VO, VI1, VI2, VI3, VI4 >, RooCFunction4PdfBinding< VO, VI1, VI2, VI3, VI4 >, RooChebychev, RooChiSquarePdf, RooCrystalBall, RooDecay, RooDstD0BG, RooExponential, RooFunctor1DBinding, RooFunctor1DPdfBinding, RooFunctorBinding, RooFunctorPdfBinding, RooGamma, RooGaussian",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:116796,integrat,integrated,116796,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['integrat'],"['integrated', 'integration']"
Integrability,"bally Unique IDent...Definition TUUID.h:42; TUUID::ReadBuffervoid ReadBuffer(char *&buffer)Stream UUID from input buffer.Definition TUUID.cxx:291; TUUID::FillBuffervoid FillBuffer(char *&buffer)Stream UUID into output buffer.Definition TUUID.cxx:275; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetAnchorconst char * GetAnchor() constDefinition TUrl.h:70; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::SetAnchorvoid SetAnchor(const char *anchor)Definition TUrl.h:86; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetValueFromOptionsconst char * GetValueFromOptions(const char *key) constReturn a value for a given key from the URL options.Definition TUrl.cxx:660; TUrl::SetProtocolvoid SetProtocol(const char *proto, Bool_t setDefaultPort=kFALSE)Set protocol and, optionally, change the port accordingly.Definition TUrl.cxx:523; TUrl::SetOptionsvoid SetOptions(const char *opt)Definition TUrl.h:87; TUrl::GetHostFQDNconst char * GetHostFQDN() constReturn fully qualified domain name of url host.Definition TUrl.cxx:472; TUrl::GetOptionsconst char * GetOptions() constDefinition TUrl.h:71; TUrl::SetHostvoid SetHost(const char *host)Definition TUrl.h:84; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TUrl::SetFilevoid SetFile(const char *file)Definition TUrl.h:85; TUrl::GetPortInt_t GetPort() constDefinition TUrl.h:78; TUrl::HasOptionBool_t HasOption(const char *key) constReturns true if the given key appears in the URL options list.Definition TUrl.cxx:683; TVirtualMonitoringWriter::SendFileReadProgressvirtual Bool_t SendFileReadProgress(TFile *)Definition TVirtualMonitoring.h:57; TVirtualMonitoringWriter::SendFileCloseEventvirtual Bool_t SendFileCloseEvent(TFile *)Definition TVirtualMonitoring.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:252423,protocol,protocol,252423,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['protocol'],['protocol']
Integrability,"bar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootCanvas(TCanvas* c = 0, const char* name = ""ROOT Canvas"", UInt_t width = 500, UInt_t height = 300); Create a basic ROOT canvas. TRootCanvas(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); Create a basic ROOT canvas. void CreateCanvas(const char* name); Create the actual canvas. ~TRootCanvas(); Delete ROOT basic canvas. Order is significant. Delete in reverse; order of creation. void Close(); Called via TCanvasImp interface by TCanvas. void ReallyDelete(); Really delete the canvas and this GUI. void CloseWindow(); In case window is closed via WM we get here. UInt_t GetCwidth() const; Return width of canvas container. UInt_t GetCheight() const; Return height of canvas container. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Gets the size and position of the window containing the canvas. This; size includes the menubar and borders. void SetStatusText(const char* txt = 0, Int_t partidx = 0); Set text in status bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Int_t InitWindow(); Called by TCanvas ctor to get window indetifier. void SetCanvasSize(UInt_t w, UInt_t h); Set size of canvas container. Units in pixels. void SetWindowPosition(Int_t x, Int_t y); Set canvas position (units in pixels). void SetWindowSize(UInt_t w, UInt_t h); Set size of canvas (units in pixels). void RaiseWindow(); Put canvas ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootCanvas.html:25636,interface,interface,25636,root/html528/TRootCanvas.html,https://root.cern,https://root.cern/root/html528/TRootCanvas.html,4,['interface'],['interface']
Integrability,"base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1251925,depend,depending,1251925,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['depend'],['depending']
Integrability,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range. » Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Chebyshev.html:3439,integrat,integration,3439,root/html530/ROOT__Math__Chebyshev.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Chebyshev.html,1,['integrat'],['integration']
Integrability,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range. » Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Chebyshev.html:3439,integrat,integration,3439,root/html532/ROOT__Math__Chebyshev.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html,1,['integrat'],['integration']
Integrability,"basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset = 0, const char* rangeName = 0) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:46752,integrat,integration,46752,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,3,['integrat'],['integration']
Integrability,"basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:50140,integrat,integration,50140,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,3,['integrat'],['integration']
Integrability,"basis_k (x) ResModel ]. where x is the set of coefficient dependents to be integrated,; y the set of basis function dependents to be integrated,; v is the set of coefficient dependents over which is normalized and; w is the set of basis function dependents over which is normalized. Set x must be contained in v and set y must be contained in w. Int_t getCoefAnalyticalIntegral(Int_t coef, RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Default implementation of function advertising integration capabilities. The interface is; similar to that of getAnalyticalIntegral except that an integer code is added that; designates the coefficient number for which the integration capabilities are requested. This default implementation advertises that no internal integrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const char* rangeName); Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:46276,integrat,integration,46276,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['integrat'],['integration']
Integrability,"bb, . double ; xx . ). DESCRIPTION: ; Returns incomplete beta integral of the arguments, evaluated from zero to x. The function is defined as x; - -; | (a+b) | | a-1 b-1 . --------— t (1-t) dt. . (a) (b) - . 0; The domain of definition is 0 <= x <= 1. In this implementation a and b are restricted to positive values. The integral from x to 1 may be obtained by the symmetry relation; 1 - incbet( a, b, x ) = incbet( b, a, 1-x ).; The integral is evaluated by a continued fraction expansion or, when b*x is small, by a power series.; ACCURACY:; Tested at uniformly distributed random points (a,b,x) with a and b in ""domain"" and x between 0 and 1. Relative error arithmetic domain # trials peak rms IEEE 0,5 10000 6.9e-15 4.5e-16 IEEE 0,85 250000 2.2e-13 1.7e-14 IEEE 0,1000 30000 5.3e-12 6.3e-13 IEEE 0,10000 250000 9.3e-11 7.1e-12 IEEE 0,100000 10000 8.7e-10 4.8e-11 Outputs smaller than the IEEE gradual underflow threshold were excluded from these statistics.; ERROR MESSAGES: message condition value returned incbet domain x<0, x>1 0.0 incbet underflow 0.0; Cephes Math Library, Release 2.8: June, 2000 Copyright 1984, 1995, 2000 by Stephen L. Moshier ; Definition at line 484 of file SpecFuncCephes.cxx. ◆ incbi(). double ROOT::Math::Cephes::incbi ; (; double ; a, . double ; b, . double ; y . ). Definition at line 411 of file SpecFuncCephesInv.cxx. ◆ lgam(). double ROOT::Math::Cephes::lgam ; (; double ; x). Definition at line 197 of file SpecFuncCephes.cxx. ◆ ndtri(). double ROOT::Math::Cephes::ndtri ; (; double ; y). Definition at line 137 of file SpecFuncCephesInv.cxx. ◆ pseries(). double ROOT::Math::Cephes::pseries ; (; double ; a, . double ; b, . double ; x . ). Definition at line 766 of file SpecFuncCephes.cxx. ◆ stirf(). static double ROOT::Math::Cephes::stirf ; (; double ; x). static . Definition at line 316 of file SpecFuncCephes.cxx. Variable Documentation. ◆ A. double ROOT::Math::Cephes::A[]. static . Initial value:= {; 8.11614167470508450300E-4,; -5.95061904284301438324",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Cephes.html:3811,message,message,3811,doc/master/namespaceROOT_1_1Math_1_1Cephes.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math_1_1Cephes.html,1,['message'],['message']
Integrability,"be a C++ callable object implementing operator()(double x); 228 @param a lower value of the integration interval; 229 @param b upper value of the integration interval; 230 */; 231 template<class Function>; 232 double Integral(Function & f, double a, double b);; 233 ; 234 ; 235 /**; 236 evaluate the Integral of a function f over the defined interval (a,b); 237 @param f integration function. The function type must implement the mathlib::IGenFunction interface; 238 @param a lower value of the integration interval; 239 @param b upper value of the integration interval; 240 */; 241 double Integral(const IGenFunction & f, double a, double b) {; 242 SetFunction(f,false);; 243 return Integral(a,b);; 244 }; 245 ; 246 ; 247// /**; 248// evaluate the Integral of a function f over the infinite interval (-inf,+inf); 249// @param f integration function. The function type must be a C++ callable object implementing operator()(double x); 250// */; 251// template<class Function>; 252// double Integral(const Function & f);; 253 ; 254 /**; 255 evaluate the Integral of a function f over the infinite interval (-inf,+inf); 256 @param f integration function. The function type must implement the mathlib::IGenFunction interface; 257 */; 258 double Integral(const IGenFunction & f) {; 259 SetFunction(f,false);; 260 return Integral();; 261 }; 262 ; 263 ; 264// /**; 265// evaluate the Integral of a function f over the semi-infinite interval (a,+inf); 266// @param f integration function. The function type must be a C++ callable object implementing operator()(double x); 267// @param a lower value of the integration interval; 268// */; 269// template<class Function>; 270// double IntegralUp(Function & f, double a);; 271 ; 272 /**; 273 evaluate the Integral of a function f over the semi-infinite interval (a,+inf); 274 @param f integration function. The function type must implement the mathlib::IGenFunction interface; 275 @param a lower value of the integration interval; 276 ; 277 */; 278 double Integr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:10050,integrat,integration,10050,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['integrat'],['integration']
Integrability,"be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IntervalCalculator(); {}. ConfInterval* GetInterval() const; Main interface to get a ConfInterval, pure virtual. Double_t Size() const; Get the size of the test (eg. rate of Type I error). Double_t ConfidenceLevel() const; Get the Confidence level for the test. void SetData(RooAbsData& ); Set the DataSet ( add to the the workspace if not already there ?). void SetModel(const RooStats::ModelConfig& ); Set the Model. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( e.g. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g. 0.95 for a 95% Confidence Interval). » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: IntervalCalculator.h 31276 2009-11-18 15:06:42Z moneta $ » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__IntervalCalculator.html:2319,interface,interface,2319,root/html526/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__IntervalCalculator.html,1,['interface'],['interface']
Integrability,"be constructed in three different way: * From an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives. * From an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives. * From an function object implementing double operator()( const double * ) for the function evaluation and another function object implementing double operator() (const double *, int icoord) for the partial derivatives.; The function dimension is required when constructing the functor.; 13.7.4.5 Special case: Wrapping TF1 objects in Parametric Function interfaces; In many cases, the user works with the TF1 class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods. If the desired interface to wrap is one-dimensional, the class to use is ROOT::Math::WrappedTF1. The default constructor takes a TF1 reference as an argument, that will be wrapped with the interfaces of a ROOT::Math::IParametricGradFunctionOneDim. Example:; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is ROOT::Math::WrappedMultiTF1. Following the usual procedure, setting the TF1 though the constructor, will wrap it into a ROOT::Math::IParametricGradFunctionMultiDim. Example:; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. cout << f(x) << endl;; cout << wf1(x) << endl;. return 0;; }; 13.8 Numerical Integration; The algorithms prov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:698675,interface,interface,698675,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['interface', 'wrap']","['interface', 'wrap']"
