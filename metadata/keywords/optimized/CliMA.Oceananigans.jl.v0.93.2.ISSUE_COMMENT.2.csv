quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:594,learn,learn,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274,1,['learn'],['learn']
Usability,"> As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. I agree that some diagnostics would be important, but I also agree with the above philosophy of Oceananigans. In cases like this wouldn't it be good to consider adding a companion repo to oceananigas that has all these diagnostics rather than putting them in Oceananigans by default? Much like LESbrary.jl does, it would be someting that (hopefully) can use `KernelComputedFields`, but it wouldn't be dedicated only to LES (so I guess it can't be LESbrary.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177:204,simpl,simple,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758899177,1,['simpl'],['simple']
Usability,"> As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would HydrostaticCurvilinearCoriolis be appropriate?. I haven't added `HydrostaticCurvilinearCoriolis` yet --- I'm planning to implement that once the PR is merged. At the current moment, I've only changed `BetaPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605:162,clear,clearly,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782726605,1,['clear'],['clearly']
Usability,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:128,feedback,feedback,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,5,"['feedback', 'simpl']","['feedback', 'simple', 'simpler', 'simply']"
Usability,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681:329,simpl,simple,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681,1,['simpl'],['simple']
Usability,"> Btw, as a side-note, I wanted to revisit those global SWE simulations. I had the feeling that the bathymetry was flipped (and possibly that's why some currents were moving the other way!). Glad you mentioned it as we never figured out why. Definitely something to revisit after some simple tests. If we start off with a topographic Rossby wave it will be very easy to know whether things are flipped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498162680:285,simpl,simple,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498162680,1,['simpl'],['simple']
Usability,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729:1372,clear,clear,1372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729,1,['clear'],['clear']
Usability,"> But I guess your hope is that this will decrease the number of mistakes in the first place since the signatures hopefully will become more intuitive?. It will make the function signatures more specific to the problem at hand, which broadly speaking eliminates more bugs. For example, in a one dimensional problem there is only one function argument, completely eliminating the possibility of mix up between two coordinates. But I think the main advantage is making the scripts more readable. I don't think there's much of a change to how ""intuitive"" the API is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858:141,intuit,intuitive,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777710858,2,['intuit'],['intuitive']
Usability,"> But I'm happy to set up a simplified biogeochemical module just in Oceananigans.jl. . Rather than setting up a module, all we need to do is write a script that implements a system of chemical reactions. This is relatively easy to do without modifying `Oceananigans.jl` source code. However, to do this, we need to know the equations that govern the reactions, along with with the reaction rate parameters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629414024:28,simpl,simplified,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629414024,1,['simpl'],['simplified']
Usability,"> But this deviates from the other interfaces we provide.; > . I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. . It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470:889,simpl,simple,889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819282470,1,['simpl'],['simple']
Usability,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475:40,simpl,simply,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475,1,['simpl'],['simply']
Usability,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:436,simpl,simple,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093,1,['simpl'],['simple']
Usability,"> Can we come up with a MWE, maybe a simple 2 point single column model that can be copy/pasted here?. This test _is_ done using 2-point single column models :). https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/test/test_ensemble_hydrostatic_free_surface_models.jl#L56-L58",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308126156:37,simpl,simple,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308126156,1,['simpl'],['simple']
Usability,"> Can you give an example that's OK and one that's not?. The example that is ok is when the limit of the loop `N` is passed in via an argument with _type_ `Val{N}`. Then `N` is known to the compiler. This is what I tried to indicate, sorry for not being clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877552215:254,clear,clear,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1877552215,1,['clear'],['clear']
Usability,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:276,clear,clear,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,2,"['clear', 'simpl']","['clear', 'simplest']"
Usability,"> Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`?. Yeah I'm trying to reproduce in CUDA.jl so I tried this first but it seems to work:. ```julia; julia> using Statistics. julia> using CUDA. julia> N = 32;. julia> a = randn(N+2, N+2, N+2) |> CuArray;. julia> v = view(a, 2:N+1, 2:N+1, 2:N+1);. julia> V = zeros(1, 1, N) |> CuArray;. julia> mean!(V, v);; typeof(R) = CuArray{Float64, 3}; threads = 384; blocks = 96; reduce_blocks = 3; typeof(R) = CuArray{Float64, 4}; threads = 32; blocks = 32; reduce_blocks = 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845609934:35,simpl,simple,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845609934,1,['simpl'],['simple']
Usability,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. I don't know what you mean that it's not ""intuitive"" (what role does intuition play here?) As for finding information about it, a basic reference for partial cell methods is [""Representation of Topography by Shaved Cells in a Height Coordinate Ocean Model"" by Adcroft et al. 1997](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). A ""partial cell"" method is one in which the height of the bottom most cell in the domain is _reduced_. This reduces cell height, interface areas, and volumes (in our current implementation --- other models are possible as well). Grid spacing is the dominant factor in the numerical stability of a model. One basic determinant of numerical stability is the CFL condition, which, for example, requires `w dt / dz < 1`. It's thus wise to modify grid metrics with care. Usually, it's undesirable to have 1 or some small number of cells with much smaller spacings / areas / volumes than the rest, because that single cell will impose severe time step restrictions on the entire model. `minimum_fractional_Δz` limits the amount by which we can reduce cell size to prevent the creation of very thin cells with severe time-step restrictions. Setting this value to 0 is likely to produce a model with impractably short time-step restrictions. MITgcm uses a default value of 0.1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324:144,intuit,intuitive,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1132039324,3,['intuit'],"['intuition', 'intuitive']"
Usability,"> Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere. The problem is that we don't want a cell to be too small because this could cause a serious restriction for numerical stability because of the CFL condition. I haven't faced this yet, but this is common practice in the MITgcm, so we are doing the same. But probably worth playing with it to see if/when it matters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131853922:144,intuit,intuitive,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131853922,1,['intuit'],['intuitive']
Usability,"> Depends if we wan tot exclude the points or edges or not (i.e where `solid_interface` is true but `solid_node` is not). Hmm yeah I am a little worried that I misunderstood the meaning of `solid_interface` since I think it does assume that the immersed boundary is ""referenced"" to a tracer cell (ie because `solid_interface(::C, ::C, ::C, i, j, k, grid) = solid_node(c, c, c, i, j, k, grid)`). But I'm not 100% sure. For example, it's presumably possible to have a solid interface at (c, c, c) even when the tracer cell is _not_ solid (ie it's a partial cell that's half-filled...). So I'm a little confused now. I think we need to distinguish between logic that's designed for enforcing impenetrability versus logic designed for enforcing boundary fluxes. We might be mixing those up right now, which works with simple immersed boundary implementations but won't generalize.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731:814,simpl,simple,814,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047270731,1,['simpl'],['simple']
Usability,"> Did you want me to give this a try? It does not seem like a lots needs to change and I will certainly learn a lot in the process. That's fine with me (and I am very happy to help, or pair program over zoom). I think resolving this issue (moving files around) should happen in a separate PR from implementing `ShallowWaterModel`. Imports and exports will also change, for example `IncompressibleModels` will become a submodule of `Models`, and we'll have to pull the name `IncompressibleModel` into `Models`:. ```julia; # in Models.jl. include(""IncompressibleModels/IncompressibleModels.jl""). using IncompressibleModels.IncompressibleModel; ```. Hopefully we can reuse as much code as possible. If your prognostic variables are `hu,`, `hv`, `h`, you may benefit from some fancy julia abstraction that will let you reuse momentum advection and tracer advection operators like `div_Uu` and `div_Uc`. I'm happy to help with that. Your fields will all have to be three-dimensional (with a single grid point in the vertical direction). Also until #1024 is fixed we will unfortunately also need halo regions in the vertical direction. Hopefully this won't matter too much and eventually we will be able to use `Flat` vertical directions. As for the file structure, I think some functions can be generalized to work for any model rather than split, like `store_tendencies!` (it perhaps makes sense that `store_tendencies!` is independent of the model type). I think it's nice that the physics-specific functions will now be in `Models/IncompressibleModels`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396:104,learn,learn,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396,1,['learn'],['learn']
Usability,"> Didn't mean to suggest that we need extensive documentation right away. Having examples of what's possible will be really useful, but we can build up a collection of good examples over time. The main confusion about abstract operations is not actually the abstract operations themselves, but the way that julia parses infix operators. Would it be clearer if I told you that you can construct an operation tree by writing a mess of nested functions like. ```julia; kinetic_energy = /(+(^(u, 2), ^(v, 2), ^(w, 2)), 2); ```. This is what happens when you write `kinetic_energy = (u^2 + v^2 + w^2) / 2` --- the infix operations `+`, `/`, and `^` parse that way. . We can document this of course but this is not our code. This is base julia. I understand that it can be mysterious if you are not completely comfortable with how infix operators translate to ordinary function calls. Thus we can demonstrate usage through examples? But there's not much documentation to write. We've define a function `+(a, b)` that acts on `a` and `b`. We defined `^(u, 2)`, or `^(a, b)`. We compose operators by nesting them inside one another (a binary operator can be defined between fields or fields and numbers). A unary function has one argument, a binary function has two, and a multiary function has 2+. The user can define an infinite of their own binary, unary, and multiary functions. If those user-defined functions are also infix operators, they will have the same interesting infix-parsing behavior that many of the operators we pre-define do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545897804:349,clear,clearer,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545897804,1,['clear'],['clearer']
Usability,"> Do we not want the substep length rather than the total time step length? For example on the cases where we're explicitly stepping a boundary condition they're getting stepped every substep. It's not a question of having one or the other. The _question_ is whether ""`last_Δt`"" means ""last time step"". We need to save the previous time step for various reasons --- for AB2 it's needed to decide whether to re-initialize with an Euler step. If we need the previous substep that was taken during RK3 multi-stage stepping, that's fine. It's the road to insanity if `last_Δt` means ""last substep"" in some cases, and ""last time step"" in others. Given the choice, why deliberately drive ourselves insane when we can simply save both the substep and the total time step?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3595#issuecomment-2104881794:711,simpl,simply,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595#issuecomment-2104881794,1,['simpl'],['simply']
Usability,> Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point? It does seem the simplest would be that anything on a bounded face only launches over 2:N. That's right.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163957:126,simpl,simplest,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389163957,1,['simpl'],['simplest']
Usability,"> Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?. That's up to you. Smaller PRs can be easier because you will have less risk of merge conflicts. However you should make sure that the code in any individual PR is motivated and tested (ie if you implement a new type then it'd be best to have a use case for it, plus a test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155:86,simpl,simple,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155,1,['simpl'],['simple']
Usability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:669,clear,clearly,669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,1,['clear'],['clearly']
Usability,"> For API this is what I suggest:; > ; > Three ""modes"":; > ; > 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; > 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; > 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?. > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name. I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887537661:661,simpl,simplified,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887537661,1,['simpl'],['simplified']
Usability,"> For example, this should work. You can probably make this work pretty easily for precomputed fields. It's no different from simply calling `Array(view(field, indices...))`. So you just have to add some stuff to `view(f::Field, i, j, k)` to special-case `StepRange` indices. It's more work / requires more ingenuity and cleverness to get that working with AbstractOperations and allocating the right amount of memory, etc, plus index gymnastics. That said I don't see any issue. Just some coding and arithmetic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091162179:126,simpl,simply,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091162179,1,['simpl'],['simply']
Usability,"> From the above, it is definitely RegularRectilinearGrid with a Flat dimension I looked at Grids.jl and have learned that RegularRectilinearGrid is of type AbstractRectilinearGrid and this is a subtype of `AbstractGrid. I guess this explains the hiearchy. Yes, that is the type hierarchy and why I thought the above code pattern would work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147648:110,learn,learned,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805147648,1,['learn'],['learned']
Usability,"> Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different; target arch. Right --- we can use a wrapper that redefines `getindex` (and potentially also is associated with a certain loop ordering). Looks like there's a julia type that does this:. https://github.com/JuliaLang/julia/blob/master/base/permuteddimsarray.jl. I doubt it would be very hard to figure out how to abstract away loop ordering so it can be flexibly changed for a target architecture. One question still remains: which is the most intuitive convention for `getindex` calls? I personally like `i, j, k` for `x, y, z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865:594,intuit,intuitive,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365865,1,['intuit'],['intuitive']
Usability,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167:240,simpl,simply,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167,1,['simpl'],['simply']
Usability,> Gotcha Oh... I misunderstood then the first comment of the PR. So forcing wasn't even working for simple constant Fields???. I don't think so.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989221909:100,simpl,simple,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989221909,1,['simpl'],['simple']
Usability,"> Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs. Just wanted to point out that APE calculations are only this simple with simple for Cartesian grids with a flat bottom and a linear equation of state. Otherwise, the hard part is actually finding the depths/pressure associated with the sorted profile density profile (see [Huang 2005](https://www.ingentaconnect.com/content/jmr/jmr/2005/00000063/00000001/art00008?token=00611657770a742f3f3b3b6a332b257d7241255e4e7d63433b393f6a573d257025447023766c7a7338422c6b6337ede82)). I've been working on implementing this in an MITgcm simulation with a linear equation of state but complicated topography, and it has been a mess (and very slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923:85,simpl,simple,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839055923,3,['simpl'],['simple']
Usability,"> Greg, Doesn't Ali have a version of immersed boundary layers going?. @johncmarshall54, Ali experimented with a simple immersed boundary implemented via Oceananigans's user-defined forcing functions. The code is these 9 lines:. https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. This implementation damps the velocity field to zero on a very fast time-scale (specified by the parameter `K`) within the immersed boundary. This is certainly a nice, simple immersed boundary implementation for Dirichlet / Value boundary conditions and could be a good starting point. However, I also think there's some good reasons to pursue an alternate immersed boundary implementation to what @ali-ramadhan has done:. 1. @ali-ramadhan's implementation doesn't obviously extend to other boundary conditions, like prescribed gradients or fluxes (the latter being crucial for the geophysical problems we're interested in). So, even if we use a continuous forcing method similar to @ali-ramadhan's implementation, we need to figure out how to enforce boundary conditions other than Dirichlet boundary conditions.; 2. @ali-ramadhan's implementation conforms exactly to the grid; however we would like to be able to model smoothly-varying boundaries.; 3. As noted by @whitleyv, @ali-ramadhan's ""continuous forcing method"" implementation introduces a time-step restriction due to the need to explicitly resolve the damping time-scale in the forcing function. It seems that a discrete forcing method overcomes this restriction and could prove crucial for geophysical problems that involve otherwise long time-steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244:113,simpl,simple,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244,2,['simpl'],['simple']
Usability,> Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. Was curious to have a look but I think the link might be dead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929:12,simpl,simplified,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929,1,['simpl'],['simplified']
Usability,"> Hi all, I have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:46,simpl,simple,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834,1,['simpl'],['simple']
Usability,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:508,simpl,simply,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769,1,['simpl'],['simply']
Usability,"> Hmmm, I don't know if many log levels will be that helpful. I'm not entirely sure either. It's worth considering whether the standard `Info` and `Debug` levels might be enough for some of your uses, but there's also nothing wrong with trying out some custom levels and removing them if they don't end up making sense. For general logging I've often wondered whether it would be helpful to have a `Notice` level with severity between `Info` and `Warn` to allow informational messages to be stratified into two groups, though we would need clear guidelines for how to use it. Likewise, to have a `Debug2` or `VerboseDebug` level for ""really verbose"" debugging messages (possibly compiled out by default, though that would need a minor tweak in Base to make it possible). > but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. This is basically what the standard `Info` level printing does in `Logging.ConsoleLogger` - it just ignores the line and file info captured by the fontend to simplify the pretty printing of the message. Btw, the pretty printing of log events can be separate from the storage format if desired. For example we could serialize log records to a binary file (including all file,line information etc) but have a tool to pretty print them with extra filtering, replay the messages from a simulation in faster than real time etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159:540,clear,clear,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-547209159,3,"['clear', 'guid', 'simpl']","['clear', 'guidelines', 'simplify']"
Usability,"> How do we deal with errors of this kind in the doctests?:; > ; > ```; >   | │; >   | │ diff =; >   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.; >   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.; >   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration; >   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44; >   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; > ...; > ```; > ; > i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different.; > ; > I remember there was a relatively simple way to deal with this, but I can't find it. Damn... I remember the issue... Something with filter doctests. I can try to sort it out. Ignore it for now :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200:777,simpl,simple,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460574200,1,['simpl'],['simple']
Usability,"> However, I need to know what to do, exactly. What code should I put in the verification folder, and what is the format? A few more questions:. If we structure it like the stratified Couette flow verification, then we just need two scripts:; 1. A script that setups up the verification experiments and outputs data necessary to produce verification experiment plots. Probably just https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/deepening_mixed_layer.jl; 2. A script that produces plots from the data. Using these plots we should be able to say whether the verification experiment is a ""pass"". I think you already did most of these in https://github.com/glwagner/ColumnModelOptimizationProject/tree/master/les/analysis. Could be more than two scripts or could be one script I guess. > Where do we write documentation for the verification experiments?. I would add a Markdown file in https://github.com/climate-machine/Oceananigans.jl/tree/master/docs/src/verification where we can add the plots too. > Are we continuously testing verification experiments to ensure they run with new versions of the code, or should verification experiments be tagged to a particular version of the code?. Yeah we should but they are expensive to run... Maybe we should do this manually before releasing new versions?. > I think all these questions should themselves be answered in the documentation, also. Otherwise it is not clear how to contribute new verification experiments. True. I can add a `verification/overview.md` describing the purpose of the verification experiments and how they're structured, how to contribute a new one, etc. > I think we should shelve Kato and Phillips, and instead pursue verification based on oceanic observations. Reproducing ocean observations will be far more challenging, but aligns better with our ultimate goals. Sounds like a good idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-562190948:1437,clear,clear,1437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-562190948,1,['clear'],['clear']
Usability,"> However, a more efficient solution is to a new parameter to the FFT-based Poisson solver. Isn't this simply setting $\bar \phi = \bar r / \mu$ in the FFT solver, rather than $\bar \phi = 0$ as we do currently? Why does this help? (I'm not implying that it doesn't help, I just don't understand why trading one constraint for another is advantageous). Also given the ease of implementing such a change, did you test it?. Also if we set $\bar r = 0$ after computing the RHS here:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Models/NonhydrostaticModels/solve_for_pressure.jl#L88-L89. then I suppose we would have $\bar \phi = \bar r / \mu = 0$ (I tested this briefly though and it didn't seem to improve the problems observed on #3831 / #3848, but we could keep trying).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2418066050:103,simpl,simply,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2418066050,1,['simpl'],['simply']
Usability,"> I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly. wow, I didn't know you could do that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203:5,pause,paused,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203,1,['pause'],['paused']
Usability,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:637,simpl,simple,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538,3,"['simpl', 'user-friendly']","['simple', 'simplicity', 'user-friendly']"
Usability,"> I admit that I don't understand the symmetric interpolant stuff that is done, which is perhaps why I can't see the error. This distinction only matters for momentum advection. For tracer advection, the velocity field does not have to be interpolated to the location of the tracer fluxes, since it's already located there due to the staggered arrangement of velocity fields and tracer fields. For tracer advection, all that matters are the definition of the left-biased and right-biased functions for interpolating cell-averaged tracer values to cell faces. These are the functions `left_biased_interpolate_xᶠᵃᵃ`, etc. This might be made clear by the operators for `advective_tracer_flux_*` when using an upwind-biased scheme:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Advection/upwind_biased_advective_fluxes.jl#L103-L110",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133:639,clear,clear,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-747713133,1,['clear'],['clear']
Usability,"> I agree that maybe `convert` is more clear, but still, I would rather have one way to do things, and for this reason: to develop the code you must need to know what it means in those lines where it is repeated 20 times, so I do not think writing it in another way improves clarity. It might actually beg the question as to why the pattern is different and if there are concrete differences between the two ways of writing it, on the other hand, if you are familiar with Oceananigans, you just have to know `FT()` once and you're done. We agreed long ago to only use `convert` --- why are we still using patterns like `FT(num)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1607573233:39,clear,clear,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1607573233,1,['clear'],['clear']
Usability,"> I agree that the PoissonSolver struct is a better place to store the pressure boundary conditions, but what do you think of just storing them in model.boundary_conditions?. I don't like this idea, because I would like the tuple of boundary conditions to have the same length as the number of solution variables to permit easy and simple looping / code reduction / arbitrary tracer stuff in the future. . While not crucial, I think it makes sense (though of course we don't currently have a `solution` tuple, though that would be easy to add). Edit: we could achieve both aims by adding a level of hierarchy to `boundary_conditions`, so that it has fields `solution, tendencies, pressure`, (each of them a tuple), or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861:332,simpl,simple,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861,1,['simpl'],['simple']
Usability,"> I also have trouble understanding it...; > ; > Perhaps @tomchor can elaborate? Or simplify it to exemplify the issue?. > So you can run for 18 steps instead of 4. (@tomchor why 18?). Sorry for the unclear example, guys and thanks for the help. I posted this after many hours of trying to catch the culprit in a _very_ complex simulation and at the time I was so tired that the MWE seemed reasonable to me. Now I see it's pretty badly set up. I'm gonna work a bit on this today and come up with a better MWE if we need one. But to explain a bit better, the main goal of this snippet (other than showing the issue) is to write (in the same file) an xz-slice (at `j=1`) and a y-average (using `Average(field, dims=(2,))`. For that I first create a tuple of ""full"" fields (fields without slicing or averaging, which I call `outputs_full`). Then, based on that tuple, get each element and average it in `y`, creating the tuple `outputs_yavg`. When I pass both of those tuples (merged) to the `NetCDFOutputWriter` along with the option `indices=(:,1,:)`, I get, in the same file, sliced fields (which are called `wτ1`, etc.) and y-averaged fields (called `wτ1_yavg`, etc.). I just ran @glwagner's MWE locally and the issue doesn't appear, even though at first it does exactly what my MWE does, so I need to track what's the important change there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437230261:84,simpl,simplify,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1437230261,1,['simpl'],['simplify']
Usability,"> I also see that @tomchor has done quite a bit of work with PRs #2652 and #3143. Also happy to help with those. I do see that grid spacings and metrics can be a thorny subject. Between these two, I'd say https://github.com/CliMA/Oceananigans.jl/pull/3143 should probably take priority. It should be simpler and I see it as a bug, which should be fixed. That PR didn't move forward because I unfortunately ran out of time, so feel free to take over it if you want! That said, it's a different issue than the one raised by @glwagner here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-2350933066:300,simpl,simpler,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-2350933066,1,['simpl'],['simpler']
Usability,"> I also think that we should consider also another example problem like a flow around a cylinder. Please consider as many different cases as possible or as you need. I think a real nesting case would be even better --- for example, generate a turbulent solution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The pre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:453,simpl,simple,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,['simpl'],['simple']
Usability,"> I am actually not even sure that it would be possible to do easily in this case. Just to be clear, this is just for offline diagnostics, right? Online diagnostic operations on prognostic fields still correctly feel the boundary conditions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689980077:94,clear,clear,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689980077,1,['clear'],['clear']
Usability,"> I am not sure about the purpose of this PR. What is the reason we do not want to calculate the periphery in the nonhydrostatic model tendencies?; > ; > If there is a specific reason, does this solution also apply to immersed boundaries with active cell map? It seems like nothing changed for that case. Because some open boundary conditions integrate an alternative PDE on the boundaries (eg for radiation conditions). In other words the algorithm we are using is only valid for simple open boundary conditions (we designed it for impenetrable condition). More generally, the algorithm is wrong. There are two other benefits. First, we do not use the tendencies on the periphery. So this increases the clarity of the code. Previously, it might not be obvious that even though we compute tendencies on the boundary, we overwrite the field values in `fill_halo_regions!`. It saves a little bit of computation as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988:481,simpl,simple,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2397256988,1,['simpl'],['simple']
Usability,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:243,simpl,simply,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311,1,['simpl'],['simply']
Usability,"> I am trying to follow the code, and sorry that it's not obvious to me what's goipartition = XPartition([3, 3, 3, 3])ng on.; > ; > Because you have `devices=(0,1)`, I presume that means you are running on two GPUs?; > ; > But you also have `partition = XPartition([3, 3, 3, 3])`, which seems like you are partitioning it onto 4 regions, each of length 3, which sum to 12 (the length of the domain).; > ; > If you have two devices, wouldn't you normally have two partitions and not four?. We want to allow general partitioning across devices. For example the simplest implementation of the cubed sphere is a 6 region domain, but we won't always have 6 devices. The question to ask is not what our ""usual"" case is, but rather what the most general case that we want to support looks like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1044754993:559,simpl,simplest,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1044754993,1,['simpl'],['simplest']
Usability,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373:1023,simpl,simple,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373,1,['simpl'],['simple']
Usability,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:1122,simpl,simply,1122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,1,['simpl'],['simply']
Usability,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:261,clear,clear,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,1,['clear'],['clear']
Usability,"> I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > ; > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > ; > CC @hdrake @glwagner who were in #3581. What's the problem with adding it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841:835,simpl,simpler,835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841,1,['simpl'],['simpler']
Usability,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1000,clear,clear,1000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000,1,['clear'],['clear']
Usability,"> I could also envision a few more tests to ensure the correctness of the turbulent diffusivities in simple flow fields for Constant Smagorinsky and Anisotropic Minimum Dissipation. However this last is not necessary. Hmmm, wonder if it's worth doing this if we're going to do some more rigorous LES verification anyways? The rigorous tests probably won't pass initially which will lead us to do these simpler tests first maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508953996:101,simpl,simple,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508953996,2,['simpl'],"['simple', 'simpler']"
Usability,"> I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:; >; > Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. I agree that far from the wall there is a clear trend. But I'm not sure that's a fair way to look at it. > But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps. That said, good point that the coefficient doesn't necessarily translate into the eddy viscosity. I'll check the eddy viscosity later and see what comes up as I am now curious :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803:75,clear,clear,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449535803,2,['clear'],['clear']
Usability,"> I do prefer HorizontalAverage over ZAverage though, but would rather not have a lot of aliases floating around... I think with this nomenclature, what we now call `HorizontalAverage` would become `XYAverage`. Another possibility is to simply have `Average`, and then introduce a `dim` type parameter that can be `:x`, `:y`, `:xy`, `:xyz`, etc... ? So we'd use. ```julia; horizontally_averaged_u = Average{:xy}(model.velocities.u). zonally_averaged_u = Average{:x}(model.velocities.u). volume_averaged_u = Average{:xyz}(model.velocities.u); ```. Even better would be to use an abstraction with `dims=(1,)` perhaps, but looking at the code I'm not 100% sure how to do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658383399:237,simpl,simply,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-658383399,1,['simpl'],['simply']
Usability,"> I don't know how Finite Volume would compare, but I'm tempted to start with this for simplicity. Is that method implementable on a C-grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726875161:87,simpl,simplicity,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726875161,1,['simpl'],['simplicity']
Usability,"> I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper. Can you reproduce the error in the test locally? You can try navigating to `/test`, starting with `julia --project`, and then. ```julia; julia> include(""test_forcings.jl""); ```. you might need to add a few packages to your global environment like `Test` to make this work. Also running. ```; TEST_GROUP=time_stepping_2 julia --project -e 'using Pkg; Pkg.test()'; ```. will run the forcing tests (and a few others). If you do that, do you see an error like in the CI or do the tests pass?. Also running just the problematic test in isolation can be useful:. https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L114-L130",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683:61,learn,learn,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092171683,1,['learn'],['learn']
Usability,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379:50,feedback,feedback,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379,3,"['feedback', 'simpl']","['feedback', 'simpler']"
Usability,"> I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that. What I mean is that it's makes it easier for a user to write something like:. ```julia; u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); ```. and have it (correctly) return 0 when `closure=nothing`. I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances. Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1450657876:1025,simpl,simple,1025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1450657876,1,['simpl'],['simple']
Usability,"> I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?. I believe this refers to the fact that julia's `Tridiagonal` (whose conventions are followed in the `BatchedTridiagonalSolver`) has three vectors: `d` (diagonal), `du` (upper diagonal) and `dl` (lower diagonal). `d` has length `N`, but `du` and `dl` both have length `N-1`. So for example the matrix component ""1, 2"" is index `1` in the lower diagonal vector (rather than index 2) --- I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973702664:153,simpl,simpler,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973702664,1,['simpl'],['simpler']
Usability,"> I don't think it matters that the full cubed sphere is Periodic. I think the topology is somewhat undefined especially since the i or ""x""-direction doesn't point in any particular dimension. Right, I guess I am thinking of a domain consisting of two connected grids in which the whole domain is bounded. It seems that if `Connected` behaved exactly as `Periodic` then we would have no need for a new type. (I think you understand this and imply it in your text, but I just want to be clear that the only reason `const Connected = Periodic` works is because we are considering a case in which the grids ""wrap around"", and thus having every grid behave like `Periodic` is valid).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371:486,clear,clear,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-820016371,1,['clear'],['clear']
Usability,"> I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`; > ; > If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else.; > ; > If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized. But why do we need to calculate the rank and size? That's the root issue. I'm not suggesting that we build an API to emit the rank and size. I'm suggesting that we design the code so that kind of calculation is not necessary. Consider: rank and size do not exist for non-distributed simulations. So no matter how it is done, if your code needs to calculate the rank and size, then it is not ""agnostic"" to being distributed vs serial. That is distributed-explicit code. Make it very clear: the objective is to provide a codebase that permits distributed simulations with _minimal_ code changes to serial scripts. If you find that users are constantly writing distributed-specific code, then a rethink is needed. Agree that we should not initialize when importing the module! It doesn't make sense, `DistributedComputations` is always imported but rarely used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038:1187,clear,clear,1187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894895038,1,['clear'],['clear']
Usability,"> I don’t like “Singleton”: Periodic and Bounded refer to the physical nature of the dimension, while Singleton obliquely references the size of an underlying array of discrete data. A better name would refer to the physical nature of the coordinate; “Uniform” or “Flat” are examples. We're setting up a discrete model anyways, but I guess if it's supposed to model some physical system then ""Singleton"" may not be completely appropriate. I'd vote for Flat over Uniform then. Uniform could be multiple grid points while Flat strongly implies one grid point (while both imply homogenous dynamics in that dimension). > It could make sense to make (Periodic, Periodic, Bounded) a default. This is already the default of Model. Yeah I guess we have a choice here: do we want to make horizontally periodic the default or are users now required to specify a grid topology?. I could see benefits either way. Keeping it the default would introduce no breaking changes and simplify the tests, but requiring it would improve the clarity of most scripts (an issue that has been brought up before, see #459). I think most real scripts (not tests) should be specifying a topology for clarity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581827847:964,simpl,simplify,964,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581827847,1,['simpl'],['simplify']
Usability,"> I encountered similar issues months ago when using the CG Poisson solver. I fixed my code by slightly modifying the algorithm ([Yixiao-Zhang@c7983b8/\](https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac/\)). The reason is that the CG method can be numerically unstably for positive (or negative) semi-definite matrices. Did you encounter the same issue whereby the simulation would _immediately_ NaN (rather than intermittently)? I'd be curious to see your setup in order to have more than one working example to test with. I've made a little progress with regularizing the solver (vs the simpler technique of setting the mean directly). The issue is that while regularization does seem to be able to stabilize the solver, we still experience extremely slow convergence with `FlatExtrapolationOpenBoundaryCondition` to the point that it's basically unusable practically, I think (at least if the same convergence rate is experienced at higher resolution / with better physics). It's unclear whether these issues are generic to the solver or specific to this boundary condition, so having another unstable case would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2418133864:636,simpl,simpler,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2418133864,1,['simpl'],['simpler']
Usability,"> I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`.; > ; > To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices. It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though... I'm good with both options for `with_halo`. IMO the only important thing is for this PR is to support the output of sliced `Field`s. It definitely would be nice to also support `with_halos`, but given how tricky it can be and the low priority, I'm definitely okay merging this without `with_halo` support for sliced fields. I'll leave the call up to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127152305:14,simpl,simplest,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127152305,1,['simpl'],['simplest']
Usability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:268,learn,learn,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918,1,['learn'],['learn']
Usability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. This then sounds to me like you don't have a working CUDA-aware MPI. IGG should show >90% efficiency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885287770:268,learn,learn,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885287770,1,['learn'],['learn']
Usability,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:45,clear,clearer,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,2,['clear'],"['clear', 'clearer']"
Usability,"> I intend to merge this though. It's just that apparently #1998 needs to be finished first, according to @navidcy at least, so I thought I'd wait for that. Are you suggesting we move on this one before other PRs and just for vertically stretched grids?. Nah... Well, I may have initially thought that #1998 was important to finish first, but I take it back :); Let's make this work for all grids in the simplest manner possible and merge it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-946332878:404,simpl,simplest,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-946332878,1,['simpl'],['simplest']
Usability,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:320,simpl,simple,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103,1,['simpl'],['simple']
Usability,"> I know that the rigid-lid and linear free-surface models are very closely related as the grid doesn't change, and I would think that we could use the same solver on both cases. Is that true?; > ; > I guess one important difference is in the latter we have to evole the free-surrface but that is pretty cheap compared to everything else as it's only a two-dimensional field.; > ; > Dealing with complex geometries is, well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514:494,simpl,simple,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514,1,['simpl'],['simple']
Usability,"> I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because; > ; > 1. not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; > 2. having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; > 3. I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in [Overturning, eddying channel example following Abernathey et al. 2011 #1744](https://github.com/CliMA/Oceananigans.jl/pull/1744), which I feel implies that many other users will also benefit). Fair enough. I was leaning towards simplicity as per our last conversation about simplifying the code to make it easier for development and (mostly) because I think a sine/cosine multiplication doesn't add much complexity on the user side. But it seems I'm voted out so I'll implement those functionalities back :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059:483,simpl,simplification,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059,3,['simpl'],"['simplicity', 'simplification', 'simplifying']"
Usability,"> I might suggest renaming DirectionalDiffusivity to AnisotropicDiffusivity for consistency. For some reason I convinced myself that it wasn't actually anisotropic. But thinking about it over a fresh cup of coffee I realize it is. I may also change `ScalarDiffusivity` to `IsotropicDiffusivity`... ?. > With the growing amount of notation for the operators and even things like G for source terms we should probably create a page in the docs that explains the code notation. Could be a useful reference. I like this idea. It also motivates us to be careful and systematic about using and introducing notation. The notation should be easy to read, concise, clear, and as meaningful as possible. This PR essentially proposed that we have a suite of operators that are denoted with a single symbol, appended by the direction they act in, and subscripted by the location at which they act (`caa` for something in x, `cca` for double interpolation, etc.). > We already have a subsection that describes the governing equations. I don't object to giving it its own page. That's what I meant. I am wondering if we can elevate the governing equations to a separate page (they are important!) I'd prefer not to characterize the governing equations as part of the numerics. The numerics discretize the continuous equations, and the continuous equations exist independently of numerics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495596405:656,clear,clear,656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495596405,1,['clear'],['clear']
Usability,"> I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2*2*5*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who _do_ use codes that rely _heavily_ on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). I don't disagree with anything here. I just think users should be able to run using whatever resolution they want and know that the code has been tested and works with weird inefficient resolutions. To encourage users maybe we can print a ""performance warning"" if the grid resolution is not the product of a small number of prime divisors?. > I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`. That makes sense. I think we should just be wary of having too many parametric types but architecture probably warrants being one as we'll dispatching on it so frequently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451:9,simpl,simplified,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451,1,['simpl'],['simplified']
Usability,"> I propose two changes:; > ; > 1. An example that re-implements the existing 1D diffusion example but with a background field (modifying the boundary conditions on the perturbations to make the two exactly equivalent). @liuchihl, this would be a great first contribution for you; > 2. Correction to the boundary condition in the present tilted geometry example. I am working on this now. Do we need both of those examples? I only ask because examples are a little expensive, both computationally (they have to run in CI) and also because they have to be maintained. So we want every ""example"" to present significant value... . An alternative is to put the 1D example somewhere else, perhaps just a very simple illustration in the docs for background field (that could just be a short write up, then, rather than a full blown example). The 1D and 2D cases are basically the same in terms of boundary conditions right?. Open to various things but just wanted to raise that point since we have tried to be very selective about examples in the past (and we are still very short on examples for they hydrostatic model + immersed boundaries). I also want to build out a much larger selection of simulation examples here: https://github.com/glwagner/AwesomeOceananigans but progress is slow...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083782941:704,simpl,simple,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083782941,1,['simpl'],['simple']
Usability,"> I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth. Ok, that makes sense, so `d = depth(i, j, k)` is 3D. What about `column_depth(i, j)`? Just want to have a discussion about it rather than simply deciding. Any other ideas besides ""column"", ""domain"", and ""total""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844:391,simpl,simply,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2419921844,1,['simpl'],['simply']
Usability,"> I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. NetCDFOutputWriter, JLD2OutputWriter. If you are referring to #3793 my intent is just to introduce an additional wrapper on top of the existing writers. It's merely an alternative to adding output writers manually to `simulation.output_writers`, which I find inelegant. > I believe it will be simple to change by only executting the initialize_nc_file! and initialize_jld2_file! once the model is running, instead of two times, once the writers are initialised and in run time (write_output!). I agree that it's simple to design. > Despite the implementation of this, I still see value in having a flag overwrite_existing, likely set up to false as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. Why would it result in (unintended) data loss? Because its common to mistakenly re-run a simulation? . > Regarding my changes in this PR, the function is_output_splitted! may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function. Okay, I'll take a look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954:447,simpl,simple,447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391732954,2,['simpl'],['simple']
Usability,"> I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation. I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":. Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems. We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms. It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701:1630,learn,learning,1630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701,1,['learn'],['learning']
Usability,"> I see. It would be nice to have this as a user API convenience, but then to be complete we must include all the other entries of the tensor. It might get a bit tedious when you want to include isopycnal diffusivities like `TwoDimensionalLeith` or GM (`IsopycnalSkewSymmetricDiffusivity`) for which we do not compute the tensor but directly the flux. I think the other tensor entries are much less frequently needed, so I'd propose we start only with the simple stuff and add the rest when needed. I was also thinking that for inner-working purposes it's best to keep the current `viscosity()` behavior (always returning a 'Number`) and create a second function that can be exported to the user which has the array behavior I described. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1266041565:456,simpl,simple,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1266041565,1,['simpl'],['simple']
Usability,"> I suggest that the grid constructor does not restrict the `z` topology then but instead the `HydrostaticFreeSurface` does so. Right?. That's fine with me, perhaps the error message will be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255:191,clear,clearer,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2372#issuecomment-1073394255,1,['clear'],['clearer']
Usability,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720:70,simpl,simpler,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720,2,['simpl'],"['simple', 'simpler']"
Usability,"> I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?. Yes for sure! It's probably simple enough to include directly in Oceananigans. We'd put it here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/StokesDrift.jl. @qingli411 note that our input is the Stokes shear, so I think the most convenient thing to have is the Stokes drift at every level. We can difference that between the top and bottom of a cell to get the ""finite volume averaged Stokes shear"". What do you think about that?. Perhaps it makes sense to start with the Harcourt and D'Asaro 2008 model then? I'll look into that and document what I find here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347869:234,simpl,simple,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347869,1,['simpl'],['simple']
Usability,"> I think it's definitely possible you've run across some kind of bug, I'm just having trouble figuring out what the bug might be because there's a lot going on in these examples. Got it! I'll try to simplify it more whenever I have time. > I think your syntax is wrong for KernelComputedField, because u_tot is not an AbstractField, it is an AbstractOperation. I'm passing `u_tot` as a field_dependency when calculating `Ro` and `Ri`, and those work fine! The PV calculation is the only that fails. Are you saying that `Ri` and `Ro` (and possibly `u_tot`?) should be passed with the `parameters` keyword? Or are you saying that I can't nest `KernelComputedField`s in the first place?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769359851:200,simpl,simplify,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769359851,1,['simpl'],['simplify']
Usability,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635:469,simpl,simple,469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635,2,['simpl'],"['simple', 'simplifies']"
Usability,> I think it's still working. I found an instance of it still being used here:. I meant for the specific instance that this issue refers to. > It matches the last line of the warning because that's the only line that changes from run to run. In particular the part tartarus-16 could be different it it ends up running on a different node:. My question is: why does matching the last line of the warning act to remove the whole warning? I am not asking about the intention of the filter. The intention is clear.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287767916:504,clear,clear,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287767916,1,['clear'],['clear']
Usability,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582:298,clear,clearer,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582,1,['clear'],['clearer']
Usability,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956:691,simpl,simple,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956,1,['simpl'],['simple']
Usability,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:291,simpl,simply,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,1,['simpl'],['simply']
Usability,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:915,simpl,simple,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502,1,['simpl'],['simple']
Usability,"> I think the purpose of versioning is to communicate to users and developers about bug fixes and API changes, and we should stick to that when motivating our decisions. I pretty much agree with @glwagner, and I'm not arguing against that. Just to be clear, I never said not to follow SemVer. I'm also not advocating to release v1.0 _now_. I'm just saying I see a reason to tag v1 before all the items in the wishlist are done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-885746605:251,clear,clear,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-885746605,1,['clear'],['clear']
Usability,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:33,intuit,intuitive,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708,1,['intuit'],['intuitive']
Usability,"> I think we kind of have a difference in the interface between particles and body forces. For tracers etc we always launch a kernel over every cell, get the arguments for the forcing at that point, and pass that to forcing functions. But for particles, the only way to add forcings (without making custom structs) is through the `custom_dynamics` where we just give the users forcing function all of the particles together and leave them to e.g. launch a kernel over all of them. Agree, but what point are you trying to make? I don't understand. > ; > It might be helpful to add this kind of forcing more similar to the first interface and ask users to define slip velocity functions with arbitrary arguments e.g. `w(x, y, z, t, $\rho$, d)`, and then we make the inside of the lagrangian particle advection kernel pass the correct particle properties to the function. This is basically what I was suggesting. > ; > I don't think it would be as simple to generalise particle forcings because we don't know what users want to do with the properties and in the current setup couldn't assume that they want every particle property integrated from some tendency function. I don't understand what you're trying to say. Can you elaborate or give an example?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891:945,simpl,simple,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819351891,1,['simpl'],['simple']
Usability,"> I think we should distinguish between output we need when we run the model, and output we may eventually provide to the broader community. Ideally, formats for both would be the same, but this may not be the best solution. E.g., netCDF has obvious disadvantages but is still widely used. That does not mean it should be the output format we use by default (although we may want to provide model statistics in netCDF in the end, if a few years from now this is still what everyone uses). So: separate the discussion of what is best for us now from what we should provide (e.g., in any CMIPx archive down the line). Zarr and HDF both seem worth discussing.; > ; > Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms. I agree. Ideally we'd support different formats (e.g. NetCDF, JLD2, HDF, Zarr, etc.) and have the option to use the best format for your application. We can already switch between output writers and choose which field(s)/diagnostics to output but we only do binary, NetCDF, and JLD for now. We were just focusing on NetCDF for our short-term needs, but this will definitely be a challenge for large problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978:1012,learn,learn,1012,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978,1,['learn'],['learn']
Usability,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412:149,clear,clearer,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412,1,['clear'],['clearer']
Usability,"> I think we should link to https://julialang.org/learning/getting-started/; > ; > and also take care not to repeat any material there. I actually think we should give a bit of the gist here too. A little overlap is okay because I think it helps users get an overview in one place before committing to install Oceananigans (lets them know how easy it is). Although I agree we should link Julia's ""getting started page"" too and what I wrote may be on the side of too much information. > @tomchor do you mind if I edit this PR?. Not at all. Go for it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262:50,learn,learning,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060054262,1,['learn'],['learning']
Usability,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761:360,clear,clear,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761,1,['clear'],['clear']
Usability,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541:1433,simpl,simple,1433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541,1,['simpl'],['simple']
Usability,"> I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. Yes I think a tutorial is what I meant. We can do this after the paper is done so we encapsulate what we have learnt.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377862921:199,learn,learnt,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377862921,1,['learn'],['learnt']
Usability,> I thought one of the advantages of Julia is that one can use easy to read notation. The notation for Re and Nu is anything but intuitive. Should we discuss how to improve on that?. Yes there's definitely room for improvement here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528833143:129,intuit,intuitive,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528833143,1,['intuit'],['intuitive']
Usability,"> I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. True, that PR does demonstrate convergence with time step! However we seem to rarely concern ourselves with time-stepping errors (apart from catastrophic instability), which I think is justified since spatial errors dominate in our simulations that are typically marginally-resolved in space by design. The stickier and harder question regards _time to solution_, which is what we really care about. It's stickier because it is fundamentally heuristic. For example since RK3 is a 3-stage time-stepper and AB2 is 1-stage, we need to be able to take time-steps that are 3 times longer with RK3. Theoretically, [AB2 is stable up to CFL=0.5](https://mitgcm.org/public/r2_manual/final/online_documents/node310.html) while RK3 is stable up to CFL=sqrt(3)=1.7 --- just barely achieving the ""3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendenc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394:36,clear,clearly,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394,1,['clear'],['clearly']
Usability,"> I tried to keep the plotting simple and barebones so 1. we don’t distract from the point of the example, which is to demonstrate Oceananigans usage (not to demonstrate plotting) and 2. so the examples are easy to maintain. I agree that colorbars are useful for interpreting output, but we don’t interpret output in the examples. True but using `pcolormesh` or `contourf` with a colorbar adds at most a few lines (for the 2D turbulence example). I believe most people don't actually read examples from start to finish and just quickly scroll through the text to skim the code and any plots. So having a plot with some labels might help to these potential users won't have to search the text to figure out what they're looking at. > There’s really too much code devoted to plotting as is, which we should fix by shipping plotting recipes with Oceananigans. That might help for the complicated plots although I think it'll be useful to keep some introductory examples that use the regular plotting functions so users can see how to go about plotting their own simulations without the use of our plotting recipes. > I thought the package name is Oceananigans.jl? What is convention?. Maybe getting rid of the backticks might help as it looks pretty distracting in the docs with backticks:; ![image](https://user-images.githubusercontent.com/20099589/67202162-ff667880-f3d5-11e9-80ae-afb4a90b3038.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544478257:31,simpl,simple,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544478257,1,['simpl'],['simple']
Usability,"> I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. This doesn't really need to be said! Of course, we want to be both clear, and consistent. Otherwise what are we doing here?. I'm not sure where the communication is inconsistent but please fix anything that's wrong. As for clarity, we can add a line to the page on background fields:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/. that says something like ""note that boundary conditions apply to the perturbation fields"". As for a convenience feature that applies boundary conditions to the _total_ rather than the perturbation fields: this would be a bit of work. It has seemed to me unnecessary, since if you know what the background fields are, you can apply any boundary condition you like to the perturbations. But convenience is laudable and friendly of course so we can consider it. I think we have to pass the background fields deep into `fill_halo_regions!` so that, eventually when halos are computed for `Gradient` or `Value` boundary conditions, the contribution of the background field can be included.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083499387:138,clear,clearly,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083499387,2,['clear'],"['clear', 'clearly']"
Usability,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:1013,intuit,intuition,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266,2,"['intuit', 'simpl']","['intuition', 'simpler']"
Usability,"> I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). Periodic topologies act according to periodic BC. We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; > ; > ```julia; > δyᵃᶜᵃ_nopenetration; > δxᶠᵃᵃ_noflux; > ```; > ; > ?. Two thoughts:; - ""penetration"" and ""flux"" are physical concepts. More precisely the operator returns zero when differenced across a `Bounded` direction.; - The operator names are ""mathematical"" rather than English, ie we use symbols like `δx`, rather than `x_difference`. I think we should try to strive to keep names in one category or another rather than blending them",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775922222:292,clear,clear,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775922222,1,['clear'],['clear']
Usability,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:832,simpl,simple,832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,1,['simpl'],['simple']
Usability,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:161,intuit,intuitive,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443,1,['intuit'],['intuitive']
Usability,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:19,feedback,feedback,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,2,"['clear', 'feedback']","['clearer', 'feedback']"
Usability,"> I'm a bit stumped. The error is; > ; > ```; > Test threw exception; > --; >   | Expression: advective_and_multiple_forcing(arch); >   | TaskFailedException; >   |  ; >   | nested task error: BoundsError; > ```; > ; > But I can't reproduce this locally.; > ; > I can fathom a `BoundsError` when we use a high-order advection scheme and our halos aren't big enough. Right now we check the ""model advection scheme"" and the grid halos to catch this issue, but we don't check the forcings. However, the test uses `halo = (3, 3, 3)` right now:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/791bb83e4c49386cc31292bf391762f1cd96bdee/test/test_forcings.jl#L115; > ; > On the other hand, if I time step a model for which I _know_ the halos are too small (locally), I don't get an error (even though I'd like to). So maybe there _is_ something fishy... I don't know how to help, but I am following to see if can learn something and maybe next time I can be a better helper.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547:910,learn,learn,910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1092154547,1,['learn'],['learn']
Usability,"> I'm assuming this is a relatively simple issue to resolve?. Unfortunately not due to our current algorithm that we inherited from MITgcm, but which we hope to change pretty soon. Right now Oceananigans splits up the pressure into the hydrostatic pressure anomaly and the non-hydrostatic pressure (see https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/pressure_decomposition/). MITgcm did this to facilitate easy switching between a hydrostatic mode and a non-hydrostatic mode: to turn a non-hydrostatic model into a hydrostatic one, just don't compute the non-hydrostatic pressure and recompute w from the continuity equation. But we feel we can use multiple dispatch to implement a hydrostatic model in Julia. This algorithm also requires extra memory (2 pressure fields instead of just 1). So we're hoping to change the algorithm to only use 1 pressure field and get rid of this pressure decomposition. The algorithm also makes it difficult to implement tilted gravity because the hydrostatic pressure anomaly is computed as. ```; pHY′ = ∫ buoyancy_perturbation dz from z=0 down to z=-Lz; ```. where `buoyancy_perturbation = g * (αT - βS)` if you're using a linear equation of state. So now if gravity is tilted it's not just a vertical integral. I'm actually not sure how to modify the vertical integral if gravity is tilted... Seemed easier to move away from this vertical integral by not decomposing pressure then we should be able to easily add in support for tilted gravity via a `bg⃗` term in the momentum equation where `g⃗ = g⃗(x, y, z)` can be whatever the user wants. Not sure if we have an issue discussing this change to the pressure decomposition, but if it doesn't exist then I can open one to track progress on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605:36,simpl,simple,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605,1,['simpl'],['simple']
Usability,"> I'm game to try. Should we modify the baroclinic adjustment problem or is there another benchmark you have in mind?. I think it makes sense to keep going with the baroclinic adjustment case!. To change the free surface you'll use. ```julia; free_surface = SplitExplicitFreeSurface(grid); ```. as a keyword argument in the model constructor. I think the default parameters for it make sense but @simone-silvestri can confirm. We can also try with `ExplicitFreeSurface()` which is even simpler, but in that case we'll have to modify `gravitational_acceleration` and the time step to get something that can complete in a reasonable amount of time. Btw if you paste the baroclinic adjustment script you are working with we can also check to make sure it's GPU compatible and possibly help simplify it further.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1950274069:486,simpl,simpler,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1950274069,2,['simpl'],"['simpler', 'simplify']"
Usability,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:1569,simpl,simple,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502,1,['simpl'],['simple']
Usability,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:86,simpl,simpler,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546,1,['simpl'],['simpler']
Usability,"> I'm not sure since I've been putting the external value as the condition which is kind of the same as e.g. when we specify a `Gradient` classification that the `condition` is then the value of the gradient and so the boundary point is some function of the `condition`.; > ; > This differs from `Open` as the `condition` doesn't directly specify the boundary value but instead is some function of it. I guess it would be more traditional to call this `Radiating` but I don't think that really explains what is going on.; > ; > It would be _possible_ to write a condition that did this, but I think it would make user specification of exterior values more complicated. I don't really see why it makes user specification more complicated. The discussion is purely about how the user API communicates and organizes information. I would argue that it's logical or clear to ""classify"" a radiating boundary condition as an ""open boundary condition"", because radiating boundary conditions imply that there is a non-trivial external state outside the prognostic domain. This differs from `Value` or `Gradient` which communicate the notion of either a solid wall or fixed external state. The alternative propose is to get rid of `Open` entirely, which we could do. That would be a ""flatter"" design. I think that a possible user workflow might involve 1) deciding what boundary conditions are ""Open"" versus not, and _then_ 2) deciding how to treat the open boundary numerically / physically. For example we might write ""we specify an open boundary with X method"". To me that implies including the word ""Open"" in the user API is important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979898600:861,clear,clear,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979898600,1,['clear'],['clear']
Usability,"> I'm okay with doing this but should we be worried that not all {Cell,Cell,Cell} fields are tracer fields and not all {Face,Cell,Cell} fields are u-velocity fields?. Defaults are not about correctness, but convenience --- the concept of a ""default"" implies that it is not always correct (otherwise we would not use the word ""default"", because it would never have to change). I think defaults can make user's lives simpler. I think there may be a lot of cases in field definition where boundary conditions are unused. > Hmmm, do you remember what you got stuck on?. Was just getting the dreaded ""dynamic function invocation"". It's worth a shot and documenting our progress. It seems unlikely there's a fundamental issue. We just have to figure it out. > But if you have two closures and you want to impose different diffusivity boundary conditions on each one then you can't do so by passing a named tuple to the model constructor. You can of course use DiffusivityFields to accomplish this. Okay thank you I understand. The issue here is the ability to use defaults. For that, we would have to require users to *name* closures when used in a tuple. . I am happy to leave this functionality as ""unsupported"". That said, I suspect we will have to confront this issue in the future if we want to do sophisticated GCM stuff, which can have complicated sets of turbulence closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589765930:415,simpl,simpler,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589765930,1,['simpl'],['simpler']
Usability,"> I'm starting to feel that it's better with ""add""... following the precept that functions are verbs and objects are nouns. I find `add_output!(simulation)` to be more intuitive in terms of creating the output and `output!(simulation)` actually outputs. (Thus, in the latter ""output"" is the verb, not the noun.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2414843995:168,intuit,intuitive,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2414843995,1,['intuit'],['intuitive']
Usability,"> I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?; > ; > Even this simpler:; > ; > ```julia; > using Oceananigans; > ; > grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; > z = (-1, 0),; > horizontal_direction_halo = 3); > ; > model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); > ```; > ; > took 10 min to run. Yes, it happened for me too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742939924:150,simpl,simpler,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742939924,1,['simpl'],['simpler']
Usability,"> I've also used a slightly simpler stretching function:; > ; > ```julia; > z_faces(k) = - Lz * (1 - tanh(s * (k - 1) / Nz) / tanh(s)); > ```; > ; > not sure what the difference between this and the one being used in this example is, or relative benefits. They're exactly the same, but I guess we should prefer your way since it's easier to understand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867217570:28,simpl,simpler,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867217570,1,['simpl'],['simpler']
Usability,"> If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message. Ah for sure. I was just remarking that if you need the eltype, you can use `AbstractArray{FT}` (or you can simply call `eltype`, which is preferred by [YASGuide](https://github.com/jrevels/YASGuide) --- type parameters should be used for dispatch only). I think it's ok if you keep `AbstractVector`. We can create a wrapper for Krylov.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962:252,simpl,simply,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2416855962,1,['simpl'],['simply']
Usability,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:50,simpl,simpler,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,1,['simpl'],['simpler']
Usability,"> If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up?. The user has to define `update_biogeochemical_state!` for the particular `BasicBiogeochemistry` they would like to use; if they want to compute light attenuation, they'll have to write that. However, I can envision child packages to Oceananigans providing more structured functionality for users. I think we just want to keep the Oceananigans interface as simple and general as possible since we expected it to be used by many different types of chemistry and biology models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999:494,simpl,simple,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335278999,1,['simpl'],['simple']
Usability,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:432,intuit,intuitive,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293,1,['intuit'],['intuitive']
Usability,"> If so, then we can have a generic KernelFunctionOperation that returns a 3D array of spacings, and specialize via dispatch wherever possible to return 2D and 1D arrays. Again I think this is a plotting issue and not a spacing issues. The strategy that our plotting extension takes is to drop singleton dimensions:. https://github.com/CliMA/Oceananigans.jl/blob/f2a8fb32251135f9cd9b230e0873f7bc1936f762/ext/OceananigansMakieExt.jl#L69-L83. maybe other approaches will be needed but this seems to be fairly intuitive so far",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450514567:507,intuit,intuitive,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450514567,1,['intuit'],['intuitive']
Usability,"> If that's the case, then the syntax; > ; > ```julia; > δ = ∂x(u) + ∂y(v); > ```; > ; > is valid on all grids --- isn't it?. Yes, I agree that it should be the case. . By the same rationale, the formulas for vorticity should also work on all grids, except maybe a cubed sphere?. I will experiment with the two approaches on the lat-lon grid and see what I can learn. . I will close this and return to it if I think there's a need.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136259842:361,learn,learn,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136259842,1,['learn'],['learn']
Usability,"> If the `FPlane` name really is supposed to be a vertical-component-only f-plane then it might make sense to implement it using the `NonTraditionalFPlane`.; > ; > Although, if I'm being honest, these names aren't helpful to me at all. If more people agree could we also think about renaming them? I'm not sure what names would be good here, but something with ""vertical"" and ""full""?; > ; > EDIT: Maybe we only need `FPlane` and that's it? Then passing `FPlane(f=0)` would default to `vertical_unit_vector=ZDirection()`. Although the name `vertical_unit_vector` might be inappropriate if you're trying to consider the horizontal component because you're close to the equator, not because your domain is tilted... It seems like we really just need one type, something like `BackgroundRotation`. . `FPlane` could be an alias that inserts `rotation_axis=ZDirection()` or something. But, aliases are bad for various reasons, mostly because you have to learn not only the ""real"" names of things, but their aliases too to understand code. Another point is that Oceanographers know what `FPlane` means. Long ago this was discussed (at that time, I advocated for `BackgroundRotation` or something similar), but it was rejected in favor of `FPlane` and friends. We can't have both `BackgroundRotation` and `FPlane` without an alias. We can even reuse `BackgroundRotation` for grids with a latitude-longitude coordinate system (by dispatching on `grid` and `coriolis` simultaneously).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885270896:948,learn,learn,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885270896,1,['learn'],['learn']
Usability,"> If you use the current IncompressibleModel without any tracers so the Boussinesq approximation doesn't come into play then isn't it truly an incompressible model?. It is, I agree with that. But then again, if you include a buoyancy model (which is the general case) then it's a Boussinesq model. . Also the first google result for ""boussinesq model"" gives the inexperienced user a wikipedia article that's quite clear (imo) in explaining explaining the model, so I think confusing new users wouldn't be much of a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827161847:414,clear,clear,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827161847,1,['clear'],['clear']
Usability,"> In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`). Ok to clarify you're saying we _should keep_ `diffusivity_fields` / `closure_fields`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064194104:37,simpl,simplicity,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064194104,1,['simpl'],['simplicity']
Usability,"> Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). A few ideas to make progress. * Attempt to measure a rate of convergence for this case with a resolution study?. * Implement both WENO and third-order reconstruction of vorticity to see what the difference is (perhaps measuring numerical dissipation). If we get nothing from WENO (or they exhibit similar dissipation somehow) then maybe we've learned something. On that last point, it'd be fun to support. ```julia; momentum_advection = VectorInvariant(vorticity=WENO5()); ```. or something. > (there is no viscosity!). I think we can still aim for stable simulations with zero explicit dissipation... see results on https://github.com/CliMA/GeophysicalDissipation.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060823690:582,learn,learned,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1060823690,1,['learn'],['learned']
Usability,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:116,clear,clears,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440,1,['clear'],['clears']
Usability,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:237,clear,clearly,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050,1,['clear'],['clearly']
Usability,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:678,simpl,simply,678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,1,['simpl'],['simply']
Usability,"> Interesting. You are plotting the pressure above. Is it possible to plot the components of the gradient of pressure?; > ; > The perssure is determined to within a constant and I am very curious to see of the pressure gradient also changes a lot. Yup, my first thought was that of the constant also. But as you can see in the snapshots, the gradient is also changing by a lot. Plus if it was only the constant that were changing, the std would remain the same, but it's clearly varying over many order of magnitude, which is why I didn't bother plotting the gradient in order to simplify diagnostics. In any case, here is dp/dx for the same simulation for future reference:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/fab112af-795b-45f4-a788-3886227c3ff2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102979711:471,clear,clearly,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102979711,2,"['clear', 'simpl']","['clearly', 'simplify']"
Usability,"> Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries. We definitely can do those things, I'm just not sure how it'll work with kernels. Unless I'm missing something:. ```julia; fx = 2rotation_rate * rotation_axis[1]; fy = 2rotation_rate * rotation_axis[2]; fz = 2rotation_rate * rotation_axis[3]; ```. and then to get `rotation_axis`:. ```julia; rotation_axis = [fx, fy, fz] ./ √(fx^2 + fy^2 + fz^2); ```. This would be kind of a big change though, no? Is it worth doing it in this PR?. Also, we'd need to make the difference between rotation rate and Coriolis frequency clear (meaning `f = 2rotation_rate`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887764088:850,clear,clear,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887764088,1,['clear'],['clear']
Usability,"> Is that a reason why you define the closure for the coarse_model?. There reason is that at the moment `NetCDFWriter` needs it to get some info on the `grid`. But as @glwagner and I pointed out, it's probably pretty easy to change `NetCDFWriter` to avoid that. I might try a PR soon that makes the simplest change possible and see it tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584:299,simpl,simplest,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584,1,['simpl'],['simplest']
Usability,"> Is this extra simplicity in the user interface worth the extra code to maintain?. Given the minor code changes required and the priority we place on user interface, I think so. > I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I do agree that this change means that more changes are required to port a script from having a `Flat` direction to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:16,simpl,simplicity,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,1,['simpl'],['simplicity']
Usability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555:540,clear,clearer,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555,1,['clear'],['clearer']
Usability,"> It could also be interesting to add this slip velocity to the convecting plankton example. I am developing an NPP model to run on Oceananigans, maybe instead of giving a new example, a could simply add the other terms on the plankton example. What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082511065:193,simpl,simply,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082511065,1,['simpl'],['simply']
Usability,"> It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether. Don't know if it's always possible but if we can avoid temporary variables by aggressively inlining all calculations, that would be cool. Every temporary field saved means being able to run a larger model on GPUs. We will always need a couple of temporary arrays so if we can't inline we can just try to share and reuse the temporary arrays as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396:35,simpl,simply,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396,1,['simpl'],['simply']
Usability,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:32,simpl,simpler,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,1,['simpl'],['simpler']
Usability,> It seemed quite easy but now all tests are broken for a weird reason sweat_smile. Very strange. I can't believe this one simple change would cause all these problems. Is there something else going on here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1403898162:123,simpl,simple,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1403898162,1,['simpl'],['simple']
Usability,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:301,simpl,simple,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085,1,['simpl'],['simple']
Usability,"> It would be a horizontal integral if op = +. But I don't see us needing any other operation so I could hard code in the addition (or just make it the default via a keyword argument) and rename it to horizontal_integral!. I should have added a docstring, yes. > I don't think we can or want a shared CPU/GPU version. I just mean a function `horizontal_integral` or `horizontal_sum` that works on both CPU and GPU. This function would compute the sum on the CPU in some simple manner if passed `Array` or compute the sum on the GPU using a kernel if passed `CuArray`. Make sense?. I still don't quite understand how the `accumulate` function works. Can you explain here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520542560:470,simpl,simple,470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520542560,1,['simpl'],['simple']
Usability,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:228,simpl,simplest,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['simpl'],['simplest']
Usability,"> It's also important to keep the kernel indexing intuitive, e.g. this kernel does things point-wise so it gets a triple for-loop, another kernel does things column-wise so it gets a double for-loop and a third unrolled inner loop, another only acts on the surface and bottom, etc. We need to adhere to a convention. To introduce `Tz` for 3D kernels, don't we have to change the 3D kernels to read. ```julia; @loop for k in (1:grid.Nz; (blockIdx().z - 1) * blockDim().z + threadIdx().z); @loop for j in (1:grid.Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:grid.Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); # kernel; ```. ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496554576:50,intuit,intuitive,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496554576,1,['intuit'],['intuitive']
Usability,"> It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to nothing? I did this for the abstract operations tests and they all passed. We should always use default boundary conditions for `grid` and the location, eg `Face` or `Cell` along each dimension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270269:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270269,1,['clear'],['clear']
Usability,"> Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget.; > ; > Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. I see. Did you try `Oceananigans.Fields.ConstantField`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766:13,clear,clear,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1483381766,1,['clear'],['clear']
Usability,"> Like @hdrake, I think we need a buoyancy background field to make the buoyancy (fluctuations) periodic, although we can probably get away without a background `v` field.; > ; > I can try removing the sponge layer, but the last time I tried I saw significant internal wave build up. I think the reason is that centrifugal-symmetric instabilities (of which we see a lot in this BBL example) are known to particularly efficient at exciting internal waves (compared to upper ocean convection, for example).; > ; > But I'll try it out and post the results. Sounds good. For the other boundary layer examples we don't use a sponge layer because the simulations are fairly short, I think. I realized after talking with @xiaozhour that it probably won't be simple to remove the background velocity field. The reason is that there is an (implicit) pressure gradient that maintains the flow. So, we either have to add this pressure gradient and a matching initial condition, or we have to use a background field for the velocity (using an initial condition `v=1` will produce an inertial oscillation, not a steady flow). With that consideration, it seems like it might probably simpler to use a background field. The main annoyance is the drag boundary condition, which requires explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893:751,simpl,simple,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974318893,2,['simpl'],"['simple', 'simpler']"
Usability,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:180,clear,clear,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650,1,['clear'],['clear']
Usability,"> Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull. Yes but since the object I'm suggesting is even smaller in memory than an integer (almost 0 in size except for `field_id` and possibly `z_indices`), why would you skip the intermediate abstraction? You're thinking that an integer is ""simple"" but its not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416:360,simpl,simple,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416,1,['simpl'],['simple']
Usability,"> Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing. Totally and to be clear, when we think about the economy of an interface, we are thinking about prototyping, illustrating, testing, not necessarily ""production"". I think ""production"" places fewer demands on the user interface and what we have now is ok for production. This PR mainly improves the small stuff. Also arguably it's more helpful for experienced than new users. > I think the name output! is a bit vague in what it does. Does it just output the current state of the simulation? Would add_output_writers! be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping add_callback! over renaming to callback!. I agree that with ""add"" and ""writer"" the meaning is cemented. I think it's important to recognize trade-offs though, because there is a limit to the benefit of being explicit (when things become hard to read or understand). I think in this case I accept that `output_writer!` is probably better than `ouput!`. I think prepending `add_` has a more marginal benefit (and is a little ugly) and that context is really what drives understanding of `callback!` / `add_callback!` (eg a schedule, etc). But this is certainly open for discussion. > Love this idea! Hoping that you can also pass e.g. (surface=(:, :, k), zonal=(:, 1, :), meridional=(1, :, :)) to get sliced_surface, sliced_zonal, and sliced_meridional. Yes for sure! In that example the keys ""xy"", ""xz"", etc would be names appended to the filename prefix. . > I think the default should be overwrite_existing = false just because the cost of overwriting and losing data can be very high. Do you run with this option? Curious because I never use it. I think the cost of losing data is actually usually very small, it's only in a small 1% of cases that the data is valuable. I think that's actually the key insight behi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364:171,clear,clear,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2376911364,2,['clear'],"['clear', 'clearer']"
Usability,"> Might be nice to have a `vertical_unit_vector` for both, right? Tilting the Coriolis force adds identical terms that are added when considering the full Coriolis force. Does it make sense to tilt the Coriolis force but retain the traditional approximation?. Just to be clear, you're saying that it might nice to have `vertical_unit_vector` for both traditional and non-traditional f-plane implementations? If so, I'm not sure.... I'd need to think more. Although with a tilting parameter `FPlane` can kinda do everything `NonTraditionalFPlane` can do and more, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885183732:271,clear,clear,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885183732,1,['clear'],['clear']
Usability,"> My bad, yes, \kappa is much better. Fixed. omg, **definitely** κ :). > Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. Yeap, why not. Start a PR. > @glwagner : I will send you a link to the overleaf document. Add me to that. Or better just start the PR and we can all edit there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874305803:177,feedback,feedback,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874305803,1,['feedback'],['feedback']
Usability,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659:235,clear,clearer,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659,1,['clear'],['clearer']
Usability,"> My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. If you're mostly interested in the oceanic boundary layer and don't need topography or a free surface, then Oceananigans probably has most of what you need. (See #443 if you're interested in surface physics.). 8192×3072×256 ~ 10¹⁰ grid points is out of our reach for the moment although our plan is to be able to run these super large simulations one day!. We're still limited to 1 GPU (with 16 or 32GB RAM) which lets us go up to ~5×10⁷ grid point. We could probably extend that to ~10⁸ grid points if we implement #98 but even then it would take 50-100 GPUs to reach 10¹⁰ grid points. We've mostly been running oceanic mixed layer simulations with a focus on vertical mixing so no need for a ton of horizontal resolution, but we do have horizontal mixing problems in mind at which point we'll need to start running on multiple GPUs with MPI. This is something we're starting to get serious about as we do need it ourselves. Not sure how coarse you can go but if you can go down to ~10⁸ grid points then maybe Oceananigans can be useful. If the factor of ~2 reduction in memory usage from #98 would be useful for you, let us know and we can look into implementing it. In general, I think we're happy to work together on features that you might need. I still need to work on some documentation to showcase all the model creation options, etc. so let us know if you're not sure how to impose a certain boundary condition or forcing, etc. Out of curiosity, what LES model are you currently using?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886:414,simpl,simplifications,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886,1,['simpl'],['simplifications']
Usability,"> My primitive logic: for a flux boundary condition, bc.calc() ""calculates"" the flux at the given grid point and time-step. For a ""value"" boundary condition, bc.calc() ""calculates"" the value of the boundary condition at the given grid point and time-step. But I agree it is a weird name. What is a better name?. It may not stand up to mathematical rigor but I still like `bc.impose()`. In your two examples, I feel like a flux is being _imposed_ and a value is being _imposed_. If `bc.calc()` calculates a number then it should be used as; ```julia; something = bc.calc(args...); ```; while `bc.impose` should be used like; ```julia; bc.impose!(args...); ```. But now we're just arguing semantics instead of what's important. > There are two issues: the backend, and the user interface. Maybe the title of this PR is confusing, because I think it's primarily about the backend. I think so too. API suggests more front-end. I also think discussing these dense and complicated issues (e.g. this PR and #120) among multiple busy people is difficult on GitHub. Little far ahead but maybe the Monday CliMA meetings are a good place to get high-level feedback?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439:1145,feedback,feedback,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472250439,1,['feedback'],['feedback']
Usability,"> Nice catch haha. Seems that ~30 other commits made it into this PR though?. Yes, sadly, I didn't start off on `master` and do a git pull. In retrospect, I should have trashed the branch and started again but oh well. All those are basically to restore to master. Sorry. I hope that I learned my lesson.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1528#issuecomment-811116295:286,learn,learned,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1528#issuecomment-811116295,1,['learn'],['learned']
Usability,"> Not necessarily relevant to this PR but I would rename the closures/ directory to turbulence_closures/ to make it clearer. I would also rename turbulence_closures.jl to TurbulenceClosures.jl as I think files defining a module have CamelCase filenames. I am ok with this, because there is possibility for confusion with the julia notion of a ""closure"". I think we should value conciseness a bit more though, in general...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-511418725:116,clear,clearer,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-511418725,1,['clear'],['clearer']
Usability,"> Not sure if I am missing something but first I think the user can just write; > ; > ```julia; > averaging=(1, 2); > ```. I considered taking that approach but I felt it made it a bit awkward to implement Lagrangian averaging in the future. That said, I do agree that my currently implementation is probably unnecessarily verbose. I think your suggestion below of `DimensionAveraging(dims=(1, 2))` is a good compromise. > ; > which would mean average over xy. Or if you want to be more verbose then; > ; > ```julia; > averaging=DimensionAveraging(dims=(1, 2)); > ```; > ; > or something.; > ; > Next for the average itself it seems you need; > ; > ```julia; > LM_op = KernelFunctionOperation{Center, Center, Center}(LᵢⱼMᵢⱼ_ccc, grid, u, v, w); > LM_avg = Field(Average(LM_op, averaging.dims)); > ```; > ; > In the constructor. Then you can just call `compute!(LM_avg)` without needing lots of additional dispatch. Ah, that's so simple! I'll implement that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2197150047:929,simpl,simple,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2197150047,1,['simpl'],['simple']
Usability,"> Not sure if I would have created a new turbulence_closure_imeplementations sub-directory but more organization can't hurt. What would you have done? Can you be more specific?. The purpose of creating the subdirectory is so that one is able to clearly see the source files that correspond to each closure implementation: `$ ls turbulence_closure_implementations` is more useful now. But I'm happy to change things, or raise an issue to plan some changes that do something better, if that is what you are suggesting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548736570:245,clear,clearly,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548736570,1,['clear'],['clearly']
Usability,"> Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. I hadn't realised that, I'll look into it before I work on this again. > What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines. > For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest.; > ; > Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR. Yeah, this makes sense, when I started doing this I thought it would be relatively simple, but then realised it's not. I would probably advocate for us to take this as a first draft and start again after discussion if this is something we go forward with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2451830235:634,feedback,feedback,634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2451830235,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,"> Ok, closing in! The last test is without an immersed boundary but with a bathymetry (you need to cap the bathymetry to something like -50m); > ; > If this works then we can focus all the attention to the immersed boundary. Just to be clear, the test I posted today was with an immersed boundary (continents) and a flat bottom. The previous test, what we called aquaplanet, was with no immersed boundary and boring flat topography. Could you clarify as to what you are suggesting? I was using the immersed boundary and am a bit confused. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073142216:236,clear,clear,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2073142216,1,['clear'],['clear']
Usability,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106:1275,simpl,simply,1275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106,1,['simpl'],['simply']
Usability,"> Okay, so I've got a way we could do this. When a user specifies an `AbstractTime` we can then use the type they've given to set the timestep type like:; > ; > ```julia; > clock = Clock{eltype(grid)}(time = DateTime(2020)); > ```. I think it'll work a little differently, because we will want the time-step to also be a period rather than a floating point. We don't support it yet, but we will have to convert the time-step to a floating point somewhere internally. It does look like this will affect the code you are about to write! But don't worry too much --- as long as you write clear, concise code we will be able to change it approprately in the future!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3508#issuecomment-1996014097:585,clear,clear,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3508#issuecomment-1996014097,1,['clear'],['clear']
Usability,"> On a side note, since you asked, I am going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. What GPU are you running on? You'll need an Nvidia GPU and the CUDA library installed. Installing Oceananigans through the Julia package manager should install all the required Julia package dependencies (but won't install CUDA itself). Are you getting any errors?. Hmmm, so there is a small caveat that `Nx` and `Ny` need to be multiples of 16 on the GPU right now, although you'd get an error about this. > Should I create another issue?. Hmmm yeah that might be a good idea just to keep each issue self-contained. > (I'm not sure how much you guys want to be involved in these debugging processes...). We're very interested in being involved with the debugging process! We're still in early development so I'd expect things to break quite often, and we still haven't ironed out all the bugs and usability issues. We've also mostly been using the model ourselves (hard to improve usability if you know all the internals haha), so if you're willing to report issues it would be a huge help with development!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740:975,usab,usability,975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539736740,2,['usab'],['usability']
Usability,"> On that branch you are still forming the `BinaryOperation` which is the problem. You also need to remove the `BinaryOperation`. If you open a PR we can work on it?. Sure, I'll open a new PR soon then!. But just to be clear, I totally get that the problem is that I'm still passing the binary operations. I kept them there because (if I understan correctly) if don't pass $\kappa_e$ in `DiffusivityFields()` then `model.diffusivity_fields` won't get populated, right? Or is your point that we don't have to populate `model.diffusivity_fields` for Smagorinsky?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419525329:219,clear,clear,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419525329,1,['clear'],['clear']
Usability,"> Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like. ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```. I vote for using the halo regions to satisfy boundary conditions rather than writing if-statements into the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500662671:135,simpl,simple,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500662671,1,['simpl'],['simple']
Usability,"> One thing that I think would be useful is to come up with one example to put in the docs about the choices of preconditioners and how to use it. We can perhaps use a simple example of a staircase convection to illustrate the point, advertising the FFT-preconditioned solver at the same time as well. I like this idea though I am not sure it should be an example. There are no other examples like that. We are sort of in the process of revamping the docs to add more ""tutorials"". For example, this is a tutorial on grids: https://clima.github.io/OceananigansDocumentation/stable/grids/. I think what you're proposing is a ""tutorial"" on pressure solvers. What do you think?. I think we probably should wait though. It'd be nice to publish a paper about the solver first, and then put what we learned from the paper into the tutorial.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861:168,simpl,simple,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377809861,2,"['learn', 'simpl']","['learned', 'simple']"
Usability,"> Only concern might be that by using Logging.global_logger, Oceananigans now hijacks the global logger and everything starts using it for logging. But maybe this isn't a big deal and we can revert behaviour at any time. I'm not passionate either way, but is it easy to simply avoid importing the macros associated with the global logger and defining them for a custom logger instead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674115587:270,simpl,simply,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674115587,1,['simpl'],['simply']
Usability,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:459,simpl,simple,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764,1,['simpl'],['simple']
Usability,"> P must be positive definite. WENO should guarantee that advection does not generate spurious minima, right? The boundary condition for phytoplankton are of no flux, so they should not generate negative values either. I am confused. WENO doesn't _strictly guarantee_ positivity (@ali-ramadhan showed that Gibbs phenomena can appear, especially in the presence of delta-function-like discontinuities that are narrower than the WENO stencil). But perhaps more to the point, we aren't using WENO in this example (simply because its a bit more expensive). We are using `UpwindBiasedFifthOrder` --- which does exhibit oscillatory errors (but far less than a centered scheme). @navidcy, does switching to WENO5 solve some of the problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723496722:511,simpl,simply,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723496722,1,['simpl'],['simply']
Usability,"> PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong. I've been accused of being too harsh with my words before in issues, so I try to be conservative with by adjectives whenever I can :). Thanks for the explanation! It makes perfect sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139763353:133,clear,clear,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139763353,1,['clear'],['clear']
Usability,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:680,clear,clear,680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827,1,['clear'],['clear']
Usability,> Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. very much agree.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711046398:87,clear,clearer,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711046398,1,['clear'],['clearer']
Usability,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:327,simpl,simple,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455,1,['simpl'],['simple']
Usability,"> Personally, when learning what a script is doing it's nice to execute it line by line to get to know the process. That's very useful to know. The workflow you're describing is similar to what @ali-ramadhan was recommending in the discussion on #1149 . @rcmusgrave also uses a similar approach to examples, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724722763:19,learn,learning,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724722763,1,['learn'],['learning']
Usability,"> Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > ; > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251:40,simpl,simply,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759433251,1,['simpl'],['simply']
Usability,"> Quickly looking at Lin 1997, they compare the results of their method with a finite volume (FV) method. Their method does better. I wonder if their FV method is at all similar to what the MITgcm uses?; > ; > Is it fair to say the first is easier and the second has the potential to be more accurate?. MITgcm does not use Lin 1997. Instead, they use vertical spacing from the _underlying_ grid (not the partial cell grid) to calculate the hydrostatic pressure. This somehow reduces the accuracy of the hydrostatic pressure calculation, but results in an approximation that does not have spurious pressure gradient errors. It's simple and effective. Lin 1997 _is_ a finite volume method. @glwagner and @francispoulin I think starting with Lin makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963:628,simpl,simple,628,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1087701963,1,['simpl'],['simple']
Usability,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:74,simpl,simpler,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399,1,['simpl'],['simpler']
Usability,"> Right now if you specify `prefix = cool_data` then you get a file `cool_data.jld2` before splitting.; > ; > But then when you reach `max_filesize` you get `cool_data_part1.jld2`, `cool_data_part2.jld2`, etc.; > ; > If we use filename with arbitrary extensions, then we need to ""infer"" the extension. We can do that by looking for the first `.` that appears in the string. But life is a bit simpler if we can just ask for the `prefix` / `name`, rather than name + extension. Ah, I wasn't aware that JLD2 writer split the output if the file got too big. In that case I agree with you that using `prefix` is simpler than `filename`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1030123384:392,simpl,simpler,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1030123384,2,['simpl'],['simpler']
Usability,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:207,intuit,intuitive,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717,1,['intuit'],['intuitive']
Usability,"> Same error... no idea what's happening since there are no more scaped characters. Would changing `r"".jld2""` to `raw"".jld2""` do anything?. error is in line 168 so I'm wondering if it's simply the docstring!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188:186,simpl,simply,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3113#issuecomment-1562014188,1,['simpl'],['simply']
Usability,"> Sent approval; the last major question is whether we should use `ZDirection()` and `::ZDirection` instead of `:z` and `::Val{:z}` -- and then `XDirection` and `YDirection`. Hmm, that's a good point. Honestly I have no opinion here since both are equally clear, so I'll defer to you/others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564811587:256,clear,clear,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1564811587,1,['clear'],['clear']
Usability,"> Shallow and deep trees makes sense. True we may not have an alternative implementation but we can compare the deep and shallow tree computations to get an idea. When I said ""we don't have an alternative implementation"" I should have actually said that for a ""deep"" tree, an alternative implementation to an abstract operation would be difficult to code. We definitely do have alternative implementations to abstract operations --- we can simply hand-code kernels as we have done many times in the past. The hand-coded kernel is the standard against which we should compare an abstractly-defined kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545896259:440,simpl,simply,440,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545896259,1,['simpl'],['simply']
Usability,"> Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. My two cents is that it might be better to add as much content as possible in one PR. I thinks docs PRs can be a bit painful. It's not as crucial either for docs updates that the PRs are tight and focused. I think it's simpler to keep things general for curvilinear grids than to assume constant cell spacings by the way. We should discuss 2D versus 3D a bit more. While 2D is simpler, we will almost certainly need 3D as well at some point (when we resolve #1679). So we can have a ""tutorial"" 2D section, and then a ""fully descriptive"" 3D development --- or we can just do 3D from the start.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303:106,feedback,feedback,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874268303,3,"['feedback', 'simpl']","['feedback', 'simpler']"
Usability,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532:86,simpl,simple,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532,1,['simpl'],['simple']
Usability,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:247,simpl,simpler,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960,1,['simpl'],['simpler']
Usability,"> Should we include the Stommel gyre? It seems there are simpler flow fields for an advection validation test (eg sin x sin y). How are we going to evaluate the thermal bubble validation? ""Not blowing up"" is pretty good, but I think we have decide that validation tests should be quantitative. Qualitative validation experiments can perhaps be put in `examples/`?. Yeah they're both ""temporary"" verification experiments that might be useful in the near future as we test advection schemes. Periodic advection is also a qualitative verification experiment. I think we should keep at least one interesting 2D advection verification to produce movies showing how different advection schemes behave. Hopefully we could embed all the movies in the docs so users can browse through them. I was thinking the Stommel gyre could be a good one (really I stole the idea from Glenn's animations) as the velocity does not go to zero at the western boundary/wall.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922:57,simpl,simpler,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922,1,['simpl'],['simpler']
Usability,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741:796,clear,clear,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741,2,"['clear', 'learn']","['clear', 'learned']"
Usability,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:495,simpl,simple,495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199,1,['simpl'],['simple']
Usability,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:594,clear,clear,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799,1,['clear'],['clear']
Usability,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:167,intuit,intuition,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,1,['intuit'],['intuition']
Usability,"> Something seemed to change with 0.81.1; > ; > <img alt=""image"" width=""928"" src=""https://user-images.githubusercontent.com/15271942/266183487-81cae28b-12ee-480f-b40c-1502701b97d5.png"">. That's because oftentimes I had to manually clear up the repo. That would imply creating an orphan branch and copying and committing all content back to this new orphan branch, force push, and then rename it to `gh-pages`. So the ""v0.8*"" is a manual commit message I had written while committing contents of `gh-pages` to the new orphan branch while the messages ""build based on ..."" are the automated commit messages by Documenter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161:231,clear,clear,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191#issuecomment-1711358161,1,['clear'],['clear']
Usability,"> Sorry I meant that we can now initialize field tuples (VelocityFields, TracerFields, etc.) with non-zero data. I updated the title. This change was important because it's required for checkpointing/restoring large model (implemented in #628). The field tuple constructors are further generalized in #631. Sounds good. Just for the record, `model.velocities` is just a named tuple, so if individual fields can be manually built with pre-allocated data, then so can the named tuples that hold velocity field data and tracer data. I suppose the change here is a function that achieves the same. If the current changes make the checkpointer code clearer, than I am for it. > fill_halo_regions! assumes field.data has a certain size consistent with the size of the grid. Let's be specific here. `fill_halo_regions!` does not assume anything about the ""size"" of data. Specifically, it invokes `getindex` on the property `parent` of `.data` at certain indices. Therefore such a method call must work for `.data`. In the case that `.data` is either a plain `Array` or a `CuArray`, we *know* from the properties of those types when such a `getindex` call for certain indicies will fail. Therefore, we should feel free to intercept such an error during `Field` construction. In other cases we cannot be sure that such a method will fail because we don't know how `getindex` works on `.parent` for arbitrary types. In the spirit of ""not assuming what we don't know"", we should opt to throw errors only in cases that we *know* an error should occur.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-587006980:644,clear,clearer,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-587006980,1,['clear'],['clearer']
Usability,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116:165,clear,clear,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116,1,['clear'],['clear']
Usability,"> Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. I think to implement this problem we should generalize our operators to be curvilinear in all three directions (thus permitting 2D curvilinearity in x-z), rather than attempting some rotation of the model / physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115:26,clear,clear,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814273115,2,['clear'],['clear']
Usability,"> Sounds like the plan is to switch to SolutionBoundaryConditions but that might involve more refactoring so maybe best left for another PR?. This is already done, because the model constructor calls the function `ModelBoundaryConditions` here:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/models.jl#L64. which then dispatches based on whether the argument `boundary_conditions` is a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/boundary_conditions.jl#L254. Thus in either case the model is constructed with a `ModelBoundaryConditions`. Edit: note that this is required for correct checkpointing, because the checkpointer passes a `ModelBoundaryConditions` to the model constructor, while we expect users to pass a `SolutionBoundaryConditions`. . The downside to this pattern is that the type of `model.boundary_conditions` will often be different than the keyword argument `boundary_conditions`. Hopefully this is not confusing or surprising... :-/ An alternative is perhaps to specifically delineate between them; ie change the keyword argument in the `Model` constructor to `solution_boundary_conditions`. However, something to consider is that the `tendency` and `pressure` fields of `ModelBoundaryConditions` should be uniquely determined by `SolutionBoundaryConditions`. Another factor to consider is that the pattern that keyword arguments correspond to fields is not a guaranteed julia pattern, it is simply an organizational principle that we feel is helpful. Thus I think we can break it occasionally if it improves the readability and simplicity of code. We should note the difference in the documentation to the `Model` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747:1584,simpl,simply,1584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747,2,['simpl'],"['simplicity', 'simply']"
Usability,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:998,clear,clear,998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045,1,['clear'],['clear']
Usability,"> Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y); > ; > This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code. What's the problem with split files?. Combining data into JLD2 files is not always possible is it? It would require the entirety of the output field to fit into the memory of one node. It also may not be efficient. Correct me if you think otherwise, but it seems we will always want to support split output, even if we also support combined output for distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530:185,simpl,simple,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896412530,1,['simpl'],['simple']
Usability,"> Sure, that's what I started to do but that requires `grid` to be a positional argument in many functions --- doable thought.; > Was wondering if we can infer the float type from `ψ`? What is `ψ`, a field? Something like `eltype(ψ)(ε)` would be enough?. We need `grid` as a positional argument for other reasons so I don't think a short-term solution like using `eltype` (which would just have to be undone in the near future) is a good solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873639102:401,undo,undone,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873639102,1,['undo'],['undone']
Usability,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707:209,learn,learn,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707,1,['learn'],['learn']
Usability,> Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?. It is not well documented actually. You can find some (albeit simple) explanation here https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/96JC02775. There is also an explanation in the docstrings,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162:26,clear,clear,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:583,learn,learna,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,2,"['clear', 'learn']","['clearly', 'learna']"
Usability,"> Thanks @glwagner for merging main into this branch.; > ; > I have returned to the global simulations and have learned something.; > ; > Using all the same parameters as before, I get `NaNs` after just over an hour.; > ; > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > ; > Do you think I should play around with other advection schemes, say some high order upwinding schemes?. Seems to me (but I don't know for sure) that the problem is more basic than the advection scheme...; You sure that the initial condition is consistent with bathymetry?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981129225:112,learn,learned,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981129225,1,['learn'],['learned']
Usability,"> Thanks @glwagner for merging main into this branch.; > ; > I have returned to the global simulations and have learned something.; > ; > Using all the same parameters as before, I get `NaNs` after just over an hour.; > ; > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > ; > Do you think I should play around with other advection schemes, say some high order upwinding schemes?. You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981243847:112,learn,learned,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981243847,1,['learn'],['learned']
Usability,"> Thanks for clarifying @glwagner .; > ; > I guess I need to learn how this is done in the other models. But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119920762:61,learn,learn,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119920762,1,['learn'],['learn']
Usability,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:276,simpl,simple,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,1,['simpl'],['simple']
Usability,"> That'd be a nice name, but alas we may want to apply the same terminology to the Coriolis force, since it would also need to be rotated with the domain. Yeah, I'm all in favor of having a simple name that is unified for `FPlane()` and `Buoyancy()`. My vote goes to `vertical_unit_vector`, as it is intuitive and works for both (with the trade-off that the vertical direction doesn't always align perfectly with the geopotential normal, but I think that's okay). I'll make the PR as soon as we agree on a name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770:190,simpl,simple,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496#issuecomment-802037770,2,"['intuit', 'simpl']","['intuitive', 'simple']"
Usability,"> That's because `==` falls back to `===`, right?. No idea! Like I said, it's not very intuitive behavior to me. You probably understand this way better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945891999:87,intuit,intuitive,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945891999,1,['intuit'],['intuitive']
Usability,"> That's what is already done with the run_diagnostic(model::Model, P::ProductProfile) function through multiple dispatch, but I can move it to a horizontal_integral function that can be reused. This function only works if you have a diagnostic though. I prefer to simply output the horizontal averages directly to file. How would I do that with the code in this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520550430:265,simpl,simply,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520550430,1,['simpl'],['simply']
Usability,"> That’s a good point. Unfortunately, we don’t know how to do that unfortunately. We tried bunch of things. I’ll give it a go. Can't we simply revert the commit/PR that introduced the issue for the time being?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1785633451:136,simpl,simply,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1785633451,1,['simpl'],['simply']
Usability,"> The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Thanks for the feedback @rafferrari. I talked to @leios earlier today and we think it shouldn't be a problem on the GPU. It's just straight up number crunching so it might benefit from being run on a GPU. But we can make sure by doing a quick benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076:443,feedback,feedback,443,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076,1,['feedback'],['feedback']
Usability,"> The change I suggested will still put the eddy viscosity into diffusivity_fields, and removes the eddy diffusivities (calculating them on the fly from Pr and eddy viscosity). Yes! Sorry I wasn't clear enough. I got that. I meant populate it with the diffuvisities specifically, so we're on the same page.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419719914:197,clear,clear,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419719914,1,['clear'],['clear']
Usability,"> The horizontal convection example with a boundary layer at the top is ideal for a VerticallyStretchedRectilinearGrid. I'm not sure I agree with this statement though. Just to be clear: I'm not saying I disagree, it's just not obvious to me that that's the case. From the videos in the example the viscous boundary layer seems pretty well-resolved to me (unless you're planning on changing the Pr (or Ra) number?). Plus the turbulence pretty much covers the whole domain, so I don't think we'd want a very coarse grid at the bottom. Is there a metric to look at to gauge the ""resolvedness"" of the viscous boundary layer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882572666:180,clear,clear,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882572666,1,['clear'],['clear']
Usability,"> The issue was that buoyancy was not reconstructed properly in the vertical. (There was also a problem with reconstructing buoyancy in the horizontal, but this only affects tilted domains.) So there was a bug and the discretization was incorrect. I'm aware of that. My point was more that I don't quite remember how the issue was manifested in the dynamics (the recognition of which was what prompted us to abandon https://github.com/CliMA/Oceananigans.jl/pull/1910). > @tomchor I updated the PR description. Feel free to edit it further. Thanks, that's a great detailed description. I only added one item to the advantages: simpler code and user interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197:626,simpl,simpler,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622165197,1,['simpl'],['simpler']
Usability,"> The line you're using is a bit more complicated --- do you just need to instantiate the environment?. The line I am using is simply what `.travis.yml` calls and the ""complication"" you are referring to probably is exactly the instantiation of the environment :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1072#issuecomment-710732230:127,simpl,simply,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072#issuecomment-710732230,1,['simpl'],['simply']
Usability,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:1337,clear,clear,1337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023,1,['clear'],['clear']
Usability,"> The movies don't play for me. Weird, they're playing for me on two different browsers... not sure what to do about that. > The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). True, but just to be clear, these simulations don't use any stretched grid direction, so I believe they don't use the tridiagonal solver, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734543228:393,clear,clear,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734543228,1,['clear'],['clear']
Usability,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020:549,simpl,simple,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020,1,['simpl'],['simple']
Usability,"> There's a lot of references to an 'embedded' model. Should we remove these @ali-ramadhan and simply call it a model ? It doesn't seem appropriate for documentation --- the model can be run without embedding it in anything. Yes, calling it a model and not an embedded model sounds like a good call. For context, the LaTeX notes I copied from envisioned this model being a super-parameterization or embedded model but this has changed since the notes were typeset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243:95,simpl,simply,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243,1,['simpl'],['simply']
Usability,"> Therefore, we should feel free to intercept such an error during `Field` construction. In other cases we cannot be sure that such a method will fail because we don't know how `getindex` works on `.parent` for arbitrary types. In the spirit of ""not assuming what we don't know"", we should opt to throw errors only in cases that we *know* an error should occur. Good point, I'll add a simple check for this during field creation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-588308119:385,simpl,simple,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-588308119,1,['simpl'],['simple']
Usability,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:198,clear,clearer,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,1,['clear'],['clearer']
Usability,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:28,simpl,simplify,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912,2,"['clear', 'simpl']","['clear', 'simplify']"
Usability,"> This apparently has to do with the fact that; > ; > ```julia; > julia> grid1.zᵃᵃᶜ === grid2.zᵃᵃᶜ; > false; > ; > julia> grid1.zᵃᵃᶠ === grid2.zᵃᵃᶠ; > false; > ```; > ; > I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:; > ; > ```julia; > julia> zeros(3) == zeros(3); > true; > ; > julia> zeros(3) === zeros(3); > false; > ```; > ; > which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: [JuliaLang/julia#4648](https://github.com/JuliaLang/julia/issues/4648). `===` means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. `==` is a weaker statement, usually about numerical equality. What's counter intuitive?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870:417,intuit,intuitive,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870,2,['intuit'],['intuitive']
Usability,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:306,intuit,intuitive,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,1,['intuit'],['intuitive']
Usability,"> This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`.; > ; > Any suggestions on what I should do to improve this are very welcome.; > ; > near_global_lat_lon_1440_600__fine_surface.mp4. I suggest changing the color scale to reveal more detail. You can set the limits of `colorrange` to something like 1/4 or 1/10 of the maximum(abs, vorticity).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127181498:202,learn,learn,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127181498,1,['learn'],['learn']
Usability,"> This function only works if you have a diagnostic though. I prefer to simply output the horizontal averages directly to file. How would I do that with the code in this PR?. If you don't want to use a diagnostic, you'd have to pre-allocate a 1D CuArray of size `1*1*Nz` for `Rxy` and a 2D CuArray of size `1*Ny*Nz` for `Rx`, then call `gpu_accumulate_xy!(Rxy, Rx, data, nothing, +)`, then save `Rxy` to disk. Seems like that would be less efficient as you'd have to pre-allocate memory every time you want to calculate a horizontal average. Which is why having a `VerticalProfile` diagnostic that takes care of this stuff is nice. We could write a wrapper function that allocates the arrays, and returns only the horizontal average.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786:72,simpl,simply,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520552786,1,['simpl'],['simply']
Usability,"> This is great, thanks @glwagner and @iuryt! Si Chen has been testing the code with a buouyant tracer added through forcing like this and he is running a comparison with Jenny Dingwall's simulations with Diablo. The extra `slip' velocity needs to vanish at the boundaries in order to conserve tracer, but then adding the advection term to the RHS forcing like @glwagner suggested seems to work and conserves tracer. We did something like this: . ```julia; lambda = 1 # decay scale for slip velocity in meters; for k=0:Nz+2; slip_vel.w[:,:,k].+=(tanh(max(-grid.zᵃᵃᶠ[k]/lambda,0))*tanh(max((grid.zᵃᵃᶠ[k]+Lz)/lambda,0))); end; ```. Makes sense!. Since there's a `dw/dz`, this means that the ""additional"" velocity field has divergence and thus tracer still not exactly conserved, right? But perhaps the divergence is small enough that it's almost conserved. Should we implement the advection differently (ie not using flux form) so that it's correct even when the velocity field is divergent? Another possibility is to have a flag, something like. ```julia; forcing = AdvectiveForcing(w=prescribed_w, flux_form=true); ```. Or, perhaps `divergent=true`, or something like that. Whatever's least surprising / intuitive...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863:1204,intuit,intuitive,1204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082403863,1,['intuit'],['intuitive']
Usability,"> This is great, though I'm wondering what it's role in the Oceananigans code base is. Is the intention to remove these bits once WENO is actually implemented in the code?. Yeah so the point of this PR was to test the WENO operators independently of Oceananigans.jl (also to play around with how advection schemes interact with different time steppers). The WENO operators were coded so that we can readily integrate them with the existing operators in `tracer_advection_operators`. So when an advection scheme abstraction is implemented and `weno.jl` is integrated into the main code, `verification/tracer_advection_1d/tracer_advection_1d.jl` can be converted into an Oceananigans.jl verification experiment. Right now it's just a WENO-5 verification experiment. > Why not?. Ah sorry I wasn't clear. I just didn't think running with CFL=4 would be possible in 3D. > I think the first course of action may be to do something similar to what we did for the nonlinear equation of state: implement a simple new advection scheme (even as simple as first order upwind?) for the purpose of designing an `Advection` abstraction. Agreed. First-order upwind is actually included in this PR; ```julia; @inline ∂x_advective_flux(i, Δx, u, ϕ, ::FirstOrderUpwind) =; max(u[i], 0) * (ϕ[i] - ϕ[i-1])/Δx + min(u[i], 0) * (ϕ[i+1] - ϕ[i])/Δx; ```; but it's so diffusive I don't know if we want to include it as an option (although it's up to the users, they may have a good reason to use first-order upwind).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751:794,clear,clear,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-579900751,3,"['clear', 'simpl']","['clear', 'simple']"
Usability,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:64,intuit,intuitive,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,3,"['intuit', 'simpl']","['intuitive', 'simpler']"
Usability,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231:221,clear,clear,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231,1,['clear'],['clear']
Usability,> This provides another reason to include all the `Nz+1` face data for face-centered fields. Will this feature be easy to implement in the future?. So that comment is actually outdated now. The Neumann boundary conditions can be built into the `Nz x Nz` tridiagonal system. > Pretty simple PR I think because it basically just adds a test (please confirm... ?). Yes. It was originally going to add a vertically stretched pressure solver but then I realized it would be much better code design to do the refactoring I did PR #589 first then add the solver in. So this PR just adds a test that shows you can implement a vertically stretched pressure solver using the `BatchedTridiagonalSolver`. > I think the test may be incorrectly named and can also be greatly simplified. I'm not sure if the test is 1) not achieving its intended purpose or 2) is over-complicated. Either way I think it should be cleaned up a bit before merging. Yes it is unfortunately over-complicated because there is no abstraction for a vertically stretched grid or a stretched pressure so they are implemented in the test itself. This test will be massively cleaned up in PR #543.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779:283,simpl,simple,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779,2,['simpl'],"['simple', 'simplified']"
Usability,"> Thought: we provide the sugary syntax `.top` and `.bottom` for boundary conditions in `z`. Should we also provide east, west, south, and north, and avoid using `.left` and `.right` in the code for full clarity?. Sounds like a good idea. I think `setbc!` and `getbc` aren't fully tested so also worth adding some simple tests there. I'll open an issue to document this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589873540:314,simpl,simple,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589873540,1,['simpl'],['simple']
Usability,"> To be clear, the bug was a lack of import for `CUDAnative` (not in the function `set!` for `CuArray`)?. Yes. I've changed the PR title accordingly but left the issue title as is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/635#issuecomment-588443139:8,clear,clear,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/635#issuecomment-588443139,1,['clear'],['clear']
Usability,"> To be specific, the permutation and forward 'factors' that are used for the GPU solver are defined in equation (16) and via W^k_{4N} in equation (4) and (19a)... ?. I had some difficulty figuring out exactly what to do from that paper so I ended up using the factors from these notes (which ended up working):; http://fourier.eng.hmc.edu/e161/lectures/dct/node2.html. > As for #102, I simply do not understand at first glance how to get from the eigentransform formulas in Schumann and Sweet (which involve sine and cosine) to the FFT (which involves a complex exponential). Am I missing something obvious? I feel that some non-trivial algebra is committed from every reference I have seen on this topic. The PoisFFT paper also makes the claim that this is possible but does not offer any justification or clarification. Yeah this stuff took us a while to figure out at the start. Not sure if I fully understand what you're referring to but I have _tedious_ derivations of Schumann & Sweet's equations (28) and (33) in my notebook that start from the FFTW definitions of the DFT and DCT.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496311017:387,simpl,simply,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496311017,1,['simpl'],['simply']
Usability,"> True but using pcolormesh or contourf with a colorbar adds at most a few lines (for the 2D turbulence example). It was a conscious choice on my part (not laziness) to use `imshow` rather than `pcolormesh` for exactly the purpose of eliminating ""a few lines"". I reluctantly added the grid in some of the other examples, in part because I did not want to mislead about the grid locations of `w` and tracers (possibly we can reduce plotting in the other examples too, which would be desirable). . Note that the *quantity* of lines is not the only issue; the issue is that one cannot ignore any lines when reading a code, so that each line of code has the potential to distract / confuse and thus should be absolutely meaningful and clear. This issue is especially acute for users who may already be stressed by interpreting code in an unfamiliar language. If we could fence parts of the code off and say ""don't read this part because its just for plotting"", we could maybe do that, but I think it's strange. Better in my opinion to keep plotting as minimalistic as possible to maximize readability. I really think the value of an example is a strongly diminishing function of its number of lines and its syntactical complexity. I think plotting could be important (or very important) if the plot output is crucial to the value of an example. This could be the case if we want to demonstrate the physics of the code (and I think this could be a good idea). At the moment, our examples do not explain the physics or physical motivation behind the examples. Instead, I designed the examples to be utilitarian to demonstrate valid syntax patterns for setting up a model. The physical aspects of the examples is incidental and not explained or justified (though I do think that for users who understand the physics, this ""extra sugar"" could be useful --- while causing no harm to users who do not understand the physics). Thus most of the plots simply demonstrate that the code ""did something"". They don't s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793:731,clear,clear,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793,1,['clear'],['clear']
Usability,"> True. Although I wasn't able to reproduce the failing test results in any of the several GPUs I tried (they were either Tesla V100s or Quadro GP100). Every single time I tried to run GPU tests locally, they passed. Is it possible that the tests are running on a GPU that simply isn't supported anymore by one of the packages?. Here's GPU + driver info. ```; glwagner@sverdrup:~$ nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Sun Feb 5 17:58:59 2023; Driver Version : 465.27; CUDA Version : 11.3. Attached GPUs : 1; GPU 00000000:82:00.0; Product Name : NVIDIA Quadro P6000; Product Brand : Quadro; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418288880:273,simpl,simply,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900#issuecomment-1418288880,1,['simpl'],['simply']
Usability,"> Unfortunately, I'm not entirely clear how to dispatch. Rather than. ```; cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid). ```. as posted abvove, you'll need to write. ```julia; cell_advection_timescale(model::ShallowWaterModel) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762963700:34,clear,clear,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762963700,1,['clear'],['clear']
Usability,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045:46,clear,clear,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045,1,['clear'],['clear']
Usability,"> We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?. I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888381697:213,clear,clear,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888381697,1,['clear'],['clear']
Usability,"> We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. That's what @whitleyv and I found also on #2275. I agree that may be better left for another PR...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269:5,clear,clearly,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105075269,1,['clear'],['clearly']
Usability,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:266,simpl,simplify,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483,1,['simpl'],['simplify']
Usability,"> We could also use `AndSchedule` (rather than `AllSchedule`) and `OrSchedule` (rather than `AnySchedule`). ""and"" / ""or"" refer to the underlying conditionals that are used in the reductions `all` / `any`. Is this easier to understand (I'm not sure)?. I think the `AndSchedule` and `OrSchedule` notation is clearer (or at least more explicit), so I'm leaning toward that one. But I don't feel strongly anyway so feel free to merge this whenever you're happy!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088#issuecomment-991887660:306,clear,clearer,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088#issuecomment-991887660,1,['clear'],['clearer']
Usability,"> We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag.; > ; > What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at. I don't follow. You have all of that information if you simply store the `HaloFillEvents` in a vector. Maybe you can't use the ""length"" but surely you can compute the number needed, which is currently stored as a ""counter"". You can also store the pointer to the field itself rather than an ""id"" / number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287:865,simpl,simply,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299132287,1,['simpl'],['simply']
Usability,> We could further simplify the time stepping code if we adapt the Field abstraction to be GPU compatible (#298). Just a note: I attempted this while working on abstract operations and was unable to solve the problem. But we are using new versions of julia + cuda tools all the time so it is / will be worth revisiting,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716:19,simpl,simplify,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716,1,['simpl'],['simplify']
Usability,"> We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Yes to be clear I should have said that I'm just advocating for printing warnings, not throwing errors. Users should be able to run whatever they want. I would say that these warnings make the software more useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731:224,clear,clear,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796846731,1,['clear'],['clear']
Usability,"> We probably should make these types. I like that idea! As simple as. ```julia; abstract type Device end; struct CPU <: Device end; struct GPU <: Device end; ```. in `GPUifyloops.jl`? That might make the code *slightly* faster too, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/103#issuecomment-469085721:60,simpl,simple,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/103#issuecomment-469085721,1,['simpl'],['simple']
Usability,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496:442,feedback,feedback,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496,1,['feedback'],['feedback']
Usability,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:807,clear,clearer,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,1,['clear'],['clearer']
Usability,"> We've borrowed heavily from other projects in putting that together, so by all means feel free to borrow! I have no idea how/if the license applies to a Contributor's guide. Thank you!. Also thanks @suyashbire1 for catching the typos!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/436#issuecomment-537275083:169,guid,guide,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436#issuecomment-537275083,1,['guid'],['guide']
Usability,"> We've mostly been concerned with surface ocean physics so naively it would seem nice to have the surface not be a halo cell. Your suggestion seems more to change indexing behavior rather than convention for halos --- but maybe thats not true given that we use the halos more as ghost points now, rather than overlap regions for MPI stuff, etc. Presumably, we could simply *define* the `i=N+1` point for fields on faces as ""within"" the domain, and define the points outside of `i=1:N+1` as halo points. This is a convention of our halo regions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542228588:367,simpl,simply,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542228588,1,['simpl'],['simply']
Usability,"> What are the differences?. I haven't plotted/analyzed the solutions for the regression tests carefully yet (tbh I'm not familiar yet with how the regression tests work and how the data is stored), but I have carefully compared my own simulations and a couple of the examples using `main` and this branch. The only differences I see are the usual turbulence IC ""issue"" where small disturbances in the flow amplify and lead to a different solution (pointwise speaking) but with the same statistics, qualitative behavior, etc. Given my unfamiliarity with the regression tests I'm not sure how to proceed solving the tests. So I'd appreciate some guidance here on how to move forward to get all the tests passing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1558355827:645,guid,guidance,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1558355827,1,['guid'],['guidance']
Usability,"> What bit of the code do you think needs to be modified?. Good question! I think here:. https://github.com/CliMA/Oceananigans.jl/blob/79676db7707e1f4c4cb7d21b0924562d36b2790f/src/Fields/broadcasting_abstract_fields.jl#L20-L22. Here's how we figure that out. First we use `Meta.@lower` to find the code that runs when we use `.=`:. ```julia; julia> Meta.@lower c .= c0; :($(Expr(:thunk, CodeInfo(; @ none within `top-level scope'; 1 ─ %1 = Base.broadcasted(Base.identity, c0); │ %2 = Base.materialize!(c, %1); └── return %2; )))); ```. Now we can build the operation and use `@which` to figure out what it calls:. ```julia; julia> bc = Base.broadcasted(Base.identity, c0); Base.Broadcast.Broadcasted(identity, ([0.9778532419793966]. [0.5210723026166955],)). julia> Base.materialize!(c, bc). julia> @which Base.materialize!(c, bc); materialize!(dest::Oceananigans.Fields.AbstractField, bc::Base.Broadcast.Broadcasted{var""#s183"", Axes, F, Args} where {var""#s183""<:Base.Broadcast.DefaultArrayStyle, Axes, F, Args<:Tuple}) in Oceananigans.Fields at /Users/gregorywagner/Projects/Oceananigans.jl/src/Fields/broadcasting_abstract_fields.jl:21; ```. The indicated line is the one I've posted. Might be as simple as defining. ```julia; @inline Base.Broadcast.materialize!(dest::AbstractField, bc::Broadcasted{<:DefaultArrayStyle}) =; Base.Broadcast.materialize!(interior(dest), bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902680649:1198,simpl,simple,1198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902680649,1,['simpl'],['simple']
Usability,> What do you mean by cleaner code? You mean `update_state!`? We need all of these functions still for the hydrostatic model so I don't think on the whole there's much of a change to the source code. I'm referring to the fact that dealing with just one pressure makes for cleaner/simpler code in general. But feel free to remove that statement if you don't agree.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622336006:280,simpl,simpler,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1622336006,1,['simpl'],['simpler']
Usability,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047:178,clear,clear,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047,1,['clear'],['clear']
Usability,"> What if we allowed the z kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces. I like this option!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813508041:123,clear,clearly,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813508041,1,['clear'],['clearly']
Usability,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:249,clear,clear,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267,1,['clear'],['clear']
Usability,"> What is the limitation you're referring to?. I'm referring to the fact that if you calculate a new quantity inside the kernel and then try to differentiate it the differentiation will fail because the new quantity will be a number and not a field. At least that's what I understood is happening in the piece of code below based on your feedback:. ```julia; wp = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k]; ```. Also I'm closing the issue since my I've found a workaround to it based on your comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786855273:338,feedback,feedback,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786855273,1,['feedback'],['feedback']
Usability,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382:138,clear,clear,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382,1,['clear'],['clear']
Usability,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:1118,clear,clear,1118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['clear'],['clear']
Usability,"> What would you have done? Can you be more specific?; >; > The purpose of creating the subdirectory is so that one is able to clearly see the source files that correspond to each closure implementation: `$ ls turbulence_closure_implementations` is more useful now. Sorry, yeah my ""code review"" wasn't very useful. I guess it wasn't clear to me that it provided additional code organization but perhaps you had some ideas for the future where a `turbulence_closures_imeplementations` subdirectory is helpful. I feel that users will learn about the turbulence closures from the documentation, but perhaps the subdirectory is nice if you want to look at the implementations. I'm okay with either approach.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548755809:127,clear,clearly,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515#issuecomment-548755809,3,"['clear', 'learn']","['clear', 'clearly', 'learn']"
Usability,"> What's the motivation for using a macro rather than multiple dispatch?. The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:179,simpl,simplifying,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,2,"['clear', 'simpl']","['clear', 'simplifying']"
Usability,> What's the point?. Only to benchmark against the examples before you simplified them to see how faster the docs built. The other pr also includes a simpler bci example now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591:71,simpl,simplified,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583172591,2,['simpl'],"['simpler', 'simplified']"
Usability,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:393,simpl,simply,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['simpl'],['simply']
Usability,"> When preparing a markdown document, it is convenient to view it in the pretty form, as one does in latex. Are there any markdown viewers that people might recommend for linux? If not no big deal, I will learn to use Documenter but that sounds like it might be a bit slow as you have to run code to compile it, but maybe I'm wrong. Ah yes it's quite painful :(. I guess it's not enough to look at the formatted Markdown as Documenter.jl might have to process it to add in any cross-links, references, citations, results from code blocks, math, etc. So usually when I work on documentation I have a REPL open to run `make.jl` so I can look at my changes (first time is slow but subsequent runs are decently fast). But this is still slow and it's annoying because I have to disable building the examples by commenting them out (examples run as part of building the documentation). There must be a better way... I'll ask on the #documentation channel on the Julia Slack to see if anyone has a better workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725553229:205,learn,learn,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725553229,1,['learn'],['learn']
Usability,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477:554,intuit,intuitive,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477,1,['intuit'],['intuitive']
Usability,"> Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over?. Yeah I think it would be easiest to start from a clean PR. Most of the code changes were to get the timestep in but adding it to the clock like you've suggested does seem like the most straightforward way too it. Are you happy for both of these to be one PR?. > I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an analytical solution like a mode-1 internal wave as the external state. This sounds sensible. . To keep the conversation linked I'll reset this branch to main and then add the changes again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994671401:542,simpl,simple,542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994671401,1,['simpl'],['simple']
Usability,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:549,simpl,simplifying,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['simpl'],['simplifying']
Usability,"> Where is the halo filling code?. Something like:; ```julia; @inline function _fill_west_open_halo!(j, k, grid, u, bc::PAOBC, loc, clock, model_fields); Δt = clock.last_stage_Δt. Δt = ifelse(isinf(Δt), 0, Δt). Δx = xspacing(1, j, k, grid, Face(), Center(), Center()). C = getbc(bc, j, k, grid, clock model_fields). u₀ⁿ = @inbounds u[0, j, k]; u₁ⁿ⁺¹ = @inbounds u[2, j, k]. C = min(0, max(1, Δt / Δx * C)). @inbounds u[1, j, k] = (u₀ⁿ - C * u₁ⁿ⁺¹) / (1 - C); end; ```. This is a simplification (won't work if the flow is inwards) but I'll link when I put it on GH.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389512033:479,simpl,simplification,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389512033,1,['simpl'],['simplification']
Usability,"> While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2\*2\*5\*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who *do* use codes that rely *heavily* on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). > Just a note that if we want to reuse `model.metadata.arch` with GPUifyLoops.jl then the options should be `:CPU` and `:GPU` (instead of `:cpu:` and `:gpu` which is what `ModelMetadata` currently uses) as I believe GPUifyLoops.jl expects ""capitalized"" Symbols. I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848:373,simpl,simplified,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848,1,['simpl'],['simplified']
Usability,"> Why (or when) did we change the pattern of `FT(number)` to `convert(FT, number)` (I actually prefer the former but I am ok changing it). I think it's clearer. If it appears 20 times in 3-4 lines (like, e.g. in https://github.com/CliMA/Oceananigans.jl/blob/c030aac826215bdcbdaa942f2832fa4ba16ade97/src/Advection/multi_dimensional_reconstruction.jl#L50-L58) then `FT(number)` is fine! But if it's just an isolated incident then convert is more verbose sort of like saying in English what is happening.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1605896632:152,clear,clearer,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1605896632,1,['clear'],['clearer']
Usability,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938:251,intuit,intuition,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938,1,['intuit'],['intuition']
Usability,"> With this change the whole pressure field is found through the nonhydrostatic solve. This seems like a very minor change to the temporal discretization, but it does cause the regression tests to fail (and I think @tomchor noticed some differences in the solution for ocean problems --- maybe there was a bit more noise?). The video here: https://clima.github.io/OceananigansDocumentation/previews/PR1910/generated/internal_wave/; (using the preview from https://github.com/CliMA/Oceananigans.jl/pull/1910) is what more clearly illustrates the differences. The difference is more subtle in the other examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113:521,clear,clearly,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1107074113,1,['clear'],['clearly']
Usability,"> Won't this prevent us from doing simple stuff like creating a grid with size (1, 1, 1) that has the default halos -- (3, 3, 3)?; > ; > It's better to use `map` than broadcasting btw. How can I use map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002638223:35,simpl,simple,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002638223,1,['simpl'],['simple']
Usability,"> Would also be useful to have a function (ie, parentdata) that returns a view over the parent. Decided to go with `underlying_data(::Field)` as it's a clearer name than `parent`, and I think it's a little different from `Base.parent`, but I'm not opposed to overloading `Base.parent`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487737:152,clear,clearer,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487737,1,['clear'],['clearer']
Usability,"> Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too.; > ; > Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of ϕn+1 (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:; > ; > `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,; > ; > where 0<Ub<1, but conceivably it could be something along the lines of unwinding both ways like:; > ; > `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`; > ; > Perhaps if we change to:; > ; > ```julia; > struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; > inflow_speed :: IS; > outflow_speed :: OS; > end; > ```; > ; > then we can make it the general form:; > ; > ϕin+1=(1−Ui−Uo)ϕn+Uiϕe+Uoϕi−1n; > ; > with 0<Ui,Uo<1 and only Ui or Uo can be non-zero. Could this be formulated as a condition, using the `Open` classification?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979243985:222,simpl,simplest,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979243985,1,['simpl'],['simplest']
Usability,"> Yeah that would be a good idea, although not sure what a good test would be. Double diffusive convection?. Double diffusion doesn't require a nonlinear equation of state (it requires two tracers with different diffusivities, which we actually do not currently support). But perhaps there is a simple cabbeling example that we can come up with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533089659:295,simpl,simple,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533089659,1,['simpl'],['simple']
Usability,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:548,simpl,simple,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627,1,['simpl'],['simple']
Usability,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396:43,simpl,simple,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396,1,['simpl'],['simple']
Usability,"> Yeah yeah, that makes sense now.; > ; > I think storing them together would be a lot harder when the infrastructure for arbitrary external states is already set up for conditions, so I'm not sure it's worth the tradeoff. It's kind of the same principle as gradient boundary conditions where the `condition` is some external information, and then `Gradient` specifies what is done with it to set the boundary point. But yeah I would be interested in what @simone-silvestri has to say. I really fail to understand how either decision makes things harder. From my point of view it's simply about how the code reads. Whenever we use a boundary condition, we have all the information available to us. Can you please explain why you think that this decision would affect what we are able to achieve?. Consider that this is the only difference between the two options:. ```julia; # option 1; bc.classification.matching_scheme. # option 2; bc.condition.matching_scheme; ```. How is it possible for this to affect how we achieve anything? We never have the `condition` separate from the `classification`. We always have them together.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918:582,simpl,simply,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1986572918,1,['simpl'],['simply']
Usability,"> Yeah, I've done some tests here: [#3646 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101); > The 1D test is consistent with the analytical solution, which works great!. @liuchihl, I think @navidcy is asking about smaller unit tests that could be run in Continuous Integration (CI) to automatically test the package whenever any changes get made. The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of $\text{Flux} = - \kappa \partial_{z} c$ at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950:389,simpl,simplest,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950,1,['simpl'],['simplest']
Usability,"> Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. Yeah, definitely not the clearest name... but if it's standard I guess it's good to keep it. This sounds like it's unambiguously positive though! Nice contribution",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885853182:120,clear,clearest,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885853182,1,['clear'],['clearest']
Usability,"> Yes I did. The issue still persists with all advection schemes I've tried so far and with any ""reasonable"" value of molecular diffusion. Maybe I wasn't clear, the point is that if the dynamics are linear or small-amplitude then advection doesn't play a role; it wouldn't matter what advection scheme you use. The term is small. Does hyperviscosity / hyperdiffusion allow stable simulations with non-trivial dynamics?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517987325:154,clear,clear,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517987325,1,['clear'],['clear']
Usability,"> Yes, that seems promising! For some problems of that nature we have recommended that people write functions to interpolate their discrete data, since one can then change resolution seamlessly... but perhaps there's a case where writing an interpolator doesn't make sense or is too cumbersome for a simple setup. 🤔. Writing an interpolator function would certainly be the most elegant way but some user might already be used to other regridding tools (like nco) and would prefer to read in some fields?. A simple fun example for using array inputs:. Prepare a tracer field by backward advecting the attached image or a logo in a Stommel gyre. Save the distorted image and now prepare the example using this distorted image as the initial condition for a forward advection :-). More seriously you could do the example including backward and forward integration to show the quality difference of several advection schemes. ![image](https://user-images.githubusercontent.com/19711382/118604859-ef7f6800-b7b5-11eb-87de-98934b4df17d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736:300,simpl,simple,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842903736,2,['simpl'],['simple']
Usability,"> Yes. Given the derivation I posted, and what @glwagner said, it seems like we want to be using the velocity at an edge not the cell-averaged values, which is what we are storing as fields. But I could be missing something here. I think we are making a particular choice: because we are using a staggered grid, we can reconstruct the velocity field at tracer cell interfaces simply be evaluating the cell-averaged velocity field there. Perhaps this reconstruction has a particular order of accuracy (eg second-order?) I'm not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567:376,simpl,simply,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874266567,1,['simpl'],['simply']
Usability,"> You can also accumulate the time-average on the CPU. Just to be clear though, I have plenty of 3D spatial (volume) averages, but no time-averages on my runs! I know the time-averaging does take more memory because of the accumulation process, but the spatial average is kind of a surprise for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301495852:66,clear,clear,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301495852,1,['clear'],['clear']
Usability,"> You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews? That's great! That would work amazingly. Do you know how to do this weekly schedule? (Then we can also do it for ClimaOcean Docs repo, etc!). Yes, have a look [here](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#schedule) to learn how to run a GitHub action on a schedule",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308892652:64,clear,clear,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308892652,2,"['clear', 'learn']","['clear', 'learn']"
Usability,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:866,simpl,simpler,866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461,1,['simpl'],['simpler']
Usability,"> You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. I'm not sure what the best approach is for the code. Also, I'm happy to change the docs to be consistent after we agree on what to do, but I'd rather not be the one changing the code right now (if we do decide to change it). That would require me to spend a considerable amount of time learning how to contribute to Oceananigans given that I've never started a project in Julia or contributed to a repo that wasn't my own).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363:183,clear,clear,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-747485363,2,"['clear', 'learn']","['clear', 'learning']"
Usability,"> You've pointed out here that the docs are inconsistent, so they must be changed. But we could change notation in both the code and the docs if we think it will make either one more clear. So, I thought about this a little more, and I do think that the notation used in the code and the docs could change to something more accurate and consistent. Right now, if I understand correctly, the code considers `ν_sgs` to model the action of eddies, `v` to be molecular diffusion, and `v_e` to be the sum of both:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/verstappen_anisotropic_minimum_dissipation.jl#L135. However, a better way of naming thing (which both the docs and code could follow) would be . - take `ν_e` (or `ν_eddy` if you prefer) to be the turbulent closure alone. Because that is meant to model _exclusively_ the action of eddies, so the name makes sense.; - `ν` could continue being the molecular diffusivity (we could even change it to `ν_m` or `ν_molec` to be more explicit); - `ν_sgs` is then `ν_eddy` + `ν_molec`, since this is generally what turbulence literature uses. And it makes sense, since both unresolved eddies and molecular diffusion are processes that happen at the sub-grid scales. This would require changing nomenclature in both the code and the docs, unfortunately, but the upside is that is doesn't require any change in the programming itself (it would have to change if we separated eddy and molecular viscosities). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-774500558:183,clear,clear,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-774500558,1,['clear'],['clear']
Usability,"> ```julia; > julia> using CUDA; CUDA.allowscalar(true); > ; > julia> model.velocities.u.data; > ```. This also isn't working for me now. Although I'm sure it did work at some point because I've tested this. I'm okay removing parts of this page this and linking to some CUDA docs. What led me to write that instead of referring to a link is that I don't find the [Julia GPU docs](https://juliagpu.org/cuda/) very helpful and couldn't find a docs page that explained the differences very clearly. I still can't, actually, but if anyone can suggest a page I also think it's best to just link to that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190:487,clear,clearly,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060811190,1,['clear'],['clearly']
Usability,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:658,simpl,simple,658,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['simpl'],['simple']
Usability,"> a better approach for the horizontal convection example is to save halo regions using `with_halos=true` when building the output writer. Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?; https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/examples/horizontal_convection.jl#L153-L157. It seems like this is indeed saving grids with halos, but erroneously filling them with zeros rather than the correct values? Is the intended behavior that output writers automatically call `fill_halo_region!` before saving when `with_halos=true`? That would be an intuitive enough API, even if the default was still `with_halos=false`, but I think separate from this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689073910:644,intuit,intuitive,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689073910,1,['intuit'],['intuitive']
Usability,"> an active counter that keeps track of how many communications are active. Why would you not simply keep track of the communications themselves, rather than just the _number_? There's no price to keeping a list of the events versus the number of them active so I don't understand why you throw away that info.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299019160:94,simpl,simply,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299019160,1,['simpl'],['simply']
Usability,"> and we'll only have to dispatch on one type instead of three. I guess the point of this design is to simplify more generalized dispatch by ""unfusing"" the three directions. The solution you're proposing is simply returning to what we were doing before, right?. Note one immediate advantage: the `nodes` function now works with *any* field (and the implementation is actually less code than before). We lose this feature and must return to dispatching on lots of different cases (as you say, unions), if we fuse the three directions into one type. . However, this becomes even more critical when we think about abstracting operators. When performing an `x` derivative, for example, we know that the field changes location from `{Cell, Y, Z}` to `{Face, Y, Z}`. If the directions were fused, we would have to code each 3D case manually, rather than the 1 (or 2) cases we need with this design. When writing an abstracted interpolation function from an arbitrary location `X1, Y1, Z1` to `X2, Y2, Z2`, it greatly simplifies the task if the directions are ""unfused"". I think it's also easier to reason about abstracted operators on fields this way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391:103,simpl,simplify,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391,3,['simpl'],"['simplifies', 'simplify', 'simply']"
Usability,"> any suggestions for tests I might add to get the coverage up?. Hmmm, I think for now it's sufficient that the regression tests pass as this PR should preserve existing functionality. If you're going to implement more rigorous/high-level LES tests in the future then the coverage will go up. And it'll probably become clearer which unit tests are needed. > Lastly, I am thinking that all the doc strings in closure_operators.jl are actually a detriment to readability and understandability. Thoughts?. I kind of agree, but with the docstrings we can integrate them into the documentation, and if the docstrings have LaTeX then we can view the operators alongside the math in the docs. I guess it's readable documentation vs. more readable code? Good practice says we should probably keep them, but maybe we can separate them somehow? I guess right now we only read the code but maybe in the future we'll mainly be reading the docs and not the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848:319,clear,clearer,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496471848,1,['clear'],['clearer']
Usability,"> btw the function belongs to a generic `matrix_utils.jl` file or something and instead of `initialize_matrix` it should be called `build_matrix`. ""operator"" might be more clear? Or some other semantics. We want to say something like ""Solve A*x=b, where A is..."" I don't think we want to say ""A is The Matrix"". Something more specific?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2885#issuecomment-1412113470:172,clear,clear,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2885#issuecomment-1412113470,1,['clear'],['clear']
Usability,"> buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()). I actually really like this approach. It's a bit verbose, I agree, but it's extremely clear and intuitive. It seems like it would be a bit of work though, no? (I wouldn't know how to do it...). @ali-ramadhan since you coded this PR, anything to add?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067:172,clear,clear,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782997067,2,"['clear', 'intuit']","['clear', 'intuitive']"
Usability,"> but I think even at this point we're trusting developers that use it to make sure that the sum is valid (i.e. on the same grid and location), and to only put fields in it where the rest of the code would expect fields right?. Well no --- we don't trust developers to do that. We only use it inside a kernel and in a case we know it is used correctly. This PR does something different, it introduces ""support"" for `SumOfArrays` that implies to users that it is suitable for representing a sum of fields (not just a low-level utility for sums of arrays), but doesn't implement any other facilities that correspond to such support. We want users to be able to trust the code we write so I feel this isn't the most helpful thing to do. It is interesting to consider putting together an abstraction that represents a sum of fields (though note we already have this through `MultiaryOperation`, but maybe there is a reason you would like something different?). It wouldn't be very much effort and we can indeed check that the fields all share a location and grid. Such a utility could even be used within abstract operations, as a simpler alternative to `MultiaryOperation` (which additionally can sum fields that have different locations, but perhaps is too complicated for your use case?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265955109:1127,simpl,simpler,1127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265955109,1,['simpl'],['simpler']
Usability,"> but still thinking about the best way to dispatch on e.g. DoublyPeriodicDomain, ChannelDomain, TriplyPeriodicDomain, etc. Are you envisioning that we need something additional to simply dispatching on the boundary condition types (which is already implemented?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500662238:181,simpl,simply,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500662238,1,['simpl'],['simply']
Usability,"> decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`).; > ; > If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent. I agree that the `PoissonSolver` struct is a better place to store the pressure boundary conditions, but what do you think of just storing them in `model.boundary_conditions`? We could do the same for the tendency boundary conditions. It would provide a simple and central store of all field boundary conditions. If we go with indexing `model.boundary_conditions` by name rather than number/range then we won't have to worry about the order we put them in (which might become cumbersome for many fields) and it'll make the time-stepping code clearer. But we should probably leave this for a future PR focused on cleanup.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527161814:662,simpl,simple,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527161814,2,"['clear', 'simpl']","['clearer', 'simple']"
Usability,"> forcing at the surface to generate mixing (through convection or mechanical stress), while the forcing in the interior restores the stratification. Hi there. Talked briefly about this with @zhenwu0728 earlier and was suggesting something along those lines for the physics too. I could imagine additional applications for configs like these and am willing to help with e.g. exploring the parameter space a bit if needed. Maybe the simplest, yet rather tunable, approach I could think of would be something like:. - at the top: warming (e.g. via relaxation to SST0) + wind stress to mechanically generate turbulence; - below a certain depth z1: cooling (e.g. via relaxation to T1<SST0) to restore to positive stratification. I feel that this simple approach should lead to a statistically steady stratification within an appropriate ranges of [SST0 T1 z1] and piston velocities. . With this basic config in place, which maybe is not far from your `examples/ocean_wind_mixing_and_convection.jl`, my guess is that adding a diel or seasonal mixed layer deepening is straightforward -- e.g. via a time variation in SST0. Does that make sense? Am I missing something obvious?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072:432,simpl,simplest,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072,2,['simpl'],"['simple', 'simplest']"
Usability,"> hey had a few comments, but nothing too serious; > ; > It's hard for me to check thoroughly the whole code. But I'm pleased with the benchmarks and tests -- they look very convincing. I'm approving but perhaps let's hear @glwagner?; > ; > (I'm going offline today in a bit for 2 weeks..). @navidcy thanks for the review, I ll check everything and improve the comments to make it clearer. Have nice vacations!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166:381,clear,clearer,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105#issuecomment-996204166,1,['clear'],['clearer']
Usability,"> hm... I don't know about a mixed layer...; > ; > let's just ignore the dz(b)=0 at the top&bottom _or_ we can add a remark in the example about it?. Yes definitely ignore. What we want to focus on is providing an example that is a useful starting point for other, new simulations. This is the key priority. This is why it makes sense to prioritize relatively simple examples (and also simple visualization) that can be quickly digested and are amenable to generalization. We want to _deprioritize_ bespoke or niche cases that are a dead-end. For example, if we use `GradientBoundaryCondition` at the top in this case, then most users will have to delete / change that line in order to generalize this example into the case they are interested in using.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814:360,simpl,simple,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1987303814,2,['simpl'],['simple']
Usability,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759:233,simpl,simple,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759,1,['simpl'],['simple']
Usability,> https://github.com/CliMA/GeophysicalDissipation.jl/blob/main/bickley/ocean_machine_bickley.jl. I looked at the code and it seems to be using `HydrostaticBoussinesqSuperModel`. It seems to be defined [here](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/SuperModels.jl). From what I can tell it's solvin the Hydrostatic Boussinesq model with a rigid lid. Is that correct @glwagner ? If so I can believe this Bickley jet is a solution for that model but still not clear it works for Shallow Water.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-763703829:482,clear,clear,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-763703829,1,['clear'],['clear']
Usability,"> if you do it like that (allow a function bc to be applied by filling the halos rather than as an additional tendency), then a field initialized in a model with a function bc (like a velocity for example) will always expect additional signatures for `fill_halo_regions!` and computing within an abstract operation would be impossible if not passing the additional arguments.; > ; > I am suggesting to treat all complex BCs like we treat `Flux` so that the API will not need drastic changes but we can incorporate the feature that @tomchor is talking about. No that's not true --- that's how it works now. The arguments are propagated via `args...`. If the bc is not a function, the args are thrown away:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L121-L122. if you use a function then you get:. https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115. it's actually fairly simple to understand",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179195098:1045,simpl,simple,1045,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179195098,1,['simpl'],['simple']
Usability,"> is it easy to simply avoid importing the macros associated with the global logger and defining them for a custom logger instead?. You mean like defining and using `@custom_info`, `@custom_warn` for `OceananigansLogger`? That might not be great in case users want to use a different logger. I think we want to use `@info`, `@warn`, etc. and users can always go back to the base/default logger whenever they want.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674213130:16,simpl,simply,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674213130,1,['simpl'],['simply']
Usability,"> most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". My impression is that that's why the `parameters` argument existed (but please correct me if I'm wrong). In the current way `computed_dependencies` and `parameters` clearly indicate what's what (and what happens behind the scenes). So on that note, personally, I like that `computed_dependencies` keeps things explicit. Also, I can't say for other people, but I frequently pass fields that require computation to `KFO`. (Usually passing `u-U` to calculate fluctuations, etc.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786:325,clear,clearly,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1066240786,1,['clear'],['clearly']
Usability,"> oh sorry you mean we just didn't register it?. Yes, sorry if that wasn't clear!. I thought registering and tagging could be used interchangeably since the registrator automatically registers _and_ tags a new version, no? I'll try to be more precise with the language in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2484#issuecomment-1111551048:75,clear,clear,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2484#issuecomment-1111551048,1,['clear'],['clear']
Usability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:558,simpl,simply,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,1,['simpl'],['simply']
Usability,"> that looks very weird! But it is structured in some sense, it looks like the initial condition has some inbalances that generate noise which gets cleaned up by numerical diffusion. Interesting also that buoyancy extrema are continuously increasing in magnitude. If this is not happening with z-directed gravity, it might really be that there is some bug/incorrectness in the buoyancy model. A way to test this would be to recreate the same setup with z-directed gravity and use an immersed boundary to represent the tilt. If that case behaves as expected we know where to focus. @simone-silvestri I'm not sure if that'd be an apples-to-apples comparison. We'd be comparing a domain with smooth tilted boundaries (using the rotated buoyancy) against a domain with jagged tilted boundaries (using our grid-fitted IB). So I'm not sure what we could learn there (please lmk if I'm missing something here). That said, I think it's worth the shot so I might try to implement that soon and see what happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517948385:848,learn,learn,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1517948385,1,['learn'],['learn']
Usability,"> the offender is this line; > ; > https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75; > ; > `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; > ; > ; > https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110; > ; > `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main); > ; > I see two solutions here:; > ; > 1. change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); > 2. Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?). The main criteria for the design is ease of use. So that's what we have to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230:1108,simpl,simple,1108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603164230,1,['simpl'],['simple']
Usability,"> the tests were not passing here. Yeah, I should have been more clear that I approved to merge after tests were passing, I didn't know we could even merge without tests passing. I thought that behavior was blocked",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2919#issuecomment-1427136695:65,clear,clear,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2919#issuecomment-1427136695,1,['clear'],['clear']
Usability,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:929,clear,clearer,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,1,['clear'],['clearer']
Usability,"> v1.0 isn't gonna be the last version we ever release, so I think it's okay to release a v1 with a subset of these features and push the other items to a v2.0 that might come out afterwards. I agree with this in general. But the API is changing week by week, and not just small changes either. I think we are designing a really complex system without a good guide to take from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-885738155:359,guid,guide,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-885738155,1,['guid'],['guide']
Usability,"> we could actually keep a general version maybe by just; > ; > ```; > for dir in (:x, :y, :z) ; > diffusive_flux = Symbol(:diffusive_flux_, dir) ; > viscous_flux_u = Symbol(:viscous_flux_u, dir) ; > viscous_flux_v = Symbol(:viscous_flux_v, dir) ; > viscous_flux_w = Symbol(:viscous_flux_w, dir) ; > @eval begin ; > @inline $diffusive_flux(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_u(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_v(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > @inline $viscous_flux_w(i, j, k, grid, clo::AbstractTurbulenceClosure, args...) = zero(grid) ; > end ; > end ; > ```; > ; > (and maybe move this to `closure_kernel_operators.jl`) So that we can have the best of both scenarios. But anyways I am fine with both. this makes sense to me. Maybe put it at the top-level in `TurbulenceClosures.jl` where `AbstractTurbulenceClosure` is defined (makes it clear what one gets from dispatching on `AbstractTurbulenceClosure`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3057#issuecomment-1502347491:1003,clear,clear,1003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057#issuecomment-1502347491,1,['clear'],['clear']
Usability,"> we could be calling it within flattened_cpu_interior but the method name doesn't suggest that... if you think of a way to improve do it!. Good idea. Find a new name for the function! What it does:. 1. Drops singleton dimensions; 2. Converts from CPU to GPU; 3. masks immersed regions with NaN. Perhaps simple `convert_field`, because in the context of the extension ""convert"" means to change an argument from the input into something plottable. Or perhaps `make_plottable_field(f)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068:304,simpl,simple,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3725#issuecomment-2308633068,1,['simpl'],['simple']
Usability,> without an abstraction. The memory management and reuse for shared memory to be efficient without an abstraction is going to be hard. I based the stencil abstraction on this work: https://www.sciencedirect.com/science/article/pii/S016781911300094X?via%3Dihub. https://superfri.org/superfri/article/view/276 and https://onlinelibrary.wiley.com/doi/full/10.1002/cpe.4929 might provide up-to-date guidance.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538466251:396,guid,guidance,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442#issuecomment-538466251,1,['guid'],['guidance']
Usability,"> you are referring to including the horizontal components of the rotation vector within the tangent plane approximation?. Ah I should have been clearer. For the Cartesian domains we might want `FullCoriolis` but including the cosine term would only make sense if we're running on a sphere. > Do you think that we should not have the concept of a molecular transport coefficient at all?. I think it makes sense to have this, especially so that the default is a DNS. Not sure if this is the most common use case, in which case maybe we can spit out a warning to new users so they know what they're running. > The point is that density is not a variable in a Boussinesq code and the value of the reference density has no effect on the dynamics. This makes sense to me, but then I'm wondering if ρ₀ is important to know to calculate diagnostics etc. where should we store it? EOS makes the most sense to me as a storage place even though it doesn't influence the dynamics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754:145,clear,clearer,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754,1,['clear'],['clearer']
Usability,">Agree its good to be able to build docs, but I wouldn't personally recommend building docs to debug a simple plot like this one. It'd be much slower than just running the example script. I mean, I can ""plot"" it running the script just fine. I'm doing it right now. I just don't know how it'll render when the docs are built (or if it will appear at all).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867201125:103,simpl,simple,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867201125,1,['simpl'],['simple']
Usability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:529,simpl,simplifying,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,1,['simpl'],['simplifying']
Usability,"@EavenW here is some code for you:. ```julia; using Oceananigans; using Oceananigans.Fields. f = 1e-4 # [s⁻¹] Coriolis parameter. # Use 'const' so boundary functions work on the GPU.; const ω = 2π/f # [s] Inertial period; const u★ = 0.01 # [m s⁻¹], friction velocity. # fluxes *kinematic* because they are applied to the velocity field. ; x_momentum_flux(x, y, t) = u★^2 * cos(ω * t); y_momentum_flux(x, y, t) = u★^2 * sin(ω * t). τˣ = BoundaryFunction{:z, Face, Cell}(x_momentum_flux); τʸ = BoundaryFunction{:z, Cell, Face}(y_momentum_flux). u_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τˣ)); v_boundary_condition = HorizontallyPeriodicBCs(top=BoundaryCondition(Flux, τʸ)); ```. As @ali-ramadhan we are redesigning this API this week. So expect changes very soon if you keep `Oceananigans` updated. We think the API will become clearer and easier to use. This code is young so we certainly appreciate comments and criticism that will help us make the code easier-to-use. I just noticed that the docstring defined inside the struct does not print at the REPL, so here it is:. ```julia; """"""; BoundaryFunction{B, X1, X2}(func); A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; """"""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856:859,clear,clearer,859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587013856,1,['clear'],['clearer']
Usability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:265,simpl,simple,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,3,"['learn', 'simpl']","['learn', 'simple']"
Usability,@SandreOuza @christophernhill @jm-c will be good to have your feedback too!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222849:62,feedback,feedback,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120#issuecomment-472222849,1,['feedback'],['feedback']
Usability,"@adelinehillier reports the following optimal values for CATKE to match the LESbrary (these values occur at iteration 10 -- we have to read these off the plots, as we do not have the actual numerical values. But a rough guideline should be good enough):. ![image](https://user-images.githubusercontent.com/15271942/166294013-00a64681-18f7-4abf-a35b-7f7c9b0ed3fb.png). Note that these are optimal values for an _older_ version of CATKE that calculated diffusivities at cell centers:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L140-L143. which was the case for Oceananigans v0.74.2. Therefore work still remains to recalibrate CATKE for current numerics, which calculate diffusivities at vertical cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024:220,guid,guideline,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461#issuecomment-1115142024,1,['guid'],['guideline']
Usability,@ali-ramadhan I am on the Julia Slack. I'm Alex Cavaliere on there.; I'd love to learn about and work on the models. I'm also happy doing more infrastructure work!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/466#issuecomment-566738631:81,learn,learn,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/466#issuecomment-566738631,1,['learn'],['learn']
Usability,"@ali-ramadhan I did not see this in PR #147 (too many lines of diff for time_steppers.jl, so i missed this).; But regarding your question about ""epsilon"", this is just an other name for parameter ""χ"" (chi).; In fact, I would prefer to have ""0.5 + χ"" i beeing called the AB-2 parameter; this way, if set to zero then ; we recover a simple first order forward time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286:331,simpl,simple,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286,1,['simpl'],['simple']
Usability,@ali-ramadhan I feel using `\bv` for 3D and `\bu` for 2D may simply be too easy to confuse (our newest contributor Navid was confused!) I think it's more standard is to use a subscript 'h' for horizontal.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470524323:61,simpl,simply,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470524323,1,['simpl'],['simply']
Usability,"@ali-ramadhan I haven't quite got to looking at weights yet, but have you thought about doing something like this; ```; fz = FFTW.r2r(f,FFTW.REDFT10,3); fxyz= FFTW.fft(fz,[1,2]); ```. and this. ```; ixyz=FFTW.ifft(fxyz,[1,2]); iz =FFTW.r2r(real.(ixyz),FFTW.REDFT01,3)/(2*Nz); ```; Not sure if that is completely correct syntax, but something do the Neumann forward(backward) transform first(last) and periodic ones second(first)? The current formulation looks like it might loose some cyclic info when you drop complex parts and also may get confusing around even/odd ```Nx, Ny, Nz```. Usually working in complex FFT space generally simplifies juggling factors and sizes around odd v even dimensions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443185393:633,simpl,simplifies,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-443185393,1,['simpl'],['simplifies']
Usability,"@ali-ramadhan I'm running on my desktop's GPU just to get a sense of the performance increase at the moment. According to `nvidia-smi` my card is a `NVS 310` (I apologize if I didn't get that right, I really have zero experience with GPUs). I'll create another issue to report this properly. Thanks for the feedback, though!. And I'm running our own group's LES model. Unfortunately I'm not allowed to share the code, but you can read about it [here](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2018GL080296). @glwagner I'd be very willing to compare performances of our LES with Oceananigans. The caveats here being that; - our model of choice ([lagrangian-averaged scale-dynamic](https://aip.scitation.org/doi/10.1063/1.1839152)) takes relatively long to calculate compared to other models, but generally needs lower resolution to achieve the same results (so in this sense it might be similar to AMD) and that; - I'm not sure how relevant it would be to compare with us, being that I'm not allowed to share the source code. If you're still interested to make a comparison just let me know! I'd be happy to help. @ali-ramadhan @glwagner I'm not expecting at all to run their simulation at the resolution that they're running. My intent was to set-up the same case (but very coarse) and see how much I could increase the resolution (and how much activity I could see) until it became too slow or until I ran out of memory. This is basically a fun side-project, and not an actual research attempt if I'm being honest :). Thank you both for the helpful responses! I'm glad to help with whatever bugs or attempts at simulations that I can!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839:307,feedback,feedback,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839,1,['feedback'],['feedback']
Usability,"@ali-ramadhan and @glwagner I tried the code below in some simple tests while waiting; for my car to be serviced. . ```; using Pkg; Pkg.add(""LinearAlgebra""); using LinearAlgebra. function solveLinearSystem(A,f); # Solve Aϕ=f; tol=1.e-12; E=eigen(A);; L=E.values;; V=E.vectors;; # Get amplitudes, F, of eigenvectors that give f; F=V'*f; # Get inverse eigenvalues (zeroing inverse for v. small ones); rL=map(x -> if (abs(x)>tol) 1.0/x; else 0. ; end , L);; # Get amplitudes, Φ, of eigenvectors that give ϕ; Φ=F.*rL; # Solve for ϕ given Φ; ϕ=V*Φ; println(A*ϕ,f,ϕ); return ϕ; end. Acyc=[-2. 1 1; 1 -2. 1; 1 1 -2.];; Aneu=[-1 1 0; 1. -2. 1; 0. 1. -1];; s=size(Acyc);; nx=s[1];; g=rand(nx+1,1);; divg=g[1:end-1]-g[2:end]; mdivg=sum(divg)./size(divg)[1]; divg=divg.-mdivg; solveLinearSystem(Acyc,divg); solveLinearSystem(Aneu,divg); ```. This is algorithm that underlies the FFT approach. The FFT just optimizes (and makes it more complicated) by utilizing the fact that the eigenvector/eigenvalue coefficients for the simple, constant spacing Poisson problem, are the cos and sin terms in an FFT. Code appears to work so I am going to try and hack together a ""_plugin_"" for ```solve_poisson_3d_mbc```. . The code won't be super high performance (or work for really big problems) but (fingers crossed) it should give something clean (and short) to get started and help with debugging/optimizing on GPU. Then we can work on various FFT approaches on CPU and GPU (3-d FFT, 2-d + cyclic reduction), Greg's thought on saving for gradients in continuous form. . In principle the eigenvectors and eigenvalues above should correspond with amplitudes that come out of FFTW - except that there are a bunch of 1/2 factors, N versus m numbers, complex versus split cos/sin notation bits that need to be carefully understood etc.... . Just going to learn a little about sparse matrices in Julia - I assume they must exist! Hopefully the car will take a little longer to be finished. . Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365:59,simpl,simple,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365,3,"['learn', 'simpl']","['learn', 'simple']"
Usability,@ali-ramadhan and I created that warning message. Maybe it's too agressive and we should rethink it as people clearly become concerned by it? Will have to think about that a bit more but glad it's working!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440:110,clear,clearly,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832330440,1,['clear'],['clearly']
Usability,"@ali-ramadhan do we still want this? I think this actually only requires a simple generalization of our current eddy diffusivity closures. We already have functions for computing flux divergences from arrays of diffusivities, since we do this for LES closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531048678:75,simpl,simple,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/51#issuecomment-531048678,1,['simpl'],['simple']
Usability,"@ali-ramadhan do you have any thoughts on the design of `x, y, z` `Topology` traits for the grid? I think this is becoming more important, especially because we now have two grids. This may be an essential abstraction, so we may want to make it a ""medium"" priority to implement it (and also eliminate a lot of boiler plate associated with `ChannelModel` constructor. It also will break the user API because it will enable a much simpler and straightforward interface for specifying boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695:429,simpl,simpler,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-578411695,1,['simpl'],['simpler']
Usability,"@ali-ramadhan does makes a fair point. But there will be some learning curve either way... The user should either know some git, or they should be familiar with Julia's syntax, or Julia's project management (`julia --project=...`). To that extend, perhaps the doc instructions could suggest few avenues that the user can start running the examples. Cloning the repo could be one of them. But also copy-paste from the docs after ensuring the the proper `Project.toml` is instantiated could also be a viable option!. By the way Literate.jl provides ways to output the examples in different forms other than markdown for the docs.; https://fredrikekre.github.io/Literate.jl/v2/outputformats/; With some pre/postprocessing we can have Literate.jl strip out things like `nothing #hide` and then point the users to cleaner `.jl` scripts or Jupyter notebooks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746:62,learn,learning,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746,1,['learn'],['learning']
Usability,"@ali-ramadhan here's an idea: rather than `FieldStatus`, we can simply re-use `Clock`. Then we can be paranoid and check the `time`, `iteration`, and `stage` for the purposes of recomputation. There's a bit less code which is nice too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301#issuecomment-759606744:64,simpl,simply,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301#issuecomment-759606744,1,['simpl'],['simply']
Usability,"@ali-ramadhan it might make sense to move the WENO nth order into a draft PR where we can work on making it fast, with a simple benchmark to work from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736137314:121,simpl,simple,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1221#issuecomment-736137314,1,['simpl'],['simple']
Usability,"@ali-ramadhan please see my contribution. I believe the following combinations are now supported. * number data with CPU and GPU fields; * data from alike fields for CPUs and GPUs; * CPU fields to GPU fields (using `copyto!` on `.data.parent`); * CPU arrays to CPU fields; * CPU arrays to GPU fields (by forming a CPU field and then using `set!` for CPU fields to GPU fields); * GPU arrays to GPU fields (using the kernel `_set_gpu!`); * GPU fields to CPU fields (via array conversion of `.data.parent`); * functions to CPU fields (using `nodes(u)...`); * functions to GPU fields (by computing `set!` for functions and a new CPU field and then using `set!` for CPU fields to GPU fields). I have also added a docstring for `set!(model; kwargs...)` with an example, and a simple test. (I also nuked `EdgeField`). Hopefully that is comprehensive enough for now. Please let me know if anything more should be added.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519283400:770,simpl,simple,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519283400,1,['simpl'],['simple']
Usability,@ali-ramadhan should we resume submitting to Codecov?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1052#issuecomment-983134035:24,resume,resume,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1052#issuecomment-983134035,1,['resume'],['resume']
Usability,@ali-ramadhan this PR is ready for a first review. Possibly we should also add docs in this PR. I could also envision a few more tests to ensure the correctness of the turbulent diffusivities in simple flow fields for Constant Smagorinsky and Anisotropic Minimum Dissipation. However this last is not necessary.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508840933:195,simpl,simple,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508840933,1,['simpl'],['simple']
Usability,"@ali-ramadhan, smag and AMD are IsotropicDiffusivities. . I chose to use the background diffusivity values for the boundary condition for simplicity and because I’m not sure the closures are returning non-zero nonlinear diffusivities on the boundary anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-516221218:138,simpl,simplicity,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-516221218,1,['simpl'],['simplicity']
Usability,@christophernhill feedback appreciated!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-708592718:18,feedback,feedback,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068#issuecomment-708592718,1,['feedback'],['feedback']
Usability,"@christophernhill the macro I am suggesting is just simple copy-and-paste (no manipulation of AST's, etc) --- for the purpose of reducing the large amount of boiler plate associated with our loop / kernel definitions. If we do that we can change the ordering of 3D loops by changing the macro, rather than by changing _every_ kernel function. But I hear you. I wonder what you think about PR #463...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365648:52,simpl,simple,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541365648,1,['simpl'],['simple']
Usability,@dhruvbhagtani I'm closing this as it seems stale you (or anyone!) should feel free to re-open and resume whenever.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1791223957:99,resume,resume,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1791223957,1,['resume'],['resume']
Usability,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:203,simpl,simple,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['simpl'],['simple']
Usability,@francispoulin does it also make sense to write these divergences as two-dimensional (in xy) since that's what we are restricted to for ShallowWaterModel? It might make the code clearer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-881938607:178,clear,clearer,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-881938607,1,['clear'],['clearer']
Usability,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:839,clear,clear,839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629,1,['clear'],['clear']
Usability,@francispoulin those figures are simple heatmaps:. https://makie.juliaplots.org/stable/examples/plotting_functions/heatmap/. The code you are writing looks like code for producing a surface plot on the sphere. Heatmap might be easier!. It might help to start from scratch rather than fixing whatever’s there too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126723606:33,simpl,simple,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126723606,1,['simpl'],['simple']
Usability,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171:566,simpl,simply,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"@francispoulin you are in principle correct!. However, without the equality in the criterion, me and @glwagner were trying to setup a very simple, idealized example with linear background stratification and somehow the convective adjectment started working in the bottom of the ocean (!!) because the criterion was precisely zero there. This is the ""unphysical situation"" that @glwagner is referring to -- perhaps he can elaborate a bit more?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918738850:139,simpl,simple,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918738850,1,['simpl'],['simple']
Usability,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010:282,simpl,simple,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010,1,['simpl'],['simple']
Usability,"@glwagner ; > @whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR. By all means! Whatever will help. > I think what we really want to do is define a fallback `correct_immersed_tendencies!(args...) = nothing` in the `TimeSteppers` module . Is this different than the `correct_immersed_tendencies!(model, ::Nothing, Δt, γⁿ, ζⁿ) = nothing` I have?. > @whitleyv let me know what you'd like to do: you can make these changes, or I can help either by pair programming or making them myself. I don't mind moving the `correct_immersed_tendencies!` to the `Models.IncompressibleModels` module. I know y'all moved a lot of things away from the `Timesteppers`, which makes sense. If you have the time, it'd probably be better for you to either help me or do it yourself, since I'm not sure I'd catch all the parts I need to add. > @whitleyv should we add `correct_immersed_tendencies!` to the quasi-second-order Adams-Bashforth algorithm as well?. Right now the `correct_immersed_tendencies! ` is specific to RK3 in how we negate the tendencies, but I think the future implementation will be more versatile!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506:124,simpl,simple,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781743506,1,['simpl'],['simple']
Usability,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:142,learn,learning,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,4,"['learn', 'simpl']","['learning', 'simple', 'simply']"
Usability,"@glwagner @SandreOuza Just brainstorming some ideas on how to include arbitrary closures and forcing functions on the right hand side of the momentum equation in finite volume. Would be good to get your feedback. The hackiest/easiest way to do this would be to maybe to have a; ```julia; struct ForcingFunctions; Fu::Function; Fv::Function; Fw::Function; FT::Function; FS::Function; ...; end; ```; be part of the Model struct. These forcing functions must have a very specific signature, e.g.; ```julia; F(grid, velocities, tracers, i, j, k); ```; that computes the closure/forcing for volume element (i,j,k) but not every input has to be used. Then we can figure out how to implement Smagorinsky closures and AMD (anisotropic minimum dissipation) in finite volume using `Oceananigans.Operators` (submodule containing all operators). The reason I've called them forcing functions is because they show up on the right hand side of the momentum equations, so I'm just generically treating all additive RHS terms as ""forcings"". It may not be the best name if we're implementing LES closures though. Then the forcing is only inserted into the associated momentum equation if it's defined. So without a forcing, the code is rewritten to not even include a forcing so in this sense this can be a zero-cost abstraction. Here's some pseudo code of what this macro might look like:; ```julia; # Add forcing forcing for u-momentum at the end of the expression.; macro insert_forcing_u(model, ex); if model.forcing_functions.Fu == nothing; return ($(esc(ex))); else; Fu = model.forcing_functions.Fu; return ($(esc(Expr(:call, :+, ex, Meta.parse(""Fu(grid, velocities, tracers, i, j, k)""))))); end; end; ```; We can do this without macros by having the following default setting for all these forcing functions; ```julia; @inline F(grid, velocities, tracers, i, j, k) = 0; ```; which should have the same effect (compiler will get rid of the call to Fu, if it's a smart as I think it is). This general approach mig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467038780:203,feedback,feedback,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-467038780,1,['feedback'],['feedback']
Usability,@glwagner @christophernhill can we clear this pull request?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115048138:35,clear,clear,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115048138,1,['clear'],['clear']
Usability,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:1266,simpl,simple,1266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754,2,"['simpl', 'undo']","['simple', 'undo']"
Usability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:998,learn,learning,998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,1,['learn'],['learning']
Usability,"@glwagner I am trying to set things up exactly the way they are in the example you shared with me but there are some differences. For example, rotation is not specified in your problem but I need to in mine. Second, I believe this is a 2D problem with a rigid lid. Therefore, I think what you are solving is equivant to the barotropic quasi-geostrophic model, which is simpler than shallow water. I wanted to point out that in the code (link below), there might be a typo. In line 4, the streamfunction is defined. Then in line 5, the geostrophic velocity is then defined. If there is a `2 y /L ` in the first, theny you should have a ` - y/L`, in the second, not a positive as seems to appear. I should add that this term seems strange to me as I have never included it before, but I'm including it for the sake of comparison and I don't think it should cause any problems. https://github.com/CliMA/OceanModelComparison.jl/blob/master/unstable_bickley/periodic/Bickley.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-762328386:369,simpl,simpler,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-762328386,1,['simpl'],['simpler']
Usability,"@glwagner I have simplified the test script (good idea as it was clunky for me to sieve through and I wrote it..) and the new tests pass on both `CPU()` and `GPU()`. ~~The error from the docs build does not look related to this PR as far as I can tell! The docs built on a previous version and I do not think I changed any code related to the docstring.~~. This PR is already likely enough but one thing that could be done is to move `src/Buoyancy/buoyancy_field.jl`. ```julia; # TODO: move to Models; buoyancy(model) = buoyancy(model.buoyancy, model.grid, model.tracers); buoyancy(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); BuoyancyField(model) = Field(buoyancy(model)); ```. to `Oceananigans.Models` and alter this so instead of returning `BuoyancyField` it returns the `KernelFunctionOperation`. ```julia; sewater_buoyancy_perturbation(model) = sewater_buoyancy_perturbation(model.buoyancy, model.grid, model.tracers); sewater_buoyancy_perturbation(b, grid, tracers) = KernelFunctionOperation{Center, Center, Center}(buoyancy_perturbationᶜᶜᶜ, grid, b.model, tracers); SewaterBuoyancyPerturbation(model) = sewater_buoyancy_perturbation(model); ```. to match the behaviour of `SeawaterDensity`.; Likely better to do another day but if you think it worth doing in this PR let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047:17,simpl,simplified,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758784047,1,['simpl'],['simplified']
Usability,"@glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in [this commit](https://github.com/CliMA/Oceananigans.jl/pull/1293/commits/3b11bb07ca8a1ff97976d2ce743a1cd8afe2a4f0). I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via `KernelComputedField` on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574:312,simpl,simple,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246#issuecomment-759601574,1,['simpl'],['simple']
Usability,"@glwagner I need some help with:. - Top boundary condition: when I try constructing it with parameters, e.g.,; ```; b_surf(x, y, t, p) = p.b0 * cos(π * x / p.Lx); ```; the script does run. All the movies I made was like that. But when Documenter.jl run is it fails! I can reproduce this -- I know this is not so clear now. I tried all combinations of parameters/arguments and I can't understand what's happening. That's why I hard coded the values in the surface boundary condition at the moment. - Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... - As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a `VerticallyStretchedGrid` has given be blow ups, *even when the stretching on the grid is almost zero*, i.e., when the `VerticallyStretchedGrid` ≈ `RegularGrid`. - How do I setup the Poisson solver to obtain solution of ∇²b=0 with b(x, t) = cos(πx) and no flux boundary condition at all other walls.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922:312,clear,clear,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922,1,['clear'],['clear']
Usability,"@glwagner I think I see what you mean now. It's definitely a harder problem than I anticipated. I think the ideal way would be to infer these conditions automatically, but like you said that may be a very hard problem. I don't think it's ill-posed, since you basically have all the necessary information in one way or another. So if I, a human, can arrive at the right answer with the same information, I think a program could do the same. Second best way would be to try infer the right BCs but provide an option to manually force a certain BC. I think inferring should be relatively easy in very simple cases, no? ~For example, in the pseudo-code below...~. ```julia. ... # Some code; UVelocityBoundaryConditions(grid, top = BoundaryCondition(Gradient, 0), bottom = BoundaryCondition(Gradient, 0),); ... # More code. dudz_comp = ComputedField(∂z(u)); compute!(dudz_comp); ```. ~This currently produces something with the wrong derivatives at the boundary, but I'd expect that it wouldn't be too hard to get this one right automatically since you basically have to do something similar to solve the Boussinesq equations. Am I wrong?~. Finally, I don't oppose relying completely on the user to provide the BCs for the ComputedFields like you said. Mostly I don't know the difference in the amount of effort between these options! So maybe if this one is significantly faster to code/test than the other ones, this should be the way for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-773373837:598,simpl,simple,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-773373837,1,['simpl'],['simple']
Usability,"@glwagner I thought about it a bit more and changed the time step alignment to be more elegant and more in line with #1138. This also resulted in a simpler implementation. Now each schedule defines a `align_time_step(schedule, clock, Δt)` function that returned the aligned time step (currently only `TimeInterval` defines something). This function can then be used in `align_time_step!(simulation)` to easily align the time step with all schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-735426506:148,simpl,simpler,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213#issuecomment-735426506,1,['simpl'],['simpler']
Usability,"@glwagner I'm running into a similar issue (v0.30.0):. ```; ERROR: LoadError: AssertionError: CUDAdrv.jl did not successfully initialize, and is not usable.; Stacktrace:; [1] libcuda at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/CUDAdrv.jl:82 [inlined]; [2] (::CUDAdrv.var""#535#cache_fptr!#11"")() at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:31; [3] macro expansion at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:39 [inlined]; [4] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/libcuda.jl:36 [inlined]; [5] macro expansion at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/error.jl:110 [inlined]; [6] cuDeviceGetCount at /home/mike/.julia/packages/CUDAapi/XuSHC/src/call.jl:93 [inlined]; [7] length at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:105 [inlined]; [8] iterate(::CUDAdrv.DeviceSet, ::Int64) at /home/mike/.julia/packages/CUDAdrv/Uc14X/src/devices.jl:100 (repeats 2 times); [9] iterate at ./iterators.jl:139 [inlined]; [10] iterate(::Base.Iterators.Enumerate{CUDAdrv.DeviceSet}) at ./iterators.jl:138; [11] top-level scope at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:131; [12] include(::Module, ::String) at ./Base.jl:377; [13] top-level scope at none:2; [14] eval at ./boot.jl:331 [inlined]; [15] eval(::Expr) at ./client.jl:449; [16] top-level scope at ./none:3; in expression starting at /home/mike/.julia/packages/Oceananigans/1xP6n/src/Oceananigans.jl:124; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655:149,usab,usable,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788#issuecomment-653563655,1,['usab'],['usable']
Usability,"@glwagner I've modified the PR to make clear that this is providing unit tests of the Oceananigans setting utility/broadcast functionality, at at increasingly high level",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106057500:39,clear,clear,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106057500,1,['clear'],['clear']
Usability,"@glwagner It would be great to have this option implemented! It's basically a function of the wind speed. This estimate gives the depth averaged Stokes drift so you can get the layer averaged Stokes drift profile by applying this estimate to each layer depth then compute the difference. [Here](https://github.com/gotm-model/code/blob/master/src/stokes_drift/stokes_drift_theory.F90) is the implementation in GOTM. . Another useful estimate of the Stokes drift is to use the wind-wave spectrum in [Donelan et al. (1985)](https://doi.org/10.1098/rsta.1979.0079). A modified version of it was used in the LESs of [Harcourt and D'Asaro, (2008)](https://doi.org/10.1175/2007JPO3842.1). See their Section 2b. Also see their Appendix B for computing the layer averaged Stokes drift. I used a simple version of it (without the directional spreading) in the LESs in [Li and Fox-Kemper, (2017)](https://doi.org/10.1175/JPO-D-17-0085.1). It's also [implemented in LANL's version of PALM](https://github.com/lanl/palm_lanl/blob/7f1444073b20ae81b451d4ab469d13e66b5358b7/trunk/SOURCE/stokes_drift_mod.f90#L234). . I think it will be wonderful to have a Stokes drift module in either LESbrary or Oceananigans that contains different options to estimate the Stokes drift profile. Is this something you are thinking of?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347864:786,simpl,simple,786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055347864,1,['simpl'],['simple']
Usability,"@glwagner Sorry for posting in the wrong place. Here's the same message again:. @glwagner I modified the docstring with a small example that I think illustrates the patterns relatively in this commit. I'm assuming that's what you meant by ""example"", right?. I've tested it already in some simple examples and it produces correct results. Is there anything else left besides testing this with an actual complex calculation that can only be done via KernelComputedField on a GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700:289,simpl,simple,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293#issuecomment-759718700,1,['simpl'],['simple']
Usability,"@glwagner Thanks for implementing the total tracer diffusive flux at a high level. After running several tests, I found it to work exceptionally well! I conducted a series of tests: 1) comparing 1D vs 3D, 2) with and without the Coriolis force, and 3) with and without the immersed boundary. Everything looks great! Here are some simple examples on a rotated coordinate:. - 1D test with a small f: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/63272997-5998-4d1c-8d9e-5e735a8731f8. - 3D simulation with immersed grids: . https://github.com/CliMA/Oceananigans.jl/assets/68127124/11dd0ee4-4e0a-4052-a65a-61f628ca1fef. The only caveat mentioned by @hdrake is that `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries, i.e., `GradientBoundaryCondition(-N^2*cos(θ))` is needed to make the total buoyancy gradient to be 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101:330,simpl,simple,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211254101,1,['simpl'],['simple']
Usability,"@glwagner Thanks for the detailed analyses and good points about the noise being grid-scale. That may indeed reduce the necessary time step for stability to unphysical values. Also, just to be clear, I'm not saying that I think there's a bug in the code. I'm just saying that I, personally, wouldn't rule it out yet. I guess part of my reasoning is due to the fact that I arrived at this MWE because of unphysical oscillations like these emerging due to physical (and as far as I can tell well-resolved) instabilities in my simulations. In these simulations the instabilities propagated into the stably-stratified, quasi-quiescent regions of the flow, and amplified similarly to the ones that the MWE above reproduces. Of course the fact that these behaviors look alike to the naked eye doesn't prove they are indeed the same phenomenon and, like @glwagner suggested, the fact that we're starting with grid-scale noise here possibly matters. If that's okay I'll try to investigate this a little more with grid-resolved noise before we move/close the issue. If the behavior goes away when everything is well-resolved, then I'm happy to close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445221865:193,clear,clear,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445221865,1,['clear'],['clear']
Usability,"@glwagner and @ali-ramadhan I took a quick look. ; I think you should go ahead and merge, but quick comments for future reference - . 1. there are a bunch of changes unrelated to the PR in the PR. They are probably there by accident, but the Git gods really don't like that. When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Most git projects more diligent about avoiding polluted PRs, which can be useful. . 2. I think ultimately we want halos to just be a thing that does a slightly more general form of what is in ::PBC mode. Everything else is not in halo rules. This is where we ended up in MITgcm and is similar to what is in MPIStateArray in the DG work (I am fairly sure!). A distinction to maybe think about is a set of halo() functions that just do the stuff that does not appear in any of the equations. Anything in equations turns out to be stuff that people may want to tinker with in surprisingly interesting ways. For example someone ultimately might want to do a numerical experiment that has flux BC on some set of the one bit of a boundary, something else on another bit etc.... (people do do things like this). For better or worse having bc's better separated from halos may ultimately prove the right thing. For now I wouldn't worry about it though! . 3. Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Types are good for simple things, but Type::ItsComplicated is often also needed eventually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-528944237:1546,simpl,simple,1546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-528944237,1,['simpl'],['simple']
Usability,"@glwagner and I talked yesterday and here are some points that emerged (@glwagner feel free to chime in if I'm forgetting/misrepresenting something). We agreed that the important points in this PR are two. (1) We should export all directions/formulations (`ZDirection`, `XYDirections`, `ThreeDimensional` or whatever we end up calling them) at the top level, and (2) we shouldn't reintroduce a `Vertical` direction in `TurbulenceClosures` when there already exists a `ZDirection` defined in `Grids` that's used for buoyancy purposes. However, we need to agree on a notation. A few main options emerged from our talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:737,intuit,intuitive,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,2,['intuit'],['intuitive']
Usability,@glwagner are you okay if I just add `min_Δt` as a property of `NonhydrostaticModel` and maintain the strategy of skipping the timestep is Δt is smaller than that? I think that's a reasonable and simple way to fix this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150443883:196,simpl,simple,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150443883,1,['simpl'],['simple']
Usability,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:587,simpl,simplify,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200,1,['simpl'],['simplify']
Usability,"@glwagner nice. I think it's indeed clearer. @navidcy I think the `SmagLilly` closure is tested in [time-stepping](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_time_stepping.jl), [closures](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_turbulence_closures.jl) and in [nonhydrostatic regression](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_nonhydrostatic_regression.jl#L63-L72). But I think the only instance where we're testing actual values (and not just compilation of trivial (i.e. zero) values) is in . https://github.com/CliMA/Oceananigans.jl/blob/8b42137e4224b86fe1f3f1744bd5076aa8821085/test/test_nonhydrostatic_regression.jl#L63-L72. Which does seem to pass, so I'm approving this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3102#issuecomment-1540354682:36,clear,clearer,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102#issuecomment-1540354682,1,['clear'],['clearer']
Usability,"@glwagner thanks for clarifying. Coming from an atmospheric sciences background, I'm a bit unclear on the details of TEOS-10 and the nuances associated with it. In particular it seems counter-intuitive to me how an equation of state that depends on depth fits in a Boussinesq fluid (where adiabatic rearrangement of parcels shouldn't change their buoyancy). But this probably isn't the best place to have a long discussion about it. Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109:192,intuit,intuitive,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841580109,1,['intuit'],['intuitive']
Usability,"@glwagner yes, that was more along the lines of what I was saying. From the docs it seemed to me using a Gaussian mask in the relaxation should be equivalent to a sponge layer, which is why I expected the gaussian function to be set-up with a sharp cut-off. But I think we're on the same page about what a sponge layer should be. . So I think it may be a matter of maybe making the docs clearer? Maybe also, like you said, constructing an example that uses sponge layers (I think there's an issue about there somewhere, right?). The Langmuir example might a good one. In the original paper by Jim they use a radiation boundary condition at the bottom which doesn't have an analog in the Langmuir example at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742:387,clear,clearer,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742,1,['clear'],['clearer']
Usability,"@glwagner, is that what you were intending? We're still learning the ropes on collaborative development via git here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433708209:56,learn,learning,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433708209,1,['learn'],['learning']
Usability,"@glwagner, what about; https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/test/test_boundary_conditions_integration.jl#L200. Should we simplify to `topo = (Bounded, Bounded, Bounded)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053:171,simpl,simplify,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-988286053,1,['simpl'],['simplify']
Usability,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:694,simpl,simply,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661,1,['simpl'],['simply']
Usability,"@iuryt this is a great question! Do you mind if I convert this to a discussion? I think there are multiple answers and a discussion might be better suited for keeping track of the solutions for future users. There are a few possible solutions. Note that the diffusivities can also be `AbstractArray`, which include `Field` and `AbstractOperations`. Using either a concrete `Field` or `AbstractOperation` is how you'll solve this problem. ## Solution: pre-define a Richardson number field and compute in `Simulation.callbacks`. This is perhaps the simplest solution: create a field `Ri = Field{Center, Center, Face}(grid)`, and then to define an abstract operation that's a function of this field as your diffusivity, something like:. ```julia; # Pacanowski-Philander (eg https://glwagner.github.io/OceanTurb.jl/latest/models/pacanowskiphilander/); Ri = Field{Center, Center, Face}(grid) # ∂z(b) / (∂z(u)^2 + ∂z(v)^2); ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. ν = @at (Center, Center, Center) ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = @at (Center, Center, Center) κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)); ```. _Then_, you need to compute `Ri` in a `Simulation.callback` (you also need to fill it's halo regions, which is a bit annoying but we show you how below). This is pretty advanced usage (and there are subtleties as I mention below) so I'll write a script that implements Pacanowski-Philander as an example. Note that it is currently a limitation of our turbulence closures that viscosities diffusivities must be defined at `(Center, Center, Center)`. #2295 makes some changes that will permit this restriction to be relaxed in the future, but we aren't quite there yet. ## Solution 2: precreate `velocities` and `tracers`. Another solution is to pre-create `velocities` and `tracers` by pre-creating a ""fake model"". Then, the viscosity / diffusivities can be defined directly as abstr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:547,simpl,simplest,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186,1,['simpl'],['simplest']
Usability,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031:376,clear,clear,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031,1,['clear'],['clear']
Usability,@jagoosw I committed a few changes. Feel free to undo or comment!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1487558579:49,undo,undo,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1487558579,1,['undo'],['undo']
Usability,"@jatkinson1000 thanks for your effort in https://github.com/xgcm/xgcm/pull/559. I'm glad there's now a clear standard way to proceed!. I'm gonna take a crack at adding those grid measures to Oceananigans NetCDF output in https://github.com/CliMA/Oceananigans.jl/pull/2652 now that it seems the pieces are all in place. However, I read the docs and I'm still a bit confused on how to implement them. Do you have an example NetCDF file (preferably 3D) that follows SGRID conventions that you can share? It would help me to use that as a basis of comparison. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516570220:103,clear,clear,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516570220,1,['clear'],['clear']
Usability,"@johncmarshall54 agreed, that's a challenge we have to confront. If we implement immersed boundaries using the ""continuous forcing technique"", then a boundary may be defined essentially by a masking function of `(x, y, z)` (it is also possible for it to be a function of time). In this case, we might be able to ""label"" each boundary / masking function with a name or number. The boundary condition objects we then give to fields would have to define a condition to be applied both at the boundaries of the numerical grid (which we currently support), as well as any immersed boundaries, where immersed boundaries are referenced by name or number. By the way, if we use a continuous forcing technique, we do not have to change the pressure solver. This is a major simplification. Recent work suggests there is no disadvantage in terms of accuracy in using the continuous forcing technique over discrete forcing techniques (which I think is the category the MITgcm solver falls under). I'm not sure if this is too good to believe or not --- we should discuss and take a deeper look at the literature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605461456:764,simpl,simplification,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605461456,1,['simpl'],['simplification']
Usability,"@johncmarshall54 each field (`u`, `v`, `w`, `T`, `S`) can have boundary conditions in each direction (`x`, `y`, `z`). . We could restrict ourselves to specific combinations of boundary conditions instead, which would reduce the number of possibilities. For example, we might have just doubly periodic in (`x`, `y`) plus flux in `z` on all fields, or singly-periodic in `x` and flux in (`y`, `z`) on all fields. The current design is meant to give the user maximum flexibility, but I'm open to simplifying it. That would restrict what users can do, but perhaps that's ok?. @jm-c feedback welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472224594:493,simpl,simplifying,493,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-472224594,2,"['feedback', 'simpl']","['feedback', 'simplifying']"
Usability,"@liuchihl I think the best way forward is to write a simple test that illustrates the error. Then I can help fix the error to make the test pass. Once that is done, we may be ready to merge this PR. What do you think?. PS it is always best to work with minimal examples, and to paste code directly into a discussion stream (rather than providing links). This will help us keep up an efficient workflow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270:53,simpl,simple,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433044270,1,['simpl'],['simple']
Usability,"@liuchihl check out the similarity between the simple test that I added and the MWE on #3889. I just copy-pasted the MWE code into the test (and made a few generalizations). It should be ready to merge, and it all only took a few minutes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3890#issuecomment-2450966049:47,simpl,simple,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3890#issuecomment-2450966049,1,['simpl'],['simple']
Usability,"@liuchihl, thanks for cleaning up these changes by separating them from the [background flux PR](https://github.com/CliMA/Oceananigans.jl/pull/3646)—it's much clearer now. Consolidating @glwagner and @navidcy's earlier comments, it seems there are three things that need to be done before this can be merged:; 1) Review the [the existing OutputWriter tests](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_output_writers.jl) and verify that they still pass with the new implementation in this PR; 2) Create a new, more rigorous, test that is capable of flagging the bizarre behavior you found in [your issue](https://github.com/CliMA/Oceananigans.jl/issues/3670) but (hopefully) now passes thanks to the changes in this branch.; 3) Add some warnings to let users know that `TimeInterval` and `AveragedTimeInterval` (and probably other diagnostic schedules) are currently broken and give incorrect results after picking up from a checkpoint whenever the checkpoint interval is not an integer multiple of the scheduled time interval.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223:159,clear,clearer,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2302951223,1,['clear'],['clearer']
Usability,"@matinraayai I am just setting up a buildkite CI . Unfortunately I don't know how buildkite works, but learning!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115055787:103,learn,learning,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115055787,1,['learn'],['learning']
Usability,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:412,simpl,simple,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,1,['simpl'],['simple']
Usability,"@miguelraz my two cents are that I think this is certainly feasible. I think the first step is to write up some kind of document (can you use latex?) that outlines the problem(s) you would like to solve. This is the biggest barrier. The spin-down problem is probably the simplest. I think thermal wind should also be possible, but I would use a simpler profile than in #179 with sines and cosines rather than Gaussians. . Another fun problem would be the propagation of an internal wave (or some shape), which is simpler than baroclinic instability (which requires you to solve an eigenvalue problem for some assumed initial condition --- because our domain is periodic, this may be slightly non-trivial). The most difficult problem suggested in this post is probably the saturated Rayleigh-Benard solutions. Once the problems and their solutions are written out and well-defined, it should not be too difficult to implement them in Oceananigans (especially if we lend a helping hand). I'm happy to help with the internal wave example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-489888890:271,simpl,simplest,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157#issuecomment-489888890,3,['simpl'],"['simpler', 'simplest']"
Usability,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033:213,simpl,simple,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033,1,['simpl'],['simple']
Usability,"@navidcy , yes, that looks great. However, when I click on the link I don't think I can execute the commands, but maybe I was too quick to close the page. I created a notebook for the 1D diffusion problem by basically copying and pasting what you have in the example. My markdown is a bit rusty but luckily you had all the right syntax there already. I was going to attach it to this message here but it seems that notebook are unsupported. It is nothing fancy but I do think that if there was an open to open the notebook and run it that would make it a bit easlier than copying and pasting. @glwagner that sounds like a great way to run the script, which is certainly what you want to do. Personally, when learning what a script is doing it's nice to execute it line by line to get to know the process. After you've seen it once then you definitely want to the entire example. Anyhow, my 2 cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454:708,learn,learning,708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454,1,['learn'],['learning']
Usability,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373:174,simpl,simplified,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373,1,['simpl'],['simplified']
Usability,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:24,feedback,feedback,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050,1,['feedback'],['feedback']
Usability,@navidcy any thoughts?. I think the main feedback is to keep `add_callback!` and use `add_output_writer!` instead. I think it's not very pretty but I am ok with it. It's utilitarian 🤖 .,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2385598115:41,feedback,feedback,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2385598115,1,['feedback'],['feedback']
Usability,@navidcy curious to have your feedback on this proposed API,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3626#issuecomment-2177152344:30,feedback,feedback,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3626#issuecomment-2177152344,1,['feedback'],['feedback']
Usability,"@navidcy if halos are too small then the code often NaNs or seg faults. The issue here is that we auto adjust halos in the model constructor:. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. this means that with a higher-order advection scheme, `model.grid` ends up being different from what the user passes into the constructor. This is a usability issue, because it means that `VelocityFields(arch, grid)` built before the `model` is wrong for the default grid in common scenarios with high-order advection. Thus if users want to build `VelocityFields(arch, grid)` before building a `model`, they need to know about halos. We think this is undesirable. Neatly summed the issue is mainly that we probably can't rely exclusively on the model constructor to infer halo sizes, because the grid is a crucial object that often needs to have correct halo sizes before the model is constructed. Thus we need another solution to this usability issue. I'm proposing that we make the default halos large enough to accommodate almost all use cases to solve this problem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156:446,usab,usability,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-744385156,2,['usab'],['usability']
Usability,@navidcy it didn't work --- I'm fixing it. There's a lot of references to an 'embedded' model. Should we remove these @ali-ramadhan and simply call it a model ? It doesn't seem appropriate for documentation --- the model can be run without embedding it in anything.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470527589:136,simpl,simply,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470527589,1,['simpl'],['simply']
Usability,"@navidcy what do you think about the thermal bubble as the ""canonical minimal example"" ? Is there something better, more striking, simpler, more fun?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727298057:131,simpl,simpler,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727298057,1,['simpl'],['simpler']
Usability,"@navidcy, the title's been fixed and the issue identified with @glwagner. It's been resolved in commit [bbfc656](https://github.com/CliMA/Oceananigans.jl/pull/3573/commits/bbfc656582689e35256f0f3f8f93e98c2479c810). Regarding your earlier query, the output of `Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz` should be `(3, 3, 1)` rather than `(2, 4, 1)`. Initially, I used a `ConformalCubedSphereGrid` with `panel_size = (4, 4, 1)` and `horizontal_direction_halo = 2`, but later switched to a simpler `RectilinearGrid` with `size = (3, 3, 1)` and overlooked updating the line you referenced in the MWE.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088808432:485,simpl,simpler,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088808432,1,['simpl'],['simpler']
Usability,"@peterahrens also suggested that we really wanna swizzle. We can transpose yC and reshape Nz to (1, 1, Nz) but ideally reshape all of them so the intent of the code is clear. We can also construct a ProductArray or ArrayOfBlockAxes. ```julia; """"""; ArrayOfBlockAxes. A convenient lazy array type which turns a tuple of blocked axes into an array; of axes for each block.; """"""; struct ArrayOfBlockAxes{T, N, P <: NTuple{N, AbstractVector}} <: AbstractArray{T, N}; parts::P; function ArrayOfBlockAxes{T, N, P}(parts::P) where {T, N, P}; @assert T <: Tuple{map(eltype, parts)...}; return new{T, N, P}(parts); end; end. ArrayOfBlockAxes(parts) = ArrayOfBlockAxes{Tuple{map(eltype, parts)...}}(parts); ArrayOfBlockAxes{T}(parts) where {T} = ArrayOfBlockAxes{T, length(parts), typeof(parts)}(parts). Base.IndexStyle(::ArrayOfBlockAxes) = IndexCartesian(); Base.size(arr::ArrayOfBlockAxes) = map(part -> size(part, 1), arr.parts); Base.size(arr::ArrayOfBlockAxes, d::Int) = size(arr.parts[d], 1); Base.axes(arr::ArrayOfBlockAxes) = map(part -> axes(part, 1), arr.parts); Base.axes(arr::ArrayOfBlockAxes, d::Int) = axes(arr.parts[d], 1); (Base.getindex(arr::ArrayOfBlockAxes{T, N}, i::Vararg{<:Any, N})::T) where {T, N} = map(getindex, arr.parts, i); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/23#issuecomment-465377715:168,clear,clear,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/23#issuecomment-465377715,1,['clear'],['clear']
Usability,"@peterahrens thanks for that tip!. @vchuravy, by closure-specific temporary variables (or fields), I am referring to domain-size quantities that can be re-used in computing the contribution of an LES closure to the 'source terms' for momentum and tracers. In other words, [this line, which computes the source term for `u`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/a544300cabe6f8d872b7f9658284cad34c8619ad/src/time_steppers.jl#L223) could become something like. ```julia; kernel_temporaries!(subgrid_closure, ..., i, j, k); Gu[i, j, k] = ... + subgrid_closure.u(subgrid_closure_temporaries, ..., i, j, k); ```. ... I think. In physical terms, the intermediate variable is an 'eddy viscosity' that acts on all momentum terms. But I guess when I say the computation 'will benefit' from variables to store intermediate results, what I really mean is that I'm expecting the calculation of this temporary variable to be fairly involved (potentially >20 derivatives of velocity and tracer fields in x, y, z, plus scalar operations to combine the fields, and a 'clipping' function to make sure the viscosity is not negative --- see [the formula for the eddy viscosity predictor](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html#the-eddy-viscosity-predictor)). It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674:1336,simpl,simply,1336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674,1,['simpl'],['simply']
Usability,"@rafferrari we're using the frictional Re and Nu as defined by equation (20) of Vreugdenhil & Taylor (2018). ```; frictional Re = (friction velocity) * (domain height / 2) / ν; ```; Re is still a velocity scale U times a length scale L divided by ν just with specific choices for U and L. ```; advective heat transfer = (wall heat flux qw) / (wall temperature Θw); conductive heat transfer = κ / (domain height / 2); frictional Nu = (advective heat transfer) / (conductive heat transfer); ```; So Nu is still the ratio of advective to conductive heat transfer, just with specific definitions again. Well, my ""heat transfers"" have units of m/s I guess so maybe they're not exactly heat transfer rates... @glwagner Yeah it's written a little oddly as we can easily calculate the friction velocity squared (which I then take square roots of), but perhaps the script will be clearer if I just use `uτ`. The superscript `+` and `-` indicate the top and bottom wall values, but as @glwagner has pointed out the superscript `+` is reserved for wall units so perhaps I need to improve my notation here as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528830893:871,clear,clearer,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528830893,1,['clear'],['clearer']
Usability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:252,undo,undocumented,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['undo'],['undocumented']
Usability,"@siddharthabishnu could you help by adding some simple unit tests for views of views? It'd be nice to test correctness, I think something like this would work:. ```julia; grid = RectilinearGrid(size=(1, 1, 3), x=(0, 1), y=(0, 1), z=(0, 1)); c = CenterField(grid); set!(c, (x, y, z) -> rand()). # First test that regular view is right; cv = view(c, :, :, 2:3); @test c[1, 1, 2] == cv[1, 1, 2]; @test c[1, 1, 3] == cv[1, 1, 3]. # Now test views of views; cvv = view(cv, :, :, 3); @test cv[1, 1, 3] == cvv[1, 1, 3]; ```. We may also want to test that things error correctly like. ```julia; julia> view(cv, :, :, 1); ERROR: ArgumentError: view indices (Colon(), Colon(), 1) do not intersect field indices (Colon(), Colon(), 2:3); Stacktrace:; [1] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/dev/Oceananigans.jl/src/Fields/field.jl:315; [2] top-level scope; @ REPL[25]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Maybe. ```julia; @test_throws ArgumentError view(cv, :, :, 1); ```. Not sure what else we might want maybe @navidcy has ideas.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630:48,simpl,simple,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091009630,1,['simpl'],['simple']
Usability,@siddharthabishnu this PR changes 73 files at the moment. Are you sure this is intentional?. A lot of commits seem to have happened between _this post_ and my previous post. But they are mostly things already merged in main? But this PR seems to re-introduce the changes and sometimes undo them?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1723710908:285,undo,undo,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1723710908,1,['undo'],['undo']
Usability,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924:32,simpl,simpler,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924,1,['simpl'],['simpler']
Usability,@simone-silvestri . This is a result from our updated code that shows the free-surface height restricted to 9.9 and 10.1. You can clearly see that the instabilities happend around three particular regions. https://github.com/CliMA/Oceananigans.jl/assets/8239041/af15615a-7194-4ffc-88aa-69276b2e4c9a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2007643399:130,clear,clearly,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2007643399,1,['clear'],['clearly']
Usability,"@simone-silvestri : That sounds great!. If you point me to the `VectorInvariant` form I can certainly help simplify the current form to shallow water. One issue to think about is how to switch between the current shallow water model, which is in conservative form, but that's just a detail.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062146789:107,simpl,simplify,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062146789,1,['simpl'],['simplify']
Usability,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936:113,simpl,simple,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936,1,['simpl'],['simple']
Usability,"@simone-silvestri Unfortunately, my run died just before 20 days. I guess the simple advection scheme that I was using without viscosity wasn't stable enough. . Could you help me to set up the one you suggested on the previous PR? I tried was you suggested but got an error, which is copied above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134:78,simpl,simple,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988340134,1,['simpl'],['simple']
Usability,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244:44,simpl,simple,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244,1,['simpl'],['simple']
Usability,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:564,clear,clear,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009,1,['clear'],['clear']
Usability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:1062,user experience,user experience,1062,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,2,"['simpl', 'user experience']","['simplify', 'user experience']"
Usability,"@simone-silvestri, I'm trying to understand how I build a stretched grid using the `RectilinearGrid` constructor. I can pass an array or function to, e.g., keyword argument `z = ...`. But it's not clear what would the constructor do. Will it take that array or function and construct the faces of `z` or the centers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966636899:197,clear,clear,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966636899,1,['clear'],['clear']
Usability,@suyashbire1 it'd be great to get your feedback on my comment!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545433912:39,feedback,feedback,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-545433912,1,['feedback'],['feedback']
Usability,@suyashbire1 we can use this pattern to implement a `SimpleBoundaryCondition` type as well (which addresses a concern raised in #421 about a simple way to use a function to implement boundary conditions). Happy to work on that once this is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539583516:141,simpl,simple,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539583516,1,['simpl'],['simple']
Usability,"@tomchor ; > Using the more fundamental definition of `z_*` does circumvent some of the issues mentioned by @hdrake, no? (Like topography.). Somewhat, but even with the ""fundamental"" definition below there are some implicit assumptions. Winters et al. assume the area A is constant with depth. It's not clear to me that this formula still holds if A=A(z). Also not clear how to calculate a continuous A(z) from a discrete grid in a consistent way, especially with unstructured grids / or partial cells.; ![img](https://user-images.githubusercontent.com/13205162/117906167-3edf0900-b289-11eb-9f0e-a4b7accab2a0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418:303,clear,clear,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-845144418,2,['clear'],['clear']
Usability,"@tomchor @whitleyv what's the ultimate vision for this PR? @simone-silvestri and I discussed a method for adding immersed fluxes that would introduce a new term into the tendency kernels, eg here:. https://github.com/CliMA/Oceananigans.jl/blob/30ec599de5e3813d57b46e8d8fa4196bcdd250e0/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl#L44. adding something like. ```julia; + ∂ⱼ_τ₁ⱼ_immersed(i, j, k, grid, closure, diffusivities, immersed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:674,simpl,simpler,674,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,1,['simpl'],['simpler']
Usability,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674:199,clear,clearer,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674,1,['clear'],['clearer']
Usability,"@tomchor Yes! Thanks for catching that. @glwagner Thanks for the feedback! I think I know where to start. Although I may be approaching this from a NetCDF output perspective rather than a plotting perspective, I think the one solution we're discussing should satisfy both needs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450646793:65,feedback,feedback,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450646793,1,['feedback'],['feedback']
Usability,"@tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562:146,simpl,simplify,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974127562,2,['simpl'],"['simplifications', 'simplify']"
Usability,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:749,simpl,simply,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['simpl'],['simply']
Usability,@vchuravy I like the idea of doing both weak and strong scaling analysis. Can you point out any examples that you think do this well that we could use as a guide?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794009183:156,guid,guide,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794009183,1,['guid'],['guide']
Usability,"@whitleyv do you mind if I add a unit test to ensure that `IncompressibleModel` can take one time step with a simple `immersed_boundary`? This will exercise the code that's being added during CI, so that it can't be accidentally broken in a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405:110,simpl,simple,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368#issuecomment-781613405,1,['simpl'],['simple']
Usability,"@whitleyv let us know if this feature allows you to compute the time-derivative of outputted quantities, and there's any changes or additional features that might help with its usability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987151360:177,usab,usability,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100#issuecomment-987151360,1,['usab'],['usability']
Usability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:1239,simpl,simplify,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['simpl'],['simplify']
Usability,"A dubious honour to have the most comments but clearly there was a healthy discussion, and as a result we have a very nice example. I promise that my future examples will be more direct and will have shorter PR's. Thanks everyone for all the help and glad to put this to bed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798798794:47,clear,clearly,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798798794,1,['clear'],['clearly']
Usability,"A few more thoughts:. 1) It's probably simplest to use a native time-stepping schemes to advance particle trajectories. The third-order Runge-Kutta scheme seems like a fine choice. 2) I think it makes sense to launch one kernel to compute particle trajectories. ""One kernel per thread"" is a simple paradigm. Up to ""one particle per grid point"", we know this method will work well. 3) A few challenges that I see are: i) writing functions that linearly interpolate the velocity field to the particle location, and ii) dealing with boundaries. Enforcing boundary conditions, presumably, requries launching an additional kernel after a time-step is complete that checks the location of each particle and adjusts it if the particle location lies outside the domain. Enforcing periodic conditions presumably requires a cyclic shift of the particle location. I'm less sure how to deal with solid boundaries: perhaps reflecting the particle position (an elastic collision?) is a good model?. 4) I think tackling the problem of determining particle trajectories is a big enough challenge for now. I think once we have the ability to interpolate fields to the particle location, it may not be difficult to introduce ""auxiliary fields"" for each particle, with user-specified RHS that depend on local tracer and velocity fields at the particle position.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271:39,simpl,simplest,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271,2,['simpl'],"['simple', 'simplest']"
Usability,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:225,simpl,simplify,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638,2,['simpl'],"['simple', 'simplify']"
Usability,"A lot of code simplification, nice!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1055989896:14,simpl,simplification,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1055989896,1,['simpl'],['simplification']
Usability,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:218,guid,guide,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['guid'],['guide']
Usability,"A simple fix might write an `initialize_schedule!` method for `TimeInterval` that sets the `previous_actuation_time` to the current `model.clock.time`. The schedules are initialized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Simulations/run.jl#L140. `initialize_schedule!` for `TimeInterval` goes to the fallback:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L10. I think you'll also want to change the syntax of `initialize_schedule` to take `model` as an input, so all the functions will look like `initialize_schedule!(schedule, model)`. This also affects the one non-trivial `initialize_schedule!` method here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L92. Ultimately I think @qwert2266 is right. We need to checkpoint both models and output writers, or, better yet, the entire `simulation`. This checkpointing issue also affects time-averages since they have to be checkpointed too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280:2,simpl,simple,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280#issuecomment-749248280,1,['simpl'],['simple']
Usability,"A simple fix to manage to output $\eta$ will be to pass `indices=(:,:,1-grid.Hz)` in the `JLD2OutputWriter`. i.e.:; ```; simulation.output_writers[:surface] = JLD2OutputWriter(model, ; (η=eta,),; indices=(:,:,,1-grid.Hz),; schedule = TimeInterval(200),; filename = ""surface"",; with_halos = false,; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259:2,simpl,simple,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014687259,1,['simpl'],['simple']
Usability,"A simpler (but less general) solution than what is proposed above is simply to introduce a new struct:. ```julia; struct BoussinesqEquations{A, B, C, D, F, P} <: AbstractEquation; advection :: A; buoyancy :: B; coriolis :: C; diffusivity :: D; forcing :: F; pressure :: P; end; ```. This will reduce the number of fields in `Model`. We can also implement new equations 'types' that dispatch to different solvers if need be. This may also dramatically clean up the time-stepping functionality since we can pass `eq::Equation` in bulk rather than each parameter struct individually. Less general than a tuple of tendency kernels, but probably sufficient for anything we want to do in the forseeable future. We can then have a function eg `required_halo_size(eq::AbstractEquation)` that calculates the halo size according to the maximum halo size required by each of its 'terms'. Could also have an independent struct for tracer equations (or tuple of structs for each tracer). By the way, the more I think about it, the more I think that 'closure' should actually be called 'diffusivity', for clarity... cc @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-546944544:2,simpl,simpler,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-546944544,2,['simpl'],"['simpler', 'simply']"
Usability,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:690,simpl,simple,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,1,['simpl'],['simple']
Usability,"Actually `Array` and `CuArray` aren't `isbits`. But from what I understand, I think CUDAnative uses Adapt.jl to convert a `CuArray` to something like a `CuDeviceArray` which is `isbits` when passing arguments to CUDA kernels, which is what we would have to do to convert our `Field` structs to be `isbits`. But yeah, definitely agree about avoiding abstract and unspecified types. Comes with learning Julia I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970:392,learn,learning,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970,1,['learn'],['learning']
Usability,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:429,feedback,feedback,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033,1,['feedback'],['feedback']
Usability,"Adding the Manifest won't help for the tests because the test environment generates a new manifest every time, I learned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3880#issuecomment-2457661193:113,learn,learned,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3880#issuecomment-2457661193,1,['learn'],['learned']
Usability,After #1003 and #1012 it's tempting to simplify the `two_dimensional_turbulence.jl` example. But perhaps that goes beyond the scope of this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701791366:39,simpl,simplify,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701791366,1,['simpl'],['simplify']
Usability,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:51,clear,clear,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883,3,"['clear', 'simpl', 'usab']","['clear', 'simple', 'usability']"
Usability,"After talking a bit with @ali-ramadhan, I think we might have settled on the following solution:. * Introduce a new type called `PhysicalParameters` that holds `g` and `ρ0`; * Introduce a new abstract type called `Rotation` (or some such) that encodes information about the background rotation rate of the model --- `TangentPlane` with `f` and `β`, and possibly non-traditional Coriolis parameters, another type for the sphere, etc.; * Group viscous and diffusive transport coefficients into the upcoming `TurbulenceClosure` type, allowing for isotropic constant transport coefficients, anisotropic constant coefficients, or nonlinear closure schemes. These changes will also require us to compute buoyancy rather than a density perturbation, and may motivate us to simplify the code by defining variables in `pressures` as having units of the 'kinematic pressure', which is the ordinary pressure divided by `ρ0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546:766,simpl,simplify,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546,1,['simpl'],['simplify']
Usability,"Agree its good to be able to build docs, but I wouldn't personally recommend building docs to debug a simple plot like this one. It'd be much slower than just running the example script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867200404:102,simpl,simple,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867200404,1,['simpl'],['simple']
Usability,"Agreed. Unfortunately, I'm not entirely clear how to dispatch. It will presumably require I also change something in `IncompressibleModel`, . If can give me high level descriptions of what needs to be done where, I can give it a try later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762961317:40,clear,clear,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762961317,1,['clear'],['clear']
Usability,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:846,undo,undocumented,846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['undo'],['undocumented']
Usability,Ah I see your point now. I still feel that using `:left` and `:right` for the _x_ and _y_ directions and `:top` and `:bottom` for the _z_-direction is clearer but this is a minor point.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468301754:151,clear,clearer,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468301754,1,['clear'],['clearer']
Usability,"Ah I see. Well from what I see everything in the [TurbulentStatistic.jl](https://github.com/CliMA/LESbrary.jl/tree/main/src/TurbulenceStatistics) module is compatible with new versions of Oceananigans (except maybe GPU usage). Since that is what you are using, you can maybe use it locally?. This is just a quick fix to try out the new Oceananigans. ; Also, to try out if the problem persists it is enough to test some simple second-order moments. ; The ones you have in your script should do the job; ```; u, v, w = model.velocities; t = model.tracers.T. U = Average(u, dims=(1, 2)) ; V = Average(v, dims=(1, 2)); T = Average(t, dims=(1, 2)); wu = Average(w * u, dims=(1, 2)); wv = Average(w * v, dims=(1, 2)); uu = Average(u * u, dims=(1, 2)); vv = Average(v * v, dims=(1, 2)); ww = Average(w * w, dims=(1, 2)); www = Average(w * w * w, dims=(1, 2)); wT = Average(w * t, dims=(1, 2)); uv = Average(u * v, dims=(1, 2)); uT = Average(u * t, dims=(1, 2)); vT = Average(v * t, dims=(1, 2)); TT = Average(t * t, dims=(1, 2)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571:419,simpl,simple,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571,1,['simpl'],['simple']
Usability,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494:496,simpl,simple,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494,1,['simpl'],['simple']
Usability,Ah it's not a big deal so I wouldn't worry about for this PR!. It's too late to undo right now since it's in git history and fully deleting it would involve rewriting git history which is usually bad haha. We did it once before (https://github.com/CliMA/Oceananigans.jl/issues/509) but we had lots of 50 MiB files so it was needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839888796:80,undo,undo,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839888796,1,['undo'],['undo']
Usability,"Ah right I didn't think of it that way, thanks! Might make the time stepping look cleaner if we make it clearly mark the explicit and implicit parts? I guess it might be arbitrary as the implicit pressure correction step is followed by an explicit time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463201139:104,clear,clearly,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463201139,1,['clear'],['clearly']
Usability,"Ah so great. One quick thought: we can reinterpret time_step to refer only to a single time-step, and move the current multi step function to run! Then time_step does not take keyword arguments. Is there a convenience function that takes AbstractModel as input rather than Simulation? I think that’s important for simple scripts and examples. Agree this is a huge breaking change that we should finalize as soon as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584480947:314,simpl,simple,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584480947,1,['simpl'],['simple']
Usability,"Ah sorry I must have misunderstood your question. Yeah I think broadcasts; tend to perform really well on scalar operations so I don't see why not. On Tue, Mar 5, 2019, 12:13 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm not suggesting we should always use broadcasting. I'm just wondering; > if it's ok to use it for simple operations. It's a nice abstraction that; > works on CPUs and GPUs for simple calculations / global array updates (for; > example; > <https://github.com/glwagner/StaggeredPoisson.jl/blob/d104825ba33f184af3b90ca0d958247d0011c7ad/src/solvers.jl#L148>; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/108#issuecomment-469768233>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBSiIR6hlh-r4hjpSmahUJhp3x7Gzks5vTqXEgaJpZM4bfFUj>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111:335,simpl,simple,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111,2,['simpl'],['simple']
Usability,Ah sorry for the slow reply @arcavaliere but I think I accidently ended up doing this last week as part of PR #570 and forgot to reference this issue! . @arcavaliere What sort of stuff are you interested in helping out with or learning more about?. PS: Are you the [Julia Slack](https://slackinvite.julialang.org/)? Might be easier to discuss stuff on there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/466#issuecomment-566710021:227,learn,learning,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/466#issuecomment-566710021,1,['learn'],['learning']
Usability,"Ah sorry you're right, good catch! I updated the original list with the actually supported topologies. Although I guess a side note worth mentioning is that I think you can create a grid with any topology and it won't error until it tries to construct a pressure solver. Might be clearer and more user friendly to print a useful error/warning when constructing the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732278652:280,clear,clearer,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732278652,1,['clear'],['clearer']
Usability,"Ah thanks for pointing this out @zhenwu0728! I didn't realize that. It also seems that `deleteat!` is not defined for `StructArray`... ```julia; julia> s = StructArray{ComplexF64}((randn(5), randn(5))); 5-element StructArray(::Array{Float64,1}, ::Array{Float64,1}) with eltype Complex{Float64}:; 0.6663581952584336 - 1.5283519296646326im; -0.4906568589874505 - 0.325094980686686im; 1.1453745422319603 + 0.07874273417016024im; 1.0280155738262986 - 0.37561698848991654im; 1.1466416201897343 - 1.1904623364760012im. julia> deleteat!(s, 2); ERROR: MethodError: no method matching deleteat!(::StructArray{Complex{Float64},1,NamedTuple{(:re, :im),Tuple{Array{Float64,1},Array{Float64,1}}},Int64}, ::Int64); Closest candidates are:; deleteat!(::Array{T,1} where T, ::Integer) at array.jl:1306; deleteat!(::Array{T,1} where T, ::Any) at array.jl:1343; deleteat!(::BitArray{1}, ::Integer) at bitarray.jl:935; ...; Stacktrace:; [1] top-level scope at REPL[13]:1; ```. @suyashbire1 and I decided to focus on just supporting a constant number of particles for now since it's not super clear what the best approach is for saving particle locations to disk when the number of particles keeps changing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733875716:1073,clear,clear,1073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-733875716,1,['clear'],['clear']
Usability,"Ah well I retract my comments about the validity of theory, based on this new information! We are good to go --- provided that the Stokes drift we use is the solenoidal Stokes drift. In that case, we can cope with rapid horizontal variation of the Stokes drift it seems, and still model a non-divergence Lagrangian-mean flow. But we should be clear about this in the documentation for this new type StokesDrift. > Also, based on your last comment should we just remove the vertical component of Stokes drift? It only appears in the Stokes-related forcing through its horizontal derivatives. I think we _need_ the vertical component to retain consistency in the case of modulated waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813278220:343,clear,clear,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813278220,1,['clear'],['clear']
Usability,"Ah yeah I guess that's not a user-friendly feature so having the keys go 0, 1, 2, 3, ... would be easier to work with. If you want the iteration number I think we can save it like `file[""time""]` (which we already do) and `file[""iteration""]`. Hmmm, on one hand I think it should start at 1 though since Julia is 1-based indexing but 0 makes sense for initial condition...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-696830804:29,user-friendly,user-friendly,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-696830804,1,['user-friendly'],['user-friendly']
Usability,Ah yeah. I didn't put `view` in the example just to keep it simple but the point of all of this is to support all fields. `view` returns a `Field` so should be supported.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3715#issuecomment-2296888889:60,simpl,simple,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3715#issuecomment-2296888889,1,['simpl'],['simple']
Usability,Ah yes good point. We're kind of already using milestones (only up to v0.7 right now) but this was kind of to discuss which milestones to tackle and in which order. I made the title a bit clearer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486458979:188,clear,clearer,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-486458979,1,['clear'],['clearer']
Usability,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817:75,usab,usable,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817,1,['usab'],['usable']
Usability,"Ah yes, we will have to change the user API so that it no longer accepts an advection scheme. We would also need a utility like. ```julia; total_velocities = with_advective_forcing(forcing, total_velocities); ```. that would add the forcing velocity when `forcing::AdvectiveForcing` (and otherwise simply returns `total_velocities`). That utility probably belongs in `advective_forcing.jl`. And `SumOfArrays` needs to support 3?. https://github.com/CliMA/Oceananigans.jl/blob/fa5e280115f619d01a460f012328bd7e6d253b38/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L64-L66",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1679169187:298,simpl,simply,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1679169187,1,['simpl'],['simply']
Usability,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:348,simpl,simple,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,1,['simpl'],['simple']
Usability,"Ah, maybe this happened because of a new method in OffsetArrays 1.3.0:. ```; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...); ```. This is a simple fix. We should call the Oceananigans function `new_offset_data` or something like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/991#issuecomment-700273920:155,simpl,simple,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991#issuecomment-700273920,1,['simpl'],['simple']
Usability,"Ah, sorry for not being clear. In summary: I agree with you. I can't think of anything better than `active_tracers` though. My suggestion is:. - Rename `buoyancy.model` to `buoyancy.active_tracers`; - Rename `SeawaterBuoyancy` to `TemperatureSalinityTracers`. Which I think is pretty clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648:24,clear,clear,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648,2,['clear'],['clear']
Usability,"Ah, thanks for clarifying as clearly I was mistaken. I thought I needed to impose the boundary conditions on the total field, background + deviation. If that's not the case then the boundary conditions are set up correctly. I believe the next thing to try is the same set up but without `BackgroundField` and imposing the Neumann boundary conditions associated with the buoyancy frequency. If that behaves correctly, then the problem would appear to be in `BackgroundField`, as you suspect. . **Update:** ; I made the following changes,. - Removed the background field from model,; - Added `N^2 * (z + D)` into the initial conditiosn of the buoyancy,; - Imposed `buoyancy_gradient_bc` at the top and bottom of the domain. Unfortunately, the same problems occur at the boundary. . This does not seem to be imposing the correct boundary conditions on a tracer field at the top and bottom. **Periodic condition:**; I did try setting the vertical direction to periodic and unfortunately that gave an error, copied below. . Is this a seperate problem or do people think it's related?. ```; ERROR: LoadError: ArgumentError: batching dims must be sequential; Stacktrace:; [1] create_plan(::CUDA.CUFFT.cufftType_t, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:140; [2] plan_fft! at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:256 [inlined]; [3] plan_forward_transform at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:42 [inlined]; [4] plan_transforms(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CUDA.CuArray{Complex{Float64},3}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:106; [5] Oceananigans.Solvers.FFTBasedPoissonSolver(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594:29,clear,clearly,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594,1,['clear'],['clearly']
Usability,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530:126,simpl,simple,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530,1,['simpl'],['simple']
Usability,"Ahh I see now, thank you very much! That is very clear. May I ask why you have implemented it this way? Wouldn't it be easier to add and subtract the term off each diagonal element rather than deep copy the constructors? It certainly simplifies the `update_diag!` function but is it more efficient overall?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989:49,clear,clear,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179425989,2,"['clear', 'simpl']","['clear', 'simplifies']"
Usability,"All Krylov solvers in `Krylov.jl` can take an operator as input, so if your operator-vector products can use multiple GPUs, it will already be faster.; We can develop a specific array type to limit communication and also use multiple GPUs on less expensive operations (norm, dot, axpy, ...), but simply using multiple GPUs for the most expensive part (operator-vector/operator-matrix products) will already lead to a significant speed-up. ref: https://github.com/JuliaSmoothOptimizers/Krylov.jl/issues/441",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386710918:296,simpl,simply,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386710918,1,['simpl'],['simply']
Usability,"Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509:348,learn,learn,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509,1,['learn'],['learn']
Usability,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691,1,['clear'],['clear']
Usability,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:267,simpl,simple,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882,2,['simpl'],['simple']
Usability,"Although I prefer being explicit I'm a big fan of the macro you suggested as it collapses 20+ lines into a single elegant statement (and buries the ugly unpacking) whereas the `unpack_model` function still requires a comma separate list of 20+ variables. I think I'll go with the simple macro. If the unpacking variables have descriptive names, e.g. `grid`, `source_terms`, `velocities`, etc. then I think it'll still be understandable without being explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870:280,simpl,simple,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870,1,['simpl'],['simple']
Usability,"An “edge” is the case in which 2 of Lx, Ly, or Lz are “interface”. We just; don’t need special notation. This method of specifying locations in a cube; is simpler, but also more general. On Sat, Mar 9, 2019 at 8:52 AM Ali Ramadhan <notifications@github.com>; wrote:. > Ah yes I remember @jm-c <https://github.com/jm-c>'s concern now! Yes,; > just ""face"" and ""edge"" are ambiguous.; >; > So your proposed solution will make it explicit exactly which interface; > the field is being interpolated from and to, which will be nice.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471178907>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBlzM_EBoVLsfUYqw-V_v_Pe2admmks5vU7yqgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020:155,simpl,simpler,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020,1,['simpl'],['simpler']
Usability,"And note that we only really need a unit test to merge this, same for many things. Correctness is a high bar and it's ok if we can't come up wtih someone right away. Sometimes we don't really have a way to do correctness and our best option is something like a regression test (eg we verified it worked at one point, so we just make sure that it keeps returning that same result). . One way to go partway towards functional test but not all the way to ""correctness"" is to simply test that a simple set up returns a different result when closure fluxes are included vs not (for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433794044:472,simpl,simply,472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433794044,2,['simpl'],"['simple', 'simply']"
Usability,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:453,simpl,simplified,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370,2,['simpl'],"['simplification', 'simplified']"
Usability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:372,simpl,simply,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,1,['simpl'],['simply']
Usability,"Another design we can consider is something like:; ```julia; grid = RegularCartesianGrid(size=(x=128, z=64), x=(-1, 1), z=(-1, 0), topology=(x=Periodic, z=Bounded)); ```; where since `y` has not been specified, it is assumed to be `Flat`. This makes the grid constructors more verbose but has the added benefit of being clearer and not having to specify flat dimensions, i.e. it's an xz-model so y should not even be mentioned. It would require a lot more refactoring though... but now's the time I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270:320,clear,clearer,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270,1,['clear'],['clearer']
Usability,"Another possibility is to get rid of `diffusivity_fields` altogether and put fields inside the closures. Then users have to write things like `AnisotropicMinimumDissipation(grid)`, and we probably also need to stop ""auto halo inflation"" (instead throwing an error). Might be worth it though. Also if we have `halo = (3, 3, 3)` by default then users will basically never have issues with grid construction / halo sizes. Putting fields inside the closures also makes `OceanLearning.jl` more complicated. For example, if we want to change the parameters of a model closure, we ""only"" have to build a new closure with the same type but different parameters. If we put fields inside the closures, we have to work a little harder to combine the existing closure fields with new closure parameters. Those problems are all solvable, so it's just a question of whether simplifications here are worth complications elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065:860,simpl,simplifications,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064169065,1,['simpl'],['simplifications']
Usability,Another test that reveals a problem with non-separated pressure is a simple horizontal wall in a 2D setup.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149062:69,simpl,simple,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149062,1,['simpl'],['simple']
Usability,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:117,simpl,simplest,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320,1,['simpl'],['simplest']
Usability,"Apart from `overwrite_existing` default, it seems like we have consensus that we should use `add_output_writer!` for this PR. I'll make that change and switch over the examples as well. I'll open an issue to discuss the `outputinfo` utility. I also think that an `output!` function would be useful, which simply writes the current state. Recently I have been found myself wanting only the final state of the simulation. It's a little convoluted to have to set up an output writer with a schedule for that task, it'd be easier to write. ```julia; run!(simulation); output!(""cool_stuff.jld2"", simulation); ```. in the above, the filename goes first because that's the thing being ""modified"" (similar to how `save` works)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341:305,simpl,simply,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2433135341,1,['simpl'],['simply']
Usability,"Are we sure this is very useful, or is it simply a hypothesis that this may be useful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-523233294:42,simpl,simply,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-523233294,1,['simpl'],['simply']
Usability,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:136,clear,clear,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,2,"['clear', 'simpl']","['clear', 'simplify']"
Usability,"As a side note, if we resolve #884, we can advocate the philosophy that `JLD2` output writer is for ""experimenting"" / ""personal use"", while `NetCDF` is what you should use if you intend to share your data. If it's easy to switch between the two, and we can make this concept clear, we can have a strict / hard-to-use NetCDF writer that ensures shareable, interpretable output, and a looser but easier-to-use JLD2 output writer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/885#issuecomment-683311959:275,clear,clear,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885#issuecomment-683311959,1,['clear'],['clear']
Usability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:495,user-friendly,user-friendly,495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,1,['user-friendly'],['user-friendly']
Usability,"As discussed elsewhere, it might be most convenient for users if an interface to applying moving averages is provided within the constructor for an output writer, rather than creating a wrapper object like `TimeAveragedOutputWriter`. An example of this would be. ```julia; U = HorizontalAverage(model.velocities.u); V = HorizontalAverage(model.velocities.v). statistics_writer = JLD2OutputWriter(model, (U=U, V=V), time_interval=1hour, time_averaging_window=1minute); ```. The advantage of this syntax is that deciding to time-average output is as simple as adding a keyword argument to an existing output writer. This may be easier to user than previously proposed interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748:548,simpl,simple,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748,1,['simpl'],['simple']
Usability,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:150,simpl,simple,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,3,['simpl'],"['simple', 'simply']"
Usability,"As for the API, it might simplify matters to have `architecture` as a positional argument, so that we dispatch on it. So we might end up with syntax that looks something like. ```julia; grid = RegularRectilinearGrid(CPU(), float_type=Float32, size=(1, 1, 1), x=(0, 1), y=(1, 2), z=(-3, 0)); ```. We can also add an `architecture` kwarg if others think that's better, eg. ```julia; grid = RegularRectilinearGrid(architecture=CPU(), float_type=Float32, size=(1, 1, 1), x=(0, 1), y=(1, 2), z=(-3, 0)); ```. We will have to translate the `architecture` kwarg to a positional arg (so that we can dispatch on it for the purpose of `Oceananigans.Distributed`). This adds some boilerplate for all grids, but isn't ultimately a huge concern. @christophernhill might have some useful comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880847069:25,simpl,simplify,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880847069,1,['simpl'],['simplify']
Usability,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:126,feedback,feedback,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354,5,"['feedback', 'simpl']","['feedback', 'simple', 'simpler', 'simply']"
Usability,"As the diff shows, this PR reconstructs buoyancy at the location it's needed. For example, `x_dot_g_b` must reconstruct the buoyancy perturbation, which is located at tracer locations `ccc`, at the location `fcc`. . Similarly, `z_dot_g_b` should be reconstructed at `ccf` (the location of vertical velocity). Note that we _also_ do this reconstructed when computing the hydrostatic pressure integral, therefore:. $$ p_h = \int^0_z \bar b^z \text{ } dz $$. where $\overline{()}^z$ indicates a reconstruction in $z$. Previously, we were assuming within the hydrsotatic pressure integral that `z_dot_g_b` returned at `ccc`. The first commit on this PR changed the reconstruction for `z_dot_g_b` so it returns at `ccf`. However, making this change also requires ""undoing"" the reconstruction in the hyrostatic pressure integral, which previously assumed that `z_dot_g_b` returned at `ccc`. With both changes, the regression tests should pass _and_ tilted gravity should be fixed. Hope that clears things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518051721:759,undo,undoing,759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518051721,2,"['clear', 'undo']","['clears', 'undoing']"
Usability,"Awesome! And to be more clear, I think the reason we want it to work is so that we can also reuse all the other schedules. Another reason to use it is because we may need to change `TimeInterval` in the future if we support different time types (for example `DateTime`, or other time types that solve the annoying problem of rounding error). So in all those cases it will be nice not to have to worry about different implementations of time interval schedules.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994:24,clear,clear,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3523#issuecomment-2023010994,1,['clear'],['clear']
Usability,"Awesome! I'll close the issue then. Hmmm, not sure what you're running but in general Oceananigans.jl doesn't give too much feedback (something we're hoping to improve, see #1013). If you're running things in the REPL it'll print/display what each expression returns (see below) but `run!` doesn't produce output or report on progress by default (perhaps it would be good to add a reasonable default). ```julia; julia> using Oceananigans. julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [-5.496153587253255e-18, 6.283185307179586], y ∈ [-5.496153587253255e-18, 6.283185307179586], z ∈ [-1.0, 1.7080354225002348e-17]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (100, 100, 50); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.06283185307179587, 0.06283185307179587, 0.02). julia> model = IncompressibleModel(grid=grid); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=100, Ny=100, Nz=50); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=60, stop_time=3600); Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (Int64): 1 minute ; ├── Iteration interval: 1; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 1 hour, stop iteration: Inf; ├── Diagnostics: OrderedCollections.OrderedDict with no entries; └── Output writers: OrderedCollections.OrderedDict with no entries. julia> run!(simulation); [ Info: Simu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/537#issuecomment-724191682:124,feedback,feedback,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/537#issuecomment-724191682,1,['feedback'],['feedback']
Usability,"Awesome! I'm happy to sit down and chat. I've had two meetings today with; MIT groups (ocean engineering and self-assembly lab), so maybe next week...; ;-). Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Fri, Oct 30, 2020 at 3:52 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJYHOUF5GATVQ66VU7TSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164:1013,simpl,simple,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719715164,1,['simpl'],['simple']
Usability,"Awesome. It looks like it'd require a bit of serious concentration / squinting. But hopefully the existing 5th order WENO implementation:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/weno_fifth_order.jl. is helpful. To use this we need to resolve #1015 (simple fix, but requires a bit of logic in the constructor for `IncompressibleModel` similar to what's done for viscosities and diffusivities) so that we can use different schemes for different fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1173#issuecomment-726735243:277,simpl,simple,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1173#issuecomment-726735243,1,['simpl'],['simple']
Usability,"B1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `76.54% <0.00%> (-5.28%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.07% <0.00%> (-0.55%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <0.00%> (-0.12%)` | :arrow_down: |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [44 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=footer). Last update [810a3a1...9128ab2](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/881?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-682318992:3048,learn,learn,3048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881#issuecomment-682318992,1,['learn'],['learn']
Usability,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777:208,clear,clear,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777,1,['clear'],['clear']
Usability,"Both `Function`s and `FunctionField`s are supposed to be supported in `AbstractOperation`s. In fact, supporting `Function`s in `AbstractOperations` is the original purpose of `FunctionField`. For example, see:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/AbstractOperations/binary_operations.jl#L80-L82. Though I appreciate you may have tried to simplify your code from some original example to produce an MWE, I think it's still a bit complicated to diagnose the issue. I've shown that you can construct a `ComputedField` using a `Derivative` acting on a `BinaryOperation` between a concrete `Field` and `FunctionField`. What ingredient(s) do we need to add to my example to break it? What specifically is going wrong?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769240410:393,simpl,simplify,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769240410,1,['simpl'],['simplify']
Usability,Branch off this branch to a new one and we can continue working there. Or branch off only the src changes and merge them. Whatever seems simpler.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890349625:137,simpl,simpler,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890349625,1,['simpl'],['simpler']
Usability,But can we do one thing at a time? I feel a lot of non-trivial changes are making their way in at the same time. Why don't we first ensure that we are happy with simple open boundary conditions where the outflow and/or inflow velocities are prescribed? Then we can work on getting the code together for cases where the boundary velocities are computed by some rule.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977653215:162,simpl,simple,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1977653215,1,['simpl'],['simple']
Usability,"By ""mutable"" function you mean one that modifies its args? But don't they all return nothing?. Seems you are getting down to the bottom it yourself... Perhaps try writing a simple code of your own then and running the debugger there? E.g. ```julia; function my_own_function!(a); a = 2a; return nothing; end. a = 17. my_own_function!(a). b = 10a; ```. or something like that and see if you get the same error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963:173,simpl,simple,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1616937963,1,['simpl'],['simple']
Usability,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095:59,simpl,simple,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095,1,['simpl'],['simple']
Usability,"Can we come up with a MWE, maybe a simple 2 point single column model that can be copy/pasted here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308123094:35,simpl,simple,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308123094,1,['simpl'],['simple']
Usability,Can you change the first post so merging this issue closes #3415 (and makes the connection clear),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179816144:91,clear,clear,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3416#issuecomment-2179816144,1,['clear'],['clear']
Usability,Can you explain how topology was removed? I was under the impression this was necessary for determining connectivity (or something like that) but clearly this is wrong. A detailed explanation would be helpful...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758077354:146,clear,clearly,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758077354,1,['clear'],['clearly']
Usability,Can you make a MWE? (Lower resolution... simplify initial condition)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725840281:41,simpl,simplify,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-725840281,1,['simpl'],['simplify']
Usability,Changing git history is also a bit annoying and somewhat labor intensive; there's no quick undo.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839943210:91,undo,undo,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839943210,1,['undo'],['undo']
Usability,Closing as this issue has served its purpose (for me at least). Development milestones are clearer now. Further discussion should occur in more focused issues.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-500859806:91,clear,clearer,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207#issuecomment-500859806,1,['clear'],['clearer']
Usability,"Closing as we have implemented @glwagner's simplest solution, e.g. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Models/IncompressibleModels/incompressible_model.jl#L87",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-800735149:43,simpl,simplest,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-800735149,1,['simpl'],['simplest']
Usability,Closing this PR as a simpler/lighter implementation of constant Smagorinsky has been included in v0.9.0.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-517088340:21,simpl,simpler,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-517088340,1,['simpl'],['simpler']
Usability,Closing this since it'll undo https://github.com/CliMA/Oceananigans.jl/pull/1997,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1999#issuecomment-937048847:25,undo,undo,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999#issuecomment-937048847,1,['undo'],['undo']
Usability,"Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=h1) Report; > Merging [#148](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/068da17959c1e125e4d1f9e62f0e287370f4de71?src=pr&el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #148 +/- ##; ==========================================; + Coverage 65.97% 66.03% +0.05% ; ==========================================; Files 19 19 ; Lines 629 630 +1 ; ==========================================; + Hits 415 416 +1 ; Misses 214 214; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80.76% <100%> (+0.76%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=footer). Last update [068da17...bcfacda](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/148?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/148#issuecomment-475479721:1568,learn,learn,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148#issuecomment-475479721,2,['learn'],['learn']
Usability,"Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=h1) Report; > Merging [#378](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/8c1c776b50df17ff10735e57488f22b20d455303?src=pr&el=desc) will **decrease** coverage by `0.05%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #378 +/- ##; ==========================================; - Coverage 78.37% 78.32% -0.06% ; ==========================================; Files 22 22 ; Lines 1244 1241 -3 ; ==========================================; - Hits 975 972 -3 ; Misses 269 269; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=footer). Last update [8c1c776...3e13ace](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/378?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/378#issuecomment-525945184:1568,learn,learn,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/378#issuecomment-525945184,1,['learn'],['learn']
Usability,"Could someone please explain why `minimum_fractional_Δz` is necessary? For example, why is the default value not 0, which would be (imo) more intuitive? I couldn't find this anywhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131700908:142,intuit,intuitive,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1131700908,1,['intuit'],['intuitive']
Usability,"Couple random notes and questions:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L177-L178. belong in `Grids`. Why `W isa Number` for `zweno == true`?. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L171. That line should be written. ```julia; W = zweno ? Number : Nothing; ```. but note we can also simply use `zweno` as the type parameter directly so . ```julia; const JSWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, false}; const ZWENO = WENO5{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Any, true}; ```. might make senes to move that parameter to the top of the struct. The weight calculations in the code are difficult to read and understand:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L642-L668. How can we improve this? I think more describe names would help self-document at least (eg what are `j, c, m, num, l, i, op`?). We probably should add a specific reference to an equation in the comment / docstring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047936316:450,simpl,simply,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271#issuecomment-1047936316,1,['simpl'],['simply']
Usability,"Coverage Diff @@; ## master #1083 +/- ##; ==========================================; + Coverage 56.76% 56.79% +0.03% ; ==========================================; Files 161 161 ; Lines 3793 3796 +3 ; ==========================================; + Hits 2153 2156 +3 ; Misses 1640 1640 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (ø)` | |; | [src/TimeSteppers/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy91cGRhdGVfc3RhdGUuamw=) | `87.50% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `87.93% <100.00%> (+0.21%)` | :arrow_up: |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `76.31% <100.00%> (+0.64%)` | :arrow_up: |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `79.16% <100.00%> (+0.29%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=footer). Last update [e2c1ee4...6dc402c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1083?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-713749219:2176,learn,learn,2176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1083#issuecomment-713749219,1,['learn'],['learn']
Usability,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:1655,clear,clearer,1655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,1,['clear'],['clearer']
Usability,"Currently, I'm just using Oceananigans.jl as the provider of velocities. Nutrients and plankton individuals are all computed in [PlanktonIndividuals.jl](https://github.com/zhenwu0728/PlanktonIndividuals.jl). . But I'm happy to set up a simplified biogeochemical module just in Oceananigans.jl. I'd like to start with one kind of phytoplankton and one kind of nutrient( e.g. Nitrogen) cycle first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629412454:236,simpl,simplified,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629412454,1,['simpl'],['simplified']
Usability,"Dedalus adds all the ""grid-crossing frequencies"" (e.g. `u/dx`, `v/dy`, `w/dz`) at each point, takes the maximum of this quantity across all grid points, and takes its reciprocal to determine the CFL time. We chose this because its pretty simple and properly handles doppler boosting of waves on top of mean flows. Apparently according to wikipedia this is also the right thing for diagonal velocities... but I'm not sure that's something you can show rigorously for spectral methods. Maybe so. In any event, we find that the stability boundaries in terms of the CFL safety factor (scaling the `dt` selected as described) vary a lot based on the timestepper and problem, anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-735250942:238,simpl,simple,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-735250942,1,['simpl'],['simple']
Usability,Def not worth undoing!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235869936:14,undo,undoing,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235869936,1,['undo'],['undoing']
Usability,"Definitely agree with everything @glwagner said!. > I am very curious to learn about what is currently being worked on. I can share a bit about what I've been working on (and hope to work on). Right now I'm almost done adding some support for Lagrangian particle tracking (PRs #1090 and #1091). After that I'm hoping to upgrade the pressure solver to use 1D FFTs and DCTs for the CPU and GPU (#586, #1007). This would allow us to support all possible topologies on the GPU but might require some playing around with the CuFFT library (see https://github.com/JuliaGPU/CUDA.jl/issues/119). So if you know someone who's interested in FFTs and GPUs (or interested in learning about them!), this might be useful problem to work on! I think some other members of the Julia community would benefit from figuring this out as well. Also hoping to revisit trying to support distributed parallelism with MPI (#590). So if there's someone interested in the nuts and bolts of distributed parallelism, might be great to work on this together!. We also have an early/experimental compressible version of Oceananigans.jl (see #1079 and https://github.com/ali-ramadhan/Atmosfoolery.jl) if you guys are interested in compressible fluid dynamics. > (and I can look at the issues for that I suppose). We should definitely clean those up! We have a ""good first issue"" tag that should be useful in these situations but we should use the tag more often.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724264485:73,learn,learn,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724264485,2,['learn'],"['learn', 'learning']"
Usability,"Did a quick small strong scaling benchmark on Tartarus (256^3) up to 16 cores but results don't look super great? ~9.5x speedup on 16 cores. Better than multi-threading though. Maybe I'm not benchmarking properly though. Could also be missing some MPI barriers. Should probably learn how to profile MPI code. ```; Incompressible model strong scaling benchmark; ┌─────────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├─────────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ (256, 256, 256) │ 1 │ 3.641 s │ 3.686 s │ 3.686 s │ 3.730 s │ 355.28 KiB │ 2336 │; │ (256, 256, 256) │ 2 │ 1.917 s │ 1.918 s │ 1.921 s │ 1.928 s │ 346.00 KiB │ 2782 │; │ (256, 256, 256) │ 4 │ 1.249 s │ 1.283 s │ 1.279 s │ 1.300 s │ 348.47 KiB │ 2822 │; │ (256, 256, 256) │ 8 │ 652.029 ms │ 714.833 ms │ 704.940 ms │ 738.885 ms │ 353.84 KiB │ 2902 │; │ (256, 256, 256) │ 16 │ 377.153 ms │ 388.435 ms │ 394.780 ms │ 415.562 ms │ 366.16 KiB │ 3062 │; └─────────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Incompressible model strong scaling speedup; ┌─────────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├─────────────────┼───────┼─────────┼──────────┼─────────┤; │ (256, 256, 256) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (256, 256, 256) │ 2 │ 1.92195 │ 0.973876 │ 1.19092 │; │ (256, 256, 256) │ 4 │ 2.87312 │ 0.980825 │ 1.20805 │; │ (256, 256, 256) │ 8 │ 5.15614 │ 0.995954 │ 1.24229 │; │ (256, 256, 256) │ 16 │ 9.48879 │ 1.03061 │ 1.31079 │; └─────────────────┴───────┴─────────┴──────────┴─────────┘; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624:278,learn,learn,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624,1,['learn'],['learn']
Usability,"Different perspectives are important and I admit that I have not thought about stokes drift from that perspective. Maybe mentioning this with a good reference might be appropriate? Not sure how much in depth one wants to get into this. I learned about pseudomomentum in the context of Hamiltoninan theory, but don't suspect we want to get into that level of detail, even though it is fun!. Also, if you mention pseudomomentum then do you need to also mention pseudoenergy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777567578:238,learn,learned,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777567578,1,['learn'],['learned']
Usability,Do you mean when we're computing a diagnostic like vorticity should the kernel include the boundary point? It does seem the simplest would be that anything on a bounded face only launches over 2:N,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389135623:124,simpl,simplest,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2389135623,1,['simpl'],['simplest']
Usability,"Docs are previewing here: https://clima.github.io/OceananigansDocumentation/previews/PR3080/. I checked all the examples with `NonhdyrostaticModel` and they all look the same as they do on the `stable` branch. Furthermore, the few tests failures that we have are all something like. ```; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/test/test_jld2_output_writer.jl:131; --;   | Expression: wu == zero(FT);   | Evaluated: -3.009265538105056e-35 == 0.0; ```. i.e. very small approximation errors that aren't indicative of any significant errors in the model. In other words, I think this is working well! I vote we simplify the model and get rid of the hydrostatic separation. @glwagner as you mentioned, this isn't a trivial change. If you wanna move forward with it, feel free to push to this PR or close this one and open another. I can also help if you want, just lmk what I should focus on. PS: Just like we did in https://github.com/CliMA/Oceananigans.jl/pull/1910 we might need/want to replace the `stratified_fluid_remains_at_rest_with_tilted_gravity_buoyancy_tracer()` test for something simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718:671,simpl,simplify,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1518394718,2,['simpl'],"['simpler', 'simplify']"
Usability,Does someone have a minimal example that reproduces this error? I'm just curious to learn more about the problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738823622:84,learn,learn,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738823622,1,['learn'],['learn']
Usability,"Ended up being a simple issue where; ```julia; set!(u::Field{A1}, f::Function) where {A1 <: OffsetArray{T, D, <:CuArray} where {T, D}}; ```; assumed `u_cpu` was always a `CellField`. Tests should pass now. Let me know if this makes sense but I also moved your `set_velocity_tracer_fields` test to `test_models.jl` as it constructs a model, but we don't know if `model()` actually works until we test it in `test_models.jl`. So now we test `set!` after `model()` has been tested.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519507996:17,simpl,simple,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343#issuecomment-519507996,1,['simpl'],['simple']
Usability,"Excellent advice @navidcy , I will probably do just that. I do install it on my ubuntu machine but suppose I need to learn to install it for a user only. A good thing to learn.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716:117,learn,learn,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468#issuecomment-799894716,2,['learn'],['learn']
Usability,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:81,simpl,simple,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168,1,['simpl'],['simple']
Usability,"For reducing any `AbstractField` over ""windows"", `ConditionalOperation` is sufficient. The task there is to define `condition` appropriately (`mask` is chosen as the ""neutral"" value for the particular reduction). I guess there isn't an ordinary constructor for `ConditionalOperand`, but there is a function `condition_operand`... https://github.com/CliMA/Oceananigans.jl/blob/b5bf45ed51587954f61ca7492e946fef69ff72ee/src/AbstractOperations/conditional_operations.jl#L23. (@simone-silvestri why is this function not simply a constructor for `ConditionalOperand`?) This feature is new so the API might change. We also need doc strings... ## On views of `Field`... We may also eventually want to implement the concept of `view`s of `Field`s. I think if that were implemented properly, we'd be able to reduce those objects. . #2177 is related; the location `Level` proposed there could handle slices across a whole dimension (but not necessarily ""windowing""...). This is for another issue, but field ""windows"" might be easy to support by using a `view` for `data`. Cause then:. ```julia; julia> a = rand(4); 4-element Vector{Float64}:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> b = OffsetArray(a, -1); 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.5910896175675375; 0.19567937424038506; 0.14802797670131396; 0.17994410698438923. julia> c = view(b, 2:3); 2-element view(OffsetArray(::Vector{Float64}, 0:3), 2:3) with eltype Float64:; 0.14802797670131396; 0.17994410698438923. julia> typeof(c); SubArray{Float64, 1, OffsetVector{Float64, Vector{Float64}}, Tuple{UnitRange{Int64}}, true}. julia> c.indices; (2:3,); ```. we have our indices. The challenge here is, if we are doing computations (eg `compute!`, broadcasting, or calling a reduction), we have to somehow reduce / compute over a view of the _operand_, using the indices stored in the _target_ appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677:515,simpl,simply,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1021875677,1,['simpl'],['simply']
Usability,"For simple cases, like @francispoulin mentioned, changing the architecture from `CPU()` to `GPU()` are often enough. Although if you wanna run simulations that are a bit more complicated, there are a few other things you might need to worry about. You can see a recent discussion about it [here](https://github.com/CliMA/Oceananigans.jl/issues/1509). Mostly you have to define everything that is being used in the model calculations as a constant, otherwise the GPU won't know what to do with it. So for example you probably will need to change some of your lines to. ```julia; const Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; const Hz = grid.Lz; Ξ(z) = randn() * z / Hz * (1 + z / Hz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile; ```; (probably the same goes in other places too.). I recommend you first run the very simple examples that appear in the `README` document of this repo on a GPU to make sure that Oceananigans+GPU is working correctly. And then only after that you should try to change your example to a GPU one. If you come across some errors that you can't solve we can take it from there :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747:4,simpl,simple,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808567747,2,['simpl'],['simple']
Usability,"For sure, we are happy to merge any improvement no matter how small. PRs only have to push the project forward, they don't have to be ""big"" or ""important"". Independent of that, it'd be good to have a clear conclusion about whether a redesign really is needed too because we are in a good position to make that judgment now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379750613:200,clear,clear,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379750613,1,['clear'],['clear']
Usability,"For the new types, we can add new subtypes of the “Device” abstract type in; GPUifyLoops. Why isn’t this a good design? Seems it would save clutter and; simplify the code since we don’t have to translate between Oceananigans.GPU; and GPUifyLoop.GPU, etc. On Sun, Mar 17, 2019 at 2:18 PM Ali Ramadhan <notifications@github.com>; wrote:. > We dispatch (or will want to dispatch) on CPU and GPU in many places that; > aren't GPUifyLoops.jl related. We might also want e.g. MultiGPU types; > that won't be in GPUifyLoops.jl. So I think it's best if we use our own; > types here.; >; > —; > You are receiving this because you commented.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/133#issuecomment-473691379>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBvZgzqVXlFI_4uPaR4zpn1wcXCthks5vXob3gaJpZM4b4iWH>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473691527:153,simpl,simplify,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/133#issuecomment-473691527,1,['simpl'],['simplify']
Usability,"For those following this thread the [SGRID PR](https://github.com/xgcm/xgcm/pull/559#pullrequestreview-1383786186) mentioned above has now been merged to add SGRID functionalities into [xgcm](https://github.com/xgcm/xgcm). Please do try out if useful.; There are some docs for it [here](https://xgcm.readthedocs.io/en/latest/grids.html) describing to to have it automatically detect and extract an SGRID grid, and I'm happy for feedback/questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745:428,feedback,feedback,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745,1,['feedback'],['feedback']
Usability,"From #1372:. > On the other hand, it's a bit confusing that all Coriolis forces ultimately represent a ""background rotation rate""... Yeah I agree this might make it a bit confusing. For now I didn't delete anything and created `GeneralFPlane` as a placeholder. Would it be too bad to just have `FPlane` and let it default to `rotation_axis=ZDIrection()`? I think this is simple and would do the job well enough.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886096063:371,simpl,simple,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886096063,1,['simpl'],['simple']
Usability,"From talking to @ali-ramadhan , I wonder if it's as simple as adding a function to `regularize_background_field` that works for `Fields` in `background_fields.jl`. The third one below is what I think might work. I can give it a try but any thoughts are welcome. ```; regularize_background_field(X, Y, Z, f::BackgroundField{<:Function}, grid, clock) =; FunctionField{X, Y, Z}(f.func, grid; clock=clock, parameters=f.parameters). regularize_background_field(X, Y, Z, func::Function, grid, clock) =; FunctionField{X, Y, Z}(func, grid; clock=clock). regularize_background_field(X, Y, Z, ::Field, grid, clock) =; Field{X, Y, Z, arch, grid, bcs, data}. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1831#issuecomment-875760641:52,simpl,simple,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1831#issuecomment-875760641,1,['simpl'],['simple']
Usability,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:778,simpl,simple,778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,1,['simpl'],['simple']
Usability,Fun pair programming sesh with @ali-ramadhan @whitleyv lead to this!. ![flow_around_cylinder](https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif). Implementation is here:. https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl. and the script that produced the above animation:. https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl. We just did something very simple as a starting point --- hopefully more to come. @weymouth thanks for your insights --- could make sense to schedule a meeting sometime soon to discuss next steps.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414:511,simpl,simple,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414,1,['simpl'],['simple']
Usability,"GFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0% <ø> (ø)` | :arrow_up: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `93.75% <100%> (+0.89%)` | :arrow_up: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `73.68% <100%> (ø)` | :arrow_up: |; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <100%> (ø)` | :arrow_up: |; | [...nditions/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <94.59%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=footer). Last update [ea74667...f1d341a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/601?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579024761:2807,learn,learn,2807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601#issuecomment-579024761,1,['learn'],['learn']
Usability,"Generally looks fine. Some nice clean up!. It seems you're gravitating towards having fewer files which I think is a bad idea. Having more modular files helps a lot with both readability and organization, especially for someone who's looking through the code for the first time. It also becomes harder to find stuff with longer files. For example, It's not logically clear to me that forcings and field sets should be in `models.jl`. And if I'm looking through the file for the first time, I might find it hard to comprehend all the different functionalities provided in the file. Unrelated to this PR but working on the checkpointer in `output_writers.jl` the file has become a long list of functions, some of which are shared between multiple output writers so I think it makes more sense to split it into a set of shared functions and a file for each output writer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517483988:367,clear,clear,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517483988,1,['clear'],['clear']
Usability,Good catch. This should be made very clear as it has confused us in the past... I'll make sure to address this issue on the (increasingly stale =/) `ar/integrate-vs-grid` branch...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523:37,clear,clear,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523,1,['clear'],['clear']
Usability,Good idea @glwagner. Below is a revised copy that includes simple diffusion. If we think this is a good start I can also create a PR with this in the docs. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124504211-01808e80-dd95-11eb-8225-fe05612ca812.jpeg),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874251284:59,simpl,simple,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874251284,1,['simpl'],['simple']
Usability,Good observation. I've simplified the code down to just `left_gradient` and `right_gradient` as suggested so there's still one duplicate definition but it'll be much better than having 5 duplicates once we support `Value` and `Gradient` boundary conditions in x.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-597544840:23,simpl,simplified,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/690#issuecomment-597544840,1,['simpl'],['simplified']
Usability,"Good plan. On Fri, Nov 13, 2020, 2:27 PM Francis J. Poulin <notifications@github.com>; wrote:. > I looked over the documents and learned much better how the equations,; > what they call balance laws, are put together. Very nice and clean system.; >; > I do see that in the code; > <https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl>; > the model equations are in conservative form, as you will find in equations; > 7,8, and 9 of this paper.; > <https://pdfs.semanticscholar.org/9981/51bcc42a04b281811b3b02217799c352b52f.pdf>; >; > Given that's the case I will ignord the Sadourny approach that I mentioned; > before. Thanks for the discussion to help me figure this out.; >; > I will start wtih a one-dimensional version of the linear equations; > without rotation (essentially the wave equation) and build it up from there.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726988741>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQTMZA3ATENPYU2Q5VLSPWCBJANCNFSM4TQVNFEA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-727028034:129,learn,learned,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-727028034,1,['learn'],['learned']
Usability,"Good point @iuryt. The slip velocity is proportional to the difference between the particle and fluid densities. Its common to assume that the slip velocity is constant for simplicity, but there are plenty of applications where the user might want the slip velocity to vary in space and time with the fluid density. I think that should be straightforward when adding the extra advection as a forcing term since you could make the slip velocity a function of the fluid density.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082485930:173,simpl,simplicity,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082485930,1,['simpl'],['simplicity']
Usability,Good point. A simple illustration in the docs for background field will suffice.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083918174:14,simpl,simple,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083918174,1,['simpl'],['simple']
Usability,"Good! :); If it runs, then before merging just add a remark before saying ""We construct the model to run on GPU by `architectures=...`; to run on CPU simply change to `architecture = CPU()`.""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802250849:150,simpl,simply,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802250849,1,['simpl'],['simply']
Usability,Gotcha; Oh... I misunderstood then the first comment of the PR.; So forcing wasn't even working for simple constant Fields???,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989184197:100,simpl,simple,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1989184197,1,['simpl'],['simple']
Usability,"Great job with this so far @ali-ramadhan ! . I think your approximation for the zonal wind stress is very good. It may not be perfect but it's certainly very close. Also, I agree with @christophernhill , since there are no lateral boundaries to speak off, adding some bottom drag `-r*u` would be very simple and should help you to achieve a state that is in statistical equilibrum. . Looking forward to seeing more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824261073:301,simpl,simple,301,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824261073,1,['simpl'],['simple']
Usability,"Great stuff guys. Can we now put a ridge down our eddying channel? Is an; island possible? John. On Fri, Oct 30, 2020, 11:52 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Fun pair programming sesh with @ali-ramadhan; > <https://github.com/ali-ramadhan> @whitleyv <https://github.com/whitleyv>; > lead to this!; >; > [image: flow_around_cylinder]; > <https://user-images.githubusercontent.com/15271942/97726829-083c6080-1aa6-11eb-8c62-c38771eac0bf.gif>; >; > Implementation is here:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/src/TimeSteppers/correct_immersed_tendencies.jl; >; > and the script that produced the above animation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/immersed-boundary/examples/flow_around_cylinder.jl; >; > We just did something very simple as a starting point --- hopefully more; > to come.; >; > @weymouth <https://github.com/weymouth> thanks for your insights ---; > could make sense to schedule a meeting sometime soon to discuss next steps.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-719635414>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRK6RHZWBUDAPODUQLSNLOMHANCNFSM4SNJ4CSA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502:811,simpl,simple,811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720000502,1,['simpl'],['simple']
Usability,Great to know that python can do this in one line! Maybe it will turn out to be as simple in Julia for both CPUs and GPUs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-769013373:83,simpl,simple,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-769013373,1,['simpl'],['simple']
Usability,"Great!. Just to clear up the conversation, I think its incorrect to refer to what we've discovered as a ""limitation"". Instead, we found a bug in the kernel function. The ""workaround"" is not a work around in the usual sense --- its just one _correct_ way to express the intent with code. There are several other ways to write this relatively simple kernel, which may be illuminating to explore. Exploiting the fact the the derivative function can be applied to functions of the form `f(i, j, k, grid, args...)` (as we have designed it) we might also write. ```julia; @inline wpᵃᵃᶠ(i, j, k, grid, w, p) = @inbounds ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] . @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * ∂zᵃᵃᶜ(i, j, k, grid, wpᵃᵃᶠ, w, p) # C, C, F → C, C, C; end ; ```. An even more mundane to express our intent is to manually difference the product `wp`, eg:. ```julia; @kernel function pressure_distribution_z_ccc!(dwpdz_ρ, grid, w, p, ρ₀); i, j, k = @index(Global, NTuple); @inbounds wpᵃᵃᶠ_above = ℑzᵃᵃᶠ(i, j, k+1, grid, p) * w[i, j, k+1] ; @inbounds wpᵃᵃᶠ_below = ℑzᵃᵃᶠ(i, j, k, grid, p) * w[i, j, k] ; @inbounds dwpdz_ρ[i, j, k] = (1/ρ₀) * (wpᵃᵃᶠ_above - wpᵃᵃᶠ_below) / Δzᵃᵃᶜ(i, j, k, grid) # C, C, F → C, C, C; end ; ```. Using the differencing function is probably better (its what we do in the source) because it ensures that the indexing convection is treated correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993:16,clear,clear,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786924993,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:498,simpl,simple,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['simpl'],['simple']
Usability,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:111,feedback,feedback,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['feedback'],['feedback']
Usability,Happy with any measure of resolution --- just asking for clarification. Perhaps instead of Resolution the plot can be labeled Nx (or some other word that indicates the meaning of the axis clearly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-852424175:188,clear,clearly,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-852424175,1,['clear'],['clearly']
Usability,"Here is a PDF from Allistar and section 1.2 is what describes what I'm suggesting. Clearly not my original idea. [main_ch10.pdf](https://github.com/CliMA/Oceananigans.jl/files/6266259/main_ch10.pdf). Sorry if I am not being clear. We agree that shallow water would be curvlinear in two dimesions, those dimensions are x and y. Consider the stratified of a 2D vertical slice, where the only dimensions are x,z. Clearly this problem is curvlinear in 2D as that's all there is. If we add on a y direction, that is regular, then it's still only 2D curvlinear. I guess the analogue wold be that the hydrostatic model is 3D but only curvlinear in the horizontal. This is the same thing but with a 90 degree rotation. I realize this is not what exists but I don't think there is any new methods here, it's a matter of relabeling. If this isn't clear than maybe we can chat sometime?. The ""flux_form"" operations sounds interesting, but I don't think I know what those are. . Sure, there must be a better name than what I suggested and will keep that in mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048:224,clear,clear,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814271048,2,['clear'],['clear']
Usability,"Here's a few idea:. 1. Write more constructors for `BoundaryCondition`. The simplest constructor is what we often use, when the boundary condition is a constant or array. But we should add more constructors that support specifying boundary condition parameters. We should assume that by default the user wants to use `BoundaryFunction`, rather than the current default assumption that the function being specified is low-level. We can have a public constructor for `BoundaryCondition` that takes the argument parameters, which is designed to work with what we currently call ""`BoundaryFunction`"". 2. Add support for a lower-level, non-default boundary condition function signature (the current default) that gives the user access to more of the model state, should they need it. 3. Never ask the user to tell `BoundaryCondition` what field / boundary is being used. Instead, add interpretation to `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc that rebuilds the boundary conditions objects as needed. Use defaults in the `BoundaryCondition` constructor as temporary placeholders, and rewrap as needed in `TracerBoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660:76,simpl,simplest,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660,1,['simpl'],['simplest']
Usability,"Here's a simple hydrostatic model benchmark. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```julia; 10.220 s (85845109 allocations: 37.94 GiB) # this PR; 6.284 s (66184308 allocations: 16.31 GiB) # this PR with KA downgraded to 0.7.2; ```. So we are close but not there yet. What about solvers ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085:9,simpl,simple,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482146085,1,['simpl'],['simple']
Usability,"Here's an even simpler MWE that illustrates the fundamental issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(2)). # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; run!(simulation); ```. which produces. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (383.622 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (620.680 μs).; [ Info: Iter: 2, time: 1 second; [ Info: Iter: 3, time: 2 seconds; [ Info: Iter: 5, time: 4 seconds; [ Info: Iter: 7, time: 6 seconds; [ Info: Simulation is stopping after running for 25.701 ms.; [ Info: Simulation time 8 seconds equals or exceeds stop time 8 seconds.; [ Info: Iter: 9, time: 8 seconds; ```. Basically here there is a ""spurious actuation"" at the first iteration (here iteration 2, because we started from iteration 1). This fixes the issue:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1, stop_time=6). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); progress_cb = Callback(progress_message, TimeInterval(2)); simulation.callbacks[:progress] = progress_cb. # Run a simulation that saves data to a checkpoint; model.clock.iteration = 1 # we want to start here for some reason; progress_cb.schedule.actuations = 1; run!(simulation); ```. producing. ```julia; julia> include(""test2.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (595.408 μs); [ I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947:15,simpl,simpler,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246123947,1,['simpl'],['simpler']
Usability,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:353,simpl,simpler,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['simpl'],['simpler']
Usability,"Here's the wild thing. Calling `mean!` simply goes to this small piece of code in `Base`:. ```julia; function mean!(R::AbstractArray, A::AbstractArray); sum!(R, A; init=true); x = max(1, length(R)) // length(A); R .= R .* x ; return R; end; ```. Obviously, it seems that `sum!` is working. It's only the _subsequent_ code that doesn't work. I think this is an easy fix. The quick and dirty fix might be to define our own `mean!` with an appropriate `@sync` in it (or we can modify the subsequent lines to act on `parent(R)` rather than `R`; perhaps its the broadcasting that's screwed up). Longer term we can try to figure out why the lines after `sum!` don't always execute (?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868819298:39,simpl,simply,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868819298,1,['simpl'],['simply']
Usability,"Here's what I posted earlier:. > Correct: time-averaging a TKE ComputedField; Wrong: time-averaging a TKE KernelComputedField; Wrong: time-averaging a dissipation ComputedField; Wrong: time-averaging a dissipation KernelComputedField. From this list I might infer that the two ingredients are 1) `KernelComputedField` OR 2) gradients. Gradients / interpolation ping boundary conditions, which are tricky so there's good reason to test that. Maybe two tests: one for `ComputedField` with interpolation or derivatives, and another with `KernelComputedField` (that's maybe a bit simpler)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499:576,simpl,simpler,576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817992499,1,['simpl'],['simpler']
Usability,"Hey thanks for doing all this! Things look a lot neater. Just have a few comments/thoughts that I'll pepper throughout but should be good to merge!. > A `Model` constructor is now provided in which all important information can be input via keyword arguments. This is great for understanding what the model does, I agree. Would still be nice to keep the ""legacy constructor"" around for when you just want to create a simple `Model` for playing around with or for testing. And it makes for very nice and simple example code. > I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). I would argue against this. While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. Either way, we should always be testing a wide range of grid sizes (and weird grid sizes like `109x77x13`) because the code should work for all of them. If computational cost becomes an issue we should look into paying for extra CI resources rather than reduce testing. > A few more notes:. Might be good to create some new issues based on those just to keep track of what needs to be done. > The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain. This is something I'm actively working on in a different branch. I'll make sure they work with the changes in this pull request. > Lots of work to do!. For sure!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078:417,simpl,simple,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078,2,['simpl'],['simple']
Usability,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:1157,learn,learn,1157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,1,['learn'],['learn']
Usability,"Hi @EavenW hope it wasn't too hard to get started (the documentation needs some more work, sorry about that). Not totally sure what you mean by a flux boundary condition with two components (sounds like the u and v velocity fields might be further coupled via this boundary condition?). Sounds like you're trying to impose a (time-dependent?) surface flux boundary condition which can be done a few different ways.; * If it's independent of time then [imposing a flux BC with a 2D array](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1) is one option.; * If it's time-dependent then [imposing the flux BC as a function](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1) is probably the way to go. The function signature for boundary conditions is `f(i, j, grid, t, U, C, params)` so the boundary condition can depend on time `t`, the velocity fields `U = (u, v, w)` and any tracer quantity in `C`.; * If you can write your surface flux BC as a function of only (x, y, t) then a [`BoundaryFunction`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/boundary_function.jl) can simplify the setup a little. I just realized this isn't showing up in the documentation but the docstring in the file I linked to has an example of how to use it. PS: Not sure which version you're running but we've been making some improvements to the user interface lately which may break certain things if you upgrade to v0.21 or v0.22. Please don't hesitate to ping us if you have any questions or if something isn't working. We're more than happy to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085:1284,simpl,simplify,1284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085,1,['simpl'],['simplify']
Usability,"Hi @ali-ramadhan! I'm working on Lagrangian analysis tools for ocean model output. Our original code was written in Matlab (https://doi.org/10.1109/escience.2016.7870923), but since I've recently been learning more about Julia I would like to switch. Our goal is to provide easy community access to large data volume numerical ocean simulations, with ready-made and easy-to-use tools. For Eulerian analysis we've used Python (https://doi.org/10.21105/joss.01506); that package is up and running. I want to add Lagrangian analysis tools to this framework. I'd love to learn more about what you guys are up to!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382:201,learn,learning,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382,2,['learn'],"['learn', 'learning']"
Usability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:463,responsiv,responsive,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,2,"['responsiv', 'user experience']","['responsive', 'user experience']"
Usability,"Hi @jmbeckers all topologies are supported now!. I think the issue is that on the staggered grid face-centered fields use N+1 grid cells along `Bounded` dimensions in Oceananigans.jl. So when `topology = (Periodic, Periodic, Flat)` like in the example then. ```julia; julia> size(model.velocities.u); (128, 128, 1). julia> size(model.velocities.v); (128, 128, 1); ```. but when you change to `topology = (Periodic, Bounded, Flat)` then the v field gets an extra grid cell in y:. ```julia; julia> size(model.velocities.u); (128, 128, 1). julia> size(model.velocities.v); (128, 129, 1); ```. so the initial condition from the example no longer works since it creates an array of size 128x128x1 to use for both u and v:. ```julia; u₀ = rand(size(model.grid)...); u₀ .-= mean(u₀). set!(model, u=u₀, v=u₀); ```. Perhaps the simplest solution would be to do something like. ```julia; u₀ = rand(size(model.velocities.u)...); u₀ .-= mean(u₀). v₀ = rand(size(model.velocities.v)...); v₀ .-= mean(v₀). set!(model, u=u₀, v=v₀); ```. so that u and v use different random noise arrays with the correct size. I think the example should still exhibit two-dimensional turbulence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839713415:819,simpl,simplest,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839713415,1,['simpl'],['simplest']
Usability,"Hi @ma-sadeghi, thanks for opening an issue. This should be possible using a continuous forcing immersed boundary method. It's somewhat crude as it just damps the velocity inside the boundary but is simple to implement and requires no significant changes to the model. For fast flows you might need to damp more strongly (and thus decrease the time step) but the solution should converge as you do so. It's not a built-in feature but is pretty easy to implement by adding appropriate forcing functions to an Oceananigans model. For example, in PR #693 we used such a method to simulate viscous flow around a cylinder (in 2D). Here is the simulation script: https://github.com/climate-machine/Oceananigans.jl/blob/ar/flow-around-cylinder/verification/flow_around_cylinder/flow_around_cylinder.jl. These are the most relevant lines: https://github.com/climate-machine/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. In this case the boundary was described analytically and `boundary(x, y, z)` evaluates to `1` inside the cylinder and to `0` outside. In your case maybe it's easier to describe the boundary or missing nodes with a mask or array (also updated snippet for v0.29):; ```julia; # ... Create boundary[i, j, k] array that's 1.0 inside the boundary and 0.0 outside ... K = 50.0 # ""Spring constant"" for immersed boundary method ; parameters = (boundary=boundary, K=K). # Continuous forcing immersed boundary method ; @inline u_immersed_boundary(i, j, k, grid, clock, state, params) =; @inbounds -params.boundary[i, j, k] * params.K * state.velocities.u[i, j, k] ; @inline w_immersed_boundary(i, j, k, grid, clock, state, params) =; @inbounds -params.boundary[i, j, k] * params.K * state.velocities.w[i, j, k] . u_forcing = ParameterizedForcing(u_immersed_boundary, parameters); w_forcing = ParameterizedForcing(w_immersed_boundary, parameters). forcing = ModelForcing(u=u_forcing, w=w_forcing) ; ```. Note that the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/743#issuecomment-622406785:199,simpl,simple,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/743#issuecomment-622406785,1,['simpl'],['simple']
Usability,"Hi All. I think examples with same brief context is good for JOSS. I can help; next week. Chris. On Thu, Sep 12, 2019 at 18:06 Ali Ramadhan <notifications@github.com> wrote:. > Yeah I think simplifying the existing examples as much as possible would; > be good.; >; > I can add back the rising thermal bubble example.; >; > Stratified Couette flow would make a nice example, but I'm slightly; > against including it as it has to be run at high resolution (or with LES); > to get proper results. Whereas you can run the other examples on your; > laptop and get good results quickly.; >; > I want to add the lid-driven cavity as it's even simpler than rising; > thermal bubble and is used a first example/tutorial for other CFD packages.; > But we'd have to impose no-slip via a forcing function as y boundary; > conditions aren't implemented yet, which makes it a bad example right now.; >; > Might also be good to have 1 example that uses an output writer, and; > another that uses both diagnostics and an output writer.; >; > Tutorials would be awesome, although I think simple examples are perhaps; > more important. I don't know, maybe not. Tutorials aren't required for; > JOSS, whereas examples are.; >; > @christophernhill <https://github.com/christophernhill> might have some; > good thoughts here.; >; > —; > You are receiving this because you were mentioned.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/332?email_source=notifications&email_token=AA27DYB25HFU4VF575MWPXLQJLRRPA5CNFSM4IJMNH22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD6TV2JI#issuecomment-531062053>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYBZMHILWJGUJJMX5P3QJLRRPANCNFSM4IJMNH2Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531068611:190,simpl,simplifying,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531068611,3,['simpl'],"['simple', 'simpler', 'simplifying']"
Usability,"Hi Greg,; It might be useful to have an example to show how to add a background scalar gradient like in a ‘frontal zone’ simulation (or stirring of a large-scale passive tracer gradient).; John. > On Sep 19, 2019, at 11:37 AM, Gregory L. Wagner <notifications@github.com> wrote:; > ; > I'd like to discuss examples. Here's a few that I propose:; > ; > Dramatically simplify internal wave example; > Free decay of two dimensional turbulence (use x,y plane); > Stratified Couette flow example.; > I think we should split deepening mixed layer into a few examples:; > ; > 2D convection into a stratified fluid, while forcing salinity to obey like a biological tracers (cc @johnryantaylor <https://github.com/johnryantaylor>); > ; > More sophisticated 3D deepening mixed layer example with LES.; > ; > What else?; > ; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub <https://github.com/climate-machine/Oceananigans.jl/issues/332?email_source=notifications&email_token=AE3E34KNFDIDVUY4WUHLNFDQKNI5VA5CNFSM4IJMNH22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7DAPRQ#issuecomment-533071814>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AE3E34NK2WSEJL4YLDGJZZTQKNI5VANCNFSM4IJMNH2Q>.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084212:365,simpl,simplify,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084212,1,['simpl'],['simplify']
Usability,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267:789,simpl,simple,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267,1,['simpl'],['simple']
Usability,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:757,intuit,intuitive,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,1,['intuit'],['intuitive']
Usability,"Hit a slight roadblock as the `Field` structs are not `isbitstype`:; ```julia; struct CellField{A<:AbstractArray,G<:Grid} <: Field; data::A; grid::G; end; ```; since `Array`s and `CuArray`s are not `isbits`. However, @vchuravy points out that a `CuArray` is not `isbits` only because it contains a `finalize` function (essentially a destructor) which makes it not `isbits` on the host. Apparently CUDAnative converts the `CuArray` to some sort of `CuDeviceArray` using [Adapt.jl](https://github.com/JuliaGPU/Adapt.jl) which is `isbits` and can be used as a device argument. So we'll have to figure out how to _adapt_ our `Field` structs to be `isbits` on the GPU device using Adapt.jl. It shouldn't be too hard as the struct is simple. I should also check out the `cudaconvert(args...)` function in CUDAnative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249:728,simpl,simple,728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-475660249,1,['simpl'],['simple']
Usability,"Hmm by the way `include_boundaries` is a slight misnomer --- with `include_boundaries=false` we still include the _left_ boundary, but not the _right_ boundaries. Maybe we could use `include_right_boundaries` to be totally specific and clear. As for the dispatch, I believe something similar to what `total_length` does would be good:. https://github.com/CliMA/Oceananigans.jl/blob/6d349e1d85d61ff997f249881cd58232de865996/src/Grids/grid_utils.jl#L50. would be nice to have an analogous functions `length` and `size` that don't include halos:. ```julia; Base.length(loc, topo, N) = N; Base.length(::Type{Face}, ::Type{Bounded}, N) = N+1. function Base.size(loc, grid::AbstractGrid); N = (grid.Nx, grid.Ny, grid.Nz); return Tuple(length(loc[i], topology(grid, i), N[i]) for i = 1:3); end; ```. then if `include_right_boundary=true`, you get the worksize dimension from `size(loc, grid)`. (the shenanigans with `Nx, Ny, Nz` above shows why it's nice to use tuples for everything...). (Dispatch on `AbstractGrid` may not be required). Also as convenience don't forget. ```julia; Base.size(loc, grid, i) = size(loc, grid)[i]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687201699:236,clear,clear,236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687201699,1,['clear'],['clear']
Usability,"Hmm well in terms of code design, if the operators enforce homogeneous boundary conditions, it should be possible to simply manually add the inhomogeneous part in a separate step. I don't think inhomogeneity has to be ""baked"" into operations. Eg the difference between:. ```julia; a = b + c + d; ```. and . ```julia; a = b + c; a += d; ```. We just need to have the inhomogeneous boundary conditions passed into the kernel and an appropriate ifelse statement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2398248032:117,simpl,simply,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2398248032,1,['simpl'],['simply']
Usability,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436:595,simpl,simpler,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436,1,['simpl'],['simpler']
Usability,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467:798,clear,clear,798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467,1,['clear'],['clear']
Usability,"Hmm, actually do you want to move our hard-coded values of `Tx, Ty` to `models.jl`, and then reference them in the model constructor? Might be clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/398#issuecomment-530410125:143,clear,clearer,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/398#issuecomment-530410125,1,['clear'],['clearer']
Usability,"Hmm, so after working on `ContinuousForcing` a bit, I think this discussion needs to be updated:. 1. The keyword we'll provide is `field_dependencies`, as in `field_dependencies=(:u, :v, :T)`.; 2. We'll have to put a function `regularize_boundary_conditions` inside the constructor for `IncompressibleModel`, since fundamentally this function needs to know what the `model_fields` are.; 3. Since `regularize_boundary_conditions` goes inside `IncompressibleModel`, we don't need to modify `FieldBoundaryConditions`. Instead, the boundary conditions can be ""regularized"" prior to being passed to the various field tuples. This may simplify `FieldBoundaryConditions`.; 4. The implementation within `BoundaryFunction` can basically follow what was done for `ContinuousForcing`; the only difference being that, as mentioned above, the `side` at which the boundary function is applied needs to be known for correct indexing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-702327644:629,simpl,simplify,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897#issuecomment-702327644,1,['simpl'],['simplify']
Usability,"Hmm, well `ρg` is literally the force density exerted by the weight of the fluid. On Wikipedia, 'buoyancy' is the force induced when you displace fluid; therefore the buoyancy of a solid object is equal to . gravitational acceleration x (volume of object x density of displaced fluid - mass of the object). which gives the forcing acting on the body (positive upwards due to the sign of the terms). Here we deal in densities, so the buoyant forced defined in the same manner would essentially be . gravitational acceleration x ( reference density - density of the buoyant fluid ) . which of course is precisely `-ρ' g`, since `ρ' = ρ - ρ0`. I think that from its usage the meaning of `buoyancy_perturbation` is clear. . Something to keep in mind as we continue to discuss this topic outside this PR is that atmospheric scientists go even a step further and define 'buoyancy' as `-(ρ' - <ρ'>) g / -ρ0`, where `<>` is a horizontal average --- thus omitting the z-dependent, horizontally uniform part of the 'total' buoyancy that does not contribute to dynamics (because it is balanced by a static component of pressure). Thus using `buoyancy_perturbation` to denote a quantity which, for them, comprises even non-dynamic, irrelevant components of `-ρ' g / -ρ0` could seem a bit odd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079:711,clear,clear,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079,1,['clear'],['clear']
Usability,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:250,simpl,simplify,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,1,['simpl'],['simplify']
Usability,"Hmm... I guess reductions in the time-dimension should actually return a `Field` rather than a `FieldTimeSeries`. That's different than how reductions for `Field` work, which also return `Field` but with a ""reduced location"", eg called here. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L710. and defined simply as. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Fields/field.jl#L629-L635. So maybe there is no special challenge except writing code similar to what we have for `Field` that's specialized for the time-dimension. . Reductions over time + other dimensions might work then, if the further reduction is done over the additional dimensions after the special case is handled that converts from `FieldTimeSeries` to `Field`. `Field`s also support ""conditioning"" the operation (which mostly would probably be used to mask immersed areas). But we won't have a ""time mask"", so I think possibly that doesn't pose any particular problems. . Ok, then if we want to support reductions of `FieldTimeSeries` that _dont_ act on the time dimension, that's where we basically have to replicate everything we have for `Field` I guess. For example if you average a `FieldTimeSeries` in `x` then you get a `FieldTimeSeries` back. That's a bit more annoying but still possible...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097:367,simpl,simply,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322747097,1,['simpl'],['simply']
Usability,"Hmm... we'd have to convert this to an array, and then convert back for this to work automatically. A simple fix to start could just be to avoid saving boundary conditions when they contain references to an array. Is it possible to use `has_reference(CuArray, boundary_conditions)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420#issuecomment-532780341:102,simpl,simple,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420#issuecomment-532780341,1,['simpl'],['simple']
Usability,"Hmm... with a vanilla closure, the change is completely encapsulated in the addition of two layers of abstraction (we are just calling a simple diffusion operator). So, let's figure out how to make the abstractions fast. I think the slow down for vanilla closures should be `nil`. The 'abstraction slowdown' causes much larger problems with the complicated closures, so we need to solve that problem anyways. Edit: I see your post, so what I said above holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529:137,simpl,simple,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529,1,['simpl'],['simple']
Usability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:216,learn,learns,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['learn'],['learns']
Usability,"Hmmm, I don't know if many log levels will be that helpful. I guess for debug messages we'll want to have the file name and line number, but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. I think one place that logging can hugely improve user experience is in setting up large models, especially on the GPU, where you could be waiting for several minutes while all of Julia, CUDA, and Oceananigans compiles, model is being set up, memory is allocated, etc. We know it takes time but most users will think that something is wrong if Julia is silent for 5 minutes. In this context info messages can be useful and reassure the user that Oceananigans is working properly. It's well known that progress indicators improve user experience, e.g.: https://www.nngroup.com/articles/progress-indicators/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192:356,user experience,user experience,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192,2,['user experience'],['user experience']
Usability,"Hmmm, I used ""profile"" as it's what everyone calls it. Maybe it just has a clear meaning in oceanography?. `HorizontalAverage` sounds good to me too and is less ambiguous.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520503212:75,clear,clear,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520503212,1,['clear'],['clear']
Usability,"Hmmm, I'm not 100% sure how the callable object would work with `ParameterizedForcing` but as long as it's easy/intuitive to use in scripts then that'll be great. Do you have some pseudocode about what the setup would look like for users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595941345:112,intuit,intuitive,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595941345,1,['intuit'],['intuitive']
Usability,"Hmmm, do we know why we can't adapt the full `Field` to work inside GPU kernels? I think you said you've tried it but ran into some issues a while back?. The definition is; ```julia; struct Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; boundary_conditions :: B; ```; where the `grid` has been adapted, `data` is usually an offset array which has also been adapted, and I thought individual boundary conditions have been adapted as well so feels like it should be easy to adapt the full `Field`. Note: `boundary_conditions` is a named tuple of `FieldBoundaryConditions` so maybe we just need to adapt `FieldBoundaryConditions`, `CoordinateBoundaryConditions`? Hmmm but they're really named tuples so maybe they're already adapted. If we can't adapt `Field` then yeah the adapt rules you've suggested sound pretty good and would simplify the time stepping a lot. The kernels already deal with data tuples so not much would even have to change I think. If we can adapt `Field` though, then we should get all the benefits of simpler time stepping code without the confusion of a non-vanilla adapt rule. X-Ref: https://github.com/climate-machine/Oceananigans.jl/issues/298",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535:860,simpl,simplify,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535,2,['simpl'],"['simpler', 'simplify']"
Usability,"Hmmm, looks like it's failing the verification experiment tests but passes everything else... ```; 336 Stratified Couette flow verification [CPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_verification.jl:25; 337 Test threw exception; 338 Expression: run_stratified_couette_flow_verification(arch); 339 UndefVarError: simulate_stratified_couette_flow not defined; 340 Stacktrace:; 341 [1] run_stratified_couette_flow_verification(::CPU) at /builds/JuliaGPU/Oceananigans-jl/test/test_verification.jl:14; 342 [2] top-level scope at /builds/JuliaGPU/Oceananigans-jl/test/test_verification.jl:25; 343 [3] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; 344 [4] top-level scope at /builds/JuliaGPU/Oceananigans-jl/test/test_verification.jl:24; 345 [5] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; 346 [6] top-level scope at /builds/JuliaGPU/Oceananigans-jl/test/test_verification.jl:20; ```. Will look into it. Should be a simple fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/559#issuecomment-563230624:1071,simpl,simple,1071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/559#issuecomment-563230624,1,['simpl'],['simple']
Usability,"Hmmm, not sure what the issue could be but dissipation field does look well-behaved. I agree that the time average isn't what I would expect based on the movie of the dissipation snapshots. Maybe the best way to approach this is to design a simple test that uses `KernelComputedField` + `TimeAveragedInterval`?. I'll have a look at the code to see if there's anything that stands out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691:241,simpl,simple,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809585691,1,['simpl'],['simple']
Usability,"How about `set!(u, something)` (I'm not sure I was clear about what I asked, sorry about that)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117371351:51,clear,clear,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117371351,1,['clear'],['clear']
Usability,"How about doing the arrested Ekman layer problem (as in Ruan et al. 2019)?. This would require resolving #1151 and adding a wall-model. The domain setup is otherwise very simple, fixed barotropic flow and fixed uniform background stratification. Small domain in the horizontal, and Xiaozhou's results give a nice point of comparison.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739510345:171,simpl,simple,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739510345,1,['simpl'],['simple']
Usability,"How about using just one forcing function for simplicity?. I think something like this might work:. ```julia; @inline u_mask(i, j, k, grid, p) = exp(-(xnode(Face(), Center(), Center(), i, j, k, grid) - p.center)^2 / (2 * p.width^2)). @inline u_forcing_func(i, j, k, grid, clock, model_fields, p) = @inbounds - p.rate * u_mask(i, j, k, grid, p) * model_fields.u[i, j, k]. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=(rate=1/10, center=-grid.Lz, width=grid.Lz/10)); ```. There's another example in the docs:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/forcing_functions/#%22Discrete-form%22-forcing-functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875666855:46,simpl,simplicity,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875666855,1,['simpl'],['simplicity']
Usability,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603:738,simpl,simple,738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603,1,['simpl'],['simple']
Usability,"Huh --- on my GPU I was getting 2x speed up for `Float32`. I'll have to check that again. The slow down has to do with the abstractions I have introduced. 30% is a huge slow down for one function, indicative of a major problem --- probably a type inference issue? . I think that once this problem is solved the code may become faster because of the disambiguation this PR lends to the innermost kernels. This problem becomes catastrophic for the closures, which make heavy use of the abstraction. So solving this problem is imperative. We can restore the performance of the default closure by simply pasting the old operators into `constant_diffusivity_closures.jl`. However, I believe the issue with type inference is solvable. . Unfortunately, I'm in `Cthulhu` hell right now trying to figure it out... I'm wondering whether these problems will vanish once we eliminate branches from the inmost functions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962:593,simpl,simply,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962,1,['simpl'],['simply']
Usability,I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393:3,pause,paused,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393,1,['pause'],['paused']
Usability,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:221,clear,clear,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297,2,"['clear', 'intuit']","['clear', 'intuitive']"
Usability,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:907,simpl,simple,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,1,['simpl'],['simple']
Usability,"I admit that I had to look up [Tullio.jl](https://github.com/mcabbott/Tullio.jl) to learn that it helps with matrix operations. Good for me to know, but if it's going away then maybe no longer essential. I gather that `abs` is being replaced with another version. Where does the new version come from?. Also, I remember a while ago having issues with computing norms on GPUs. Does this help with that at all?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044694374:84,learn,learn,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1044694374,1,['learn'],['learn']
Usability,"I agree that ""eddy viscosity"" is common and ""effective viscosity"" is not, and abusing the letter ""e"" could lead to confusion. However, I also think that ν_sgs is synonymous with ""eddy viscosity"" and that the molecular fluxes are not ""sub grid"" or ""sub filter"". The most important question is whether or not constant isotropic component of viscosity / diffusivity should be included in the arrays saved as `model.diffusivities`. What are people's opinions about that?. If would like to save the total viscosity there then I think we should call it just that (`ν_total`), or find a comparably simple name. If we would like to include just the ""eddy"" or nonlinear viscosity in `model.diffusivities`, then we can keep the current name in the code `νₑ`, and change the physics docs so that they are consistent with the code. The [physics docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) are currently consistent with the code -- its just that we don't want to call ""sgs + molecular"" as `νₑ` or ""eddy"". As pointed out in the original post, the [numerical implementation docs](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/turbulence_closures/) are out of sync with both the physics docs and the code. I think this is because they were essentially written as a stand-alone tutorial to large eddy simulation rather than something that pertains specifically to Oceananigans. I think a lot of the numerical implementation docs are a bit dated. It might be better to nuke this section than confuse future users. But an alternative is to spend some time sprucing it up. More than just the large eddy simulation section needs to be improved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775312009:591,simpl,simple,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775312009,1,['simpl'],['simple']
Usability,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:89,clear,clearly,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548,1,['clear'],['clearly']
Usability,"I agree that `BoussinesqModel` is the more general case. I also agree that Googling for ""Boussinesq model"" returns the relevant result but I wouldn't say it's super clear, especially to a newcomer (perhaps an undergrad), how it might relate to what they want to simulate. To someone wanting to simulate a simple CFD setup like a lid-driven cavity, having to read about approximations for buoyancy-driven flows on Wikipedia might obfuscate the fact that they indeed want to use the `BoussinesqModel` even though they're not using any buoyancy model. We could use both names if `IncompressibleModel` becomes an alias for `BoussinesqModel` but with `tracers = nothing, buoyancy = nothing`, etc. Not sure we want to use aliases though as we've been on a trend of using fewer aliases (e.g. https://github.com/CliMA/Oceananigans.jl/pull/613). As a side note: does it make sense to also consider renaming `HydrostaticFreeSurfaceModel` to something less wordy at the same time as we consider renaming `IncompressibleModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827170262:165,clear,clear,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827170262,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:26,clear,clearer,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,1,['clear'],['clearer']
Usability,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565:70,clear,clearly,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565,1,['clear'],['clearly']
Usability,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544:117,intuit,intuitive,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544,1,['intuit'],['intuitive']
Usability,"I agree that maybe `convert` is more clear, but still, I would rather have one way to do things, and for this reason: ; to develop the code you must need to know what it means in those lines where it is repeated 20 times, so I do not think writing it in another way improves clarity. It might actually beg the question as to why the pattern is different and if there are concrete differences between the two ways of writing it, on the other hand, if you are familiar with Oceananigans, you just have to know `FT()` once and you're done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1606894945:37,clear,clear,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1606894945,1,['clear'],['clear']
Usability,"I agree that to define the grid with `z_faces` we need to know the number of grid points, but that can be done internally. I don't believe we need that in the arguments. In the example you showed previously, with a `cheb` grid, you specified it in terms of a function of `z`. I can imagine the user specifying `z=(0, Lz)`, `Nz` and some `f(z)`, and then we compute what the grid is. I guess if `f(z)=z`, then we get a linear or uniform grid. . I imagine some people might prefer to be more hands on and specify it in terms fo indices. Both clearly can work. What your suggesting sounds very general, which is nice, but also a bit complicated. I wonder if we might want to start with something simple, one of the two, and then as we get to use it then decide how we want to change it. I'm perfectly fine with specifying the index form, since that is consistent with what we are currently doing, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245:540,clear,clearly,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815163245,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"I agree very much with this decision, it would be very convenient (and intuitive) to be able to change boundary conditions like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-972916256:71,intuit,intuitive,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-972916256,1,['intuit'],['intuitive']
Usability,"I agree with this point. But, to play devil's advocate one could argue that the advection scheme should not be part of the model either, no? One could intuitively think that `model`=PDE and `simulation`=PDE+numerical schemes required to solve it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-728306024:151,intuit,intuitively,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-728306024,1,['intuit'],['intuitively']
Usability,I agree with this. It makes it clearer what's happening behind the scenes. I'd prefer keeping the `parameters` keyword for now though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1369#issuecomment-780604891:31,clear,clearer,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369#issuecomment-780604891,1,['clear'],['clearer']
Usability,"I agree with what you're saying (although I didn't know every calculation inside the solid was thrown away; I thought it was just some stuff like setting the velocities to zero). However, wouldn't using `xor` make the functions simpler and decrease the number of computations?. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. The above could be replaced by the following line. ```julia; east_bounded(LX, LY, LZ, i, j, k, grid) = solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. Idk if this makes a lot of difference in the grand scheme of a complete simulation, but as a rule `if` statements and comparisons are pretty expensive, so it might be better to try and decrease them, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176248:228,simpl,simpler,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047176248,1,['simpl'],['simpler']
Usability,"I agree with you @jklymak , you can certainly compute APE in a rotating fluid, which will require a global sort. I wonder if the issue is how to pick the angle of the pycnoclines in the state of least potential energy? I am sure there are ways of doing these, and we can learn how when needed. It would be good to give the user an option as to whether they want to compute it and how often. Given what is set up in the time stepping wizard, I don't imagine this will be a concern, and would be nice to give the user the power to control this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449:271,learn,learn,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-759708449,1,['learn'],['learn']
Usability,"I agree with your arguments. However, if I understood correctly, my only; concern (as a user) is that if you set them to zero by default,; setting `closure=IsotropicDiffusivity()` in a model will create a; simulation that will have no diffusivities and most likely will crash. From; a user perspective that's not the expected behavior I think, right?. On Wed, Dec 16, 2020, 18:17 Gregory L. Wagner <notifications@github.com>; wrote:. > IsotropicDiffusivity currently uses a viscosity and thermal diffusivity; > appropriate for water at 20 degrees Celsius and 35 psu:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28; >; > When I put this in I originally thought it was positive because it; > provided a reference. It's also cute because its ""oceanic"".; >; > But as time has gone on I now fear its actually surprising and also not; > very useful, since it's not actually a common to use Oceananigans for; > direct numerical simulations of miniscule boxes with molecular transport; > coefficients. Instead, IsotropicDiffusivity is useful for 1) idealized; > problems and education and 2) as a simple turbulence closure when setting; > up a simulation / testing ideas, possibly prior to implementing a more; > complicated closure. This ""ocean-realistic"" default is inconvenient for; > either case.; >; > So, I propose changing the default for both the viscosity and diffusivity; > to 0.; >; > cc @tomchor <https://github.com/tomchor> @xiaozhour; > <https://github.com/xiaozhour>; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1278>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KU2HG7BRG62RUDLKJTSVFS5JANCNFSM4U64DLDA>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506:1229,simpl,simple,1229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278#issuecomment-747170506,1,['simpl'],['simple']
Usability,"I agree, it seems best simply to add drag to the internal tide example for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599991092:23,simpl,simply,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1599991092,1,['simpl'],['simply']
Usability,"I agree. So I pushed [8eaf216](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/8eaf216f277bf245d4035b277bbe7d65766d2fec). If there are opposing opinions we can undo this. With this export we can do:. ```Julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```; instead of ; ```julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=Oceananigans.Models.ShallowWaterModels.VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144247947:171,undo,undo,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144247947,1,['undo'],['undo']
Usability,I also have trouble understanding it... Perhaps @tomchor can elaborate? Or simplify it to exemplify the issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096348:75,simpl,simplify,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096348,1,['simpl'],['simplify']
Usability,I also think it’s a good idea to use a full equation of state for all simulations sooner rather than later. It’s simpler: we won’t have to report constants of linearization everywhere. And setting up simulations will be easier. I’ll defer to the modelers for whether Roquet’s approximation is an acceptable model for TEOS-10. This package is relevant and we should consider contributing to it rather than implementing an equation of state somewhere in the Clima ecosystem:. https://github.com/gher-ulg/PhysOcean.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596611426:113,simpl,simpler,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596611426,1,['simpl'],['simpler']
Usability,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611:834,simpl,simply,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611,1,['simpl'],['simply']
Usability,"I am happy to report that following @glwagner 's suggestion, I set the buoyancy frequency to zero and that seemed to solve the problem. Nothing formed at the boundary and therefore no numerical instability. This is good evidence to suggest that it's because the background state is not being consistent with the top and bottom boundary conditions, which require a Neuman (Derivative) boundary condtiion. A big step forward! . A few questions come to mind. - Where is it exactly that GPUs have difficulties dealing with this?; - Why can CPUs do this without any problem? Or maybe where is the difference between the two methods? . A simple solution to my problem is to change the boundary conditions to be consistent with the background state and that should fix things up nicely, i.e. set a non-zero Neumann (Derivative) Boundary Condition at the top and bottom. . I will give that a try tomorrow, but I am still interested in the differences between what the CPU and GPU are doing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815382772:632,simpl,simple,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815382772,1,['simpl'],['simple']
Usability,"I am happy to say that I am now able to get plots of the solutions and errors for a range of resolutions and advections_schemes. I have also learned a lot about `Plots.jl` in the process. . Tomorrow I will work on modifying `plot_error_convergence!`, since that actually gives us the plots that we want. Here are a couple of samples. They can and will be improved up. The first is the error for WENO5 and the scaling matches the theory very well, as I will confirm tomorrow. . ![test2WENO5](https://user-images.githubusercontent.com/8239041/102304453-78565700-3f2b-11eb-8219-dc377571c0e8.png). The second is the error from the UpwindBiasedFifthOrder, that shows that the error in the centre does not converge. I would guess this is either a time stepping problem or perhaps a but somewhere. ![test2UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102304487-8c9a5400-3f2b-11eb-88dc-e5c15e172edd.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542:141,learn,learned,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745753542,1,['learn'],['learned']
Usability,"I am happy to say that I successflly built the docs on my local machine for the first, but not last time. @navidcy : Your instructions are very clear. The problem was with my `.julia` file, I think, but you should not have to account for this peculiar experience. Thanks to you and @tomchor for helping me along with this. I am happy to have learned more about this. Please merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869168362:144,clear,clear,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869168362,2,"['clear', 'learn']","['clear', 'learned']"
Usability,I am happy to say that the `VectorInvariant` formulation yields similar growth rates `0.144` and `0.123`. Given the numerical methods are different I'm not bothered by this difference. They should converge with increased resolution. Any more questions/concerns on this simple validation problem before I return to the global one?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533:269,simpl,simple,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533,1,['simpl'],['simple']
Usability,"I am including an update of my notes. Differences of note:. - Doing everything in 2D, but can downgrade to 1D if people feel this is confusing. I thought this would work well with the 2D picture we have already; - Using overline to denote a cell-averaged quantity. I know the code doesn't do this but this is the convention in the literature and seems good to have something to distintuish between cell-average and simply value; - The final answer is indeed in terms of quantities are the edges but the final equation is exact. The approximations come in when we approximate those fluxes using the cell-averaged quantities. We have a bunch of ways of doing this and I for one would like to discuss this more, but thought we should discuss what I have so far before going any further. ![Finite_Volume_Tracer_Equation](https://user-images.githubusercontent.com/8239041/124492299-4222dc80-dd82-11eb-9484-72f57f4f65ff.jpeg)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245:415,simpl,simply,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874189245,1,['simpl'],['simply']
Usability,"I am including the link from above [here](https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Advection/centered_second_order.jl#L30). . This shows that areas, or lenghts for shallow water, do appear but they are at the last step of the inbedded functions. It's not clear to me that points 1 and 2 are a bug since the areas do appear in the calculations. The evidence to support that is the above plots where the conservative scheme is very similar to the vector invariant scheme. Point 3 no long is relevant to the code. Point 4 is not a bug but a matter of maybe reducing the accuracy to second order, which might be the highest we can do anyhow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165819827:305,clear,clear,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165819827,1,['clear'],['clear']
Usability,"I am looking into these changes (sorry for the delay) and I am a big puzzled on how to proceed. @glwagner said that we might want to remove `Δx` in favour of other terms like `Δxᶜᶜᵃ`. This sounds reasonable. However, it seems like the latter is defined in terms of the former. I take this to mean that we don't want to completely eliminate the `Δx` but simply not use it later?. ```; @inline Δxᶜᶜᵃ(i, j, k, grid::ARG) = Δx(i, j, k, grid); ```. It seems to me that there is a lot of room for cleaning things up in `spacings_and_arrays_and_volumnes.jl`, but since I don't understand all the models I'm pretty sure I'm not the ideal person to be suggesting these changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-847940744:353,simpl,simply,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-847940744,1,['simpl'],['simply']
Usability,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912:142,simpl,simply,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912,1,['simpl'],['simply']
Usability,I am okay with a change of names. If the new name is clearer then probably better to change it sooner than later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1457014531:53,clear,clearer,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1457014531,1,['clear'],['clearer']
Usability,"I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882740823:241,simpl,simply,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882740823,1,['simpl'],['simply']
Usability,"I am open to trying whatever simple example you suggest @christophernhill , but I'm not sure what you mean by stream benchmark. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106:29,simpl,simple,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106,1,['simpl'],['simple']
Usability,"I am still learning how to parse the output but this is what I get. ```julia> typeof(results[CenteredSecondOrder]); Array{NamedTuple{(:cx, :grid),Tuple{NamedTuple{(:simulation, :analytical, :L₁, :L∞),Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}},Oceananigans.Grids.RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},0}; ```. Also, I found that I can use map in the following way. ```; julia> c_ana = map(r -> r.cx.analytical[:], results[CenteredSecondOrder]); 0-dimensional Array{Array{Float64,1},0}:; [8.339763449228298e-167, 9.289942488656767e-154, 3.0530062298945994e-141, 2.960041007581741e-129, 8.466874781928682e-118, 7.14502772471784e-107, 1.7788530458865225e-96, 1.3065667360543323e-86, 2.831251796148466e-77, 1.8100091259558352e-68 … 6.525187676003588e-221, 1.7125465800091643e-236, 1.3260110721966124e-252, 3.0290558443461884e-269, 2.0413749536348825e-286, 4.058762655833247e-304, 2.2e-322, 0.0, 0.0, 0.0]; ```. Then I can access the array using `c_ana[1]'. This seems strange to me but I guess this is what I need to be doing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185:11,learn,learning,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185,1,['learn'],['learning']
Usability,"I am wondering if physics should also go to submodules, eg `Buoyancy`, `Coriolis`, and soon, `SurfaceWaves`. I think this will help us keep our parameter structs concise. For example, `FPlane` is a bit confusing when it appears in isolation. But `Coriolis.FPlane` is clear. Also, the word ""Buoyancy"" appears a lot. If all buoyancy-related things are encapsulated within submodules, naming becomes easier. We can stop exporting so many names at the top-level, and instead export the submodules. So a user will write. ```julia; buoyancy = Buoyancy.Seawater(); ```. or. ```julia; coriolis = Coriolis.FPlane(); ```. or. ```julia; surface_waves = SurfaceWaves.UniformStokesDrift(); ```. What do we think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/495#issuecomment-547392191:267,clear,clear,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/495#issuecomment-547392191,1,['clear'],['clear']
Usability,"I appreciate the help, @glwagner. There's a lot to go through here so let's go little by little. @ali-ramadhan 's suggestion was right. Removing `ComputedField` from the definition of `u_tot` did the trick for my calculations. It seems that complexity is the limiting factor here. For example, this works. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). dbdz_abs = ComputedField(∂z(b_tot)) # Simple; dudz_abs = ComputedField(∂z(u_tot)) # Simple; Ri_abs2 = ComputedField(dbdz_abs/ dudz^2) # Try Ri again with but using other ComputedFields; compute!(Ri_abs2); ```. But trying to do all the calculations in one go fails for some reason:. ```julia; u_tot = ComputedField(u + U); b_tot = ComputedField(b + B). Ri_abs = ComputedField(∂z(b_tot) / ∂z(u_tot)^2) # More complex; ```. The above code computes something, but it's the wrong result. (Curiously the result it computes is numerically the same as the calculation of the Rossby number in the same script, which may be a clue.). Here's my [Minimum Working Example](https://pastebin.com/v3hMpCWQ) made simpler. Hopefully it's easier to understand what's going on. There's a switch when defining `u_tot` to flip between an `AbstractOperation` definition and a `ComputedField` one. I think this is interesting behavior, and it's kinda dangerous since it fails silently. Can you guys confirm that you can reproduce the behavior?. I think I'll open another issue for the `KernelComputedField` stuff since I think it's something different.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284:1072,simpl,simpler,1072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769546284,1,['simpl'],['simpler']
Usability,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542:226,simpl,simple,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542,1,['simpl'],['simple']
Usability,"I believe setting up a simple test is a quick way to determine whether there is a problem with your script and also improves Oceananigans.jl, making progress towards solving this problem, if there is one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922:23,simpl,simple,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817979922,1,['simpl'],['simple']
Usability,"I believe this smells like validation rather than an example. Examples are nice if they are simple yet interesting. This is complicated, but boring (but super useful for validation, obviously!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945:92,simpl,simple,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945,1,['simpl'],['simple']
Usability,"I can approve this but I am concerned about the benchmarking being contained in another package. What's the reason for this? For example, we already have a `benchmark` directory in the code, which not only has some custom source code in `benchmark/src` but many benchmarking scripts. It seems that rather than address the issue with this code (which has a lot of stale stuff) we are trying to skirt / avoid the problem by creating another repo. Ultimately though this just leads to lower quality code across the board since its not clear whether we are supposed to continue to maintain `benchmark` or move to `NESAPOceananigans`. Eventually _somebody_ will have to address this, right? Who will do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050:532,clear,clear,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050,1,['clear'],['clear']
Usability,"I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where). I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler. CC @hdrake @glwagner who were in https://github.com/CliMA/Oceananigans.jl/pull/3581",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415:826,simpl,simpler,826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415,1,['simpl'],['simpler']
Usability,"I can help with a few things:. 1. Moving the existing implementation of `set!` to `Models/IncompressibleModels`.; 2. Writing a new version of `set!` that works with `ShallowWaterModel`.; 3. Implementing a few simple tests that ensure `ShallowWaterModel` can be instantiated. @francispoulin let me know if you'd like to me to work on those three things. For 2. I need some clarification: `IncompressibleModel` has a tuple of fields called `model.velocities`, which always has fields `velocities.u, velocities.v, velocities.w`. For `ShallowWaterModel` I believe the three essential prognostic variables are `uh`, `vh`, and `h`. Then there can be additional tracers in `sw_model.tracers`. How do you want to organize the essential prognostic variables? I think you can come up with any name you want, or you can split them into multiple places...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232:209,simpl,simple,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232,1,['simpl'],['simple']
Usability,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468:156,simpl,simply,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468,1,['simpl'],['simply']
Usability,I couldn't find any other `@eval` inside functions so I think we are clear. ; @vchuravy can you confirm?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2111362174:69,clear,clear,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2111362174,1,['clear'],['clear']
Usability,"I created a new branch `glw-ncc/actual-overturning-channel-example` with the example, and I'm going to get rid of it in this PR (it'll probably simple just to copy/paste the example from that branch rather than continue developing from there when we decide to start working on it again in the future).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-903127221:144,simpl,simple,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-903127221,1,['simpl'],['simple']
Usability,"I didn't see any docstring explaining what's actually being done. Is it possible to add some? Maybe with a minimal example? (Unless I missed it, in which case please ignore the comment.). Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-922972217:293,simpl,simply,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-922972217,1,['simpl'],['simply']
Usability,"I do agree that `backend_kw` is maybe not the best name for this. I think I named it so out of the discussion in https://github.com/CliMA/Oceananigans.jl/issues/3680 around ""storing the kwargs in the backend"". But yeah there's a backend where the data is stored, e.g. in memory or on disk, but there's also how the data is read, e.g. JLD2 or NetCDF. ""Backend kwargs"" should go into the call to `OnDisk` for example. So `reader_kwargs` makes sense to me (or `reader_kw` if we want to be consistent with `JLD2OutputWriter` property names). Maybe the better names will become clear once `FieldTimeSeries` supports reading from NetCDF (something I'm interested in working on).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441835962:573,clear,clear,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441835962,1,['clear'],['clear']
Usability,"I do love tests but I think it might make sense to simplify / reduce the lines added for testing compared to what's in the PR now. Typically we find that maintaining tests is a significant fraction of developer time so it's best to make them as minimal and simple as possible. Awesome PR, thank you!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970:51,simpl,simplify,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3329#issuecomment-1758036970,2,['simpl'],"['simple', 'simplify']"
Usability,"I don't have enough experience to say which method is better so I'll ask @jm-c and @christophernhill to learn more and reply back. We're also thinking of adding MPI support sooner rather than later (same with supporting multiple models per GPU) which may or may not change things. > Another benefit of this method is that the boundary conditions can actually be saved to disk along with the interior part of the solution, and the value of fields on the boundary can be calculated directly from the saved field. Just noting that whether we should save boundary values (i.e. halo data) to disk is an open issue #92.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-500848885:104,learn,learn,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-500848885,1,['learn'],['learn']
Usability,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:297,simpl,simple,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,1,['simpl'],['simple']
Usability,"I don't know a lot about this (@ali-ramadhan and @glwagner can give you a much clearer picture) but I think up until last week KernelAbstractions.jl straight up didn't support AMD. It relied on defining CUDAKernels which are specific to Nvidia GPUs. Now I believe they also added ROCKernels, that are meant to take care of the AMD case. However I think we still need some work on our end since Oceananigans imports CUDA and uses some CUDA-specific functions in lots of places. I think something needs to be done in these instances.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813560368:79,clear,clearer,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813560368,1,['clear'],['clearer']
Usability,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645:45,clear,clearer,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645,1,['clear'],['clearer']
Usability,I don't know the details here to provide useful feedback. Sorry... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223170867:48,feedback,feedback,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223170867,1,['feedback'],['feedback']
Usability,"I don't know. Is the `Vector` somehow a flattened 2D object? We can `reshape` at will without allocating memory:. ```julia; julia> a = Vector(1:16); 16-element Vector{Int64}:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16. julia> b = reshape(a, (4, 4)); 4×4 Matrix{Int64}:; 1 5 9 13; 2 6 10 14; 3 7 11 15; 4 8 12 16. julia> b[1, 1] = 0; 0. julia> a; 16-element Vector{Int64}:; 0; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; ```. But it's a little sketchy if this right hand side doesn't have halos. It's probably ok to allow `Fields` with no halos that don't use `OffsetArray`. Certainly, if it were a field, its physical nature might be a little more clear. As a vector I don't think we can figure out what it represents, just reading the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2184#issuecomment-1021881101:668,clear,clear,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184#issuecomment-1021881101,1,['clear'],['clear']
Usability,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:271,simpl,simplified,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,1,['simpl'],['simplified']
Usability,I don't think the MWE even requires saving output. Can't we also achieve an MWE using a simple `Callback`?. This issue should be independent of whether you are using the CPU or GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2152008883:88,simpl,simple,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2152008883,1,['simpl'],['simple']
Usability,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:1531,simpl,simply,1531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781,1,['simpl'],['simply']
Usability,"I feel I'm not making myself clear. It's not a matter of names or semantics here. It's a matter of the abstraction. . Either the first index means left or not. This is applied uniformly to every direction. There is only *one* `CoordinateBoundaryConditions` for all of `x`, `y`, and `z`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488127247:29,clear,clear,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/213#issuecomment-488127247,1,['clear'],['clear']
Usability,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:395,clear,clearly,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444,1,['clear'],['clearly']
Usability,"I guess I'm confused about these signatures. I feel like in Python the function signatures are very clearly communicated by the prompt itself, etc. But in Julia I often get confused. For example, from the lines you mentioned I'd think the signature would be. ```; KernelComputedField(kernel, arch, grid; kwargs...) ; ```. But in practice we actually call it as; ```julia; ε = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_ccc!, model;; field_dependencies=(νₑ, u, v, w)); ```; because of multiple dispatch here: https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L70-L71. So I'd think that the signature should really be; ```; KernelComputedField(X, Y, Z, kernel, model; kwargs...) ; ```. Or, because they're all valid ways to call the function, should they be all of those?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1370#issuecomment-781514348:100,clear,clearly,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1370#issuecomment-781514348,1,['clear'],['clearly']
Usability,"I guess part of the confusion is that some kwargs are for users while others were introduced for checkpointer usage. I agree that `timestepper_method` and `timestepper` are redundant. We should be able to just do something like `time_stepper = AdamsBashforth2()` for something. Or go with your suggestion on Slack of having the choice of either passing a Symbol for a full struct. Users might usually pass `tracers = (:a, :b)` but checkpointer might pass `tracers = TracerFields(...)`. > It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. I'm totally on board with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852:581,simpl,simplicity,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852,1,['simpl'],['simplicity']
Usability,"I guess we can simplify this even more by dropping DocumenterCitations all together? The idea for this script is to be able to build the Docs with only one or a few examples. So no bibliography is needed, right?. I'll let @ali-ramadhan remark on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1353#issuecomment-777915733:15,simpl,simplify,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1353#issuecomment-777915733,1,['simpl'],['simplify']
Usability,I have added a bit of documentation for the `transpose` functions. Now everything should be a bit clearer,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2233468948:98,clear,clearer,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2233468948,1,['clear'],['clearer']
Usability,I have an individual-based plankton [model](https://github.com/zhenwu0728/PlanktonIndividuals.jl) that uses Oceananigans.jl to provide velocities. But I can also setup a simple biogeochemical model just in Oceananigans.jl like the example in documentation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629361421:170,simpl,simple,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629361421,1,['simpl'],['simple']
Usability,"I have created a doc that goes with this example. This is my first attempt at this so feedback is greatly appreciated. Below are some questions that I have, 4 are mentioned explicitly in the docs and 1 I just thought of now. Of course these lines will be removed before merging. - <del>In the sidebar on the left I have that the title looks weird because of the underscores. How should I fix this?</del>; - <del>I should be able to reduce the number of lined with `using`. This may require modifying the model as well.</del>; - Should I change the parameters to be planetary or is this fine? ; - <del>The diagnostics that are produced are helped to compute the growth rates. Is there a cleaner way of doing this?</del>; - The final part should plot the figure and not save it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770:86,feedback,feedback,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797013770,1,['feedback'],['feedback']
Usability,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450:175,simpl,simple,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450,1,['simpl'],['simple']
Usability,I have not used GPUs and don't appreciate the difficulty here at all but would be happy to discuss this sometime if people wanted to have a brainstorming session. Certainly starting simple is what I would recommend.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738522552:182,simpl,simple,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738522552,1,['simpl'],['simple']
Usability,"I have removed names and linestyle for now, but will get back to this when things are working.; I changed the input argument to simply be results, instead of all_results, but maybe that was a bad idea. I can try it now and see how it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745484536:128,simpl,simply,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745484536,1,['simpl'],['simply']
Usability,"I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent. I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885260173:259,learn,learn,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885260173,1,['learn'],['learn']
Usability,I haven't done any profiling --- just simple benchmarks. (Short example coming soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481266449:38,simpl,simple,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481266449,1,['simpl'],['simple']
Usability,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:16,simpl,simple,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,1,['simpl'],['simple']
Usability,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:316,simpl,simple,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382,1,['simpl'],['simple']
Usability,"I just noticed this:. ```julia; julia> x = range(1, stop=10, step=1.0); 1.0:1.0:10.0. julia> y = reshape(x, 10, 1, 1); 10×1×1 reshape(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 10, 1, 1) with eltype Float64:; [:, :, 1] =; 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0. julia> typeof(y); Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}; ```. So the reshaped ranges do not convert to arrays / `collect` elements --- they are still ranges, with a wrapper (which means that we don't have to do anything special for GPU). I don't think there's any downside to reshape the ranges for convenience in this case. This will slightly simplify the `xnodes`, etc functions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364:737,simpl,simplify,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364,1,['simpl'],['simplify']
Usability,"I just thought I'd drop by with my point of view as user and (for now) not a developer. Talking with other people who have tried Oceananigans, the most important thing from our point of view may be the MPI parallelism. I know there is some debate to be had in this topic (I've had a couple discussions with @glwagner myself), but for now my understanding is that it's much easier to have access to CPUs then GPUs. Also if I understand correctly that would allow the model to be run on multiple GPUs, which will allow for some really big simulations resolving a huge array of scales. I bet there's new physics to be found there among the nonlinear interactions between all these scales!. From my point of view (now without talking to other users) #1241 seems like a pretty big issue. It's hard to use Oceananigans if you're not sure you're going to be able to calculate the statistics you need to do your science straightforwardly. For what I want right now it seems like I can use `LESbrary.jl`, but that might not always be the case. I'd definitely put that in the list of issues to be resolved asap. From a user perspective I think #890 is also important. I've suffered the consequences of lack of attention to BCs already and it'd be nice to have the model check those for me. I also think #471 would be nice to have. I agree with @navidcy that it's not a deal breaker, but it would save computation and (if I understand correctly) all the hard work for that has been done already, no?. Anyway, I'm still learning about Oceananigans and might be kind of naive in relation to some of the model's particularities. So please that fact into consideration when assessing my suggestions! . Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452:1508,learn,learning,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452,1,['learn'],['learning']
Usability,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:203,simpl,simple,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151,1,['simpl'],['simple']
Usability,"I know that the rigid-lid and linear free-surface models are very closely related as the grid doesn't change, and I would think that we could use the same solver on both cases. Is that true?. I guess one important difference is in the latter we have to evole the free-surrface but that is pretty cheap compared to everything else as it's only a two-dimensional field. Dealing with complex geometries is, well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882593053:479,simpl,simple,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882593053,1,['simpl'],['simple']
Usability,"I learned today that cuda failed if I did not define a parameter as a constant, which I had no idea about before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800502949:2,learn,learned,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800502949,1,['learn'],['learned']
Usability,"I left a few comments in the code. To guide the design of this feature, consider a few important use cases:. 1. Buoyant particles (eg particles that feel an ""additional"" advecting velocity, in addition to `model.velocities` and `model.background_fields.velocities`); 2. Chemical reactions taking place on particles; 3. ""Elastic"" particles that bounce of walls with a specified coefficient of restitution; 4. Particles that are nudged with random stochastic noise in addition to advection (this is a crucial feature that is necessary to approximate the effect of molecular / subfilter turbulent diffusion). I am not suggesting that we support all of these immediately or in the near future, but it'd be good to have a type-based infrastructure for particle dynamics that can be extended to include more features.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396:38,guid,guide,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396,1,['guid'],['guide']
Usability,"I like the idea of having the same ""name"" for all grids when it comes to length, number of points, and halos. . Having different descriptors might be a tad clearer but much more of a nuisance. Maybe instead of `x`, `y` and `z` we can generalize the names with `1` `2` and `3` referring to the three directions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3134#issuecomment-1575643780:156,clear,clearer,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3134#issuecomment-1575643780,1,['clear'],['clearer']
Usability,I like the proposed idea for how to specify `FieldBoundaryConditions`. That seems very clearn and friendly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101585372:87,clear,clearn,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101585372,1,['clear'],['clearn']
Usability,"I like the second verbose form. This might be hard to solve because the location information is encoded in types, so it's not quite as simple as dispatching on something like. ```julia; const NamedFieldTuple = NamedTuple{S, NTuple{N, <:AbstractField}} where {S, N}; ```. We might some super-field-tuple type idealization like. ```julia; FieldTuple = Union{Tuple{<:AbstractField}, Tuple{<:AbstractField, <:AbstractField}, ...}; ```. and. ```julia; const NamedFieldTuple = NamedTuple{S, FieldTuple} where S; ```. but I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1256#issuecomment-739544512:135,simpl,simple,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1256#issuecomment-739544512,1,['simpl'],['simple']
Usability,"I looked over the documents and learned much better how the equations, what they call balance laws, are put together. Very nice and clean system. I do see that in the [code](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl) the model equations are in conservative form, as you will find in equations 7,8, and 9 of this [paper.](https://pdfs.semanticscholar.org/9981/51bcc42a04b281811b3b02217799c352b52f.pdf) . Given that's the case I will ignord the Sadourny approach that I mentioned before. Thanks for the discussion to help me figure this out. I will start wtih a one-dimensional version of the linear equations without rotation (essentially the wave equation) and build it up from there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726988741:32,learn,learned,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726988741,1,['learn'],['learned']
Usability,"I made a simple script for testing, and it takes 3 minutes to run on my PC \(on either CPU or GPU\). This is a 2D simulation initialized with a lateral buoyancy gradient. The top is tilted. The figure shows the comparison between the default solver and the `HeptadiagonalIterativeSolver`. The default FFT solver produces pixelated patterns near the top boundary and deep zonal jets in the ocean interior. Besides, I tired the `HeptadiagonalIterativeSolver` with the FFT-based solver as a preconditioner. It did not crash for this script and produced almost the same as the `HeptadiagonalIterativeSolver` with no preconditioner. ![u](https://github.com/CliMA/Oceananigans.jl/assets/49335616/104a8b9b-4b09-4d36-a24d-64625320e0ba). ```Julia; using Printf; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver. # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(); const time_stepper = :RungeKutta3; const advection = WENO(). # Grid; const Nx = 1; const Ny = 200; const Nz = 50; const Lx = 100.0e3; const Ly = 200.0e3; const Lz = 50.0e3. const Δz = Lz / 2 # elevation difference at the top. # Time Stepping; const Δt = 1800.0. # Physical Parameters; const diffusivity = 1.0e-4; const Pr = 1.0; const f₀ = 1.0e-4; const Δb = 1.0e-6 # buoyancy difference at the top. # Output; const output_interval = 1; const deflatelevel = 4. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; return Lz - (Δz / Ly) * y; end. # Viscosity; const viscosity = Pr * diffusivity. # Initial Fields; @inline function b_initial(x::R, y::R, z::R) where {R<:Real}; ϵ = 100 * eps(R); return (Δb / Ly) * y + randn() * ϵ; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577:9,simpl,simple,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2070993577,1,['simpl'],['simple']
Usability,"I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. If there isn't, then I completely agree it's much simpler (without, I think, loss of functionality) to have it be two simple functions (advective and diffusive cfl). > is a hack that's not accurate (overly restrictive) on stretched grids. I think we can replace this with; > ```julia; > using Oceananigans.AbstractOperations: Δx, Δy, Δz; > ; > function cell_advection_timescale(grid, u, v, w); > arch = architecture(u); > ; > max_u_Δx = maximum(abs, u / Δx); > max_v_Δy = maximum(abs, v / Δy); > max_w_Δz = maximum(abs, w / Δz); > ; > return 1 / max(max_u_Δx, max_v_Δy, max_w_Δz); > end; > ```. I thought the reason we hadn't implemented the above is because it's slow to compute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038:193,simpl,simpler,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038,2,['simpl'],"['simple', 'simpler']"
Usability,"I noticed this change last week but I thought it was intentional. I don't have a strong opinion here. . If we're trying to cater to more inexperienced users (of which Oceananigans will probably attract a lot of, since it's always portrayed as user-friendly) then it might make sense to try and guard against this somehow (since the errors you get when trying to do stuff with timedeltas that can't be done aren't very useful). . Otherwise I'd say it's up to the user to deal with this, since on the Oceananigans end the change was (imho) for the better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920:243,user-friendly,user-friendly,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-790717920,1,['user-friendly'],['user-friendly']
Usability,I personally find this ordering of import statements to be clear:; 1. Standard library imports; 2. Third-party imports; 3. Application-specific imports. It's pretty popular with Python and is apparently part of the CIA coding guidelines: https://stackoverflow.com/a/42701457,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545584921:59,clear,clear,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-545584921,2,"['clear', 'guid']","['clear', 'guidelines']"
Usability,"I propose we change the API for vector invariant with WENO interpolation to read something like. ```julia; momentum_advection = VectorInvariant(WENO5(), VelocitySmoothness()); ```. or something like that. In other words I think the nesting should be reversed: the _first_ question is whether we are using the vector invariant or flux form formulation (flux form is default right now). The _second_ question is how we interpolate vorticity. The _third_ question is the field used in the smoothness metric. I also think we should disentangle the smoothness indicators (eg velocity and vorticity) from the WENO5 struct; we can express this concept simply by re-writing the functions to accept two fields: one for reconstruction, and one for smoothness. The default uses the reconstructed field for smoothness. `VectorInvariant` will handle passing vorticity or velocity into those kernels. We'll then need. ```julia; struct VectorInvariant; vorticity_stencil # energy or enstrophy conserving; vorticity_reconstruction # any advection scheme but we focus on `WENO5` and `CenteredSecondOrder()`; smoothness_indicator # `VelocitySmoothness()` or `VorticitySmoothness()`; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138:645,simpl,simply,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1081946138,1,['simpl'],['simply']
Usability,I pushed [e852f50](https://github.com/CliMA/Oceananigans.jl/pull/3117/commits/e852f50548f33c5e5cf5004a77c95680b62209c6) because it was easier for me to commit than add code suggestion. but. feel free to undo it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1565986013:203,undo,undo,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117#issuecomment-1565986013,1,['undo'],['undo']
Usability,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005:83,simpl,simple,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005,1,['simpl'],['simple']
Usability,"I ran the `benchmark_incompressible_model.jl` script on the master branch (twice) and this branch (also twice), and ; actually see a tiny bit of a speedup, maybe only significant for larger CPU models though. Hard to say whether it's noise, it might be more due to other processes causing small variations in runtime. To me I don't think this PR slows down or speeds up the code, but it simplifies and improves the time stepping code so it should be merged. There's a few more memory allocations now (due to extra kernel launches) but this shouldn't affect performance. # System info. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. # Master branch; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.399 ms │ 5.668 ms │ 5.758 ms │ 7.186 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 36.710 ms │ 37.583 ms │ 37.974 ms │ 41.678 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 312.780 ms │ 313.477 ms │ 313.622 ms │ 314.726 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 256 │ 2.802 s │ 2.819 s │ 2.819 s │ 2.836 s │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 5.828 ms │ 6.049 ms │ 6.157 ms │ 7.044 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 43.084 ms │ 43.619 ms │ 43.650 ms │ 44.363 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 365.051 ms │ 365.317 ms │ 365.475 ms │ 366.288 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 256 │ 3.602 s │ 3.653 s │ 3.653 s │ 3.703 s │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.797 ms │ 2.870 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263:387,simpl,simplifies,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263,1,['simpl'],['simplifies']
Usability,"I remember discussing a strategy for working on the _design_ of open boundary conditions, and for that I advocated for finding a simple scheme to implement and focusing on the overall design. The purpose of that is to allow us to think clearly and logically about the software design without getting tangled up in numerics. Once we have a good design (I'm not sure that we do unfortunately...) then the door is open to work on numerics, hopefully without being hindered too much (the point of a good design). Then we can make rapid progress. But this sort of strategy to focus on ""one thing at a time"" is not a comment about whether we should put numerics in the source code or not. It's a strategy for software development, not a comment about package organization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391355404:129,simpl,simple,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391355404,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973:338,simpl,simple,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973,1,['simpl'],['simple']
Usability,"I see some stuff like `N2` in the [plankton example](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/#Boundary-conditions), which is a fixed problem parameter used in the BC but isn't a `const`. I haven't tried to test if making this a constant speeds up things, but I guess I should, no? Should I make a PR to make those alterations?. P.S.: I'm not super clear on which cases defining things as a const helps or not. I just know that the general rule is use something as a `const` if it really isn't gonna change in the problem. That general rule comes from the julia docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256:395,clear,clear,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256,1,['clear'],['clear']
Usability,"I see that the two animations are similar, but not exactly the same. I presume the initial condigurations aren't simply rotated by 90 degrees?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107520465:113,simpl,simply,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107520465,1,['simpl'],['simply']
Usability,"I see that you have very strong gravity, `g = 100 m/s^2`, to make things as barotropic as possible I presume. Without advection there seems to be a lot of giggling around. With advection there still seems to be something odd happening at the equator. . If you were to take `IncompressibleModel` and run it with one vertical grid point, that is essentially a barotropic model. If you initialize it with a planar Rossby Haurwitz wave, then it simply propagates westward. This might be worth setting up just to see what happens in the planar case. Just a thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818746820:441,simpl,simply,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-818746820,1,['simpl'],['simply']
Usability,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283:304,simpl,simple,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283,2,['simpl'],['simple']
Usability,"I see what you mean that `h ∇ ⋅ (ν ∇u)` also satisfies some nice properties. I haven't seen that before but why not? Seems like a viable option. Maybe add that to the list of possible viscosity for shallow water?. It would be fun to test what difference these terms have on a simple problem. Just need to think about the problem, and of course get the code working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474:276,simpl,simple,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090416474,1,['simpl'],['simple']
Usability,"I see your point @simone-silvestri . I thought these changes would make things clearer but perhaps they have done the opposite. My apologies. If you wanted to change them back to volumes, I'm perfectly happy with that. Also, can you confirm that we don't need any extra metrics on the calculation of the momentum, as @glwagner originaly asked about it #1866 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165832984:79,clear,clearer,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165832984,1,['clear'],['clearer']
Usability,"I see. I was thinking that we could solve the issue with the sliced fields' outputwriter in that simple way, but it turns out it is a deeper problem since `view(field, indices(field)...)` does not work for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2771#issuecomment-1267784624:97,simpl,simple,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2771#issuecomment-1267784624,1,['simpl'],['simple']
Usability,"I simply paste the code from the README in a Julia REPL. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> N = Nx = Ny = Nz = 128 # Number of grid points in each dimension.; 128. julia> L = Lx = Ly = Lz = 2000 # Length of each dimension.; 2000. julia> topology = (Periodic, Periodic, Bounded); (Periodic, Periodic, Bounded). julia> model = IncompressibleModel(; architecture = CPU(),; grid = RegularRectilinearGrid(topology=topology, size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)),; closure = IsotropicDiffusivity(ν=4e-2, κ=4e-2); ); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=128, Ny=128, Nz=128); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> # Set a temperature perturbation with a Gaussian profile located at the center.; # This will create a buoyant thermal bubble that will rise with time.; x₀, z₀ = Lx/2, Lz/2; (1000.0, 1000.0). julia> T₀(x, y, z) = 20 + 0.01 * exp(-100 * ((x - x₀)^2 + (z - z₀)^2) / (Lx^2 + Lz^2)); T₀ (generic function with 1 method). julia> set!(model, T=T₀); julia> simulation = Simulation(model, Δt=10, stop_iteration=5000); Simulation{IncompressibleModel{CPU, Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step (Int64): 10 seconds; ├── Iteration interval: 1; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: Inf years, stop iteration: 5000; ├── Diagnostics: OrderedCollections.OrderedDict with 1 entry:; │ └── nan_checker => NaNChecker; └── Output writers: OrderedCollections.OrderedDict with no entries. julia> run!(simulation); ```. How were you",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807688276:2,simpl,simply,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807688276,1,['simpl'],['simply']
Usability,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:457,simpl,simplest,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,1,['simpl'],['simplest']
Usability,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:23,simpl,simple,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989,1,['simpl'],['simple']
Usability,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:719,simpl,simple,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924,3,['simpl'],"['simple', 'simpler']"
Usability,"I think I figured it out, basically there is a function `args_preferred_axis` that determines which Axis type to use (when it's not specified), and because `Field isa AbstractArray{3}` it ends up choosing `LScene`. So the simple fix here is just to say that `Field` does not have a preferred axis type. As a result, when the axis is not provided, it is determined later on (by the converted arguments, rather than the un-converted `Field`). We could in the future attempt to figure out the ""effective dimensionality"" of a `Field` and then use that to determine whether it has a preferred axis type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3727#issuecomment-2309347163:222,simpl,simple,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3727#issuecomment-2309347163,1,['simpl'],['simple']
Usability,I think I now have the ability to restart the build but don't know how. I'm happy to do it next time if I can get a bit of guidance as to how to do that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843333581:123,guid,guidance,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843333581,1,['guid'],['guidance']
Usability,"I think I still prefer to not append the extension and leave things the way they are mainly for three reasons:. - If you don't include the extension, then (using [usual jargon](https://www.computerhope.com/jargon/f/filename.htm)) it's not a complete file name anymore since it doesn't uniquely identify the file. To be correct I think we'd need to go back to `prefix` which isn't super clear imo; - It leads to less clear code if you're postprocessing the output in the name script. Like this pseudo code:. ```julia; simulation.output_writers[:writer] = JLD2OutputWriter(model, outputs, filename=filename). run!(simulation); real_filename = filename * "".jld2""; jldopen(real_filename); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695:386,clear,clear,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098252695,2,['clear'],['clear']
Usability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:94,feedback,feedback,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['feedback'],['feedback']
Usability,I think `Center` is much clearer than `Cell` but I prefer `Face` over `Interface` for brevity.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-535737567:25,clear,clearer,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-535737567,1,['clear'],['clearer']
Usability,"I think any of those projects would be super welcome. A 1-layer shallow water model would be nice and simple, and @ali-ramadhan could use it for his MPI parallelization work since it has no pressure solver. A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functional",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:102,simpl,simple,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,1,['simpl'],['simple']
Usability,"I think broadcasting for same-field operators, e.g. `CellField .+ CellField` would be really useful and make the code more readable. The simplification here is fewer loops to look at which is a big plus I think. But cross-field broadcasting is a bit trickier so might be better to leave it unimplemented especially as it's not a very common operation, I only use it when adding `f .* v` to `Gu` or `f .* u` to `Gv`. Without it you would have to explicitly write `u .+ avgx(avgy(v))` so if you forget it then it might make finding the bug a bit harder. With it, you can just write `u .+ v` with the averaging happening behind the scenes, so you might apply it by mistake without realizing it. Another potentially difficult bug to find. I feel like everyone has a different opinion on this but in my mind, I'm thinking this would make the code easier to read and write (short-term), and ultimately easier to extend by users (long-term). I just sometimes use issues leave random TODO notes and ramble.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799:137,simpl,simplification,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799,1,['simpl'],['simplification']
Usability,"I think code-wise, this is pretty much ready (save some occasional polishing like [here](https://github.com/CliMA/Oceananigans.jl/pull/3080#discussion_r1192737129)). `pHY` and `pNHS` are no more, and both both hydrostatic and nonhydrostaic models, the pressure is simply `model.pressure`. The only tests that are failing and some regression tests, whose data will have to be re-done, and a scalar-index issue on GPUs. I think the only major change that's left is the documentation. @glwagner, in the past you preferred to make big changes to the docs yourself. Do you wanna remove the pressure separation part from the docs and push it here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1550241035:264,simpl,simply,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1550241035,1,['simpl'],['simply']
Usability,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537:28,simpl,simpler,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537,1,['simpl'],['simpler']
Usability,"I think for option 2 the best option might be to simply define a new function (`add_diagnostic!(model, diag)`?) which assigns the diagnostic(s) with some default name (perhaps just the index number).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529621264:49,simpl,simply,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-529621264,1,['simpl'],['simply']
Usability,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:166,simpl,simply,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023,1,['simpl'],['simply']
Usability,"I think it would be clearer to call this ""internal tide"" or ""barotropic tide over seamount"". The point is not the barotropic tide, the point is to showcase the generation of internal waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575762100:20,clear,clearer,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575762100,1,['clear'],['clearer']
Usability,"I think it's a good idea to merge a `RegularCartesianGrid` we're fully happy with as I'm going to add a `VerticallyStretchedCartesianGrid` very soon so would be nice to have them both share the same design. Happy to expand the scope of this PR a bit. > why not use `size` instead of `N`. Now that `L` is no longer a keyword argument, we can use `size`. > We've also never discussed this --- but why do we use `Nx` rather than `nx`? I find it harder to type; plus julia uses capital letters for types so its a bit of a break in pattern; almost everything else is lowercase. I'm on board with a change to lowercase `n` as it fits the Julia style guide. > I'm not too fond of `RegularCartesianGrid(size, length)`, but happy to keep it around if some find it useful, we just don't need to use it in examples and docs. Same here, it's a legacy constructor but we can get rid of it in this PR which would also help address #429. > ```julia; > RegularCartesianGrid(FT, nx, ny, nz; length) = RegularCartesianGrid(FT; size=(nx, ny, > nz), ; > x=(-length[1]/2, length[1]/2), y=(-length[2]/2, length[2]/2), z=(-length[3], 0)); > ```. This seems like a good default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541321384:644,guid,guide,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541321384,1,['guid'],['guide']
Usability,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:433,simpl,simple,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554,2,['simpl'],['simple']
Usability,"I think it's as simple as something like. ```julia; macro unpack_model(model); esc(quote; forcing = $(model).forcing; # etc; end # quote; ); end. @unpack_model model # pastes forcing=model.forcing, etc; ```. I think? Maybe there's a way to make it more automated though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477592022:16,simpl,simple,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477592022,1,['simpl'],['simple']
Usability,"I think it's important to have the word `immersed` somewhere in the flag name otherwise it might not be clear that we're masking. I vote for `immersed _mask_value` flag. It's kinda verbose, but imo 100% clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200:104,clear,clear,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528069200,2,['clear'],['clear']
Usability,"I think it's more intuitive if `gravitational_direction` is a unit vector where `|g|=1`, no?. > I guess we thought this PR was missing a test? I'm happy to merge it as long as the 45 degree slanted rising thermal bubble looks good and we can worry about adding a more rigorous test in a future PR?. I ran the bubble case and it looked okay to me. I don't know if that's already good enough for merging this PR. I'd recomment merging once we get the more general tilt for buoyancy (if you agree that that's important.). My idea was to start a more rigorous test using a tilted BBL example from the literature this weekend. I was thinking this could eventually become a docs example to show. - Tilted gravity; - Monin-Obukhov similarity wall model; - Maybe stretched grid if it's done by then?; - NetCDF outputs (I think none of the current examples use NetCDF). I ended up not doing it because the papers I went through used both buoyancy as a tracer (not implement yet in this PR; hence my comment here) and tilt the domain in the `x` direction, so I'd need an `x` component of coriolis (hence my issue https://github.com/CliMA/Oceananigans.jl/issues/1372). I know these things are easy to circumvent with the available tools (i.e. using temperature to get the proper buoyancy and rotating the domain so that the tilt is in `y`, not `x`), but I thought it was best to make a thorough test once as these tools were in place already.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746:18,intuit,intuitive,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-783490746,1,['intuit'],['intuitive']
Usability,"I think it's nice to explain how to use array input but it's not clear to me that this example is the best place to do it. I like the idea of having a simple fix here, as was suggested above, and then another example that reads in data or something, as @jmbeckers suggested.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842297531:65,clear,clear,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-842297531,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634:447,simpl,simple,447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634,2,['simpl'],"['simple', 'simplifies']"
Usability,"I think it's probably a good idea to (cautiously) add diagnostics that are important yet difficult to write, such as this one. Note that this would be the first!. As a historical note, we have resisted adding diagnostics to the code base so far because we believed that a more generic solution would make it ""easy"" for users to define their own diagnostics (eg, as simple as writing the mathematical expression), and because long lists of diagnostics impose a maintenance burden. But I think there are some examples (such as APE) for which we probably can't define simply via abstractions like those provided by AbstractOperations. And as the code becomes more stable (and we have more contributors), maintaining a list of difficult-to-code but commonly-used diagnostics is more feasible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250:365,simpl,simple,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758710250,2,['simpl'],"['simple', 'simply']"
Usability,"I think its correct that `Periodic` boundary conditions have `condition=nothing`. . Shouldn't we fill halos in all 3 directions? That way everything is neat and simple and there's no special directions. It will also allow us to easily implement `Periodic` in the z direction at some point in the future, which may be useful for both science and validating the model against established results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066:161,simpl,simple,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066,1,['simpl'],['simple']
Usability,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760:317,learn,learned,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760,1,['learn'],['learned']
Usability,"I think that's a good one. So we have:. * `immersed_value = 0`; * `immersed_mask_value = 0`; * `mask_immersed = 0`; * `fill_immersed = 0`. Would even just `mask = 0` be sufficient? I've also been annoyed about ""mask_immersed_field"" and wondered whether simply `mask!(field)` would be clear and a little cleaner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210:253,simpl,simply,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1527950210,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"I think the `Documenter.jl` approach is appropriate for large codes. Requiring lots of modules makes the code clearer, protects namespaces, and enforces local import statements. Plus all the JuliaDocs packages are just really neat and useful. PS: are there other nice julia codes that we might turn to for inspiration?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/521#issuecomment-549104561:110,clear,clearer,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/521#issuecomment-549104561,1,['clear'],['clearer']
Usability,"I think the error is surprisingly clear actually! There's no pressure solver for grids that are stretched in `x` or `y`. But it won't be much effort to add a more specific warning in the constructor for `NonhydrostaticModel`. @simone-silvestri good point that the FFT/tridiagonal solver should work in other directions! Unfortunately though I think the tridiagonal solver is hard-coded to batch in `i, j` and solve in `k`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819:34,clear,clear,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022767819,1,['clear'],['clear']
Usability,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:284,simpl,simply,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,1,['simpl'],['simply']
Usability,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:135,clear,clear,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149,1,['clear'],['clear']
Usability,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:555,clear,clear,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072,1,['clear'],['clear']
Usability,"I think the problem is basically that the schedules are not saved to the checkpoint. Actually, the output themselves are also not saved to checkpoint which is also an issue for time averages. I believe this wasn't previously an issue but recent changes to `TimeInterval` in #3616 may have created the problem... Likely we can find some simple way to fix `TimeInterval` but let's keep in mind that there are some broader challenges to be solved for checkpointing that basically will require a feature that can save callback and output writer states.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467:336,simpl,simple,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246084467,1,['simpl'],['simple']
Usability,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136:278,simpl,simply,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136,2,['simpl'],"['simpler', 'simply']"
Usability,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977:84,simpl,simple,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977,1,['simpl'],['simple']
Usability,I think this is pretty vague so I'm closing this issue. It'll become clear what we want in our diagnostics once we start trying to do fast on-the-fly diagnostics.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/43#issuecomment-499539206:69,clear,clear,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/43#issuecomment-499539206,1,['clear'],['clear']
Usability,I think this pattern takes care of this issue:; https://github.com/climate-machine/Oceananigans.jl/blob/7a4142c43b6cf1f5541687fa349d75cb52605c50/examples/deepening_mixed_layer.jl#L3-L10. I think the problem with multiple `Project.toml` files is that it's awkward for users just adding the package via `]add Oceananigans` to switch between different environments just to run a simple example. But an error like `module PyPlot not found` is clear enough that they just need `PyPlot` to run the example.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-520786369:376,simpl,simple,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195#issuecomment-520786369,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"I think we are never going to be both 100% accurate and 100% clear for everyone at the same time, so I guess we need to pick our poison. In this matter my personal opinion is that we should choose the more accurate name, but I'm not 100% sure either. And I also think this is a pretty big breaking change (given that atm most Oceananigans scripts probably use `IncompressibleModel`), so maybe it would be good to get input from other people as well?. CC: @glwagner @francispoulin @navidcy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827175522:61,clear,clear,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827175522,1,['clear'],['clear']
Usability,I think we should link to https://julialang.org/learning/getting-started/. and also take care not to repeat any material there. @tomchor do you mind if I edit this PR?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060052035:48,learn,learning,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1060052035,1,['learn'],['learning']
Usability,I think we should test this independently of an example. Examples change but it'd be nice to make sure this functionality still works. I'll add something simple and then we can iterate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3815#issuecomment-2389128694:154,simpl,simple,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3815#issuecomment-2389128694,1,['simpl'],['simple']
Usability,"I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor. That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that. The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can be used in subsequent `AbstractOperations`. When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction. We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures. To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1271046814:1370,simpl,simple,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1271046814,1,['simpl'],['simple']
Usability,"I think what we want in terms of API is the ability to specify boundary conditions on the surface of an immersed boundary. One design would be to introduce a type called `ImmersedBoundary` that collects information about the location of the boundary and the boundary conditions for each field prescribed on it. This could be relatively simple to implement in the code, though it doesn't exactly conform to our current code design in which boundary conditions are embedded in `Field` objects. Another possibility that may better conform to our current boundary conditions / field design would be to embed `boundaries` in `grid` objects. With this design, `ImmersedBoundary` collects only information about its geometry and parameters related to its numerical implementation (eg regularization functions, interpolation methods, etc). We can then infer from `grid` the information needed to define boundary conditions for fields in both (`x` ,`y`, `z`), as well as on any `ImmersedBoundary`s. Grid constructors would then be something like. ```julia; grid = RegularCartesianGrid(; immersed_boundaries = ImmersedBoundary(geometry = # a function of (x, y, z, t); transfer_function = # parameters ; ); topology = # etc; ); ```; ; As for verification, I think we should use a quantitative test that verifies that boundary conditions are satisfied on the immersed boundary. Reproducing the Reynolds number correction to the drag coefficient on a sphere might be a good one, though it could be challenging because we'd have to use sponge layers to replicate an open boundary. We could also reproduce driven-cavity results in a triply periodic domain using rectangular immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759:336,simpl,simple,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759,1,['simpl'],['simple']
Usability,"I think you instantiate a model to do many things; one of them is time-stepping, but another may be analysis. Another is testing. Even now we can't actually solve poisson's equation without a `Model` easily, which seems like an unnecessary restriction of our non-modularity. I don't think we should make this problem worse. I think it makes sense `model` is a field of `Simulation`. Its simple to envision `Simulation` parameters that are identical, with a different underlying `model` (eg, changing the number of passive tracers)`. The way I envision a logical course for the development of complex software in general is that we start with the fundamental building blocks and make them as easy to use in their low-level form as possible. When we've decided we can proceed no farther, we add another layer of abstraction that fuses these underlying building blocks into a higher-order coherent object. And so on. I think its a better design strategy to add *layers* of abstraction, rather than *embedding* abstraction within already complex objects. The latter strategy would lead to unmanageable complexity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410:387,simpl,simple,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410,1,['simpl'],['simple']
Usability,"I think you need. ```julia; ε = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); ```. might be a good idea to implement a constructor thats consistent with the other field constructors though. Not sure which form we prefer (curly brackets, or plain function arguments). Probably the version without curly brackets is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866548009:400,simpl,simpler,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758#issuecomment-866548009,1,['simpl'],['simpler']
Usability,I think you should add a simple test so this doesn't regress again,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514:25,simpl,simple,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3388#issuecomment-1809340514,1,['simpl'],['simple']
Usability,"I think you've started in the right place by looking at the examples. I suggest reading a few more examples! The ""Model setup"" section in the documentation should also be useful. If you can describe your problem in more detail then we may be in a better position to help. Here's some guiding questions:. * What is the physical situation you are trying to model? Can you describe the geometry of your problem and its motivation?; * What is the dimensionality of your problem? Most fluids problems of interest are either two- or three-dimensional. You have implied that your problem is two-dimensional but did not state this explicitly.; * What boundary conditions would you like to impose? You have stated that you want to generate inlet and outlet boundary conditions. But the domain you mentioned is periodic in x and bounded in z. Would you like to impose an inlet and outlet flow in the z direction (thus you would impose inflow and outflow conditions on the vertical velocity)? Note, it may be challenging to impose outlet boundary conditions, but we are happy to help if this is what you want to do.; * Does your problem involve tracer fields? Would you like to simulate the trajectory of particles advected in your flow as well?. The term ""laminar flow"" is not specific --- it's possible to have laminar flows in both two and three dimensions, and in bounded or periodic domains and with a variety of boundary conditions. I'm not sure what you mean by ""single particle"". We have some functionality for modeling what we call ""Lagrangian particles"", which are like grains of sand that are advected by the flow. We can explain how to model a single Lagrangian particle, if that is indeed what you are trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-818273534:284,guid,guiding,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-818273534,1,['guid'],['guiding']
Usability,I think ‘range’ is clearer anyways!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/480#issuecomment-542459193:19,clear,clearer,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480#issuecomment-542459193,1,['clear'],['clearer']
Usability,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840:791,learn,learn,791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840,1,['learn'],['learn']
Usability,"I thought one of the advantages of Julia is that one can use easy to read notation. The notation for Re and Nu is anything but intuitive. Should we discuss how to improve on that?. Raffaele . > On Sep 6, 2019, at 8:08 AM, Gregory L. Wagner <notifications@github.com> wrote:; > ; > @rafferrari; > ; > √uτ²⁺ is a velocity scale (it's written oddly I think...), h is a length scale, and ν is ν.; > ; > @ali-ramadhan should correct me, but it looks like κ * Θw / h is a diffusive heat flux scaling across the domain, whereas qw⁺ is the wall temperature flux (not sure how its calculated).; > ; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub, or mute the thread.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528830831:127,intuit,intuitive,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-528830831,1,['intuit'],['intuitive']
Usability,"I tried the simple example from #1942 and that worked great with this PR, so that's good news. Is there something in particular that you are expecting to fail? I will be keeping my fingers crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902687574:12,simpl,simple,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902687574,1,['simpl'],['simple']
Usability,"I tried the simulation commenting out the line `bat = - bat` and that become unstable in a few hours, so clearly not correct. I also put this line back in and forced the minimum dept to be 50 m instead of 10 m, and that became unstable after 53 days instead of 52 days. Not much of a difference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1994922908:105,clear,clearly,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1994922908,1,['clear'],['clearly']
Usability,I updated the PR with `@diagnostic` and `@setup` as suggested [here](https://github.com/JuliaLang/julia/issues/33418#issuecomment-543098427). Would you like me to work on porting the formatting from MicroLogging & Logging.ConsoleLogger over the ModelLogger next? Or is the getting the PrintableDiagnostic struct created and usable the next priority?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544160908:324,usab,usable,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544160908,1,['usab'],['usable']
Usability,I vote for simply `mask = default_value` and `mask!(field)`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302:11,simpl,simply,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528003302,1,['simpl'],['simply']
Usability,"I vote for writing new operators for new grid types. I think it makes sense to use the fastest algorithm available. It is also potentially confusing to a future reader of the code if 'Δz' is --- unnecessarily --- an array of constants. I believe the code is *clearer* if the code structure, structs, etc reflect *intent* accurately and in detail. A regular grid has a constant Δz by definition; therefore, Δz should be a scalar. You may find that regular grids have advantages and will be used often in the future. It is much easier to double the resolution of a regular grid, for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/47#issuecomment-462851293:259,clear,clearer,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47#issuecomment-462851293,1,['clear'],['clearer']
Usability,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:81,clear,clear,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407,1,['clear'],['clear']
Usability,I was not calling the script correctl. I have since learned I should be doing the following . ```; mpiexec -n 4 julia --project mpi_shallow_water_turbulence.jl; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794318967:52,learn,learned,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794318967,1,['learn'],['learned']
Usability,"I was thinking about it. The problem is that they do in fact encode some physical statements, like, for example, impenetrability for U (XFaceFields) and V (YFaceFields) and no flux for center-fields (C). ; Periodic topologies act according to periodic BC.; We probably need a way to make this clear. I am afraid a compact notation would not convey this entirely, maybe we can be a bit more verbose like; ```julia; δyᵃᶜᵃ_nopenetration; δxᶠᵃᵃ_noflux; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775917629:293,clear,clear,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-1775917629,1,['clear'],['clear']
Usability,"I was thinking even simpler:. ```julia; F(i, j, k, grid, clock, state); ```. Any 'parameters' that are needed for forcing functions can be introduced by defining a callable object that carries around its parameters. We can introduce something simple like `ParameterizedForcing` for users, too, perhaps. (Now that I think of it, we should probably separate `SimpleForcing` (forcing functions of `x,y,z,t` with no parameters) from `SimpleParameterizedForcing` (simple forcing functions with parameters) too...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595931041:20,simpl,simpler,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595931041,3,['simpl'],"['simple', 'simpler']"
Usability,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:747,undo,undocumented,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,1,['undo'],['undocumented']
Usability,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941:39,simpl,simply,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941,1,['simpl'],['simply']
Usability,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:254,clear,clearly,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154,1,['clear'],['clearly']
Usability,"I would argue that `SpecifiedTimes` shouldn't be actuated in iteration 0 since, if that is desired by the user, it's trivially easy to add zero to the list of times. I also think it's counter-intuitive to have something with `SpecifiedTimes([5, 10])` to actuate at `t=[0, 5, 10]` in practice, although I guess that's up for debate. If no one opposes this, I can open a PR to make this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233399368:192,intuit,intuitive,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233399368,1,['intuit'],['intuitive']
Usability,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:229,simpl,simply,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708,1,['simpl'],['simply']
Usability,"I would go with the second option for one reason:; If a user knows enough to pass a tuple of closures to the model constructor they are well aware that `closure` is a tuple. There is no need to go the extra mile to sum them together. We can also have a function that returns a `tuple` of viscosities associated with the `tuple` of closures but maybe it would require a different name like `closure_viscosities`; ```; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); closure_viscosities(model) #returns (1.05e-6, νₑ); closure_diffusivities(model, :b) # returns (1e-7, κₑ); closure_diffusivities(model) # returns a tuple of named tuples with all tracer diffusivities; ```. The problem is that not every closure might have a diffusivity or viscosity associated with it (like mass flux models), in that case we will have to think at something else. In addition, I am convinced of the simplicity of keeping the `diffusivity_fields`, nesting too many structs might make code too complex (thinking also at future development of `MultiRegion`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064188091:914,simpl,simplicity,914,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064188091,1,['simpl'],['simplicity']
Usability,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990:28,simpl,simple,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990,2,['simpl'],['simple']
Usability,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:260,simpl,simply,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,1,['simpl'],['simply']
Usability,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:170,clear,clearer,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,1,['clear'],['clearer']
Usability,"I would recommend a baroclinically-unstable channel. On Thu, Sep 19, 2019, 10:36 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I'd like to discuss examples. Here's a few that I propose:; >; > 1. Dramatically simplify internal wave example; > 2. Free decay of two dimensional turbulence (use x,y plane); >; > I think we should split deepening mixed layer into a few examples:; >; > 1.; >; > 2D convection into a stratified fluid, while forcing salinity to obey; > like a biological tracers (cc @joynryantaylor); > 2.; >; > More sophisticated 3D deepening mixed layer example with LES.; > 3.; >; > Stratified Couette flow example.; >; > What else?; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/332?email_source=notifications&email_token=AKXUEQSMVFCHNFUOW5PSCVTQKNI3ZA5CNFSM4IJMNH22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7DAPRQ#issuecomment-533071814>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQWVFMJ2T654SLTVQTQKNI3ZANCNFSM4IJMNH2Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084952:221,simpl,simplify,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084952,1,['simpl'],['simplify']
Usability,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513:1236,clear,clear,1236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513,1,['clear'],['clear']
Usability,"I wrote a simple test that I believe represents a similar case, in which the fields of the type in question are pointers. On my machine there does not seem to be any performance difference. ```julia; using Random, BenchmarkTools, Printf ; ; struct Dummy ; a::Array{Float64,2} ; b::Array{Float64,2} ; c::Array{Float64,2} ; end ; ; mutable struct MutableDummy ; a::Array{Float64,2} ; b::Array{Float64,2} ; c::Array{Float64,2} ; end ; ; Dummy(n) = Dummy(rand(n, n), rand(n, n), rand(n, n)) ; MutableDummy(n) = MutableDummy(rand(n, n), rand(n, n), rand(n, n)) ; ; function crunch_dummy(d, nloops) ; for i = 1:nloops ; @. d.a = d.b * d.c ; end ; nothing ; end ; ; nloops = 1000 ; n = 1024 ; d = Dummy(n) ; mutable_d = MutableDummy(n) ; ; # Compile ; crunch_dummy(d, 1) ; crunch_dummy(mutable_d, 1) ; ; @printf ""Dummy crunching numbers: "" ; @btime crunch_dummy(d, nloops) ; ; @printf ""Mutable dummy crunching numbers: "" ; @btime crunch_dummy(mutable_d, nloops) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/42#issuecomment-462544959:10,simpl,simple,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42#issuecomment-462544959,1,['simpl'],['simple']
Usability,"I wrote some validation scripts and I think the model is working, but I'd appreciate some feedback. First, this animation shows two 3D decaying turbulence simulations, one with `SmagorinskyLilly` and another with the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us her",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:90,feedback,feedback,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,1,['feedback'],['feedback']
Usability,I'd also intuitively prefer if this is part of simulation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278791010:9,intuit,intuitively,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278791010,1,['intuit'],['intuitively']
Usability,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:319,simpl,simply,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,2,"['intuit', 'simpl']","['intuitive', 'simply']"
Usability,"I'd like to also two 2D examples. 1. rising thermal bubble and; 2. lid-driven cavity. as super simple examples. Their set up shouldn't take more than 10 lines excluding comments. > Dramatically simplify internal wave example. +1! Always good to simplify scripts as much as possible. Would also be nice to include it in the example tests (PR #418) if it can use something like `makeplot = false`. > Free decay of two dimensional turbulence (use x,y plane). Only issue with 2D xy-plane simulations is I think things are weird with `Nz=1` so I had to use `Nz=2` (see Taylor-Green vortex test in `test_dynamics.jl`). 1D and 2D models haven't been a priority unfortunately so this sort of stuff has cropped up. I think 2D xz and yz simulations are fine with `Ny=1` and `Nx=1` respectively. > Stratified Couette flow example. I can simplify the simulation script from PR #381 down to a 2D example. This one would be good. > I think we should split deepening mixed layer into a few examples. Sound like a good idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378:95,simpl,simple,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533084378,4,['simpl'],"['simple', 'simplify']"
Usability,"I'd like to discuss examples. Here's a few that I propose:. 1. Dramatically simplify internal wave example; 2. Free decay of two dimensional turbulence (use x,y plane); 3. Stratified Couette flow example. I think we should split deepening mixed layer into a few examples:. 4. 2D convection into a stratified fluid, while forcing salinity to obey like a biological tracers (cc @johnryantaylor). 5. More sophisticated 3D deepening mixed layer example with LES. What else?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533071814:76,simpl,simplify,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-533071814,1,['simpl'],['simplify']
Usability,I'd like to help and hopefully clean up or simplify the tests along the way.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140:43,simpl,simplify,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2307#issuecomment-1120209140,1,['simpl'],['simplify']
Usability,"I'd vote for resolving #1138 and #963 before releasing a 1.0, and also some usability issues like #890 . #1175 is also breaking. Something to consider: vertically-stretched grids may require specifying the `architecture` in `grid`, rather than `model`... ? This would be a substantial change to the API. So one motivation for requiring a vertically stretched grid implementation for 1.0 would be so that we don't have to ""anticipate"" breaking changes that the stretched grid requires. I'm slightly concerned about boundary conditions too (in principle, we should be able to coalesce `TracerBoundaryConditions`, `UVelocityBoundaryConditions` into a single `FieldBoundaryConditions` specifier). But because it's not super high priority we haven't found time to attend to that and maybe it doesn't matter for 1.0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-737519674:76,usab,usability,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-737519674,1,['usab'],['usability']
Usability,I'll also add a seventh feature (from #1250):. 7. Run simulation callback/progress function at iteration 0. Right now the callback/progress function is only called for the first time when `iteration = iteration_interval` but I think we actually want to run the progress function at iteration 0 as it helps provide more feedback to the user at a time of heavy compilation. @glwagner also suggested that all the callbacks should be initialized at the beginning of run.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-739541599:319,feedback,feedback,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138#issuecomment-739541599,1,['feedback'],['feedback']
Usability,"I'll close this for now as it's not clear what we can do to make it better, and `@inbounds` helps a lot. We can revisit if we find ourselves in dire need of more performance out of the forcing functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525333615:36,clear,clear,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525333615,1,['clear'],['clear']
Usability,I'll proceed with nuking as soon as tests pass. But I do advocate for the need of a simple example on the sphere to appear in the docs soon... :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847373536:84,simpl,simple,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847373536,1,['simpl'],['simple']
Usability,I'll set up a simple test in which both tracers and velocity fields oscillate and see if we can reproduce the bug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716:14,simpl,simple,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-818006716,1,['simpl'],['simple']
Usability,I'll simplify the ShallowWaterModel constructor in a new PR...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849945455:5,simpl,simplify,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849945455,1,['simpl'],['simplify']
Usability,I'lll let @ali-ramadhan review this since I'm not 100% sure the implications of this change. > After #1003 and #1012 it's tempting to simplify the `two_dimensional_turbulence.jl` example. But perhaps that goes beyond the scope of this PR?. Probably best to have a self-contained PR that shows the precise changes that make a model `Flat`. Submit it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-702051278:134,simpl,simplify,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-702051278,1,['simpl'],['simplify']
Usability,"I'm also doubtful small round off errors in the timestep would be related, unless there a place in the code where the scheduled times for outputting / checkpointing need to exactly match some value. In the MWE, the problematic values look like they're all zeros. In our more complicated example, where the averaging interval is a large (decimal) multiple of the timestep, it's not clear if the values are underestimated because the velocities are of both signs so a biased average could go either way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595:381,clear,clear,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2263839595,1,['clear'],['clear']
Usability,"I'm amazed though - do we not have a test for building HydrostaticFreeSurfaceModel in this simplest case? It seems we need quite a few more tests for the TripolarGrid. We need to test various combination of model inputs and make sure that all of the ones we intent to support are working (free surfaces, advection schemes, coriolis, closures, etc).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2397268979:91,simpl,simplest,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2397268979,1,['simpl'],['simplest']
Usability,I'm going to start with some simple analytical solution tests (perhaps heat/salinity diffusion) until #73 is resolved. Then can begin on the 'designed forcing' CI tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467629836:29,simpl,simple,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467629836,1,['simpl'],['simple']
Usability,"I'm happy to do this. However, I need to know what to do, exactly. What code should I put in the verification folder, and what is the format? A few more questions:. - Where do we write documentation for the verification experiments? ; - Are we continuously testing verification experiments to ensure they run with new versions of the code, or should verification experiments be tagged to a particular version of the code?. I think all these questions should themselves be answered in the documentation, also. Otherwise it is not clear how to contribute new verification experiments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-562111833:529,clear,clear,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-562111833,1,['clear'],['clear']
Usability,I'm having trouble following your example. Can you come up with a simpler illustration of the issue and avoid constructions with many operations on a line?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837:66,simpl,simpler,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837,1,['simpl'],['simpler']
Usability,I'm not suggesting we should always use broadcasting. I'm just wondering if it's ok to use it for simple operations. It's a nice abstraction that works on CPUs and GPUs for simple calculations / global array updates ([for example](https://github.com/glwagner/StaggeredPoisson.jl/blob/d104825ba33f184af3b90ca0d958247d0011c7ad/src/solvers.jl#L148)).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469768233:98,simpl,simple,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469768233,2,['simpl'],['simple']
Usability,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:72,simpl,simple,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,1,['simpl'],['simple']
Usability,"I'm not sure if people are still thinking about this, but I may have some relevant information (Good news!) that I'd appreciate some feedback on. Consider the following MWE:. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Fields. Lx = 150; Ly = 6000; Lz = 80; topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(1, 512, 8), x=(0, Lx), y=(0, Ly), z=(-Lz, 0),; topology=(Periodic, Bounded, Bounded)). model = IncompressibleModel(architecture = GPU(),; grid = grid,; ). w_ic(x, y, z) = 0.01*y; v_ic(x, y, z) = 0.01*x; set!(model, w=w_ic, v=v_ic). import Oceananigans.Fields: ComputedField, KernelComputedField; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.Grids: Center, Face. u, v, w = model.velocities. function naive_calc(); p = sum(model.pressures); wp = @at (Center, Center, Face) w*p; dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end. function nested_calc(); p = ComputedField(sum(model.pressures)); wp = ComputedField(@at (Center, Center, Face) w*p); dwpdz = (1/1024) * ∂z(wp); println(dwpdz); return ComputedField(dwpdz); end; ```. I can include this script in the REPL after which I get the following results. First, when trying to compute the naive calculation using a GPU I get an error, which is expected at this point:. ```julia; julia> dwpdz_naive = naive_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── * at (Center, Center, Face) via identity;          ├── Field located at (Center, Center, Face);          └── + at (Center, Center, Center) via identity;             ├── Field located at (Center, Center, Center);             └── Field located at (Center, Center, Center)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:133,feedback,feedback,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['feedback'],['feedback']
Usability,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157:84,simpl,simpler,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157,1,['simpl'],['simpler']
Usability,"I'm not sure this is a bug by the way. The code is correct -- it may simply be that the pressure solver numerical method itself is wrong (or ""approximate"" if you want to be generous). A pressure solver that is at least theoretically correct for complex domains is/was being developed here: https://github.com/CliMA/Oceananigans.jl/pull/3188",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149898:69,simpl,simply,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270149898,1,['simpl'],['simply']
Usability,"I'm ok to advertise this. It seems maybe we need some guidelines about when to decide to document something. For practical purposes, we need to merge experimental features... My main uncertainty is that I don't know if this convective adjustment implementation is similar to the implementation in other ocean codes., but that definitely shouldn't prevent us from describe it in the docs. I'm not 100% happy with the implementation --- I want us to be able to prescribe a different diffusivity for each tracer (and I think we can get away with one fewer 3D array). That improvement would change the closure slightly, but it'd be easy to change the docs when we can do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967178951:54,guid,guidelines,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967178951,1,['guid'],['guidelines']
Usability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:124,simpl,simply,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,1,['simpl'],['simply']
Usability,"I'm saying, we can put boundary conditions in the kernels. I just don't think they should go into the _operators_. I'm not sure I am being clear. Can you please let me know if you understand what I'm saying.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2400251817:139,clear,clear,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2400251817,1,['clear'],['clear']
Usability,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1307,clear,clearly,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,1,['clear'],['clearly']
Usability,I'm simply confused with the whole shenanigans of this issue. I need a fresh start perhaps :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-817043969:4,simpl,simply,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1561#issuecomment-817043969,1,['simpl'],['simply']
Usability,"I'm thinking about introducing a new container for ""auxiliary fields"" called `model.auxiliaries`, getting rid of `model.diffusivities`, and putting references to the ""eddy diffusivity"" in the LES closure parameter structs. Are we okay with removing the constant background viscosities and diffusivities from the LES closures, and using closure tuples instead to implement this behavior? Much is simplified this way I think, because we can now have `closure.νₑ` straightforwardly. I think scripts are also clearer because users would write:. ```julia; closure = (AnisotropicMinimumDissipation(), IsotropicDiffusivity(ν=1.05e-6)); ```. To implement an LES closure in addition to a constant background isotropic viscosity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791:395,simpl,simplified,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-837110791,2,"['clear', 'simpl']","['clearer', 'simplified']"
Usability,"I'm trying to debug the situation and the code hangs long time at model construction. Is this happening for you @siddharthabishnu?. Even this simpler:. ```Julia; using Oceananigans. grid = ConformalCubedSphereGrid(; panel_size = (10, 10, 2),; z = (-1, 0),; horizontal_direction_halo = 3). model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ```. took 10 min to run.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742744955:142,simpl,simpler,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742744955,1,['simpl'],['simpler']
Usability,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024:42,clear,clearer,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024,1,['clear'],['clearer']
Usability,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:194,simpl,simple,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,2,['simpl'],"['simple', 'simpler']"
Usability,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:900,guid,guidelines,900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,1,['guid'],['guidelines']
Usability,"I've also used a slightly simpler stretching function:. ```julia; z_faces(k) = - Lz * (1 - tanh(s * (k - 1) / Nz) / tanh(s)); ```. not sure what the difference between this and the one being used in this example is, or relative benefits.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867213169:26,simpl,simpler,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867213169,1,['simpl'],['simpler']
Usability,"I've been looking at a coastal upwelling model with an analytical solution ([Estrade *et al.*, 2008](https://elischolar.library.yale.edu/journal_of_marine_research/207/)'s Equation 15, plotted below) that could be a good candidate for an immersed boundary validation test. It is an extension of Ekman's classical 1D solution to a simple 2D planar slope ($x-z$) geometry:. ![EMVR08_analytical](https://github.com/CliMA/Oceananigans.jl/assets/4955404/5a8775df-3887-4503-af87-0bbca795e6f7). Estrade *et al.* test this with a 2D ROMS implementation (their Figure 10) that I've tried to replicate in Oceananigans:. ![compare_EMVR08-analytical-numerical](https://github.com/CliMA/Oceananigans.jl/assets/4955404/c17b41e9-cb0c-463a-9bae-d418ab30e007). The discrepancy is mostly in the BBL, so I'm wondering if cut cells (#3146) would improve it. But I'm also not sure if I'm prescribing bottom friction correctly at the immersed boundary (see code below run in Oceananigans v0.91.0). Any thoughts?. ```julia; using Oceananigans; using Oceananigans.Units; using Printf. Lx = 200kilometers; dx = 100meters #200meters#500meters; hmin = 4meters; slope = 1e-3. D = 50meters; f = 3.8145e-05 # At ~15N. dz = 2meters #4meters. Ti = 2π/f; Av = f*(D/π)^2/2; @info @sprintf(""Ti: %.1f h"", Ti/3600); @info @sprintf(""Av: %1.3e m2/s for D = %d m"", Av, D) # Av = 4.831e-3 m2/s, D = 50 m, lat = 15N in Estrade et al. (2008). te = 4Ti #10Ti; outdt = Ti/10; fout = ""upwelling2Dhomog.nc"". logdt = outdt#Ti/100; maxcfl = 0.7. H = hmin + slope*Lx; Nx = Int(ceil(Lx/dx)); Nz = Int(ceil(H/dz)). underlying_grid = RectilinearGrid(CPU(),; size=(Nx, Nz), halo=(3, 3),; x = (-Lx, 0),; z = (-H, 0),; topology=(Bounded, Flat, Bounded)). h(x) = hmin + slope*x; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(h)). τx₀ = 0 # [Pa]; τy₀ = -0.1 # [Pa]; ρ₀ = 1025 # [kg/m3]; r = 5e-3. Twind = Ti/2 # Wind ramp-up timescale. τx₀ = τx₀/ρ₀; τy₀ = τy₀/ρ₀. # Boundary conditions (wind stress and bottom friction).; @inline wind_stress_u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906:330,simpl,simple,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2132214906,1,['simpl'],['simple']
Usability,"I've been thinking about open boundaries more and have some things I want to test, but they're more questions about the numerics and I don't think this is the place for it. . From the last examples I sent + other experiments I've done with it I think matching schemes are justified because even in the nested case we don't want the boundary value to modify the outflow to modify the internal solution as in the cylinder example. For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2032715863:620,simpl,simple,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2032715863,1,['simpl'],['simple']
Usability,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529:708,clear,clearer,708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529,1,['clear'],['clearer']
Usability,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:1130,clear,clearly,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,1,['clear'],['clearly']
Usability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:891,simpl,simpler,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,1,['simpl'],['simpler']
Usability,"I've had a play implementing an NPD model in this framework now and think that the other way to define the source functions is preferential:; https://github.com/CliMA/Oceananigans.jl/blob/45971e4b113182958aac43357e2a4633510617db/test/test_biogeochemistry.jl#L33-L37. We could even go one step further and define a model like this:; ```julia; struct NPD; Kₙ :: Float64; m :: Float64; nitrif :: Float64; end. validate_biogeochemistry(::NPD, tracernames) = all([T ∈ tracernames for T in [:N, :P, :D]]). @inline function (model::NPD)(i, j, k, grid, ::Val{:N}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.nitrif*D - P*N/(N+model.Kₙ) ; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:P}, clock, fields); P = @inbounds fields.P[i, j, k]; N = @inbounds fields.N[i, j, k]; return P*N/(N+model.Kₙ) - model.m*P; end. @inline function (model::NPD)(i, j, k, grid, ::Val{:D}, clock, fields); P = @inbounds fields.P[i, j, k]; D = @inbounds fields.D[i, j, k]. return model.m*P - model.nitrif*D; end. @inline (model::NPD)(args...) = 0.0; ```; This negates the need to define a `get_biogeochemial_forcing` function, but you do have to define the zero function (last line) and I'm not sure how clear and usable this API is to most users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1304900744:1268,clear,clear,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1304900744,2,"['clear', 'usab']","['clear', 'usable']"
Usability,"I've updated the code to `ParticleVelocities` and changed the function signature to . ```julia; @inline particle_u_velocity(x, y, z, u_fluid, particles, p, advective_velocity::ParticleVelocities, grid, clock, Δt, model_fields) = advective_velocity.u(x, y, z, u_fluid, particles, p, grid, clock, Δt, model_fields); ```. I also swapped around `advect_lagrangian_particles!` and `dynamics`, so now the particles are advected before the `dynamics` function is applied. I found this to be easier when implementing an example with the drag. I've implemented a simple example with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229:554,simpl,simple,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1871616229,1,['simpl'],['simple']
Usability,"If it's the same, then I'm okay calling compute on everything and don't separate between `parameters` and `computed_dependencies` anymore. I think we gotta make that clear on the docstring though!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1069134148:166,clear,clear,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1069134148,1,['clear'],['clear']
Usability,"If the current approach is significantly faster than one option is to simply take the time step to be 1/3 of what you are currently doing. This assumes the worst case that the velocity is as fast in each direction. It's more conservative than the sum but should be slightly better to ensure stability. However if you take your clf number to be 1/3 of what you are doing, then you get the same result. This doesn't seem to be a problem to me but maybe I'm not getting all the details.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-738530724:70,simpl,simply,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-738530724,1,['simpl'],['simply']
Usability,If we agree that this PR is a net positive change can we merge it and agree to change it to a stop criteria as part of resolving #1138?. Would be nice to have so that users like @tomchor don't have to add it to the simulation callback and learn about CUDA scalar operations the hard way...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-733823109:239,learn,learn,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198#issuecomment-733823109,1,['learn'],['learn']
Usability,"If we can't fix it I'm happy to leave the v0.30.0 docs as ""missing"" since v0.30.0 didn't include any updated docs and it isn't really a usable version anyways. What do you guys think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661476432:136,usab,usable,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808#issuecomment-661476432,1,['usab'],['usable']
Usability,"If we wanted to quantify the difference, we can simply find an exact solution and simulate it and compute the error. There are lots of examples to choose from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266:48,simpl,simply,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876063266,1,['simpl'],['simply']
Usability,"If you can demonstrate that this code can be implemented in a way that encourages debugging, inspection at the REPL, etc, without the abstraction, then that can be accepted. I just think that creating the abstraction is not only helpful for future people but will also help _you_ organize your ideas. I would start with that and in the end if you find its not useful, eliminate it. But I wouldn't start by designing code without it and ""seeing what happens"". The objective here is not simply to ""make things work"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299014618:485,simpl,simply,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299014618,1,['simpl'],['simply']
Usability,"If you clone only the master branch, you will see that it is quite clean:. ```bash; $ git clone https://github.com/climate-machine/Oceananigans.jl.git --single-branch; Cloning into 'Oceananigans.jl'...; remote: Enumerating objects: 19, done.; remote: Counting objects: 100% (19/19), done.; remote: Compressing objects: 100% (19/19), done.; remote: Total 12346 (delta 0), reused 19 (delta 0), pack-reused 12327; Receiving objects: 100% (12346/12346), 10.25 MiB | 1.02 MiB/s, done.; Resolving deltas: 100% (8872/8872), done.; ```. ```bash; $ du -sh Oceananigans.jl/.git; 12M	Oceananigans.jl/.git; ```. So only 12M of (compressed) files are downloaded. On the other hand, cloning the documentation branch `gh-pages` downloads 117 M:. ```bash; $ git clone https://github.com/climate-machine/Oceananigans.jl.git --single-branch --branch=gh-pages; Cloning into 'Oceananigans.jl'...; remote: Enumerating objects: 4040, done.; remote: Total 4040 (delta 0), reused 0 (delta 0), pack-reused 4040; Receiving objects: 100% (4040/4040), 117.40 MiB | 6.62 MiB/s, done.; Resolving deltas: 100% (1819/1819), done.; ```. So this is nothing to worry too much about :-) A simple non-disruptive solution is to change your hosting solution for the docs to use something other than the main git repository, and to delete the `gh-pages` branch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-554172631:1153,simpl,simple,1153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509#issuecomment-554172631,1,['simpl'],['simple']
Usability,"If you want to integrate with the Julia ""progress bar"" system, you could put in something like:; ```julia; @debug ""this is a short description of my loop"" progress=iteration/length_of_loop; ```. This works in Juno, and with MicroLogging.jl in the REPL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872:41,progress bar,progress bar,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872,1,['progress bar'],['progress bar']
Usability,"Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `58.9% <100%> (+1.76%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.58% <100%> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `87.5% <100%> (+6.25%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `84.21% <82.35%> (+71.71%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `74.86% <0%> (-1.07%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=footer). Last update [35a6a05...5771f8d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223463:2504,learn,learn,2504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223463,1,['learn'],['learn']
Usability,In #1722 we compared CPU vs GPU for the `ShallowWaterModel` for problems starting at 32x32 going as high as 16384x1634. Not quite the same model miind you but for 256x256 we found the speed up to be 7. This problem is 512x256 so it could be slightly beter but there is the pressure solve so this is just a guide. I know that the Poisson solves are a bit part of it and agree this will take time.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868118543:306,guid,guide,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868118543,1,['guid'],['guide']
Usability,"In an ideal world we would illustrate visualization with a range of plotting utilities, including Plots, Makie, etc. I think if we found that Plots were unusual for a ""substantial"" number of people then we might consider not using it in examples. But as far as I know Plots is actively developed. If you can distill the problem you're encountering to a simple example, you might report it to Plots.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867001489:353,simpl,simple,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867001489,1,['simpl'],['simple']
Usability,"In fact, the entire construction process could be simplified with the rules:. 1) If a location is shared, perform the operation there, and interpolate afterwards; 2) If a location is not shared, perform the operation at the final location. Currently rule 1) is enforced only if _all_ locations are shared (eg for tracer-tracer operations, or operations of fields with themselves).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/959#issuecomment-694942449:50,simpl,simplified,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/959#issuecomment-694942449,1,['simpl'],['simplified']
Usability,"In hindsight I think that @christophernhill is probably right about; pipeline stalls becoming a bottleneck if we use z as the fast index. (Which; leaves me unsure why it's common in the atmospheric models I've used....; Maybe just prioritizing simplicity over performance?). On Sat, Oct 12, 2019, 5:33 PM Chris Hill <notifications@github.com> wrote:. > P.S. that was a comment on the @ali-ramadhan; > <https://github.com/ali-ramadhan> comment, not the @glwagner; > <https://github.com/glwagner> comment. Greg is correct that some code; > generation can help, although sometimes its cleaner just to write elegant; > code than get carried away with meta-programming ( e.g. see Steve J; > meta-programming regrets talk https://www.youtube.com/watch?v=mSgXWpvQEHE; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/470?email_source=notifications&email_token=ACZDSTS5AH2A5CC2HC43EELQOI7CRA5CNFSM4JAEMGO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBCIYQQ#issuecomment-541363266>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACZDSTWNQED7NDAS2U5KTETQOI7CRANCNFSM4JAEMGOQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541364103:244,simpl,simplicity,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541364103,1,['simpl'],['simplicity']
Usability,"In my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), the preconditioner is also perturbed. The goal is to solve the following equation in an immersed boundary grid. $$\nabla^2 \phi + \delta N \bar \phi = R $$. The perturbed preconditioner solves this equation in a regular grid:. $$ \phi = L_\mathrm{FFT}R + \frac{1}{\delta N}\overline{R}$$. where $L_\mathrm{FFT}$ is the FFT-based Poisson solver. Due to the gauge condition of $L_\mathrm{FFT}$,. $$\nabla^2L_\mathrm{FFT}R = R - \overline{R}$$. $$\overline{L_\mathrm{FFT}R} = 0$$. for a random $R$ whose mean is not necessarily zero. The latter is simply the gauge condition; the former means that $L_\mathrm{FFT}$ ignores the mean component of $R$ \(which can be understood as $\frac{1}{N}ee^TR$\). It is easy to verify that the preconditioner gives the exact solution in a regular grid. Besides, in my implementation \(https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac\), I perturb the preconditioner directly by adding the mean of the input vector. However, a more efficient solution is to a new parameter to the FFT-based Poisson solver, so that it solves. $$\nabla^2 \phi + m \phi - \mu \overline{\phi} = r $$. where $\mu$ represents the role of $\delta$ or $c$ in previous comments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874:667,simpl,simply,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417544874,1,['simpl'],['simply']
Usability,"In some ways, omitting instantiation is a tempting hack that helps script-readability, but introduces slight complications in the source code and leads to confusion and memorization demands in the API... I guess the confusion here is that there's no _meaningful_ difference data type like `Cell, Periodic, WENO5, GPU` and their concrete realizations `Cell(), Periodic()`, etc. There's only a meaningful difference when concrete realizations can contain additional data. We could simply require concrete realizations for specification everywhere. Then the semantics is uniform specifying types with additional data `FPlane(f=1e-4)` and types without data `WENO5()`. And we become ok with the syntax `topology = (Periodic(), Periodic(), Bounded())`. We could alternatively auto-instantiate `DataType` where appropriate so that both `CPU` and `CPU()` work as expected. This wouldn't break the current API and may not be too much work, though could be harder to maintain moving forward. Which is more friendly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1119#issuecomment-720088204:479,simpl,simply,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119#issuecomment-720088204,1,['simpl'],['simply']
Usability,"In terms of the validation experimens, from what I understand, they are created when someone does something new and the script is a proof by example, or sorts. Since they are never run in tests they do become stale, and a bunch no longer run, as has been pointed out. The same can be said for benchmarks. . Examples are great because they are continually tested and therefore updated as needed. There are a bunch, but still, I don't think as much is covered in the examples as we see in validation. It would be nice for people to see whats in validation, but if they don't work then that causes other problems. I don't claim there is a simple solution but I'm glad we're talking about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039:636,simpl,simple,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872510039,1,['simpl'],['simple']
Usability,"In the above, WENO-JS is the scheme we have now, and WENO-NM is the ""weighted"" scheme they propose. The weighted scheme is ~~extremely simple~~ fairly simple. ~~It's just a little algebra to get it to work for us.~~ On reading the paper again, I realize that the smoothness indicators are a bit annoying. But doable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876450169:135,simpl,simple,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-876450169,2,['simpl'],['simple']
Usability,"In this case if we see convergence with decreasing time-step (spatial resolution isn't relevant for these dynamics, which are at the grid scale and therefore not physical) then I suppose that would be an indication the issue is due to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could div",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423:686,guid,guide,686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423,1,['guid'],['guide']
Usability,"Indeed, it seems like . ```; @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); ```; clears the problem. Interesting... ; Do you guys have any idea why that could influence the `fill_halo_bottom`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1083925352:99,clear,clears,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1083925352,1,['clear'],['clears']
Usability,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390:785,simpl,simplicity,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390,2,"['intuit', 'simpl']","['intuitive', 'simplicity']"
Usability,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:230,clear,clearly,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103,1,['clear'],['clearly']
Usability,"Interesting that `mutable`s can't be `isbits`. But `Array` is mutable and `isbits`? Maybe some exceptions... I do think you should avoid fields with abstract or unspecified types in all cases (when simple, like this one) though, even if just for style points, but also to avoid an unexpected performance gotcha. `Clock{T}` seems appropriate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073:198,simpl,simple,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073,1,['simpl'],['simple']
Usability,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:571,simpl,simply,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134,1,['simpl'],['simply']
Usability,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069:86,clear,clear,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069,1,['clear'],['clear']
Usability,"Interesting. We have deliberately avoided operations for field time series but we can consider it. How does this work for operations that involve both a Field and a FieldTimeSeries? I'm worried this will be a bit brittle and potentially lead to some wasted time for users, since it may only work for the simplest cases. Another issue is that we don't have a time derivative operator. Another way to implement a time series computation is to make a new/empty FieldTimeSeries, and then loop over the time-index to compute each field in the time series. Is this PR merely a convenience to avoid that loop? Are there other solutions / syntax we could think about supporting that might be more useful / generalize better for users?. Note I think for big feature changes like this it's best to discuss in an issue first before having a PR, but we can discuss here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393:304,simpl,simplest,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393,1,['simpl'],['simplest']
Usability,"Interestingly, all the tests still pass when we explicitly time-step w instead of recompute it from continuity. So still not clear whether we need to do the recomputation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876660:125,clear,clear,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876660,1,['clear'],['clear']
Usability,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:14,simpl,simplicity,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680,1,['simpl'],['simplicity']
Usability,Is this simply a problem of ; https://github.com/CliMA/Oceananigans.jl/blob/02b0e71c993a8aef4285e231f7416fd0758af380/src/BoundaryConditions/show_boundary_conditions.jl#L20-L40; not having a method corresponding to `Flat` dimensions (that I guess come without any boundary conditions)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026#issuecomment-718287680:8,simpl,simply,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026#issuecomment-718287680,1,['simpl'],['simply']
Usability,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343:65,simpl,simply,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343,1,['simpl'],['simply']
Usability,"It could make sense to have a separate PR for the change to `Clock` since it's pretty simple. Should it be called ""previous"" dt in the Clock perhaps? (Not sure ""previous_"" is the best name either, it could also be ""last_dt"" or something)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994999546:86,simpl,simple,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1994999546,1,['simpl'],['simple']
Usability,It may be the answer to several conundrums. Or simply not many use fields for BCs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3286#issuecomment-1735856663:47,simpl,simply,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3286#issuecomment-1735856663,1,['simpl'],['simply']
Usability,"It might actually be more appropriate to add `NaN`-checking as a default stop criteria to `Simulations`. This seems a bit more clear. Also, we don't need to check every single grid point like the current `NaNChecker` does. It's sufficient to check just one point; perhaps checking pressure is most appropriate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/938#issuecomment-709693850:127,clear,clear,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/938#issuecomment-709693850,1,['clear'],['clear']
Usability,"It might be reasonable to simply generalize `parent_slice_indices` for `AbstractRange`s:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L61. We might want to use `minimum(rng)` rather than `rng[1]`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L64. And we can return `StepRange(left, step(rng), right)` rather than `UnitRange(left, right)`:. https://github.com/CliMA/Oceananigans.jl/blob/a4be062049b096ce20ac0908ee40f0b81b16d5ae/src/Diagnostics/field_slicer.jl#L71",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810573826:26,simpl,simply,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-810573826,1,['simpl'],['simply']
Usability,"It might make sense to convert this to a discussion and change the title to ""Building reproducible LES setups"". The info here could be useful for future Oceananigans users that would like to build reproducible setups (thanks for your efforts in this department @fspereira1). Of note, the lessons learned here are mostly about achieving reproducibility with Julia and FFTW (the lessons are not Oceananigans specific, and are applicable to other Julia applications). And to summarize the important points:. * Reproducible initial conditions must be constructed with care. If using random initial conditions, we have to set the seed of the random number generator, and ensure that any random arrays are constructed deterministically (for example, we can't use `rand()` inside an initial condition function because loop ordering is not deterministic in Oceananigans). There could be special concerns for random array initial conditions on GPU.; * Reproducible results from solvers that use FFTW (either 3D pressure solvers, or the 2D free surface solvers for `HydrostaticFreeSurfaceModel`) must use the `FFTW.ESTIMATE` planner flag (see solver documentation for how to do this in each case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295914743:296,learn,learned,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295914743,1,['learn'],['learned']
Usability,It seemed that @tomchor and I both came up with the idea of `ConstantCoriolis` within a short span of time. It's simple and accurate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679972:113,simpl,simple,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679972,1,['simpl'],['simple']
Usability,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:737,guid,guide,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071,1,['guid'],['guide']
Usability,"It would also be nice to add a simple biogeochemical model to this set up. @zhenwu0728, can you recommend a system of reactive tracers that would be nice to include, along with their boundary conditions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629360356:31,simpl,simple,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629360356,1,['simpl'],['simple']
Usability,It'd be best if you guys can take a look at the conflicts in `src/Architectures.jl`; it's not clear to me what some decisions would influence elsewhere in the code - quite a bit has changed that you are probably more aware of. I'm happy to test the code once conflicts are resolved.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997670821:94,clear,clear,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997670821,1,['clear'],['clear']
Usability,It'd be easy as an intermediate step to discontinue GPU support only I suppose. Depends how much we want to simplify the code... Also this is a reason not to eliminate `LatitudeLongitudeGrid` because it seems like it will always have fewer parameters than `OrthogonalSphericalShellGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031:108,simpl,simplify,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031,1,['simpl'],['simplify']
Usability,It'd be good to get some feedback from @nolanrei99. Might need merge master because I think its gotten a bit stale.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-716547929:25,feedback,feedback,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-716547929,1,['feedback'],['feedback']
Usability,"It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. For example, benchmarking *might* show that a GPU-friendly algorithm performs poorly compared to a CPU-specific algorithm, which might justify maintaining separate solvers for the GPU and CPU. Is this the case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572064187:226,simpl,simplest,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572064187,1,['simpl'],['simplest']
Usability,"It's a Mac. @glwagner, I just tried to install it on my home laptop (also a Mac) by simply `add Oceananigans` and the build time of HDF5 is much shorter (~1 min). Not sure what was happening on the other laptop this afternoon...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501103347:84,simpl,simply,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501103347,1,['simpl'],['simply']
Usability,"It's a bit hard to tell what's gone wrong here at this point. I'd do something like; * Create a local branch with `git branch logging_orig $some_hash_or_branch_name` or something to keep this safe. If you've lost the original branch or hash name, don't panic (and don't delete your .git directory)! You can use `git reflog` to find it again.; * Create and check out another local branch as a work in progress `git checkout -b logging_wip logging_orig`; * Squash your changes with `git rebase -i` on `logging_wip` branch into a single commit.; * Reset your master (this PR) to the new rewritten upstream master `git checkout master; git reset --hard origin/master` (presuming origin is `git@github.com:climate-machine/Oceananigans.jl.git`); * Cherry pick the single commit from `logging_wip` onto this new master with `git cherry-pick logging_wip`.; * Force push your new master up to this pull request. (By the way, this would probably be clearer for you if you'd made the original pull request off a branch rather than your master branch. Generally that's a good idea, especially if you want to do multiple PRs)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496:939,clear,clearer,939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496,1,['clear'],['clearer']
Usability,It's all simple stuff... someone just has to sit down and do it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736:9,simpl,simple,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866275736,1,['simpl'],['simple']
Usability,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075:247,simpl,simply,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075,1,['simpl'],['simply']
Usability,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:1050,clear,clear,1050,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,1,['clear'],['clear']
Usability,"It's coming from this annoying function:. https://github.com/CliMA/Oceananigans.jl/blob/30e3e05fe661cb5f7a0db37ab6c3f42ac8c5f80e/src/Fields/field_tuples.jl#L56-L83. which we can certainly simplify. We can also play around this avoiding hitting this line altogether, at least for a certain class of models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214:188,simpl,simplify,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214,1,['simpl'],['simplify']
Usability,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:33,simpl,simple,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947,1,['simpl'],['simple']
Usability,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:370,simpl,simple,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,1,['simpl'],['simple']
Usability,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:390,simpl,simple,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706,1,['simpl'],['simple']
Usability,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:521,clear,clear,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432,1,['clear'],['clear']
Usability,"JjL0ZpZWxkcy9iYWNrZ3JvdW5kX2ZpZWxkcy5qbA==) | `92.85% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `79.09% <0.00%> (+0.96%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `96.87% <0.00%> (+1.63%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `85.71% <0.00%> (+2.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `96.15% <0.00%> (+2.40%)` | :arrow_up: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `42.85% <0.00%> (+2.85%)` | :arrow_up: |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `82.35% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=footer). Last update [d274364...1675e40](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1039?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1039#issuecomment-707647298:3346,learn,learn,3346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039#issuecomment-707647298,1,['learn'],['learn']
Usability,"JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (+22.85%)` | :arrow_up: |; | [src/LagrangianParticleTracking.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL0xhZ3JhbmdpYW5QYXJ0aWNsZVRyYWNraW5nLmps) | `83.33% <83.33%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `76.92% <100.00%> (+0.60%)` | :arrow_up: |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/store\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9zdG9yZV90ZW5kZW5jaWVzLmps) | `72.72% <0.00%> (ø)` | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | | |; | [...Models/IncompressibleModels/pressure\_correction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | | |; | ... and [29 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=footer). Last update [7d30dba...03d1209](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1091?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713522601:3089,learn,learn,3089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713522601,1,['learn'],['learn']
Usability,"JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [41 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=footer). Last update [0676c76...645a483](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/656?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/656#issuecomment-592649433:3583,learn,learn,3583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/656#issuecomment-592649433,1,['learn'],['learn']
Usability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:550,clear,clear,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,1,['clear'],['clear']
Usability,"Just adding to @glwagner's comment, @whitleyv and I have discussed adding:. - Boundary interpolation, so the topography does not have to match the grid.; - Neumann boundary conditions. ; - A simple log-layer wall-model. I think we have a good sense of how to approach the above. I'm also interested in discussing pressure solver modifications with @weymouth, we will talk on our end and then be in touch to schedule a time to chat. ; Thanks!; Jacob",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720088717:191,simpl,simple,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-720088717,1,['simpl'],['simple']
Usability,"Just as a reference, the sed command to do this (I believe) is. ```sed ""s/\<Cell\>/Center/g""```. which produces the following results (as an example):. ```bash; $ line=""(Cell, Cellphone), Cell; :Cell, Cell.something""; $ echo ""$line"" | sed ""s/\<Cell\>/Center/g""; (Center, Cellphone), Center; :Center, Center.something; ```. So a one-liner to do this is (I think; I haven't tested):. ``` find . -type f -name ""*.jl"" -print0 | xargs -0 sed ""s/\<Cell\>/Center/g"" ```. assuming we just wanna replace in ""*.jl"" files. I agree with `Center` and `Face` being the most intuitive and I'd be glad to do this change if everyone agrees. Although this would probably need to come with a bump to the next version since this is a breaking change, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-763796870:560,intuit,intuitive,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/414#issuecomment-763796870,1,['intuit'],['intuitive']
Usability,"Just as a simple counterargument, when `FT=Float64`, we are not getting precision / promotion issues. This is specific to `Float32`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445644828:10,simpl,simple,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445644828,1,['simpl'],['simple']
Usability,"Just as an update --- we actually currently cannot do this verification experiment because of a problem with LES models (a theoretical problem, not an implementation problem) with specified buoyancy flux boundary conditions and zero stress boundary conditions. In short, we observe grid-scale oscillations in the near-surface buoyancy gradient when buoyancy fluxes are specified. The primary issue is associated with a too-small near-surface LES diffusivity. . I want to emphasize that this is not a numerical issue with boundary condition specification, or a bug in the LES implementation --- this is a fundamental, theoretical problem with LES formulation. Others have observed this issue before with a variety of LES formulations, so this issue is not particular to AMD, either. I'm working on a fix because this is an important, canonical problem. The easiest way to fix the problem is to allow the LES model constant (which we should view as a free parameter) to vary in space and in particular to increase near the wall. This is simple, yet completely empirical solution. . The level of empiricism / near-wall enhancement of the model constant needed for a smooth solution is mitigated somewhat if we can specify the gradient of buoyancy / temperature on the boundary. This second component of the fix can be done by introducing a wall model on top of the interior LES formulation that applies *on* boundaries. The wall model introduces a second free parameter in addition to the interior LES free parameter. Adjusting the wall model's free parameter allows us to ""effectively"" increase the near-wall value of the AMD diffusivity. An even better, more complete fix would also modify the interior LES model near the wall. But this is an open-ended science problem with no clear solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239:1035,simpl,simple,1035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"Just dropping a link here https://github.com/hdrake/simplearth for some of our (WIP) ""intro to climate modelling"" repository, featuring some interactive climate modelling Pluto.jl notebooks. These are just toy models but I imagine doing the same thing with low-resolution or 2-D research-grade models like Oceananigans.jl and ClimateMachine.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1109#issuecomment-718745678:52,simpl,simplearth,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1109#issuecomment-718745678,1,['simpl'],['simplearth']
Usability,"Just for the record, @glwagner and I decided to go with [this suggestion](https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905) which is the simplest for the time being. The naming is more intuitive and (with the new name) is makes sense that an empty element is created when a closure doesn't require an auxiliary field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510:164,simpl,simplest,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510,2,"['intuit', 'simpl']","['intuitive', 'simplest']"
Usability,"Just here to say that I had to update some code from using `grid.xC` to using `grid.Δxᵃᵃᶜ` which is more difficult to write, so I support a redesign or some more user-friendly way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205:162,user-friendly,user-friendly,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205,1,['user-friendly'],['user-friendly']
Usability,"Just note that you'll have to redo any work you do in the context of shallow water because the formulation is different. `ShallowWaterModel` uses a conservative form and thus solves for `uh`, rather than `u = uh / h`. It was coded in this way explicitly to have different conservation properties. So you should probably not expect that things like numerical dissipation will be consistent between `ShallowWaterModel` and `HydrostaticFreeSurfaceModel`. Note that a single layer `HydrostaticFreeSurfaceModel` is _simpler_ than `ShallowWaterModel` because it linearizes the free surface. In other words, a `HydrostaticFreeSurfaceModel` with one vertical layer is a ""shallow water model"", but with a linear free surface. You can use that fact if you like if you want to derive analytical solutions. I'd just caution that working with `ShallowWaterModel` probably makes the problem _more complex_ rather than simpler. So while interesting in its own right, it doesn't seem like the easiest way to make progress towards getting an advection scheme working for `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062924033:904,simpl,simpler,904,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062924033,1,['simpl'],['simpler']
Usability,"Just opened a PR with this, we can discuss what's the best approach. > Would users still have to define all three for two-dimensional domains?. Ideally no. I can modify `RegularCartesianGrid` to take this into account. > I understand the benefit in terms of being explicit, but I'm worried there are a lot of use cases in which the origin of the domain is simply unimportant, and the only relevant parameter is the domain extent. The legacy constructor `RegularCartesianGrid(N, L)` can still be used in this case. > Is there any concern about confusion between specifying the domain in terms of bounding cell faces versus cell centers?. I don't think so. When specifying the domain size, you are in effect specifying the location of the first and last face. All cell centers are located strictly between the first and last cell interface. I don't think it makes sense to specify the domain via the cell centers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091:356,simpl,simply,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091,1,['simpl'],['simply']
Usability,"Just to be clear, I don't think that's a super important issue. We could just leave it like it is. But I do think it would be nice if the spacing varied only a little in the surface layer, which is where we care more about the physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867672551:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867672551,1,['clear'],['clear']
Usability,"Just to be clear, I'm not suggesting that we document experimental features to the level that we document mature ones. That'd be impossibly hard to maintain. But maybe a page somewhere with a list of experimental features (all I know about are immersed boundaries and parallelism, although I'm sure there are more that I'm not aware) that links to the relevant issues/PRs/discussions and maybe to relevant files in `src`? Otherwise I think it's hard for users to know what experimental features there are since they have to browse issues/PRs/discussions looking for stuff in the titles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1068043951:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355#issuecomment-1068043951,1,['clear'],['clear']
Usability,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583,1,['clear'],['clear']
Usability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,1,['clear'],['clear']
Usability,"Just to be clear: our goal is to develop an API for distributed simulations that require a ""minimum"" of changes to the same script applied to a non-distributed simulation. The point of this goal is to make it easy to scale simulations from single-process to multi-process.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894652800:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894652800,1,['clear'],['clear']
Usability,"Just to be completely clear I am suggesting changing the above to. ```julia; convert_output(outputs::NamedTuple, writer) = ; NamedTuple{keys(outputs)}(Tuple(convert_output(output, writer) for output in outputs)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-784318930:22,clear,clear,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1398#issuecomment-784318930,1,['clear'],['clear']
Usability,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342:980,simpl,simply,980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342,2,['simpl'],['simply']
Usability,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:411,simpl,simple,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,1,['simpl'],['simple']
Usability,"Just to make @ali-ramadhan 's comment a bit more clear, we should also change `t` to `time`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702068166:49,clear,clear,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-702068166,1,['clear'],['clear']
Usability,"Just trying to understand the conversation so far and I have a couple of questions:. 1. Is it correct to think of this PR as being a precursor to PR #1532 (I guess this PR should be merged first)?; 2. Am I right in thinking that the current discussion is around whether we want to specify `z=(-Lz, 0), z_stretch=something` vs. just `z_stretch=something` (and infering `z=(-Lz, 0)` from `z_stretch`)?. I think it would be awesome if users never had to think about the staggered grid but in this case it might be unavoidable? I guess `z_stretch` (`zF` in the main branch) specifies the location of the faces (of which there are Nz+1 if z is `Bounded`) so this should be made clear (could be in the docstring I suppose). I'm also not a fan of `zF`. I think `z_stretch` is better. What if we allowed the `z` kwarg to be either a function, an array, or a 2-tuple (inferred to be regularly spaced)? And we clearly explain in the docstring and docs that arrays and functions specify the location of the faces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794:673,clear,clear,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813490794,2,['clear'],"['clear', 'clearly']"
Usability,"JzLmps) | `46.97% <96.15%> (-17.77%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <0%> (-56.97%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `16.21% <0%> (-40.93%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `51.42% <0%> (-37.15%)` | :arrow_down: |; | [src/turbulence\_closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY2xvc3VyZV9vcGVyYXRvcnMuamw=) | `42.62% <0%> (-22.55%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `42% <0%> (-20.03%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.15% <0%> (-10.85%)` | :arrow_down: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=footer). Last update [66670ad...40fd4b0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974976:2961,learn,learn,2961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974976,1,['learn'],['learn']
Usability,"KaTeX cannot do equation numbers or references yet. There are a number of issues open on katex github about this. . I think to suppress output you’d have to add a line with ‘nothing’. But this is silly, so yes, show for the output writers is important. . I tried to keep the plotting simple and barebones so 1. we don’t distract from the point of the example, which is to demonstrate Oceananigans usage (not to demonstrate plotting) and 2. so the examples are easy to maintain. I agree that colorbars are useful for interpreting output, but we don’t interpret output in the examples. . I think viridis is an acceptable colormap, but I’m also happy to pick a prettier one. As I noted above, I think we should keep plotting simple and involving as few characters as possible so the examples are maximally useful in demonstrating how Oceananigans is used. (There’s really too much code devoted to plotting as is, which we should fix by shipping plotting recipes with Oceananigans.). I thought the package name is Oceananigans.jl? What is convention?. Typos noted, I will fix before merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544317275:284,simpl,simple,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544317275,2,['simpl'],['simple']
Usability,"Kinda. The current behavior is this https://github.com/CliMA/Oceananigans.jl/blob/470fd110a99b1967510979fbc313093dac060636/src/OutputWriters/netcdf_output_writer.jl#L302-L308. So the default is similar to what it was when this issue was posted, although I think it's formulated a little clearer now. I'm okay with this and also okay with closing this issue, but I'm not sure everyone else feels this way. You mentioned at some point that we could move this part to after `run!()` is called and I don't think we discussed that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1100262668:287,clear,clearer,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1100262668,1,['clear'],['clearer']
Usability,"L2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <ø> (ø)` | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | `0.00% <ø> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <50.00%> (-8.19%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `89.36% <54.54%> (-10.64%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <85.71%> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `93.42% <87.50%> (-2.95%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=footer). Last update [40e7caf...2a19ef9](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/823?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956:3101,learn,learn,3101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823#issuecomment-664396956,1,['learn'],['learn']
Usability,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:135,undo,undo,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570,1,['undo'],['undo']
Usability,"Leaving this here for future reference, but also for discussion: maybe include some guidelines on using, slicing, and even viewing arrays when working on GPUs. These are definitely not obvious. It might be useful for users using external data (as arrays) in simulations, such as https://github.com/CliMA/Oceananigans.jl/issues/1509.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-812678465:84,guid,guidelines,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-812678465,1,['guid'],['guidelines']
Usability,"Let it be recorded: we discussed ghost cells and decided *not* to use them. The main reason for not using ghost cells is that it is not clear whether an algorithm based on ghost cells can be used for irregular boundaries, where a cell point within land may be shared between 2 or more adjacent fluid cells. We will need to figure out how to include the correct values of `FaceField`s on the boundary in output, for arbitrary boundary conditions. Perhaps we can implement some kind of pseudo-ghost cell functionality that only affects the calculation of output. Something to stew over.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468508346:136,clear,clear,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92#issuecomment-468508346,1,['clear'],['clear']
Usability,"Let me make things concrete. Right now we have:. ```Julia; ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = (-u∇u(u, v, w, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + fCor*avg_xy(v, Nx, Ny, i, j, k); - δx_c2f(pHY′, Nx, i, j, k) / (Δx * ρ₀); + 𝜈∇²u(u, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + F.u(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)); # ...; ```. A simple change we could make would be instead write. ```Julia; ""Calculate the right-hand-side of the u-momentum equation at I, j, k.""; u_eqn(args..., F::Function i, j, k) = stuff + F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); u_eqn(args..., F::AbstractArray i, j, k) = stuff + F[i, j, k]; u_eqn(args..., F::Nothing, i, j, k) = stuff. ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = u_eqn(args..., F.u, i, j, k); # ...; ```; We could write even less code if we created an abstraction for the right hand side, something like. ```Julia; struct Equation{TF}; G::Function; F::TF; end. (eq::Equation{TF})(args..., i, j, k) where TF <: Function = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: AbstractArray = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: Nothing = eq.G(args..., i, j, k) . u_eqn = Equation(Gu, Fu). ...; @inbounds Gu[i, j, k] = u_eqn(args..., i, j, k); ```. We can then load all the equations we have into a `FieldVector` or `LabeledArray` to make things even better and do something like . ```julia; @lo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169:616,simpl,simple,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169,1,['simpl'],['simple']
Usability,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684:11,simpl,simple,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684,1,['simpl'],['simple']
Usability,"Let's get to the blackboard together and sort it out. Don't code things; that are not clear. On Thu, May 23, 2019, 8:41 AM Ali Ramadhan <notifications@github.com> wrote:. > Ali, Please explain why it's x delt rather than divide. John; >; > I think when you discretize you get ∂u/∂t you get 1/Δt but then I think; > you're solving for the *predictor* or intermediate velocity *u**, which; > is fed into the right hand side, has a Δt multiplying the *Gu* source; > terms. It's not super clear to me yet, probably a good reason to actually; > write out all the equations and properly document this step.; >; > I ended up following the MITgcm manual:; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#equation-elliptic-pnh; >; > Equation (2.52) gives the 3D elliptic equations, and if you expand the; > right hand side using (2.53-2.55) and (2.58-2.59), and set *η=0* (we have; > no free surface) then we get ∇²ϕNH = ∇·u(n) + Δt*∇·Gu(n+½).; >; > What's worrying me right now is that this all seems to work great when *Δt; > = 1* but otherwise it doesn't work. I tried dividing by *Δt* just to make; > sure but it also didn't work (you get very high velocity divergences and it; > eventually blows up).; >; > Ps Does it work for 32bit now?; >; > It works better (the velocity divergence accumulates 10-20x more slowly); > but we might still need further fixes.; >; > Before:; >; > [ Info: Velocity divergence after 1 time steps (CPU(), Float32): min=-2.6085445e-10, max=-2.6085445e-10, sum=-2.683187e-11, abs_sum=7.933663e-7; >; > [ Info: Velocity divergence after 10 time steps (CPU(), Float32): min=-1.2560122e-9, max=-1.2560122e-9, sum=1.3686829e-12, abs_sum=3.0624833e-6; >; > [ Info: Velocity divergence after 100 time steps (CPU(), Float32): min=-5.4315024e-9, max=-5.4315024e-9, sum=1.2459012e-10, abs_sum=2.1301974e-5; >; > [ Info: Velocity divergence after 1000 time steps (CPU(), Float32): min=-6.495975e-8, max=-6.495975e-8, sum=-3.066242e-8, abs_sum=0.0002503319; >; >; > Afte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146:86,clear,clear,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146,2,['clear'],['clear']
Usability,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:1070,simpl,simplest,1070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178,1,['simpl'],['simplest']
Usability,Let’s discuss the user API here though it’s pretty simple,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1526887412:51,simpl,simple,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1526887412,1,['simpl'],['simple']
Usability,"Looks great, thank you for the PR!. We've recently begun to follow the [ColPrac](https://github.com/SciML/ColPrac) guide (also PR #1044) which has some pretty nice guidelines on community package development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732305765:115,guid,guide,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192#issuecomment-732305765,2,['guid'],"['guide', 'guidelines']"
Usability,Looks pretty good and the coding was simpler than I imagined. Provided the tests for halo regions pass is there anything else to do for ComputedFields?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566:37,simpl,simpler,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340#issuecomment-773409566,1,['simpl'],['simpler']
Usability,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422:178,clear,clear,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422,1,['clear'],['clear']
Usability,Maybe a lat-lon barotropic double gyre like MITgcm has? . https://mitgcm.readthedocs.io/en/latest/examples/barotropic_gyre/barotropic_gyre.html. Let's keep it as simple as possible too...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140507140:162,simpl,simple,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140507140,1,['simpl'],['simple']
Usability,"Maybe more specifically I don't understand the motivation for this:. https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L44-L48. This is a kind of abstraction for a send/recv event, but its super implicit just consisting of integers, rather than simply recording this information as symbols or strings (is a number the only way to generate a unique ID for a field?). I can't figure out why we would record the Z location, this seems random. Why not record the 3D location directly (not use a digit)? Otherwise this code is seemingly more specific than it needs to be. It would be annoying to debug this too since you'd have to be constantly computing these codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2294426510:332,simpl,simply,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2294426510,1,['simpl'],['simply']
Usability,"Maybe part of my confusion is on whether the solution fields, `uh,vh,h`, are cell averaged quantities or not. If they are then do we need to multipy by the area?. Maybe having docs on the finite volume method, as discussed previously, would help to clear some of this up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882704896:249,clear,clear,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882704896,1,['clear'],['clear']
Usability,Maybe we should take a step back and think about what our goal is? What do we want from this system? Will this simplify the MITgcm algorithm?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494101:111,simpl,simplify,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494101,1,['simpl'],['simplify']
Usability,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397:80,simpl,simple,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397,1,['simpl'],['simple']
Usability,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:125,simpl,simple,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262,1,['simpl'],['simple']
Usability,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307:183,clear,clearly,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307,1,['clear'],['clearly']
Usability,"More thoughts. . 1. I'm reading the discussion on immersed boundary methods (IBMs) with interest on [#916](https://github.com/CliMA/Oceananigans.jl/issues/1036). It should be pointed out that this would be a great thing to test in a shalllow water model since there is no pressure inversion and it's much easier to resolve the horizontal, since we have no vertical. 2. Climate Machine also has a shallow water [model](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl). I don't know the details of what this does but I should probably learn how the two models will differ.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726868983:584,learn,learn,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726868983,1,['learn'],['learn']
Usability,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:126,simpl,simple,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['simpl'],['simple']
Usability,"My bad, yes, \kappa is much better. Fixed. Also, I rewrote the Laplacian as the divergence of the product of \kappa and the gradient of c. That is also better I agree. Should I put together a PR for this part and then work on the momentum? I'm also happy to wait for more feedback. @navidcy , what do you think?. @glwagner : I will send you a link to the overleaf document.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874264766:272,feedback,feedback,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874264766,1,['feedback'],['feedback']
Usability,"My bad. I was not clear. Yes, T1 - T2 = 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273701074:18,clear,clear,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273701074,1,['clear'],['clear']
Usability,"My biggest concern is that introducing a grid topology and keeping the current implementation of boundary conditions will cause confusion as they perform overlapping functions. But I think with a bit of thinking there can be lots of benefits to adding a grid topology as you say. > This change will eliminate the need for a special `ChannelModel` constructor, and also eliminates the need for constructors with names like `HorizontallyPeriodicBCs`. Instead, we have a generic constructor for `FieldBoundaryConditions` that lets a user specify boundary conditions in any direction. That would be great I think. If each field now carries around its own boundary conditions and horizontally periodic and channel BCs are treated a grid topology then we can get rid of `HorizontallyPeriodicBCs`, `HorizontallyPeriodicSolutionBCs`, `ChannelBCs`, and `ChannelSolutionBCs` (+ same for triply periodic and boxes) which would greatly simplify model setup and eliminate most overlap between boundary conditions and grid topology. > A `Flat` topology will enable us to set halo sizes to 0 for `Flat` directions, and elide the unnecessary interpolation and differentiation operations in `Flat` directions that currently plagues two and one-dimensional models. True. We currently don't have a clean way of eliding unnecessary operations for 1D and 2D models. Dispatching on the grid topology would provide a way of doing this very cleanly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-579888892:924,simpl,simplify,924,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-579888892,1,['simpl'],['simplify']
Usability,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713:233,clear,clearer,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713,1,['clear'],['clearer']
Usability,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:475,simpl,simple,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028,1,['simpl'],['simple']
Usability,"My main concern is that if it doesn't work for most cases (only simple ones) then we won't really want to document / advertise the new feature. Right now this is what users have to do I think:. ```julia; u10 = FieldTimeSeries(""atmosphere.jld2"", ""u10""). tau = FieldTimeSeries{Face, Center, Nothing}(grid, u10.times). for n = 1:length(tau); u10n = u10[n]; tau[n] .= - ρₐ / ρₒ * cᴰ * u10n * abs(u10n); end; ```. collapsing this to fewer lines and also potentially making it faster (by launching a 4D kernel that computes over time as well as space could be a significant advantage but I think we probably need to be able to mix `Field`s into the computation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2200448875:64,simpl,simple,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2200448875,1,['simpl'],['simple']
Usability,"My question: what are we defending against with this check? If we only want to ensure that we don't throw an error if `progress===nothing`, we can simply check for that case and otherwise call `progress(sim)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/642#issuecomment-590416350:147,simpl,simply,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/642#issuecomment-590416350,1,['simpl'],['simply']
Usability,"My reasoning was that the functions VelocityFields, TracerFields, and PressureFields seem to provide a minor convenience and are only called from the model constructor (in principle one could simply build named tuples of velocity fields, tracers, pressures directly in the constructor without intervening functions). Thus it seems nice for these functions to live close to the model constructor where they can be understood while reading the model constructor code. That is my main motivation for coalescing what would have remained from fieldsets.jl into models.jl. . As for forcing, it’s just one/two lines, so it didn’t seem right to have a separate file. Ultimately this is a temporary implementation. We will need a more sophisticated way to build tuples or forcing functions when we have arbitrary tracers. . I don’t immediately see why putting those functions in separate files is helpful for readability, since I find it hard to read code that is spread across many small files. But I’m open to putting them back if my views are idiosyncratic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517520348:192,simpl,simply,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517520348,1,['simpl'],['simply']
Usability,"My take is that I don't think there's a way around the choices I just mentioned in the previous post. To make it ever harder, based on @glwagner's comment I think we also need to discuss what exactly (regardless of format) `zspacings` should return to the user. Taking `PartialGridBottom` as an example, if we're to mimic the internals of the code, then it `zspacings(ibm_grid::IBG)` should return. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. `zspacings(ibm_grid.underlying_grid)` if `z` is fully below/inside the immersed boundary/solid. afaik this is exactly how the code internals work. However, since `zspacings` (and I guess also `zspacing`?) is a user-facing function, it's not clear if this is the best approach. For example, as a user, I wonder why we don't include the space occupied by the solid object when the cell is in the immersed _boundary_, but we do include it fully when the cell is completely inside/below the immersed boundary? In other words, why don't we do:. 1. `zspacings(ibm_grid.underlying_grid)` if `z` is above the immersed boundary; 2. `zspacing(ibm_grid)` if the grid is at the immersed boundary (i.e. if the cell is partially wet, partially immersed); 3. zero. ?. I think this latter option is more consistent (i.e. a solid _never_ counts as ""wet space"") and it makes stuff like offline integrals easier (since `sum(quantity * Δz) / sum(Δz)` will return the correct integral (ignoring x and y)). This is also more in line with the `xgcm` (also SGRID I think) conventions that I'm trying to implement in https://github.com/CliMA/Oceananigans.jl/pull/2652. I'm proposing the name `active_zspacing()` there:. https://github.com/CliMA/Oceananigans.jl/blob/b8b80598fb7250495f0d1925bfb406e15b3305b2/src/Grids/grid_utils.jl#L482-L496. (The main difference there is that the space _outside_ the domain (i.e. halos) al",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636853738:844,clear,clear,844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636853738,1,['clear'],['clear']
Usability,"My two cents. Both the f-plane and beta-plane approximations approximate the Coriolis pseudo-force from a spherical coordiante, using latitude \varphi, to a planar geometry using typicallay y and z. Since they are both approximations into a plane (which could be tilted as this PR is trying to do) how about `ConstantPlanarCoriolis` for `f-plane` and `LinearPlanarCoriolis` for `beta-plane`? . In Calculus, these approximations can be thought of as a constant approximation (`f-plane`) or linear approximation (`beta-plane`). Another idea is to call them simply `ConstantCoriolis` and `LinearCoriois`. . I agree that `Grid` is not really relevant since we always use a grid. Also, `Rectilinear` does not seem as descriptive as",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679066:555,simpl,simply,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679066,1,['simpl'],['simply']
Usability,"My understanding is that you can write `convert_arguments` methods and then all the different plot types just work, for example (obviously not what you'd want in a finished extension but just as a simple example):; ```julia; using CairoMakie . import MakieCore: convert_arguments. convert_arguments(P::Type{<:AbstractPlot}, f::Field) = convert_arguments(P, xnodes(f), ynodes(f), interior(f, :, :, 1)). fig = Figure(); ax = Axis(fig[1, 1]); heatmap!(ax, c); ```; correctly plots the bottom level of a field `c` and puts the `x` and `y` axes in. I think you can pass other arguments too like:; ```julia; convert_arguments(P::Type{<:AbstractPlot}, f::Field, indices = (:, :, 1)) = convert_arguments(P, xnodes(f)[indices[1]], ynodes(f)[indices[2]], interior(f, indices...)); heatmap!(ax, c, (1:10, :, 1)); ```. so you could deal with slicing up 3D fields that way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2272112363:197,simpl,simple,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2272112363,1,['simpl'],['simple']
Usability,"N0X3NvbHZlcnMuamw=) | | |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [test/test\_grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2dyaWRzLmps) | | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...ence\_tests/ConvergenceTests/OneDimensionalUtils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxVdGlscy5qbA==) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=footer). Last update [d80be8c...a0ca748](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/979?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574:3252,learn,learn,3252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/979#issuecomment-699227574,1,['learn'],['learn']
Usability,"NaNs often occur either because the time step is too small, or because the problem being posed is too extreme or not physical (such that a reasonable and stable time step cannot be found). One issue is that the use of `ValueBoundaryCondition` is incorrect here:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)); ```. You are trying to specify an impenetrable boundary condition on the vertical velocity, which requires `NormalFlowBoundaryCondition`:. ```julia; w_bcs = WVelocityBoundaryConditions(grid, top = NormalFlowBoundaryCondition(0.0), bottom=NormalFlowBoundaryCondition(0.0)); ```. this is also the default for a grid with `topology(grid) = (Periodic, Periodic, Bounded)`, so there's no need to specify it explicitly. In other words, try changing . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)); ```. to . ```julia; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ```. in your constructor for `IncompressibleModel`. A good approach for developing a complex simulation is to start with something simple (or something that worked previously) and modify the script incrementally (slowly!), re-running and re-testing the script after each significant change. For this is useful to run either a two-dimensional version of the problem or a very low resolution simulation. I also suggest adding some lines at the bottom of your script to plot the solution so you can visually inspect it after a run. Your setup looks like a laboratory-scale simulation of convection. I think starting with uniform cooling (rather than spatially varying), omitting the effect of salinity, and using an `IsotropicDiffusivity` in two-dimensions (rather than starting out in three dimensions) might be a good path forward for working and building up your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056:1106,simpl,simple,1106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432#issuecomment-791953056,1,['simpl'],['simple']
Usability,"Nice!. I was actually going to advocate for adding such a utility because I've found myself running a few tests where the time steps are likely to be diffusion limited:; 1. possibly stratified Couette flow sometimes,; 2. the Pearson vortex test from PR #336,; 3. more recently the [forced flow test](https://github.com/climate-machine/Oceananigans.jl/blob/5355044deae3120134b55cc20f6e38f637eea6a5/test/verification/forced_flow.jl) from (Brown, Cortez, & Minion, 2000) that I'm using to test whether our operator-splitting method is second-order accurate in both velocity and pressure. For geophysical flows, the time step will almost always be limited by advection, but there seem to be many other flows where the time step will be limited by diffusion. So if we want a package that is usable for not just geophysical flows, it would be nice to have adaptive time stepping that works with both advective and diffusive CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951:786,usab,usable,786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951,1,['usab'],['usable']
Usability,"Nice, thanks!. I'm pretty surprised that `ab2_step_field!` dominates the cost. `ab2_step_field!` is this simple function:. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/src/TimeSteppers/quasi_adams_bashforth_2.jl#L121. which seems much cheaper than something like `calculate_Gu!`. What's going on?. I'm also noticing that function is a bit sketchy because it uses the type of `χ` to convert `1.5` and `0.5`. This is fine if `χ` is a floating point number, but not otherwise... it should probably use `eltype(U)`. . How did you run the profiler? Does it make sense to add a new `profile` directory to the source code (or maybe just add something to `benchmark/`)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070:105,simpl,simple,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070,1,['simpl'],['simple']
Usability,No need to worry about CUDA package errors anymore!. https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366#issuecomment-524361260:111,simpl,simplified-package-loading,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366#issuecomment-524361260,1,['simpl'],['simplified-package-loading']
Usability,Not clear to me what this set of changes to the grid in latest commit 0819e08f0fdbb88030215c2c3688ea9b0b4e063e is added to this PR which was supposed to just; fix horizontal discretisation of Coriolis term (with zero change/interaction with grid specification). Why not; in a separate PR ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-493537961:4,clear,clear,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/215#issuecomment-493537961,1,['clear'],['clear']
Usability,"Not even sure we need a boolean for switching it off. I think it makes sense to simply implement this. If its important to some user that the time step isn't changed, they will be using a constant time-step anyways and can calculate the `frequency` rather than using an interval. Eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-586557018:80,simpl,simply,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-586557018,1,['simpl'],['simply']
Usability,Note that the divergence is calculated by dividing by area:. https://github.com/CliMA/Oceananigans.jl/blob/98bcdde7ae679583ea88474ec0909469abccfc90/src/Operators/divergence_operators.jl#L35-L37. So this change could be more simply explained as reconstructing `δx(Δy * u) + δy(Δx * v)` (it may be silly to divide by A then multiply by A).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1528951908:224,simpl,simply,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1528951908,1,['simpl'],['simply']
Usability,"Note that the implementation in `IncompressibleModel` is really experimental and doesn't enforce boundary conditions or work for tracers. I think we might be able to improve on what's done for `IncompressibleModel`. A simple implementation would just mask the immersed boundary in `update_state!`. We have to work a bit harder to make sure that boundary conditions are satisfied, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605:218,simpl,simple,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-797812605,1,['simpl'],['simple']
Usability,"Note there is already substepping implemented for CATKEVerticalDiffusivity and TKEDissipationVerticalDiffusivity. What are the challenges? For the closures this feature was relatively straightforward to implement. But this PR seems quite large. For many reasons it is often better to open the PR _first_ (better yet, an issue that defines the problem, so we can discuss designs), rather than at a late stage where feedback is difficult to manifest. Also, rather than supporting this generally for all time-steppers, I would argue that the correct approach is to implement this for just one model and one time-stepper. Once the proof of concept is well developed and tested, it can be applied more broadly in a separate PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2450582918:414,feedback,feedback,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2450582918,1,['feedback'],['feedback']
Usability,"Nothing has changed over at CI, so this looks like a legitimate issue?. That said, you are [using](https://github.com/climate-machine/Oceananigans.jl/blob/master/.gitlab-ci.yml) the `v4` templates, which do `pkg""develop""` and as a result ignore the Manifest. Maybe that's related? You might want to use the new `v5` templates, which do `pkg""instantiate""` (respecting the manifest) with a simpler CI organization (single `test.yml`, include file with extensible templates instead of predefined jobs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-536881361:388,simpl,simpler,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-536881361,1,['simpl'],['simpler']
Usability,"OK, I think I understand the issue mentioned here but the terminology intrinsic and extrinsic is not self-explanatory (for my intuition at least). . I'm not trying to argue against the names, I just want to understand exactly what's been discussed. I think something in this spirit @siddharthabishnu bumped into in trying to set initial conditions or surface forcing on a ConformalCubedSphereGrid..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2185341516:126,intuit,intuition,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2185341516,1,['intuit'],['intuition']
Usability,"OK, I'm merging! We can always undo. I think it's a step fwd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1619192341:31,undo,undo,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1619192341,1,['undo'],['undo']
Usability,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231:468,simpl,simply,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231,1,['simpl'],['simply']
Usability,"OK, now we should resume working on this ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1482207594:18,resume,resume,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1482207594,1,['resume'],['resume']
Usability,"Oceananigans.jl/pull/336?src=pr&el=h1) Report; > Merging [#336](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a26da9c932f562241fd96d97bfcc16f3c033e72a?src=pr&el=desc) will **increase** coverage by `0.51%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #336 +/- ##; ==========================================; + Coverage 61.06% 61.57% +0.51% ; ==========================================; Files 22 22 ; Lines 1243 1231 -12 ; ==========================================; - Hits 759 758 -1 ; + Misses 484 473 -11; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `9.67% <0%> (-3.23%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.41% <0%> (+4.42%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=footer). Last update [a26da9c...a2cabed](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/336?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876039:1615,learn,learn,1615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336#issuecomment-518876039,1,['learn'],['learn']
Usability,"Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <0%> (-57.62%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `39.34% <0%> (-19.56%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `46.83% <0%> (-15.19%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.19% <0%> (-1.94%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `62.5% <0%> (-1.79%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `76.06% <0%> (-0.54%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86% <0%> (-0.28%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=footer). Last update [af5d513...e113346](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/388?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388#issuecomment-526922577:2874,learn,learn,2874,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388#issuecomment-526922577,1,['learn'],['learn']
Usability,"Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.80% <100.00%> (+2.91%)` | :arrow_up: |; | [src/TurbulenceClosures/diffusion\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <100.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92aXNjb3VzX2Rpc3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100.00% <100.00%> (ø)` | |; | ... and [39 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=footer). Last update [e808a82...b56c813](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/999?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403:3464,learn,learn,3464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999#issuecomment-700403403,1,['learn'],['learn']
Usability,Oh I see. This was not at all clear to me from your previous question. I thought you were asking whether the new versions dropped support to CuArrays and therefore explain why tests were failing!. Let me get back on your question now that I understand!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613661175:30,clear,clear,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613661175,1,['clear'],['clear']
Usability,"Oh interesting there is a difference between `Integral` and `Average`. Another thing to try is something like `Reduction(sum!, c, dims=1)` which is even simpler...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168694876:153,simpl,simpler,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168694876,1,['simpl'],['simpler']
Usability,"Oh yeah that should work. I'll wait and see what your implementation looks like then. I agree that something like `set_surface_temperature!(model, 300)` looks much more user-friendly and portable!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399:169,user-friendly,user-friendly,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399,1,['user-friendly'],['user-friendly']
Usability,"Ok I did a bit of investigation and found the following (script pasted below):. * Using the default `maxiter = prod(size(grid))` allows the solver to go unstable at the first iteration; * With `maxiter=50` or greater, I get instability with `FlatExtrapolationOpenBoundaryCondition` eventually. However with `maxiter=10` the simulation completes. It's also stable with `maxiter=1, 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridF",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:958,simpl,simply,958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,1,['simpl'],['simply']
Usability,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:241,clear,clear,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). We then have the mapping:. * `Scan` to `Accumulation`; * `Accumulation` to `Cumulation` (but we only really need the cumulative sum / integral anyways probably, so this need not be user facing anyways); * `Accumulating` to `Cumulating`. Honestly discussing this, the phrase ""cumulative sum"" is not the most clear, either. But, history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538:586,clear,clear,586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104552538,1,['clear'],['clear']
Usability,"Ok here's something simple:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Here's what I've done:. * Run this on fresh clone of `main`. This returns. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 20.460 s (144483404 allocations: 94.43 GiB); ```. * Restrict compat on KernelAbstractions to 0.7.2 and CUDAKernels to 0.3.3. This returns:. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 2.202 s (118604 allocations: 52.20 MiB); ```. I'm running on a single core, Mac M1. Here the performance loss is just 10x so I'll change the somewhat dramatic title of this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842:20,simpl,simple,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842,1,['simpl'],['simple']
Usability,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387:424,clear,clear,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387,1,['clear'],['clear']
Usability,"Ok, I agree that is a bug if that's how it is implemented. I was responding to this:. > The current implementation of ImmersedBondaryCondition has opposite conventions as FieldBoundaryConditions. which is also true. But I guess there's a miscommunication because it's not clear what ""conventions"" means.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582815705:272,clear,clear,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1582815705,1,['clear'],['clear']
Usability,"Ok, a couple of important notes about the `apply_bcs!` function:. 1. The function takes a ""diffusivity"" as input. Thus, it is not necessary to have different functions for viscosity and diffusivity. Functionally viscosity *is* diffusivity --- for momentum. See this line:. https://github.com/climate-machine/Oceananigans.jl/blob/4c627e89efe5c268c26d458059bf1904995ebd5b/src/time_steppers.jl#L307. where the viscosity `𝜈` is passed as an input to `apply_bcs`. On this line:. https://github.com/climate-machine/Oceananigans.jl/blob/4c627e89efe5c268c26d458059bf1904995ebd5b/src/time_steppers.jl#L296. `𝜈` is determined to be `cfg.𝜈v`. This will change in the future when we have closures that can modify the viscosity/diffusivity (and hopefully the default viscosity and diffusivity will be made isotropic and defined as fluid 'constants', like gravitational acceleration). We also will need to modify `apply_bcs!` when the viscosity at top and bottom is different. 2. To add a new boundary condition (in the current set-up with periodic lateral boundaries), one needs to define `apply_z_top_bc!` and `apply_z_bottom_bc` for that boundary condition. See this line and below in `boundary_conditions.jl`:. https://github.com/climate-machine/Oceananigans.jl/blob/4c627e89efe5c268c26d458059bf1904995ebd5b/src/boundary_conditions.jl#L155. Notice that `ϕ` is an arbitrary field, and `κ` is the diffusivity/viscosity for `ϕ`. Let me know if this makes sense. If it doesn't, we should think about ways we can simplify the boundary condition implementation (and I am happy to implement `Value` boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/166#issuecomment-481648278:1498,simpl,simplify,1498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/166#issuecomment-481648278,1,['simpl'],['simplify']
Usability,"Ok, can you reproduce the error by trying to loop over a simple kernel that returns `nothing` using `KernelAbstractions`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878:57,simpl,simple,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624165878,1,['simpl'],['simple']
Usability,"Ok, here's a multi-pronged strategy to address this:. 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?; 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247:1124,simpl,simply,1124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103328247,1,['simpl'],['simply']
Usability,"Ok, multiplying by `h` then it would seem the possible models are. ```; 1. ∇ ⋅ (ν h ∇u); 2. ∇ ⋅ (ν ∇hu); 3. h ∇ ⋅ (ν ∇u); ```. ? These all have the same dimensions but different properties. I think 3. is what we get if we derive the closure from horizontal dissipation in Navier-Stokes. 2. is simple because it requires no code changes (ie it's the ordinary viscosity, except with `u -> hu`). 1. is supported by the theoretical arguments you listed. Also, I agree that this is first and foremost a _closure_, so ""derivability from Navier-Stokes"" is not paramount.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089686499:293,simpl,simple,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089686499,1,['simpl'],['simple']
Usability,"Ok, now that this is clear, I clone and modify the PR #3793.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393108337:21,clear,clear,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393108337,1,['clear'],['clear']
Usability,"Ok, thank you. That papers certainly clears up how to go from the n-point FFT to the DCT. To be specific, the permutation and forward 'factors' that are used for the GPU solver are defined in equation (16) and via `W^k_{4N}` in equation (4) and (19a)... ?. As for #102, I simply do not understand at first glance how to get from the eigentransform formulas in Schumann and Sweet (which involve `sine` and `cosine`) to the FFT (which involves a complex exponential). Am I missing something obvious? I feel that some non-trivial algebra is committed from every reference I have seen on this topic. The PoisFFT paper also makes the claim that this is possible but does not offer any justification or clarification.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496305412:37,clear,clears,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/240#issuecomment-496305412,2,"['clear', 'simpl']","['clears', 'simply']"
Usability,"Ok, this function:. https://github.com/climate-machine/Oceananigans.jl/blob/4ad7e93f6ea9e715ca89ae2c1129f258430df656/src/Grids/grid_utils.jl#L97. Makes clear that `ΔzF` is the delta between faces. Let's document this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597393469:152,clear,clear,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597393469,1,['clear'],['clear']
Usability,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842:107,simpl,simplify,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842,1,['simpl'],['simplify']
Usability,"Okay @johncmarshall54. Changes made. Unfortunately I implemented that my changes on my own fork, and it seems I can't push to this PR without @navidcy 's permission, I believe... ? (still learning git...). I suggest we merge this PR, and then I will open another PR for the additional docs changes that I have made. Does that sound good @ali-ramadhan ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470543835:188,learn,learning,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470543835,1,['learn'],['learning']
Usability,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823:606,simpl,simply,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823,1,['simpl'],['simply']
Usability,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712:932,clear,clearly,932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712,1,['clear'],['clearly']
Usability,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1396,simpl,simplifying,1396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416,2,['simpl'],"['simplifying', 'simplying']"
Usability,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:155,simpl,simple,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,1,['simpl'],['simple']
Usability,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:485,clear,clear,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793,1,['clear'],['clear']
Usability,"Okay, thank you. It seems that our choices are actually more restricted than simply ensuring that `Tx*Ty*Tz*Bx*By*Bz == Nx*Ny*Nz`. It appears to me that, due to [assumptions about indexing in the kernels](https://github.com/climate-machine/Oceananigans.jl/blob/b746a0bce63642a8beb9e6771b4b43cd17368ba6/src/time_steppers.jl#L109), we have to ensure that `Bi*Ti = Ni` along each dimension `i`. In addition, the kernels will have to be modified if we wish to introduce `Tz`. Is this correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496529444:77,simpl,simply,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496529444,1,['simpl'],['simply']
Usability,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:800,feedback,feedback,800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464,1,['feedback'],['feedback']
Usability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:563,feedback,feedback,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,1,['feedback'],['feedback']
Usability,One example that reproduced this result was `benchmarks_shallow_water_mode.jl` but incompressible model also had the same issue. I think that @ali-ramadhan 's suggestion is a simple fix and our current and future windows users will appreciate this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1672#issuecomment-844273400:175,simpl,simple,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1672#issuecomment-844273400,1,['simpl'],['simple']
Usability,"One simple solution would be to host the GitHub action on the `OceananigansDocumentation` and have it so that it runs on a schedule (e.g., weekly).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712:4,simpl,simple,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308611712,1,['simpl'],['simple']
Usability,"Our earlier [tests](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295354459) with a simple sine function indicate that when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, the results after the checkpoint seem reasonable. However, I’ve noticed this isn't the case with the following parameter settings, for instance:. ```julia; Δt = .01 # timestep; T1 = 6Δt # first simulation stop time; T2 = 2T1 # second simulation stop time; window_nΔt = 2 # window interval: 2Δt; interval_nΔt = 2 # time average saving interval: 2Δt; stride = 1; ```; The averaged values are clearly off after the checkpoint (t>6Δt):; <img width=""587"" alt=""image"" src=""https://github.com/user-attachments/assets/24c0238d-3723-435d-bca2-4b4a2be83e71"">. This issue does not only occur in the existing MWE (decaying function); it also occurs in our [MWE](https://github.com/liuchihl/Oceananigans.jl/pull/1#issuecomment-2295343588) using the exact same parameters mentioned above. The dashed curve and steps indicate `TimeInterval` and `AveragedTimeInterval` outputs, respectively, shown in the figure below. It is unclear to me as to why spurious zero appears in this case.; <img width=""892"" alt=""image"" src=""https://github.com/user-attachments/assets/5e78add8-7b29-45f3-8123-156cf6ae38d3"">. The point of these tests is to show that even when the checkpoint interval is an integer multiple of the `AveragedTimeInterval`, issues can still arise. . Here is the MWE with the decaying function for reference: ; ```julia; using Oceananigans; using Plots; using NCDatasets; using Test; if isfile(""single_decay_windowed_time_average_test.nc""); rm(""single_decay_windowed_time_average_test.nc""); end; run(`sh -c ""rm test_iteration*.jld2""`). function test_simulation(stop_time, Δt, window_nΔt, interval_nΔt, stride, overwrite). arch = CPU(); topo = (Periodic, Periodic, Periodic); domain = (x=(0, 1), y=(0, 1), z=(0, 1)); grid = RectilinearGrid(arch, topology=topo, size=(4, 4, 4); domain...). λ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629:103,simpl,simple,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2380652629,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947:337,clear,clearly,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947,1,['clear'],['clearly']
Usability,Perhaps I should know this but is there a simple summary of why supporting reductions across the 4th dimension are hard?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322240720:42,simpl,simple,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322240720,1,['simpl'],['simple']
Usability,"Perhaps this simply means that we should keep the name `taper_factor_ccc`, but redefine its implementation to be more stable along the lines you're suggesting?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185957960:13,simpl,simply,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185957960,1,['simpl'],['simply']
Usability,"Perhaps we don't have this, but can we rotate a `LatitudeLongitudeGrid` by a certain angle, and then test that the vectors are rotated exactly by that angle? This would provide a simple deterministic test. This could work for a very small grid on the equator, for example...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3744#issuecomment-2315768430:179,simpl,simple,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744#issuecomment-2315768430,1,['simpl'],['simple']
Usability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:244,simpl,simplified,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,2,['simpl'],"['simpler', 'simplified']"
Usability,"Personally I think it makes sense to start simple from an API perspective, and add convenience when its warranted",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1464621131:43,simpl,simple,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1464621131,1,['simpl'],['simple']
Usability,"Please feel free to change the filenames. Julia used to recommend somewhere in the documentation that one should only use underscores when necessary (and many of the core julia functions seem reflect this style). I guess I felt that `timesteppers` is clear and readable. I'm fine if you change it though. It would be more consistent with the rest of the code anyways (for example, the function `time_step!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/216#issuecomment-491665335:251,clear,clear,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/216#issuecomment-491665335,1,['clear'],['clear']
Usability,Please go ahead @glwagner and get this started. I am happy to help where I can but clearly you understand what needs to be done here better than I do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882739134:83,clear,clearly,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882739134,1,['clear'],['clearly']
Usability,"Possibly you want to invent a new function (or keyword argument) for this? Something like. ```julia; set!(model, checkpoint_file; with_halos=false); ```. Hopefully this can be done simply. I was going to suggest using `FieldTimeSeries`. But then I realized that can't be done with `Checkpointer`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401:181,simpl,simply,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659126401,1,['simpl'],['simply']
Usability,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:758,simpl,simply,758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965,1,['simpl'],['simply']
Usability,"Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`. The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160:38,simpl,simply,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758655160,1,['simpl'],['simply']
Usability,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956:112,simpl,simply,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956,1,['simpl'],['simply']
Usability,"Quite concerning that some of the convergence tests do not pass on the GPU... This is probably due to #1170 since the simpler convergence tests that do not rely on a pressure solver seem to pass (also the fact that it passes forced flow free slip with doubly periodic (x, z) but not with a wall-bounded dimension (x, y)). Hmmm, but the Taylor-Green one is doubly periodic... ![image](https://user-images.githubusercontent.com/20099589/100450333-76634b80-3083-11eb-92ea-0d645f564aab.png). ![image](https://user-images.githubusercontent.com/20099589/100450382-8c710c00-3083-11eb-801e-1ed16e5b22a9.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-734821927:118,simpl,simpler,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223#issuecomment-734821927,1,['simpl'],['simpler']
Usability,"R $$. where $\delta$ is a constant. I was a bit confused about this form until I understood that $e^T \phi = N \bar \phi$, so that in continuous from this would read. $$ \Bigg ( \underbrace{\nabla^2 + \frac{\delta N}{V} \int \mathrm{d} V}_{\tilde L} \Bigg ) \phi = \nabla^2 \phi + \delta N \bar \phi = R $$. where $\tilde L$ is the ""regularized Laplacian operator"". $\tilde L$ is regularized because taking the mean is well-defined:. $$ \overline{\tilde L \phi} = \delta N \bar \phi = \bar R $$. unlike the unregularized Poisson equation when $\bar R \ne 0$. In terms of implementation, this is simply implemented by defining a new linear operator that adds the additional term, eg. https://github.com/CliMA/Oceananigans.jl/blob/4f6ffd71933fc3dd55df8a6093fd52d420b06b1d/src/Solvers/conjugate_gradient_poisson_solver.jl#L47-L51. Here are a few more loose ends:. 1. I am wondering whether this perturbation or shifting of the Laplacian is independent of the preconditioner. For example, the FFT-based preconditioner _also_ applies a gauge condition:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Solvers/fft_based_poisson_solver.jl#L109-L115. Therefore it is unclear to me whether additionally solving the regularized Poisson equation is necessary or valid when we already have a linear constraint embedded in the preconditioner. Also, note that the constrained implemented in this PR is simply a shifting of the constraint embedded in the FFT-based preconditioner. While the FFT preconditioner zeros out the mean pressure over the whole domain, the constraint in this PR takes into account the immersed boundary when zeroing the mean pressure. > I just don't understand why we will find the same solution because CG should return one solution among an infinity of solution (before the shift). The ""infinity of solutions"" differ only in their mean value right? Or in other words, in the arbitrary value $e^T \phi$. I am maybe being too loose with language.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665:2802,simpl,simply,2802,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665,1,['simpl'],['simply']
Usability,"Rather than working in the complicated setting of a multiregion grid, it might be better to have a simpler context to look at the issue. Here's an MWE:. ```julia; julia> grid = RectilinearGrid(size=(3, 3, 3), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); set!(c, (x, y, z) -> randn()); 3×3×3 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 3×3×3 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 9×9×9 OffsetArray(::Array{Float64, 3}, -2:6, -2:6, -2:6) with eltype Float64 with indices -2:6×-2:6×-2:6; └── max=2.47269, min=-2.49748, mean=-0.0773234. julia> a = rand(3, 3, 3); b = rand(3, 3, 3);; ```. Now we can illustrate how `Field` does not behave like `Array`. This works:. ```julia; julia> view(a, :, 1, 1) .= view(b, 1, :, 1); 3-element view(::Array{Float64, 3}, :, 1, 1) with eltype Float64:; 0.23703924592859704; 0.02820508483630202; 0.7546236569353038; ```. but this does not:. ```julia; julia> view(a, :, 1, 1) .= view(c, 1, :, 1); ```. and instead throws `DimensionMismatch`. Does that boil down the issue @siddharthabishnu ?. Actually, it is curious that for some reason things do work out correctly if setting to a `Field`:. ```julia; julia> d = CenterField(grid);. julia> view(d, :, 1, 1) .= view(c, 1, :, 1);. julia> interior(d, :, 1, 1); 3-element view(::Array{Float64, 3}, 4:6, 4, 4) with eltype Float64:; 0.06779701769558852; -1.1932513091536738; -1.1239966299690682. julia> interior(c, 1, :, 1); 3-element view(::Array{Float64, 3}, 4, 4:6, 4) with eltype Float64:; 0.06779701769558852; -0.5935171905074843; 1.399692772040493; ```. No idea why that works...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718:99,simpl,simpler,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038161718,1,['simpl'],['simpler']
Usability,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037:185,simpl,simple,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037,1,['simpl'],['simple']
Usability,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572), can anyone help me understand some things?. The following MWE works:. ```julia; grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); model = NonhydrostaticModel(grid = grid). simulation = Simulation(model, Δt=1, stop_iteration=10,); wizard = TimeStepWizard(max_change=1.02, cfl=0.8); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4)); ```. And I can confirm that Δt is indeed changed by the end of the simulation. However, when I issue `wizard.cell_advection_timescale(model)` I get error above. I also get errors when using `wizard.cell_advection_timescale(model.grid, model.velocities)`. . So I'm clearly missing something here. It seems to me the answer includes `construct_regionally` or `@apply_regionally`, but I couldn't figure it out from the available docs and code. PS: for now I'm using only one CPU core to run things, but still passing two devices to the `MultiRegionGrid` constructor, in case that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304897071:850,clear,clearly,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304897071,1,['clear'],['clearly']
Usability,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:72,simpl,simpler,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965,1,['simpl'],['simpler']
Usability,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233:327,clear,clear,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233,1,['clear'],['clear']
Usability,"Reviving this ancient issue to propose we make the `advection_scheme` a property of the field as we may want different advection schemes for different tracers, or different schemes for momentum and tracers. Storing all the advection schemes in some `model.advection_schemes` will probably be messy and bring us back to a situation like PR #631. Agreed that advection schemes should be simple types that we dispatch on. @glwagner What do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/77#issuecomment-596843744:385,simpl,simple,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/77#issuecomment-596843744,1,['simpl'],['simple']
Usability,"RfdXRpbHMuamw=) | `82.50% <30.00%> (-4.78%)` | :arrow_down: |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `73.68% <81.25%> (-2.79%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (ø)` | |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (ø)` | |; | [src/Diagnostics/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL3dpbmRvd2VkX3RpbWVfYXZlcmFnZS5qbA==) | `52.94% <0.00%> (-31.44%)` | :arrow_down: |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `60.00% <0.00%> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `92.30% <0.00%> (+0.78%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=footer). Last update [0f33c1d...ed03e78](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/929?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/929#issuecomment-690596871:3070,learn,learn,3070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/929#issuecomment-690596871,1,['learn'],['learn']
Usability,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354:344,simpl,simple,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354,1,['simpl'],['simple']
Usability,"Right now if you specify `prefix = cool_data` then you get a file `cool_data.jld2` before splitting. But then when you reach `max_filesize` you get `cool_data_part1.jld2`, `cool_data_part2.jld2`, etc. If we use filename with arbitrary extensions, then we need to ""infer"" the extension. We can do that by looking for the first `.` that appears in the string. But life is a bit simpler if we can just ask for the `prefix` / `name`, rather than name + extension.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1030085562:376,simpl,simpler,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884#issuecomment-1030085562,1,['simpl'],['simpler']
Usability,"Right now with this current function for the faces the grid spacing looks like this:. ![Screenshot from 2021-06-23 16-53-31](https://user-images.githubusercontent.com/13205162/123182158-b33dc800-d443-11eb-82d6-1aac1ee34527.png). which means that the grid spacing is approximately constant at the bottom and changes rapidly at the top. I think it would be good to flip that and have Δz be approximately constant (but finer) at the top and change more rapidly at the bottom, no? I can't come up with a simple hyperbolic equation to do that though. Suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867233421:500,simpl,simple,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867233421,1,['simpl'],['simple']
Usability,"Right, and I understand now there's no free lunch on this subject!. I think there is some API design that will need to be done to make specifying boundary conditions simple once the model is completely statically typed (its complicated because there are potentially 30 boundary conditions that can be set on 5 3D fields), but this is future work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/261#issuecomment-497969724:166,simpl,simple,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/261#issuecomment-497969724,1,['simpl'],['simple']
Usability,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:200,intuit,intuitive,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343,1,['intuit'],['intuitive']
Usability,"Right. It serves the same purpose as the `OutputWriter` abstract type. It's dispatched on for functions like `run_diagnostic` and `time_to_run` in PR #352. https://github.com/climate-machine/Oceananigans.jl/blob/908ae4d23ce3e472d03fd69766edc457301df681/src/diagnostics.jl#L6. We did agree to refactor the diagnostics abstraction anyways, so maybe the need for an abstract `Diagnostics` type will disappear. I might hold off on this issue until it's clearer what `diagnostics.jl` will look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721:449,clear,clearer,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721,1,['clear'],['clearer']
Usability,"Rigid lid is actually just a short step from having an implicit free surface (and looks like we are about to have a direct solver for simple domains ala #1869...) --- the math is identical for the implicit solve, with a few terms zero'd out (eg, take the limit of an infinitely long time step). This implies too that models with an implicit free surface that take very long time steps compared to the gravity wave time-scale (most large scale models...) are effectively quite close mathematically to the rigid lid case (notwithstanding effects of runoff, precipitation, and evaporation). It seems an _explicit_ rigid lid formulation is not very practically useful, mostly because iterative solves take longer so rigid lid models in complex domains where there's no direct solve end up being slower. I'm not sure if there are any advantages re: tracer conservation. The story might get more interesting with generalized vertical coordinates, too. If anyone is keen to run problems with rigid lids, we can implement it and test it without too much trouble. MITgcm docs explain this well: https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#implicit-time-stepping-backward-method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882560379:134,simpl,simple,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882560379,1,['simpl'],['simple']
Usability,See #315. I've implemented simpler constructors for `HorizontallyPeriodicBCs` and `ChannelBCs`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515210124:27,simpl,simpler,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515210124,1,['simpl'],['simpler']
Usability,Seeing this I wonder two things:. 1. We could always return `CPU` or `GPU` from `architecture` and then define a different function that would return `Distributed` for a distributed simulation. Probably we shouldn't do this because we want `architecture(grid)` to correspond to `grid.architecture`. But its a thought. 2. `child_architecture` seems weird and not super intuitive. Maybe `device_architecture` or something would make more sense?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2294417925:368,intuit,intuitive,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2294417925,1,['intuit'],['intuitive']
Usability,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:453,simpl,simpler,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059,1,['simpl'],['simpler']
Usability,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750:229,simpl,simpler,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750,1,['simpl'],['simpler']
Usability,"Simple example why this doesn't make sense: `immersed_peripheral_node` is. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/ImmersedBoundaries/ImmersedBoundaries.jl#L217-L218. So, for example, if the entire bottom of a grid is immersed, then it will be _included_ in the reduction --- because those nodes _are_ on the periphery of the underlying grid, so. ```julia; !peripheral_node(i, j, k, ibg.underlying_grid, LX, LY, LZ); ```. is `false`. Including the bottom row of cells in the reduction makes no sense because these nodes are far beneath the immersed boundary. As a quick fix we could add another condition that also ignores `inactive_node`. But I'd also like to understand why we don't simply ignore all peripheral_nodes...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3064#issuecomment-1506411904:736,simpl,simply,736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3064#issuecomment-1506411904,1,['simpl'],['simply']
Usability,"Simulation API is almost ready. Comments on some of the points above:; 3. I made `stop criteria` an array so you can push/append extra stop criteria as needed.; 4. Out of scope for this PR.; 6. Went all out and completely removed `time_step!` for multiple time steps. Only the single step version remains. Major breaking changes:; 1. Diagnostics and output writers are now part of `Simulation`, not `Model`.; 2. `time_step!` takes a single time step. For multiple time steps, use a loop or a `Simulation`. Still need to:; 1. Write some simple `Simulation` units tests although it's already used by a lot of tests already.; 1. Update examples.; 2. Update model setup documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-586623011:536,simpl,simple,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-586623011,1,['simpl'],['simple']
Usability,"Since `[2]` is resolved at compile time and `2` is known I believe this can get compiled away, ie the result will simply be evaluating the second component of tuple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516999602:114,simpl,simply,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516999602,1,['simpl'],['simply']
Usability,"Since there are only three cases it's probably simple to have `Connected`, `LeftConnected` and `RightConnected`. But another possibility is something like. ```julia; struct Connected{Side} end; ```. so theres `Connected{Left}`, `Connected{Both}`, `Connected{Right}` (or something)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-819600334:47,simpl,simple,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1582#issuecomment-819600334,1,['simpl'],['simple']
Usability,"Slow down of 10% when introducing `exp` could make sense. > With const rate=1/10 and DiscreteForcing things are as fast as with no forcing. Okay, that makes sense. > So this seems to be a CPU issue. So the problem is that `ContinuousForcing` is rather slow on the CPU. That is a bit annoying. Kind of like how WENO is really slow on the CPU for unknown reasons. At least we have a workaround with `DiscreteForcing`... > Would a MWE help here?. I think what would help the most is a simple benchmarking script that compares identical forcing function implementations with `ContinuousForcing` and `DiscreteForcing` to no forcing. I think we only need one forcing function, and it's probably best if its simple (eg `- p.mu * model_fields.u[i, j, k]`) and doesn't involve complicated functions like `exp`. Since it's only a CPU issue I think it's not the highest priority though (it might not be something we can easily solve either...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875762070:482,simpl,simple,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875762070,2,['simpl'],['simple']
Usability,"So I ended up defining `dictify` but wanted to apply it recursively to any of the kwargs that could be non-dicts (`outputs`, `output_attributes`, `global_attributes`, and `dimensions`). Found out that the general case is pretty difficult as lots of things implement `keys` and `outputs` (e.g. strings and arrays to name just two) and relying on `fieldnames` requires you to define an accompanying `fieldvalues` which seemed to require quite a bit of extra logic. So I stuck to the simple one-liner that only does something to named tuples; ```julia; dictify(outputs) = outputs; dictify(outputs::NamedTuple) = Dict(string(k) => dictify(v) for (k, v) in zip(keys(outputs), values(outputs))); ```; because it's a simple solution that works recursively for the most common use case (named tuples instead of dicts).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1139#issuecomment-722409494:481,simpl,simple,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1139#issuecomment-722409494,2,['simpl'],['simple']
Usability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:264,simpl,simple,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,1,['simpl'],['simple']
Usability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:18,simpl,simply,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,2,['simpl'],"['simplest', 'simply']"
Usability,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:129,clear,clear,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['clear'],['clear']
Usability,"Some comments:. 1. We may want to allow users to output in JLD2 in addition to NetCDF. 2. Check out what FourierFlows.jl does:. https://github.com/FourierFlows/FourierFlows.jl/blob/f7a87d4090123fc3c241bed621b64660a6f3596f/src/output.jl#L1. Output is specified by the user as a function that extracts the output from `Model`. This permits completely arbitrary output, including on-line calculations. An added benefit is that it is simple to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475526251:430,simpl,simple,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475526251,1,['simpl'],['simple']
Usability,"Some pretty promising Lagrangian particle tracking benchmarks!. Couple of takeaways (all assuming a model with 128^3 grid points and QAB2 time stepping):; 1. **Low overhead**: You can advect up to ~100,000 particles on the CPU and up to ~10,000,000 particles on a (Titan V) GPU before the model slows down by more than 30%.; 2. **Great on GPUs**: Seems that the GPU is great for advecting millions of particles. You can advect ~100,000,000 particles and your model only slows down by a factor of 4x. In this scenario, the GPU is ~620x faster than a single CPU core.; 3. Calculated using `(t_100000000 - t_0) / 100000000`, advecting a single particle on the CPU takes ~110 ns while on the GPU it only takes ~0.127 ns. This seems a little too good to be true but I'll double check this. I'll start refactoring this PR using @glwagner's and @zhenwu0728's feedback, but I think it would be really great if we can keep this performance. # Benchmarks. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Lagrangian particle tracking benchmarks; ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; │ CPU │ 1000 │ 378.076 ms │ 384.114 ms │ 383.611 ms │ 388.507 ms │ 297.16 KiB │ 1906 │; │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:852,feedback,feedback,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['feedback'],['feedback']
Usability,"Some thoughts:. The first case (`N=100`) doesn't look great but it shows that the MPData schemes do not differ very much whether we have 2 or 5 iteractions, and they are somewhere between 1st and 3rd order upwinding. The second case (`N=200`) looks better and I can't really see any difference between 2 and 5 iterations. The third case (`N=400`) has all the schemes performing well, even first order upwinding. Again we can't differentiate between the two MPData schemes and it's even hard to differentiate between 3rd and 5th order upwinding. I lesson that I learned from here is to use as much spatial resolution as we can as this does much more compared to the number of iterations. . @simone-silvestri : do you think we should do a similar comparison for 2D advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883:561,learn,learned,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883,1,['learn'],['learned']
Usability,"Something I don't quite understand: say that I want to output horizontal averages, and I pre-allocate memory to store the result of these computations on the GPU. How would I then write a function to use with `JLD2OutputWriter`?. I don't understand the implementation and the use of shared memory for this task. Isn't it enough to write a simple kernel that computes something like. ```julia; average[k] += field[i, j, k] / (grid.Nx * grid.Ny); ```. at every horizontal location `i, j`?. Edit: actually, I think it'd be better to write a function that computes an integral, eg. ```julia; integral[k] += field[i, j, k] * A_cell[i, j]; ```. We can then transfer `integral` to the CPU and compute the average there by dividing by the total area of the domain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520506054:339,simpl,simple,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520506054,1,['simpl'],['simple']
Usability,"Something I see that needs to be fixed right away is that the ""mean"" and ""prime"" terms have to be precomputed _outside_ a kernel. For example,. ```julia; @kernel function calculate_pressure_source_term_fft_based_solver_rapid!(rhs, grid, Δt, U★); i, j, k = @index(Global, NTuple); U = Field(Average(U★.u, dims=(1, 2))); V = Field(Average(U★.v, dims=(1, 2))); W = Field(Average(U★.w, dims=(1, 2))); ```. probably won't work. The other issue is that we have to call `compute!` to precompute these fields, which is not being done. Also, just as a matter of approach, I would suggest not changing the source code to do this problem but instead using the solvers directly to compute the solution to this new Poisson problem. That will allow you to more quickly compare the pressure computed by the native algorithm to the ""new"" pressure that is computed offline. The first step towards solving this problem is to show that you can solve Poisson's equation correctly using `FFTBasedPoissonSolver`! (This is the solver that will work for grids that are regularly spaced in all directions.) Once you have code that can solve the Poisson equation for a simple RHS, then I suggest building up the RHS terms that you have piece by piece. When you add a new term to the RHS, plot the term to make sure it looks right. Then solve Poisson's equation with the new term, and make sure the solution looks good. Keep adding terms ensuring that each time you build up the complexity the result is as expected and you don't get NaNs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1930108162:1143,simpl,simple,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1930108162,1,['simpl'],['simple']
Usability,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620:45,clear,clearly,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620,2,"['clear', 'simpl']","['clearly', 'simplifications']"
Usability,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749:152,intuit,intuition,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749,1,['intuit'],['intuition']
Usability,"Something worth discussing is if we want to unit test the operators. I guess maybe not simple stuff like `∂x_faa` but the composing ones like `∂x_caa(i, j, k, grid, F::Function, args...)` might need testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495594948:87,simpl,simple,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495594948,1,['simpl'],['simple']
Usability,Sorry about that. Should I undo the merge and then try again?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839884965:27,undo,undo,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839884965,1,['undo'],['undo']
Usability,"Sorry for not being clear, wil try again with code. Consider the following. ```; grid = RegularRectilinearGrid(size=(4,4), extent=(1,1), topology=(Periodic,Periodic,Flat)); model = ShallowWaterModel(grid=grid, gravitational_acceleration=1); ```. The first line says we are using a `RegularRectilinearGrid` and the second line says we have `Flat` in the vertical. . The three options to compute the vertical grid spacing are the following,. ```; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid) = grid.Δz; @inline ΔzF(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.Δzᵃᵃᶜ[k]; @inline ΔzF(i, j, k, grid::AbstractGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```; It seems like the first and third functions are both options. When I tried it, even though I had `Flat` in the vertical, it used the first and computed the spacing in the vertical to be `0` instead of `1`. This resulted in a lot of `NaNs`. I should say that I am calling it using the following syntax `ΔzF(i,j,k,grid)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804938362:20,clear,clear,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-804938362,1,['clear'],['clear']
Usability,"Sorry for requesting review early then moving things around into files. Operators should be all there. I tried following the Marshall et al. (1997) paper to get the finite volume form correct, but I'm sure I made a few mistakes. One big one is I need to make the distinction between `ΔzC` and `ΔzF`. I can make the docstrings and comments clearer by showing how I arrived at the operators starting from the math. Should help with debugging and clarity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504432540:339,clear,clearer,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-504432540,1,['clear'],['clearer']
Usability,"Sorry for the slow reply. Might be easier to discuss in person, I don't think I did a good job of explaining what I'm doing. I'd be very interested in learning how to enforce this through some sort of pressure correction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-441631191:151,learn,learning,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-441631191,1,['learn'],['learning']
Usability,"Sounds great! I've had a discussion with Greg about this before, and which method you need to implement really depends on the application. ; - The ""penalty function"" boundary was the first type proposed historically, but it is completely inappropriate for unsteady flows and will really mess up a turbulent boundary layer evolution.; - Direct forcing methods and other similar approaches go in and set the value of velocity components inside the immersed solid at each time step to satisfy the velocity boundary conditions before or after the projection step. However, you have to choose between enforcing a divergence free velocity and the BC - you can't have both without modifying the pressure Poisson equation. As long as the body isn't moving, the results tend to be fine. The pressure forces will not be time accurate and so dynamic forces will suffer. ; - For fluid structure interaction problems you really need to get those forces right and therefore must modify the pressure equation. . I've attach a write-up one of my students is working on which lays this out with a few simple examples. Section 3 reviews Immersed Boundary methods and 3.1 has a simple 1D FSI example. . [Mr M Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf](https://github.com/CliMA/Oceananigans.jl/files/5370790/Mr.M.Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163:1084,simpl,simple,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163,2,['simpl'],['simple']
Usability,"Sounds like a good idea to me as well! I suppose it further complicates the handling of boundary conditions (when is it ever simple though?) and fix issues with `Gradient` boundary conditions not being held as reported by @sandreza. But I'm not experienced enough to see the potential future implication/difficulties with this mixed approach, so I'd rely on the wisdom of @jm-c and @christophernhill.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525538318:125,simpl,simple,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-525538318,1,['simpl'],['simple']
Usability,"Sounds like a good idea. I think `setbc!` and `getbc` aren't fully tested so also worth adding some simple tests there. Hmmm, so right now aliases like `top` and `bottom` are defined on coordinate boundary conditions but maybe we want to define them on `FieldBoundaryConditions`?. ```julia; getbc(fbc::FieldBoundaryConditions, ::Val{:south}) = getfield(fbc.y, :left); getbc(fbc::FieldBoundaryConditions, ::Val{:top}) = getfield(fbc.z, :right); ```. So accessing boundary conditions of a field `u` would look like; ```julia; u.boundary_conditions.south # Instead of u.boundary_conditions.y.south; u.boundary_conditions.top # Instead of u.boundary_conditions.z.top; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/637#issuecomment-589875183:100,simpl,simple,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/637#issuecomment-589875183,1,['simpl'],['simple']
Usability,"Suggestions are definitely welcome for streamlining everything!. Note: in dedalus, this problem is handled by allowing users to accumulate parameters into something like `model.parameters` (in dedalus, this is essentially a dict whose keys are accessible by their names to any function/equation defined with a string expression). Having a ""global-like"" variable (like `model.parameters`) is pretty convenient, but also leads to more complicated code. The more democratic callable object strategy is a bit simpler and more modular, but may involve a slightly more complicated API (though I'm not 100% sure about that --- users must decide!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214:505,simpl,simpler,505,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214,1,['simpl'],['simpler']
Usability,"Sure @francispoulin, this was just a placeholder.; I'll add more details and ping you to either chip in or simply have a look...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-846688815:107,simpl,simply,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690#issuecomment-846688815,1,['simpl'],['simply']
Usability,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:500,clear,clear,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,Sure! I was just doing what the test does to reproduce why CI fails... :) Let's simplify the test also!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1560123791:80,simpl,simplify,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1560123791,1,['simpl'],['simplify']
Usability,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870:14,simpl,simple,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870,1,['simpl'],['simple']
Usability,"Sure, that is just how we are doing it now (the difference would be just inserting the rank behind the scenes). @iuryt if you want to have a go at it in this PR, that should be quite simple to implement (the rank is held in the architecture in `arch.local_rank`) and make sure that the the correct partitioning is taken into account (x partitioning vs y partitioning vs x-y). This API ""problem"" does not exhaust the IO issue though. The problem I was referring to is having split files. I still believe that distributed IO is necessary to have a fully functioning distributed code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896032607:183,simpl,simple,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896032607,1,['simpl'],['simple']
Usability,"Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. ### Local topologies. The local grid topology may need",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:1013,simpl,simple,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['simpl'],['simple']
Usability,"Tests all pass but code is a bit messy (especially `plan_transforms.jl`) due to lots of special cases that I'm not yet sure how to simplify so needs some work. Ran new FFT-based Poisson solver benchmarks on Tartarus (Titan V GPUs) and static ocean benchmarks for all topologies on Satori (Tesla V100 GPUs) + regression. Results are below. Will post a followup with some highlights/conclusions. # FFT-based Poisson solver benchmarks. ## Raw numbers. ```; FFT-based Poisson solver benchmarks; ┌───────────────┬─────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 560.466 ms │ 563.145 ms │ 563.074 ms │ 566.700 ms │ 192 bytes │ 4 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 434.408 ms │ 435.974 ms │ 437.003 ms │ 441.246 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 472.312 ms │ 473.340 ms │ 473.620 ms │ 475.649 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 333.460 ms │ 334.702 ms │ 334.998 ms │ 336.918 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 495.012 ms │ 497.853 ms │ 497.462 ms │ 500.181 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 363.169 ms │ 365.104 ms │ 365.891 ms │ 373.893 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 349.305 ms │ 350.431 ms │ 352.641 ms │ 371.861 ms │ 160 bytes │ 2 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 203.109 ms │ 203.653 ms │ 204.025 ms │ 206.834 ms │ 192 bytes │ 4 │; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 7.765 ms │ 16.841 ms │ 15.934 ms │ 16.872 ms │ 84.00 KiB │ 904 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 6.492 ms │ 13.599 ms │ 12.878 ms │ 13.633 ms │ 57.50 KiB │ 651 │; │ GPU │ 192 │ (Bounded, Peri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:131,simpl,simplify,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,1,['simpl'],['simplify']
Usability,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256:193,learn,learn,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256,1,['learn'],['learn']
Usability,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:1014,simpl,simple,1014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,1,['simpl'],['simple']
Usability,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:61,clear,clearly,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,1,['clear'],['clearly']
Usability,"Thank you for your feedback @maleadt! What is CUDAnative compilation? If you mean the precompilation phase when CUDAnative is first loaded, then it's not that as I start timing after all packages are loaded. I thought 6-7 minutes was normal/expected as @vchuravy et al. reported similar GPU compilation times for their shallow water model: https://github.com/JuliaLabs/ShallowWaterBench. I haven't done any rigorous benchmarking yet but out of those 6 minutes, ~1.5 minutes are spent on compiling code that creates CuFFT plans (the first plan takes 1.5 minutes then the others take <1 second). From watching the log I'm guessing the other 4.5 minutes are evenly split between setting up the model (creating CuArrays, initializing them, etc.) and the first time step (where the kernels are getting compiled presumably). I don't think we have that many kernels (just 5 bigger ones) but one of them; https://github.com/ali-ramadhan/Oceananigans.jl/blob/2b64d584c79ece0429f2421335ddb6bc0c6c6663/src/time_steppers.jl#L213; has several layers of inlining (it's inlining the majority of the functions in [operators/ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl)) after which it probably balloons up to be a pretty big kernel. They also have tons of arguments crammed in as the structs I was passing weren't `isbitstype` (working on this #59). I should come back and update this issue once we do some proper benchmarking (note to self: nvprof seems like it's being deprecated in favor of Nsight). Caching kernels between sessions sounds tough but will definitely look into timing compilations in CUDAnative, might provide some insight on how to speed things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765:19,feedback,feedback,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765,1,['feedback'],['feedback']
Usability,"Thank you for your reply! And apologies for have not been clear.; Firstly, we want to simulate a ""half-channel flow"", so we only use no-slip boundary condition at the bottom. Secondly, we have used periodic boundary condition in x (streamwise) and y (crosswise) direction.; Finally, in this case the z-axis is range from -15 to 0, so I can't use ``` const z₁ = -1*znodes(Center,grid)[1] ``` because if I do that, the value of z1 will change to 14.88. My code ``` const z₁ = -1*znodes(Center,grid)[grid.Nz] ``` will keep z1 equals to Closest grid center to the bottom (0.12).; Everything seems right, but the result seems strange!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648882721:58,clear,clear,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1648882721,1,['clear'],['clear']
Usability,"Thank you for your response and for providing the guiding questions. I summarized the motivation and context of the project below. > If you can describe your problem in more detail then we may be in a better position to help. Here's some guiding questions:; > What is the physical situation you are trying to model? Can you describe the geometry of your problem and its motivation? . It is a thesis project about the dispersal and migration of fish larvae in the sea. Juveniles from a coral reef fish population can return to their natal reef after being dispersed into the open ocean by the currents. Fish larvae, in particular, have the ability to swim directionally and increasingly fast during ontogeny, indicating that they may not only disperse, but also migrate to their natal reef using environmental signals. How and when larvae use local and large-scale cues remains a mystery. To bring light into this we want to build a simulation where we simulate the ocean including some Lagrangian particles in it(which simulate the larvae). Then we will try out several possible factors, which might help the larvae to find their natal reefs after being dispersed.; For this we picked Oceananigans as a tool. We want to use it to build a module where you can activate several simulated factors like odor(through a continuity equation), swarm behaviour or navigation. Ideally this would be another great example for Oceananigans as a whole.; Our plan is to use the laminar flow with single particle – case as a starting point to build the other cases (more particles, turbulent flow, etc.) on. > What is the dimensionality of your problem? Most fluids problems of interest are either two- or three-dimensional. You have implied that your problem is two-dimensional but did not state this explicitly. We plan to do this two-dimensionaly at first since it is „just“ a bachelor’s thesis. > What boundary conditions would you like to impose? You have stated that you want to generate inlet and outlet bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819080471:50,guid,guiding,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819080471,2,['guid'],['guiding']
Usability,"Thank you so much! This clears up a lot about how to communicate the boundary conditions. And yes, I'll be at OSM albeit presenting something completely different.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587087912:24,clear,clears,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-587087912,1,['clear'],['clears']
Usability,Thank you! I appreciate it. I'm assuming this is a relatively simple issue to resolve?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732361750:62,simpl,simple,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732361750,1,['simpl'],['simple']
Usability,Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258929817:24,clear,clear,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258929817,1,['clear'],['clear']
Usability,Thanks @Sumanshekhar17 for the simpler example and @glwagner has answered your question I believe. Why don't you try it without `prettytime(wizard)` to see if that works?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902842128:31,simpl,simpler,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902842128,1,['simpl'],['simpler']
Usability,Thanks @ali-ramadhan . You are correct. I see the raw latex when looking at the source code but everything looks pretty with the compiled documentation. . I presume you use Documenter.jl to build the docs?. If yes I will learn how that works.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725489785:221,learn,learn,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725489785,1,['learn'],['learn']
Usability,"Thanks @ali-ramadhan and @glwagner . I agree with you completely. It is important to be focused and clearly Oceananigans should focus on the Ocean, and Ocean related activities. Now that I know I can import this repo into other repos, I am happy to piggy back on Oceananigans and have something else. Maybe Magnetonanigans? Still word smithing that. . Thanks again for making Oceananigans happen as I know it's a great resouce and so happy to be able to learn from it and use it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805:100,clear,clearly,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304#issuecomment-766901805,2,"['clear', 'learn']","['clearly', 'learn']"
Usability,"Thanks @ali-ramadhan for the feedback. What I have so far is only redoing the `one_dimensional_advection_schemes.jl` but I thought this was a good place to start. When we are happy with this it should be easy to do other more interesting cases. I am happy to work with you to merge this with what you did in the other PR, when you have time. I agree that having some `@test` checks is a good idea. . I don't think it's as simple as everything being single as I tried running Oceananigans using single and reproduced the same plot. @glwagner suggested maybe something happens in the pressure solve. Could be but I don't know yet but I'm going to try and test this using ShallowWaterModel, which has no pressure solve. I have used a small enough time step that the scheme hasn't bee a problem, but I agree that RK3 would be better. I was only using QAB2 because I wanted to compare it with what I had programmed, AB2, to get similar results. From what I have seen both QAB2 and AB2 do pretty much the same thing, in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823:29,feedback,feedback,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-754024823,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,"Thanks @glwagner . . Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed. I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344:569,learn,learna,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181190344,1,['learn'],['learna']
Usability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:908,learn,learn,908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['learn'],['learn']
Usability,"Thanks @glwagner and I agree, speed up is better. WIll fix that that. The x-axis is the number of points in each direction. We could square it to get the total degrees of freedom, and that might be nice, but I keep on thinking that looking at the number of points in each direction on a square grid would be easier for the user to learn what to expect. But both are easy enough to produce. But I will keep this in mind when we are doing the `'IncompressibleModel`, where we would cube it. They should yield similar behaviour, I would think. But maybe the pressure solver makes things different. I hope to know better by tomorrow. I agree about this being enlightening. It seems to me that for high resolutions, the cpus and gpus have pretty much the same slopes, it just takes a lot for the gpu to start to increase. I didn't know this before and am happy to have learned it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851711479:331,learn,learn,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851711479,2,['learn'],"['learn', 'learned']"
Usability,Thanks @glwagner and great we have both options. I imagine that @pvthinker (Guillaume) would be very interesting to learn about this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081963426:116,learn,learn,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081963426,1,['learn'],['learn']
Usability,Thanks @glwagner for clarifying and I see the point. Thanks also in advance for fixing it up. . I encountered the same problem when I wanted to test `Flat` and in the end separted out the different dimensinal cases. Not ideal but it worked for my simple purposes. Will be nice to have something more elegant in the tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820403743:247,simpl,simple,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-820403743,1,['simpl'],['simple']
Usability,"Thanks @glwagner for merging main into this branch. I have returned to the global simulations and have learned something. Using all the same parameters as before, I get `NaNs` after just over an hour. Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help. . Do you think I should play around with other advection schemes, say some high order upwinding schemes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981111211:103,learn,learned,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981111211,1,['learn'],['learned']
Usability,"Thanks @glwagner for more thoughts and the references. I agree that sticking to `stokes_drift` in this context is the simplest thing. . However, I wonder if we might want to have a nice example that tries and explain pseudomomentum? Since there is a lot of confusion in the literature (as you pointed out), I think it should be 1D to be as simple as possible. I found a reference for pseudomomentum in the [shallow water model](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems/8088FF1275BB78313627198546516FB2). I have not read this article yet but I wonder whether we might want to make an example that tries to explain this better? Maybe then people might go to Oceananigans for a reference on pseudomomentum? . Since this issue is closed if there is interest, this discussion should continue elsewhere.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379:118,simpl,simplest,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778188379,3,['simpl'],"['simple', 'simple-criterion-for-the-sign-of-the-pseudomomentum-of-modes-in-shallow-water-systems', 'simplest']"
Usability,"Thanks @glwagner for the feedback. There are tests that were added for both the time-stepping and introducing tracers. https://github.com/CliMA/Oceananigans.jl/blob/swm-shenanigans/test/test_shallow_water_models.jl. I agree that testing shallow_water_model_forcing on the other code, is a good idea. @ali-ramadhan , did you want to try that in this PR or in a subsequent one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081:25,feedback,feedback,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756152081,1,['feedback'],['feedback']
Usability,"Thanks @glwagner for the quickly and in depth rely!. I don't know the details of AEL but sounds interesting, and complicated. I think what I am suggesting is much simpler, but certainly related. Maybe this could be a first step in that bigger problem? . Starting simple, `ShallowWaterModel` would be the place to start as it only has horizontal coordiantes and so there would not need to be any need (I don't think) to create any new operators. The steps to do this could include the following:. - [ ] Create a dispatch between `ConservationForm` and `VectorInvariantForm` (similar to `HydrostaticModel` I presume); - [ ] Define a new grid, maybe called `BoundaryFollowingGrid`; - [ ] Merge the two together. Could it be that easy? If @glwagner could help with the dispactching between the two forms, then I think I could borrow heavily from `HydrostaticModel` to put together the right equations. As a bonus, this would also allow us to do `SphericalShallowWater` free of charge. . As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in `xz` space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. Actually Allistair had some great news of a class he taught at MIT on the MITgcm, that explaines it very well. I know as that's where I learned it from. . But as per usual, maybe I will suggest doing shallow water first as it's easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133:163,simpl,simpler,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814256133,3,"['learn', 'simpl']","['learned', 'simple', 'simpler']"
Usability,Thanks @glwagner. Sorry I didn't test before but I assumed that since we never reached that warning it couldn't cause problems. I'll close this issue since it's clearly out of the scope for Oceananigans,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911238491:161,clear,clearly,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911238491,1,['clear'],['clearly']
Usability,Thanks @hennyg888 for sharing this. I thought i tested the last PR with `WENO5` but cleared I messed up with that. Sorry.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871689677:84,clear,cleared,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871689677,1,['clear'],['cleared']
Usability,"Thanks @jklymak . . I looked at this paper and the APE for the incompressible Boussinesq model is defined explicitly in section 2.4. The APE is defined in equation 3.6 as . APE = \int_V E_a dV ; = \int_V \rho g (z - z_R) dV, (1). where `E_a` is the APE density. This is exact and to compute this one needs to find the reference depth, `z_R`, which is I presume where the sorting comes in. . Then, it says that one can show that the APE density can be written as. E_a = - \int_0^\zeta g \tilde \zeta \rho_R' (z - \tilde \zeta) d \tilde \zeta (2); ; E_a \approx \rho_0 N_r^2 \zeta^2/2 (3). where `N_R^2 = - g/\rho_0 \rho_R'` is the Brunt-Vaisala frequency based on the reference density. Equations (1) and (2) are exact and (3) is approximate, but I believe (3) is exact in the case of constant stratifiation. . I wonder whether using equation (1) is the simplest? . (If anyone can tell me how to make equations in markdown I am happy to change this to make it prettier.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758708719:853,simpl,simplest,853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-758708719,1,['simpl'],['simplest']
Usability,"Thanks @kburns for the suggestion. I will look at Dedalus to see what they do and learn from them. I don't think we would want to find the full spectrum unless the problem is one-dimensional, but I guess it depends on what we want it to do. Lots of potential here I'm sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860:82,learn,learn,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860,1,['learn'],['learn']
Usability,"Thanks @maleadt! I didn't know about `Base.mapreducedim`. Will look into using it when I revisit this PR!. > I don't see any problem with this but as a user, since both are simply estiamtes (we need to pick a scaling factor in both cases) I am probably more inclined to pick the faster more conservative estimate, but why not give the user the choice and they can decide?. Yes definitely agree. The default can be the very fast `cell_advection_timescale` function while this PR can add a new `accurate_cell_advection_timescale`. The main use for `accurate_cell_advection_timescale` will be for curvilinear grids where a fast method is probably too conservative or for when you want an accurate CFL diagnostic. I've been using it on the cubed sphere in PR #1522 and it seems to work great fast enough on the CPU. > @ali-ramadhan can you explain in greater detail why this problem requires nested calls to mapreduce?. Yes. We essentially want to `mapreduce` over operations like `w / Δz` but `w` and `Δz` need to have the same size for `mapreduce` to work on multiple iterators (`w` and `Δz`). They have different sizes on all grids right now. Only way I could figure out how to do it using just `mapreduce` was to do an ""inner `mapreduce`"" where e.g. `w[i, j, :]` and `Δz` have the same size and the ""outer `mapreduce`"" iterates over the other dimensions. So we would also need slightly different `mapreduce` implementations for the different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811204289:173,simpl,simply,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-811204289,1,['simpl'],['simply']
Usability,"Thanks @maleadt, that's very helpful!. In this PR, we haven't directly changed any kernel function signatures. However, this PR does pass more complicated objects into kernels (a wrapper around an `OffsetArray` called a ""`Field`"", rather than simply the `OffsetArray`). The primary changes in this PR are thus 1. _not_ to extract the underlying `OffsetArray` from a `Field`, and 2. writing an `adapt_structure` method for `Field`s. I suppose the translation that's performed by `adapt_structure` increases the number or arguments to the function `ptxcall_calculate_Gu__66`?. The changes made in this PR are not strictly necessary --- they are a convenience. If manually unwrapping `Field`s (the method we previously used) is necessitated by CUDA limitations, I think we can live with that. If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987:243,simpl,simply,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987,1,['simpl'],['simply']
Usability,Thanks @navidcy ! That definitely did the trick. Now to learn how to make an animation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126796762:56,learn,learn,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126796762,1,['learn'],['learn']
Usability,"Thanks @qingli411. One obvious way to introduce the concept of dynamic dependencies is to break functionality out into multiple small packages (`OceananigansPlotting`, `OceananigansOutput`, etc). @vchuravy argued that this is a good philosophy for packages; perhaps even more so for a complex project like this one: we may want to keep the core as simple as possible. This would also make the tests run faster, and might make development easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624:348,simpl,simple,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624,1,['simpl'],['simple']
Usability,"Thanks @simone-silvestri for clarifying. I checkede and the RH-wave is an exact solution in the case of a rigid-lid. Since the hydrostatic model must have a free-surface, taking gravity to be very big should make the solution even better. . It is impressive that everything is stable and can run with such a large time step considering how strong gravity is. . The advection of a bump is a simpler test case but not nearly as interesting as the RH-wave.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426:390,simpl,simpler,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061780426,1,['simpl'],['simpler']
Usability,"Thanks @simone-silvestri for the observations. I will think about that tomorrow. Today I also tried to do a flat bottom run, just to see what would happen with no bathymetry. I added the last line below, which I thought would set the bottom of the ocean to 5km below the free-surface. Unfortunately, when I ran the simulation nothing happened after even a year.; ```; bat = file_bathymetry[""bathymetry""]; boundary = Int.(bat .> 0); bat[ bat .> 0 ] .= 0 ; bat = -bat; bat = 0*bat .- 5e3; ```; This clearly didn't work. Any observations as to what I did wrong?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1992825789:497,clear,clearly,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1992825789,1,['clear'],['clearly']
Usability,"Thanks @tomchor . Sadly, I'm still learning the naming conventions, but did you mean to suggest `z_Faces`? If yes I'm happy to use that, or `z_faces`, if that is more inline with convention.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814124178:35,learn,learning,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814124178,1,['learn'],['learning']
Usability,Thanks @tomchor for fixing this PR so that the tests pass. So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. . I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. @glwagner also suggested we test this with lat-lon grids and create tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301:437,simpl,simple,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1125406301,1,['simpl'],['simple']
Usability,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:25,feedback,feedback,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145,5,"['clear', 'feedback', 'intuit']","['clear', 'clearer', 'clearly', 'feedback', 'intuitive']"
Usability,"Thanks all for the feedback! I chose the fake wall case because it permits a simple direct comparison between a ""true"" solution and the immersed boundary solution. But I agree that judging the fidelity of statistics and budgets in a more complicated case is also necessary. The challenge of more complicated cases is finding reference statistics to compare to. It'd be nice to find an ""[Askervein Hill](https://news.ucar.edu/126732/capturing-detailed-portrait-wind) of the ocean""... As for modifications to the pressure solver, we may be able to use an preconditioned conjugate gradient method (an iterative, matrix-free method) with the FFT-based solver as a preconditioner. I think a conjugate gradient method could provide some improvement over a ""naive"" iterative approach (iteratively applying the pressure correction step). We've already coded up such a solver to work with Oceananigans data structures:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl. A multigrid method would also be nice and might be even faster... ! But, probably a bit more difficult to code up I think. Getting the conjugate gradient solver to work might not take long.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862712452:19,feedback,feedback,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862712452,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,"Thanks everyone for the feedback. I did some debugging and I'm happy to say that bathymetry is now specified as we expected, no negative sign, and it gives results that are consistent with previous findings: prograde is more unstable and retrograde is more stable. . You can see the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl). . Any other thoughts on this before I move on to the global model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794:24,feedback,feedback,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1978912794,1,['feedback'],['feedback']
Usability,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335:25,feedback,feedback,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335,1,['feedback'],['feedback']
Usability,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:241,clear,clear,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166,2,['clear'],"['clear', 'clearly']"
Usability,"Thanks for bringing these up! This stuff certainly needs some work, and we should probably make it clear what's e.g. a free parameter. > I see a few problems:; > * `f` is not a property of a planet. Agreed. Perhaps now that we're also thinking of channel models on a _β_-plane, we should also build a ""rotation"" abstraction to choose between _f_-plane, _β_-plane, and Coriolis force (possible with cosine term). > * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients. Yes. This should be addressed by incorporating a `TurbulentDiffusivity` struct like the one you proposed in #120. I agree with John that when we do this, isotropic and anisotropic diffusion should be options. > * A reference density is not a parameter in an equation of state.; Hmmm, but if ρ₀ is needed to calculate ρ then isn't it a parameter of the EOS?. Sounds like this issue is worth discussing and strategizing about. We could maybe get some ideas and inspiration from how CliMA.jl is handling parameters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405:99,clear,clear,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405,1,['clear'],['clear']
Usability,Thanks for clarifying @glwagner . . I guess I need to learn how this is done in the other models.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119880246:54,learn,learn,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119880246,1,['learn'],['learn']
Usability,"Thanks for embarking on this @glwagner!. > It's a bit of a work in progress. Before merging we need:; > * tests (simple 1D test with temperature to see if budgets are correct?). Just added ""WIP"" (work in progress) to the PR title. We can work on the tests together. For testing, we should be able to extend the 1D column model example: https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/column_model.jl. > Also looks like Travis is failing; not sure why that is. Looks like it's just the one test in the time stepping section that's failing. Maybe something to do with how the boundary conditions are called during the time stepping? The Model test passes so it's not erroring during model initialization/construction. > I propose changing the struct `BoundaryConditions` to `ModelBoundaryConditions` for clarity. I'll always vote for clarity!. Just one initial question: I might be misunderstanding the purpose of `bc.calc` but why not `bc.impose(args...)` instead of `bc.calc(args...)` as we usually say that we _impose_ boundary conditions?. Have to run out but will have a more detailed look later today. Otherwise, looks really neat! On a more practical note, might end up being easier to discuss this PR in person.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606:113,simpl,simple,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606,1,['simpl'],['simple']
Usability,"Thanks for looking into this @maleadt!. Hmmm, if it's indeed a multithreading issue then maybe the simple solution is to just turn off multithreading for FFTW during testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589249373:99,simpl,simple,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589249373,1,['simpl'],['simple']
Usability,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:65,feedback,feedback,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,2,"['clear', 'feedback']","['clear', 'feedback']"
Usability,"Thanks for putting your thoughts about this together Zheng! I support Greg's suggestion of moving this to the discussion section. In response to your BC question: since I don't yet understand the nuances of the Oceananigans pressure solver and time stepping, I would follow Greg's guidance with the aim of writing code that calculates all of the individual pressure components using the existing /default Oceananigans homogeneous Neumann BC implementation for each term. Once you have confidence that your code works and is using the correct RHS for each pressure component, I would check the residual (how much of the total non-hydrostatic pressure is explained by the sum of the pressure components). If the residual is very small I do not think it would be necessary to delve into the BC details. If the residual is large, you probably need to look at the BC implementation in more detail.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1931379047:281,guid,guidance,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459#issuecomment-1931379047,1,['guid'],['guidance']
Usability,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:535,simpl,simplifications,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151,1,['simpl'],['simplifications']
Usability,Thanks for running these tests. It would be nice to see how MPData performs in a 2D flow. . It's interesting that tweaking the number of iterations doesn't seem to make much difference. I'm a bit skeptical about this scheme though; it seems pretty diffusive and doesn't even beat third-order upwind which is way simpler. I might have introduced a bug although I went through the code again and it looks correct to me. Another possibility is that the high diffusivity is the trade-off for keeping the scheme positivity-preserving?; Godunov's theorem sets some tough standards -- it's not possible to obtain monotonic advection with a linear scheme beyond first order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946:312,simpl,simpler,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946,1,['simpl'],['simpler']
Usability,"Thanks for sharing @glwagner !. I will certainly give that a try as my copying and pasting clearly leaves something to be desired. I tried it and I think this works great! Such a great tool to have, and proven to be way faster, and usually more accurate than my copying and pasting. One thing I noticed in the 2D turbulence example, you need to only have one # on each of the commented lines, otherwise it doesn't convert the comment into a nice text. ```; # To make our equations prettier, we unpack `u`, `v`, and `w` from ; # the `NamedTuple` model.velocities:. u, v, w = model.velocities. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724731293:91,clear,clearly,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724731293,1,['clear'],['clearly']
Usability,"Thanks for the comments! I've rerun the simulation with Ri = 0.04 so that the viscous boundary layer is resolved. Horizontal resolution may still be an issue but I can roughly double it. We may also have to figure out which `C` to use, but might be more useful to do when we know we have a run that looks reasonable?. Just posting vertical profiles from that run. They look better but non-linear diffusivity profiles are still off. The shape of the profiles looks different from the figure I posted above. The magnitudes also seem very low (they're barely above the background values). Magnitude could be a plotting error (if it is I can't see it...). Discrepency could be because I'm doing the Pr = 0.7 case while the profiles posted in V&T figure 7 are for the Pr = 7 case. I assume things will be different, but I don't have the intuition to tell how big of a difference to expect. Note: nu and kappaT profiles are nu_SGS/nu and kappa_SGS/kappa. ![plots_stratified_couette_flow_u_profiles (1)](https://user-images.githubusercontent.com/20099589/63734344-df895d00-c849-11e9-8204-80d0e052b4fe.png); ![plots_stratified_couette_flow_T_profiles (1)](https://user-images.githubusercontent.com/20099589/63734346-e0ba8a00-c849-11e9-9aea-dabb37693962.png); ![plots_stratified_couette_flow_nu_profiles (1)](https://user-images.githubusercontent.com/20099589/63734350-e31ce400-c849-11e9-953c-56c5688a12c1.png); ![plots_stratified_couette_flow_kappaT_profiles (1)](https://user-images.githubusercontent.com/20099589/63734351-e3b57a80-c849-11e9-970a-eaa314caf8f8.png); ![plots_stratified_couette_flow_Pr_profiles](https://user-images.githubusercontent.com/20099589/63734355-e4e6a780-c849-11e9-8945-56dd8c1f95f0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-525099847:832,intuit,intuition,832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310#issuecomment-525099847,1,['intuit'],['intuition']
Usability,"Thanks for the effort in this PR @francispoulin. And it's a good point that without much user feedback it's hard to anticipate what will be best for them. > One change that I would like to make is instead of having zF as input, I would prefer to have zFs or even zFaces, to emphasize that all the faces are specified. Usually, when I see zF I think of a face, and that's not the case here. @tomchor , what do you think about this?. I agree that `zFaces` is better than `zF` and `z_stretched`. Way more intuitive. To be inline with the Oceananigans/Julia naming conventions it might be best to use `z_faces` or `ZFaces` though. But that's up to you. I have no personal preference here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908:94,feedback,feedback,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814119908,2,"['feedback', 'intuit']","['feedback', 'intuitive']"
Usability,"Thanks for the explanation @glwagner . No problem that you didn't understand this perfectly in the past as I am still learning the difference between `print`, `show`, and `summary`. It seems that all the advection schemes have the same structure, except `WENO5` but this is not a problem and therefore I am happy to close #2098 . This issue perhaps better addressed in a future PR, that focuses on the structure we would want in general. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986801723:118,learn,learning,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986801723,1,['learn'],['learning']
Usability,"Thanks for the explanation. I agree there are pros and cons. I still prefer the simpler approach, but I can see why this one might be desirable. I'm still a bit unclear on what `z_stretch` should be, though. If it's an array or a function, it should provide the location of the faces, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813479254:80,simpl,simpler,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813479254,1,['simpl'],['simpler']
Usability,Thanks for the feedback @francispoulin. Since this fixes two bugs I took the liberty of releasing a new version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1750#issuecomment-865467286:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1750#issuecomment-865467286,1,['feedback'],['feedback']
Usability,"Thanks for the feedback @glwagner and @navidcy . I think it would be easy to do this in a channel on a beta-plane and see some zonal jets developing. That would be great to do. Also, if you turn off beta one should of course get a very similar result to the two-dimensional turbulence example. I'll get to work on this today and share what I come up with. . Do we have biharmonic diffusion in Oceananigans already? If yes I'm also happy to play with that too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780599859:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-780599859,1,['feedback'],['feedback']
Usability,"Thanks for the feedback @glwagner and @tomchor . I will respond soon but I have an updated I wanted to share. I did a simulation in each for 100 time steps a few times each. I found sometimes the second simulation was way faster than the first. For different advection schemes I found, to my surprise, they do scale differently. ```; scheme ratio; ====== ===; C2 1.7; U3 2.4; C4 3; U5 2.4; W5 3.4; ```. I would not call these offical benchmarks but more back of the envelop calculations (between friends). But these numbers are, mostly, around 3, which is what I expected. . For fun, I will do the same thing with GPUs (and will find out if my new code runs on a GPU). I guess one mystery is why is it that my actual simulation ran so slowly? I will try it again for 2 hours instead of 2 days and see how the scalings look.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816767845:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816767845,1,['feedback'],['feedback']
Usability,Thanks for the feedback @ranjanan !; * Instead of using `const` we went with structs.; * CuArrays have worked quite well but still working on writing performant CPU/GPU shared kernels (hoping [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl) will help here).; * Multicore parallelism is a bit lower priority right now but have had some pretty good results with DistributedArrays although I think MPIArrays will be the way forward for us here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2#issuecomment-462058793:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2#issuecomment-462058793,1,['feedback'],['feedback']
Usability,Thanks for the feedback and no worries on the delay! I haven't been as active as I would have liked these past couple of months 😅 ; I think we can go a head and merge this in assuming I didn't break the build!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-561700707:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-561700707,1,['feedback'],['feedback']
Usability,"Thanks for the feedback! We were also thinking that if the ocean and atmosphere shared the same vertical indexing then maybe using some shared parameterizations would be easy but as pointed out, vertical indexing isn't necessarily a rigid thing in DG. Also sounds like the ocean and atmosphere don't need to agree as they're arbitrary decisions anyways. Interesting point about setting the vertical index to be the fastest running index to help speed up vertical integrals. We only have one vertical integral in the time stepping core so not sure if it'll make a big difference on the ocean side but something to think about! Might be relevant to #21. We decided to switch our convention and use _k=1_ at the bottom. I'll submit a PR soon with this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068,1,['feedback'],['feedback']
Usability,"Thanks for the feedback. . First, I used the formatting to get nicer output,; ```; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2 ; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3 ; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4 ; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5 ; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5 ; ```. Second, sorry about the extra files. I will probably close this and create a new one rather than having a bunch of commits, as that will be cleaner. I presume that's the preferred option?. Third, can you point me to another validation experiment that uses a library not in the library?. Fourth, I won't do any other advection schemes for this PR. Fifth, I will move this into the validation folder and chane the name of the files appropriately.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393:15,feedback,feedback,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839144393,1,['feedback'],['feedback']
Usability,"Thanks for the further thoughts. We don't actually want a `Value` boundary condition I just wanted to find a simple example to set something. Clearly I choose badly. Sorry. What I actually need to impose `NormalFlow` boundary condition, as I first mentoined to you. Unfortunately, when I tried that it didn't seem to have any effect. I should go back to the problem I wanted to solve originally and try and figure out why the boundary condtions were not being imposed. I'm pretty sure that normal flow is something we can impose without having second-order fluxes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852530819:109,simpl,simple,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852530819,1,['simpl'],['simple']
Usability,"Thanks for the offer of doing this together. Since I know that it would go much faster doing this together, and also I will learn more from talking to you, how about we do this over zoom? Let me know by email what you prefer. Yes, I do think that we can use a lot of the existing code, which will make things easier and consistent. . I do have a question of the form of the equations being solved. The docs suggest that the advection terms are written as; u \cdot \nabla u for example. Is it solved like this or is incompressability used to write it as \nabla \cdot (u u)? . Since this is a finite volume method I presume it's the latter but not entirely sure. . Having extra ghost cells for a whlle should not be a problem as this is just temporary. I agree that much of the code can be shared, and should be shared where possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725541589:124,learn,learn,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725541589,1,['learn'],['learn']
Usability,"Thanks for the suggestion @jmbeckers! Since we can now use broadcasting on fields, another possibility is. ```julia; u₀(x, y, z) = rand(); set!(model, u = u₀, v = u₀). model.velocities.u .-= mean(model.velocities.u); model.velocities.v .-= mean(model.velocities.v); ```. This emphasizes using function input, which is generally a better way to work, and avoids annoyances associated with `size` (and is shorter and possibly clearer). However, I agree that @jmbeckers suggestion is better if we want to provide an example of array input. I like the idea of providing such an example, but I'm not sure if we want to put it in such a prominent place as the two dimensional turbulence example because it can be annoying and inconvenient to use them, as this issue illustrates...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253:424,clear,clearer,424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253,1,['clear'],['clearer']
Usability,"Thanks for the videos @PharmCat, those simulations look pretty cool!. > So if I make model of tank and impeller can I use Oceananigans.jl for hydrodynamic simulation? this is my main question. Yes I think it is possible to simulate mixing tanks in Oceananigans, but I don't know if the simulations will be good. Oceananigans development has not focused on moving boundaries or rigid bodies. I suspect codes like ANSYS Fluent or OpenFOAM would be better for your problem, but I'm not familiar with them. Some of the impellers look pretty small so if you want to use an immersed boundary method to simulate the rigid body and walls, then you might need high resolutions with many grid points to resolve the impeller. Depending on how fast the impeller spins then your time step might need to be very small. Also, I don't know how accurate the immersed boundary method is with moving rigid bodies. You might need even smaller time steps to get good accuracy. > I just start to learn Oceananigans.jl and now i can't say this. Is it possible to use boundary for simulation mooving of rigid body in water?. From the videos I think you just want a moving boundary that describes a rotating rigid body. I think this is possible with Oceananigans but nobody has tried it. If you're interested in trying to simulate a mixing tank with Oceananigans that would be pretty cool! Please let us know if you have any questions (also feel free to open new issues) and if you post your script here we can help with debugging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/830#issuecomment-669402349:974,learn,learn,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/830#issuecomment-669402349,1,['learn'],['learn']
Usability,"Thanks for the warning @navidcy . Both look great but I appreciate that they also have different goals. . Also, sorry for the very general question and maybe I should have been more specific. I am very curious to learn about what is currently being worked on (and I can look at the issues for that I suppose) but one question that comes to mind is, can you solve the hydrostatic problem as well? I gather the incompressible sovler is for the more complicated non-hydrostatic case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724254474:213,learn,learn,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724254474,1,['learn'],['learn']
Usability,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302:110,simpl,simplifies,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302,1,['simpl'],['simplifies']
Usability,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:220,intuit,intuitive,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255,1,['intuit'],['intuitive']
Usability,"Thanks! I'll take a look. My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. On a side note, since you asked, I _am_ going through some difficulties running the same example with a GPU. My inexperience with GPUs is keeping me from figuring this one out. Should I create another issue? (I'm not sure how much you guys want to be involved in these debugging processes...). Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539727583:438,simpl,simplifications,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539727583,1,['simpl'],['simplifications']
Usability,"Thanks, @tomchor ! ; Is that a reason why you define the closure for the coarse_model?. Until now, what I was doing was something like this. ```julia; for i = 1:10:model.Nz; key = Symbol(""xy"", i) # Create the dictionary key dynamically; fname = ""vxy_z$(@sprintf(""%05d"", i)).nc""; simulation.output_writers[key] = NetCDFOutputWriter(model, output_fields,; schedule = TimeInterval(output_interval),; filename = fname,; indices = (:,:,i),; with_halos = false,; overwrite_existing = overwrite_existing,; array_type = Array{Float32}); end; ```; Which creates a file for each subset level. While I think that @tomchor solution is the best because it is more general and can be for any arbitrary new grid, I still think we should also be able to simply pass the indices to `NetCDFOutputWriter`. For example, this should work. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; indices = (:,:,1:10:model.Nz),; overwrite_existing=true,). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470:738,simpl,simply,738,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091084470,1,['simpl'],['simply']
Usability,"Thanks, everyone! Sorry it took so long, the learning curve was a little steeper than I thought. Next one will probably go smoother ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011056:45,learn,learning,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-788011056,1,['learn'],['learning']
Usability,"Thanks, everyone. I agree with the major points here. To answer some specific comments:. > Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). This is mostly because the majority of my exploratory runs are run in the GPU, and since I have limited GPU time I try to not leave interactive GPU sessions open. If I unlimited access to a GPU (or in the cases where I can explore on the CPU), then I agree with your point. > I agree with Navid, it is better to have a more complicated script for cases this specific than a complicated source code. Again, agree. I posted this more because, if this was something a lot of other people were doing, it might be worth to maintain the infrastructure. But since it sounds like that's not the case, then I agree it's best to have complex user scripts and keep the source code simple. > Does @navidcy's suggestion work for you @tomchor ?. Yes, thanks for the suggestion @navidcy. I think this is the next best thing. The one disadvantage for me is that is ""wastes"" computation advecting tracers in the spin-up, but it has the huge advantage of keeping the source code simple, with also a readable user script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386:1042,simpl,simple,1042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1606169386,2,['simpl'],['simple']
Usability,"Thanks, everyone. I'll merge this for now and we can improve on it later based on feedback from users. @glwagner I'm thinking of opening another PR soon to address your [comment about using GPUs](https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711). Like I mentioned, some of this info is already available in the ""Using GPUs"" page, but maybe it's useful to expand a bit on it and link this newly created page there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114:82,feedback,feedback,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819606114,1,['feedback'],['feedback']
Usability,"Thanks, forgot about Circle CI. I just emailed around for quotes from Travis CI, Drone, GitLab CI, and Circle CI. Sounds like enterprise tends to roll their own CI using Jenkins or TeamCity but we're just a small team that needs a custom solution so something simple like Travis CI might be fine. Sounds like we can spin up our own cloud instances (e.g. on Google Cloud with those sweet credits) according to the specs we need then pay the CI service to basically set it up, maintain it, and provide support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474821028:260,simpl,simple,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474821028,1,['simpl'],['simple']
Usability,Thanks. I get the same output but no visuals and no data saved. I will learn how to do that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/537#issuecomment-724213468:71,learn,learn,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/537#issuecomment-724213468,1,['learn'],['learn']
Usability,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:21,feedback,feedback,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807,2,"['feedback', 'simpl']","['feedback', 'simple']"
Usability,That is very clear and accurate. Agreed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-829649309:13,clear,clear,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-829649309,1,['clear'],['clear']
Usability,"That makes sense and I am a firm believer in starting simple, and I'm glad you made that choice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729127118:54,simpl,simple,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729127118,1,['simpl'],['simple']
Usability,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:274,simpl,simple,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189,1,['simpl'],['simple']
Usability,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:207,simpl,simply,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882,1,['simpl'],['simply']
Usability,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:158,user-friendly,user-friendly,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229,1,['user-friendly'],['user-friendly']
Usability,"That sounds like a very solid plan and I like it. Just to be clear, the folders should have the following:. ```; TimeSteppers/; TimeSteppers.jl; quasi_adams_bashforth_2.jl; runge_kutta_3.jl; ; Models/; Models.jl. IncompressibleModels/; incompressiblemodels.jl; calculate_incompressible_tendencies.jl; pressure_correction.jl; store_tendencies.jl; update_hydrostatic_pressure.jl; update_state.jl; velocity_and_tracer_tendencies.jl. ShallowWaterModels/; ShallowWaterModels.jl; calculate_shallow_water_tendencies.jl; other_shallow_water_specific_files.jl . ```; Even before SW is created, this requires moving things around, as you have shown above. Did you want me to give this a try? It does not seem like a lots needs to change and I will certainly learn a lot in the process. On a different note, I've noticed that when I view the docs in chrome (on ubuntu) the math equations aren't actually converted. I have a chrome extension but that asks for $ and $$ and so forth. The docs are using `` instead. What should one use to view this? I went down a rabbit hole of finding markdown viewers and sadly did not succeed in figuring this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725449013:61,clear,clear,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725449013,2,"['clear', 'learn']","['clear', 'learn']"
Usability,"That'd be amazing to be able to simply drop in walls!. Something that isn't clear to me is what boundary conditions the solver can handle. Can it really handle arbitrary boundary conditions in all directions? I would have thought that the boundary conditions affect the boundary condition on pressure, and thus affect the Poisson solver. (Or perhaps we would need a new solver, but it's simply a matter of treating the horizontal direction like the vertical one when implementing a *new* Poisson solver for no-flux boundary conditions in two directions... ?). Are solver details addressed in the docs?. Something to discuss on Monday...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468943513:32,simpl,simply,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468943513,3,"['clear', 'simpl']","['clear', 'simply']"
Usability,"That's awesome, thanks @arcavaliere!. I think if we can get a printing format similar to [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl) with a timestamp on the left and log level + line location then we'll have a great logger we can merge into the code and start using!. And once we start using it we can tweak and improve it as we learn more. But let me know if you had other features in mind!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544481969:344,learn,learn,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-544481969,1,['learn'],['learn']
Usability,That's definitely good! It's not an issue that would crash a simulation but next time I'm editing `test_output_writers.jl` I'll remember to add some simple tests for this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414:149,simpl,simple,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1299#issuecomment-758166414,1,['simpl'],['simple']
Usability,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:72,learn,learn,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['learn'],['learn']
Usability,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985:25,simpl,simplicity,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985,4,['simpl'],"['simpler', 'simplicity', 'simply']"
Usability,"That's some great debugging there, @glwagner. Thanks!. Yeah I agree passing indices alongside averages is unclear to say the least. When I first set up the output writer to do this (with only one tracer) I was surprised that it worked out of the box since I expected an error or warning. But since it made code simpler and it worked, I kept it. Then this error creeped up on me :grimacing: . I'd be okay if you want to not allow that, or throw a warning or something in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438636158:311,simpl,simpler,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438636158,1,['simpl'],['simpler']
Usability,"The Partial cell method is bugged at the moment. @jm-c is working on correcting the bugs. An example is the output of `_immersed_cell` https://github.com/CliMA/Oceananigans.jl/blob/3c4785c03a9eb649a3636b79664134d1c802083b/src/ImmersedBoundaries/partial_cell_bottom.jl#L97-L102; which is incoherent with the notion of a `minimum_fractional_cell_height`. I.e., the test that checks whether a cell is immersed or not should include the minimal fractional cell height. ; Something more along these lines; ```julia; @inline function _immersed_cell(i, j, k, underlying_grid, ib::PartialCellBottom); # Face node below current cell; z = znode(i, j, k, underlying_grid, c, c, f); h = @inbounds ib.bottom_height[i, j, 1]; ϵ = ib.minimum_fractional_cell_height; # z + Δz is equal to the face above the current cell; Δz = Δzᶜᶜᶜ(i, j, k, ibg.underlying_grid); return z + Δz * ϵ ≤ h ; end; ```. There are other inconsistencies as we find out that simple examples still crash also with this fix. ; A simple case for which partial cells lead to the simulation crashing (independently on the time step size) is the [internal tide](https://github.com/CliMA/Oceananigans.jl/blob/main/examples/internal_tide.jl) example. If you want to contribute we are trying to correct the implementation over in #3682.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2274573004:933,simpl,simple,933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775#issuecomment-2274573004,2,['simpl'],['simple']
Usability,"The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Raffaele. > On Mar 9, 2020, at 11:48 AM, Gregory L. Wagner <notifications@github.com> wrote:; > ; > I also think it’s a good idea to use a full equation of state for all simulations sooner rather than later. It’s simpler: we won’t have to report constants of linearization everywhere. And setting up simulations will be easier.; > ; > I’ll defer to the modelers for whether Roquet’s approximation is an acceptable model for TEOS-10.; > ; > This package is relevant and we should consider contributing to it rather than implementing an equation of state somewhere in the Clima ecosystem:; > ; > https://github.com/gher-ulg/PhysOcean.jl <https://github.com/gher-ulg/PhysOcean.jl>; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub <https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AK24ROIBMZMYD77AGEZNM3DRGUMURA5CNFSM4LEKJAAKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEOHZCYQ#issuecomment-596611426>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AK24ROONT4RO4YCCF6BTIIDRGUMURANCNFSM4LEKJAAA>.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596726895:639,simpl,simpler,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596726895,1,['simpl'],['simpler']
Usability,"The `Open` classification was designed for boundaries that have a prescribed external state. If the current English description of `Open` does not adequately express this idea then we should simply change the description. I don't think a docstring written long ago motivates code design. We have to design this whole thing from the ground up. It sounds like any `Open` boundary requires two pieces of information:. 1. The external state that is prescribed.; 2. A (numerical) method for coping with the fact that the internal state inevitably deviates from the external state. One choice is simply to do nothing (use the prescribed external state), but this may have issues. There seem to be a diversity of other options, as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1981228442:191,simpl,simply,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1981228442,2,['simpl'],['simply']
Usability,"The advantage is clearer for diagnostics: with a dictionary (or other named/associative collection) it will presumably be easier to keep track of the elements of `model.diagnostics` for the purpose of logging/printing, or saving their values... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-523545677:17,clear,clearer,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/362#issuecomment-523545677,1,['clear'],['clearer']
Usability,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:993,simpl,simple,993,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,1,['simpl'],['simple']
Usability,"The climate machine shallow water model used DG numerics. I agree with Greg; that it would be nice to do a side-by-side comparison of two; numerical approaches to the same underlying equations. Not sure it used a; Bernoulli formulation.; john; ps Francis - great that you are involved with oceananigans!. On Fri, Nov 13, 2020 at 11:53 AM Gregory L. Wagner <notifications@github.com>; wrote:. > 2. Climate Machine also has a shallow water model; > <https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl>.; > I don't know the details of what this does but I should probably learn how; > the two models will differ.; >; > I'm not 100% sure how its implemented but I think at the end it'd be great; > if both ClimateMachine and Oceananigans shallow water models used the same; > equation set, since we can then compare the numerics. We don't have the; > bandwidth to develop the ClimateMachine shallow water model, but possibly; > at the time the Oceananigans has a nice one we'll be motivated to flesh out; > ClimateMachine's model.; >; > I'm not sure about immersed boundaries --- does the method generalize in a; > simple way? I'm not sure whether a special treatment is required for the; > height field, compared to an ordinary velocity variable, or tracer.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWKUQJEBFEYXSOVQO3SPVQABANCNFSM4TQVNFEA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931:617,learn,learn,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931,2,"['learn', 'simpl']","['learn', 'simple']"
Usability,"The convention we use for the other variables stored on faces is that our ""interior"" data spans from `i=1` to `i=N`. Thus we call the `i=N+1` a ""halo point"" for fields on faces, even though it really is not (its on the boundary, see #455). . In addition, we use a convention that face indices are ""left"" of cell indices. Thus `iFace=1` corresponds to the ""left"" boundary of the domain. `iCell=N` is the rightmost cell in the domain; and `iFace=N+1` corresponds to the rightmost boundary. Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this? This is confusing to me and I don't see why we would want to have an odd and surprising convention for the vertical coordinate. The fact is simply that the face at `i=N` is a very concrete and real place. It lies in the interior of the domain, to the left of the cell point `i=N`. This is a fact of our grid and must be internalized by anyone who wants to work with the discrete data and index fields directly by raw index. If/when we use named axis conventions for `fields` (see #457), we would be able to access the surface via `u[Z(At(0))]` (or some syntax like that. We can also create an alias `Surface() = Z(At(0))`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106:721,simpl,simply,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106,1,['simpl'],['simply']
Usability,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:285,simpl,simplification,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470,1,['simpl'],['simplification']
Usability,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834:175,simpl,simple,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834,1,['simpl'],['simple']
Usability,"The difficulty is that there's no end to useful tricks one might be able to deploy if they get a little more proficient with Julia. I'm learning new things all the time too. I'd rather put this kind of stuff in the wiki rather than putting stuff in the docs that's not really Oceananigans-specific (these things fall more in to the category ""general Julia knowledge applicable to Oceananigans""). In fact I thought we were moving towards that but it does seem like there's still some overlap between that simulation tips section and the wiki now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458718824:136,learn,learning,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458718824,1,['learn'],['learning']
Usability,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079:112,simpl,simplest,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079,1,['simpl'],['simplest']
Usability,"The discussion about molecular viscosity being resolved/modeled physics is a deep one. Probably too deep for a github issue. After many discussions with Jim McWilliams he managed to convince me that the only difference between the modeling of eddy versus molecular diffusion is scale separation between processes. The issue about always keeping a more rigorous set of equations and including the molecular diffusivity by default (even though it's probably not important in the vast majority of cases) is one of many modeling philosophies. I highly recommend the paper by [Kerry Emanuel](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2019AV000129). It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:844,simpl,simple,844,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,1,['simpl'],['simple']
Usability,"The error is not as clear, @glwagner. ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```. does not immediately reads ""no pressure solver for grids that are stretched in x or y"". One needs to infer that from the long types of the function arguments.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921:20,clear,clear,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022770921,1,['clear'],['clear']
Usability,"The explanations that @johnryantaylor gave are worth for a textbook. I was just about to write that we usually assume no flux at the boundaries in order to conserve the tracer, but he gave a new perspective to this. Taking an example from [PSOM](https://github.com/PSOM/V1.0/blob/master/code/NA/src/tracersource_nut.f90), they forced phytoplankton flux to zero at the boundaries, but using a first-order upwind scheme. ```fortran; flux(0)= 0.0; flux(NK)= 0.0; do k=NK-1,1,-1; ! Kz is at cell faces; dpdz= (Tr(1,i,j,k+1,0)-Tr(1,i,j,k,0))*wz(i,j,k)*DLinv; flux(k) = KzmaxTr*Kz(i,j,k)*dpdz + wsink*Tr(1,i,j,k+1,0); end do; ```. What if we leave for the users to give the velocity in which it will be advected?; Does that makes sense to simply give `w` as a function of `z` in which relax to 0 a the boundaries?; But you mentioned that Oceananigans assume non-divergent velocity field, but that's for the forcing, so it should be fine, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082454081:733,simpl,simply,733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082454081,1,['simpl'],['simply']
Usability,"The extra function you need looks like this. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/AbstractOperations/conditional_operations.jl#L108-L111. It should be added here:; https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/src/ImmersedBoundaries/immersed_reductions.jl#L22. and should specifically be. ```julia; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask) ; condition = arch_array(architecture(operand.grid), condition) ; return ConditionalOperation(operand; func, condition, mask) ; end ; ```. using the const `IF` defined above that. I guess this is a convenience for users who build CPU-based conditional and want to use them on the GPU. > since it fails if I simply set condition=boundary_node_ccf. I'm interested in seeing the error so we can fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904976682:797,simpl,simply,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1904976682,1,['simpl'],['simply']
Usability,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:13,user experience,user experience,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,2,"['simpl', 'user experience']","['simplified', 'user experience']"
Usability,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530:742,simpl,simpler,742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530,1,['simpl'],['simpler']
Usability,"The issue with `Δx` is that these are already defined as ""GridMetricOperation""s, eg objects that can be used within abstract operations. A simple solution is to follow the ""nodes"" semantics (might be better anyways)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1328167577:139,simpl,simple,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1328167577,1,['simpl'],['simple']
Usability,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:1016,simpl,simplest,1016,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074,1,['simpl'],['simplest']
Usability,"The movies look great, and I agree that the top row looks much better than the bottom row. @glwagner You mentioned that the top right (vorticity) is more dissipative than the top left (velocity). It's hard for me to see this from the movies. Did you look at other diagnostics to determine this or maybe you are much more perceptive to the fine details than I am. @simone-silvestri : I would be very interested to learn how your scheme difffers from the published method above. I have read through the paper and know it pretty well. Can you give me an idea as to what you do differently? Otherwise, I suppose I can look at the code I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081905400:413,learn,learn,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081905400,1,['learn'],['learn']
Usability,The name seems very clear and I like how this is structured.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130039874:20,clear,clear,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130039874,1,['clear'],['clear']
Usability,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348:300,clear,clear,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348,1,['clear'],['clear']
Usability,"The problem here I think is that arbitrary derivatives or interpolation operations are not automatically well-defined in our finite volume method. The most egregious case is when fields have `Flux` boundary conditions; in that case we don't attempt to determine the gradients of those fields across boundaries at all (in principle this is _often_, but not always, inferable given completely knowledge of the PDE / turbulence closure used for the field...). With second-order operations, we need halo regions of size 1 in order to compute second order quantities like the an isotropic diffusivity. However, to be well-defined on boundaries, higher-order derivatives would require more boundary conditions. So far we've skirted the issue (or just ignored it) by simply not allowing boundary conditions for `ComputedField`s. This has the sad consequence that `ComputedField`s cannot be trusted adjacent to boundaries; a restriction that is especially severe for flat problems in which the entire problem is adjacent to a boundary. I think the simplest solution for now is to ask users to supply boundary conditions for their `ComputedField`s where appropriate. We could also have a discussion about how to infer boundary conditions on `ComputedField`s based on their expression tree / operand, but I'm worried this might be a hard, or even ill-posed problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-771040461:760,simpl,simply,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130#issuecomment-771040461,2,['simpl'],"['simplest', 'simply']"
Usability,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708:711,clear,clear,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708,1,['clear'],['clear']
Usability,"The results in [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) show that WENO reverts to 2nd-order accuracy on stretched grids. So its not ""incorrect"", just less accurate. However, for any given problem, the convergence rate is only one aspect of the accuracy of a solution. It's possible that WENO5 is still more accurate than any other numerical scheme, even if the solution only _converges_ to the true solution at a 2nd order rate. It also seems likely that this is true for any reconstruction stencil. I'm not sure how much attention is paid to this issue in other codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861:18,simpl,simple,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861,1,['simpl'],['simple']
Usability,"The suggestion here is to require users to explicitly define `x`, `y`, and `z`? Would users still have to define all three for two-dimensional domains?. I understand the benefit in terms of being explicit, but I'm worried there are a lot of use cases in which the origin of the domain is simply unimportant, and the only relevant parameter is the domain extent. . Is there any concern about confusion between specifying the domain in terms of bounding cell faces versus cell centers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-536199890:288,simpl,simply,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-536199890,1,['simpl'],['simply']
Usability,"The traditional 2.5D model retains $\partial_y vu + \partial_z wu$. Even in a QG setup, background field advection is still important. ; `flat` in the previous version means no variation in the `flat` direction but it now assumes no momentum flux variation in all directions for the `flat` direction velocity. . That's why I don't think turning off $\nabla \cdot \vec{u} u$ as `flat` default is GFD intuitive. Especially, it is not clearly indicated in the documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555:399,intuit,intuitive,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555,2,"['clear', 'intuit']","['clearly', 'intuitive']"
Usability,"The typo fix is good of course, but the fixes to commenting style will not produce the intended result when this example is compiled to markdown using Literate; I don’t think we want two extra primary headers. . To nonlinearize around something is similar to linearizing around something, except keeping the nonlinear terms! But @navidcy’s suggestion could be more clear and usual semantics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/527#issuecomment-550913680:365,clear,clear,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/527#issuecomment-550913680,1,['clear'],['clear']
Usability,The versions of some software are different. Should I delete the Julia clearly and re-run my previous steps?. How to delete Julia clearly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824065744:71,clear,clearly,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824065744,2,['clear'],['clearly']
Usability,The way forward here might be to just defined a `CheckpointedModel` struct with stuff we want to save to the checkpoint file. That way we can keep the struct simple and we won't have to worry about all sorts of weird things being serialized to disk.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177#issuecomment-483219835:158,simpl,simple,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177#issuecomment-483219835,1,['simpl'],['simple']
Usability,"The words do actually mean that for me as well, i.e. ""belonging to a thing by its very nature"" or ""originating from the outside"". But because I've never before heard them in the context of coordinate systems it was not totally obvious to me what their meaning in this context was _from just by seeing the name_. But it did became clear soon!. I think it's ok that some of the names aren't 100% self explanatory just by reading the name and you need to read a bit the docstring or something to understand 100% what these objects/methods are.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2190774936:330,clear,clear,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2190774936,1,['clear'],['clear']
Usability,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499:1029,simpl,simplest,1029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499,2,['simpl'],"['simplest', 'simply']"
Usability,"There are a few ways it could be implemented. One simple way is. ```julia; function mask_immersed_field(bop::BinaryOperation, value=zero(b.grid)); mask_immersed_field(bop.a, value); mask_immersed_field(bop.b, value); return nothing; end; ```. One could also be more specific, eg. ```julia; const FieldBinaryOperation = BinaryOperation{<:Any, <:Any, <:Any, <:Any, <:Field, <:Field}; ```. Then we are sure its a binary operation between two fields. And the operation can be restricted to addition as well. Just some ideas...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269866889:50,simpl,simple,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269866889,1,['simpl'],['simple']
Usability,"There are different thoughts as to what biharmonic means. Harmonic is clearer and we all agree that the harmonic operator is the Laplacian and looks like ; ```; \nabla^2 = \partial_xx + \partial_yy + \partial_zz. ; ```; Biharmonic is usually defined has the harmonic operator squared, which is ; ```; (\nabla^2)^2 = (\partial_xx + \partial_yy + \partial_zz)^2,; ```; which involves cross terms. What we mention in the docs is horizontal biharmonic plus vertical harmonic. Not something that rolls off the tongue. . The one that we currently used, is fourth-order hyperdiffusion, and makes a lot of sense in a lot of contexts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1279#issuecomment-747484630:70,clear,clearer,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279#issuecomment-747484630,1,['clear'],['clearer']
Usability,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627:16,simpl,simple,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627,2,['simpl'],['simple']
Usability,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:142,simpl,simply,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,"['intuit', 'simpl']","['intuitive', 'simply']"
Usability,"These are definitely cool ideas for progress statements!. I see logging as being much more general though. It should also be used when printing progress statements, but I think it's especially useful to have `@debug` messages in certain places to help with debugging. And maybe `@info` messages so the user knows what the model is doing. It could get noisy if we get carried away with them but a user staring at a blank screen for 3 minutes might not know that the GPU stuff is just compiling in the background. More responsive software feels more user-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998:517,responsiv,responsive,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998,2,"['responsiv', 'user-friendly']","['responsive', 'user-friendly']"
Usability,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:616,clear,clear,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400,1,['clear'],['clear']
Usability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:793,clear,clearer,793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,['clear'],"['clear', 'clearer']"
Usability,This PR is pretty simple so I'll try to revive it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1214#issuecomment-1104642228:18,simpl,simple,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214#issuecomment-1104642228,1,['simpl'],['simple']
Usability,"This PR might want to add a simple test that runs these functions to ensure this doesn't continue to happen (and improve coverage), rather than only fixing the current code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/557#issuecomment-563226383:28,simpl,simple,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/557#issuecomment-563226383,1,['simpl'],['simple']
Usability,This abstraction would also simplify the ECCO/SOSE LESbrary.jl setup although it's also messy due to other terms and me jamming in Interpolations.jl objects: https://github.com/CliMA/LESbrary.jl/blob/master/scripts/pilot_simulation.jl#L117-L145. It seems like some complex setups could benefit a lot from a background fields abstraction. It shouldn't affect performance since the two interaction terms should results in no-ops. > I think we would want this functionality to assume that the linear balances between background terms are somehow separately satisfied. Agree with this. Users are responsible for making sure that they impose sensible background fields (just like they are responsible for setting sensible fields).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-701523300:28,simpl,simplify,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-701523300,1,['simpl'],['simplify']
Usability,This apparently has to do with the fact that . ```julia; julia> grid1.zᵃᵃᶜ === grid2.zᵃᵃᶜ; false. julia> grid1.zᵃᵃᶠ === grid2.zᵃᵃᶠ; false. ```. I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:. ```julia; julia> zeros(3) == zeros(3); true. julia> zeros(3) === zeros(3); false. ```. which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: https://github.com/JuliaLang/julia/issues/4648,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945144113:364,intuit,intuitive,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945144113,1,['intuit'],['intuitive']
Usability,"This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`. Any suggestions on what I should do to improve this are very welcome. https://user-images.githubusercontent.com/8239041/168451788-556cf7ca-ade4-415f-ad84-40c57bfb303c.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126828919:200,learn,learn,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126828919,1,['learn'],['learn']
Usability,"This does it:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); B(args...) = 0; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); ```. You can use this in a test, something like. ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end. @test time_step_background_fields_with_closure_fluxes(arch); ```. If it throws an error, the test fails. This is a basic unit test which is always a good idea to write first. The next step is to write a test that confirms the functionality works _correctly_. This is an example of a hierarchy of tests proceeding from simple to complex.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320:1006,simpl,simple,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320,1,['simpl'],['simple']
Usability,"This is a plot of the shallow water benchmark times: cpu vs gpu. What do you think?. *Absolute Times*. ![shallow_water_times](https://user-images.githubusercontent.com/8239041/120535459-fc54ac00-c3b0-11eb-90a6-71010d09b7fa.png). *Speed Up*. ![shallow_water_benchmarks2](https://user-images.githubusercontent.com/8239041/120205347-dcc65380-c1f7-11eb-9674-8bb2514b3045.png). In theory, it should be easy to include the code to create this image in the benchmark script. However, because the garbage collector does not clear the memory, we actually have to run the script separately for the high resolution runs. Any advice on how to resolve this issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851504385:516,clear,clear,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-851504385,1,['clear'],['clear']
Usability,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:71,clear,clear,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893,1,['clear'],['clear']
Usability,"This is becoming a high priority issue now. We don't have to worry about using a second core to compute diagnostics yet but should develop some reusable kernels to compute, e.g. vertical profiles, covariances, etc. Unfortunately taking the horizontal average of a field via `mean()` is very slow on the GPU (scalar CuArray operations again) as we have to take the mean of `data(::Field)` or `ardata(::Field)`, which are non-contiguous views into a CuArray. We must use a non-contiguous view to ignore halos as including halos in the averaging would produce a wrong answer. This is what I've been doing for now which works okay (no scalar ops) but not great:; ```julia; function horizontal_avg(model, field); function havg(model); f = Array(ardata(field)); return mean(f, dims=[1, 2])[:]; end; return havg; end. function horizontal_avg(model, f1, f2); function havg(model); prod = Array(ardata(f1)) .* Array(ardata(f2)); return mean(prod, dims=[1, 2])[:]; end; return havg; end; ```. and some timings from a 256^3 simulation; ```; [ Info: Calculating JLD2 output Symbol[:T, :w, :kappaT, :v, :nu, :u]...; 1.049922 seconds (4.51 k allocations: 786.251 MiB, 50.95% gc time); [ Info: Writing JLD2 output Symbol[:T, :w, :kappaT, :v, :nu, :u]...; [ Info: Done writing (t: 6.914 s); [ Info: Calculating JLD2 output Symbol[:vv, :w, :kappaT, :nu, :S, :wv, :v, :uv, :ww, :u, :uw, :vu, :T, :wT, :wu, :uu, :vw]...; 6.309173 seconds (3.16 k allocations: 4.625 GiB, 52.27% gc time); [ Info: Writing JLD2 output Symbol[:vv, :w, :kappaT, :nu, :S, :wv, :v, :uv, :ww, :u, :uw, :vu, :T, :wT, :wu, :uu, :vw]...; [ Info: Done writing (t: 3.469 ms); ```. Shouldn't be hard to code up some simple kernels that do this quickly with minimal allocations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519582498:1666,simpl,simple,1666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186#issuecomment-519582498,1,['simpl'],['simple']
Usability,"This is great, though I'm wondering what it's role in the Oceananigans code base is. Is the intention to remove these bits once WENO is actually implemented in the code?. > Not sure if it'll generalize to 3D. Why not?. I think the first course of action may be to do something similar to what we did for the nonlinear equation of state: implement a simple new advection scheme (even as simple as first order upwind?) for the purpose of designing an `Advection` abstraction. WENO can come thereafter. We may actually need `MomentumAdvection` and `TracerAdvection` (in the absence of a separate `Equation` abstraction for each momentum and tracer equation).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-577858130:349,simpl,simple,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-577858130,2,['simpl'],['simple']
Usability,This is intuitive and a good idea moving forward. I like it!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1055498269:8,intuit,intuitive,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292#issuecomment-1055498269,1,['intuit'],['intuitive']
Usability,"This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088669067:62,intuit,intuitive,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088669067,2,['intuit'],['intuitive']
Usability,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:376,simpl,simple,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592,1,['simpl'],['simple']
Usability,"This is partially solved by #234 and #245. We still may want to introduce a new type for rotation. I was thinking that `Coriolis` and a new model field `model.coriolis` is actually more descriptive and specific than `Rotation`. Then we can write things like `f = coriolis.f`, which is utterly clear, and not have to worry about names like `fCor`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-498024032:293,clear,clear,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-498024032,1,['clear'],['clear']
Usability,"This is tough because there are an infinity of possible dumb mistakes. For many purposes, restricting the types of the keyword arguments may be simplest:. ```julia; julia> f(x; y::AbstractFloat=2.0) = x + y; f (generic function with 1 method). julia> f(1; y=2); ERROR: TypeError: in keyword argument y, expected AbstractFloat, got Int64; Stacktrace:; [1] (::getfield(Main, Symbol(""#kw##f"")))(::NamedTuple{(:y,),Tuple{Int64}}, ::typeof(f), ::Int64) at ./none:0; [2] top-level scope at REPL[6]:1; ```. I think this is a reasonable restriction for *outermost* constructors where we would otherwise use input validation that has exactly the same functional impact. Note that keyword arguments cannot be used for dispatch. Or, you can write a function:. ```julia; function validate_instance(argname, a); typeof(a) <: Type && throw(ArgumentError(""Argument $argname = $a is a `Type` rather than an instance of the type $a. Perhaps you meant to write $argname = $a()?"")); return nothing; end; ```. Then you can write. ```julia; validate_instance(""buoyancy"", buoyancy); ```. Or write a loop. ```julia; [validate_instance(arg, eval(arg)) for arg in (:buoyancy, :closure, :architecture)]; ```. Seems like a black hole to me, but maybe people will benefit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-541374330:144,simpl,simplest,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465#issuecomment-541374330,1,['simpl'],['simplest']
Usability,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:622,simpl,simpler,622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,1,['simpl'],['simpler']
Usability,"This looks like a good start!. I think we should use multiples of 2 and 3 for the resolution in x and z (24, 48, 64, etc). This has some minor advantages for FFT performance, but more importantly is something of a convention that I think is nice to stick to. We may want to write a simple abstraction for specifying systems of reactions. I will think about that. What would be a good biochemical system to consider that involves a handful of reactive tracers?. @ali-ramadhan just to be clear, the diel vertical migration cycle is something that's computed offline? In other words, we are not modeling the vertical motion of individual plankton in this model. We can, however, model other tracers directly in Oceananigans, such as nutrient concentrations, CO2, and carbonates that contribute to dissolved inorganic carbon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629398620:282,simpl,simple,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629398620,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,This looks like a great simple test. Perhaps `time_step_wizard_shallow_water_model_works` is a good name for the function? You may want `stop_iteration=2` to ensure that the `update_dt` works as expected.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698:24,simpl,simple,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764812698,1,['simpl'],['simple']
Usability,"This looks very much like a bug. We have used particle tracking on immersed grids many times in the past. That kernel should work for both immersed and not-immersed grids, the fix should be simple. It looks like this feature is not tested, so; it would be nice to add a test, (something simple like a particle bouncing off a wall in a 1D domain with an immersed boundary compared to a Bounded domain). @tomchor do you want (or have time) to tackle this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3761#issuecomment-2332079749:190,simpl,simple,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761#issuecomment-2332079749,2,['simpl'],['simple']
Usability,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:454,clear,clearer,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999,1,['clear'],['clearer']
Usability,This seems like a pretty nice design. I'm just concerned about mixing diagnostics with output writers. I think we kinda agreed to merge diagnostics and output writers. Would doing so simplify the `WindowedTimeAverage`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-672259073:183,simpl,simplify,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-672259073,1,['simpl'],['simplify']
Usability,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:43,simpl,simple,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559,2,"['clear', 'simpl']","['clearly', 'simple']"
Usability,"This sounds great and am glad we are discussing it. This is something we could also do in `ShallowWaterModel` and wouldn't require any changes to the pressure solver, because there is none. Might this be a simpler first step? Or maybe just very different?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934701973:206,simpl,simpler,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833#issuecomment-934701973,1,['simpl'],['simpler']
Usability,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:314,simpl,simply,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,1,['simpl'],['simply']
Usability,"This sounds really useful! . I kept reusing some code for wall (just with a flat-bottomed domain) and wind stress so I put some bits together in [this package](https://github.com/jagoosw/Walrus.jl) and I came to the same conclusion of having functions that make the boundary conditions so I could just write:. ```julia; stress_boundary_conditions = WallStressBoundaryConditions(). boundary_conditions = (u = FieldBoundaryConditions(bottom = stress_boundary_conditions.u),; v = FieldBoundaryConditions(bottom = stress_boundary_conditions.v)); ```. The way I did it was to make a type for `WindStress` which could have different models for the drag coefficient and parameters. The only other thing I learned from doing it was that it was very useful to precompute roughness lengths for different speeds rather than compute them on the fly since they're well behaved functions that I could interpolate easily. (There is some inefficiency in the code that I did the wind and wall stress separately, even though they're basically the same thing, but a kind of merge of how I did each would probably be the most general way todo it because I put more work into the wind stress and just have the very simple flat bottomed law of the wall wall stress. Also, the code is not well-tested and probably won't work on non-rectilinear grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2385865288:698,learn,learned,698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807#issuecomment-2385865288,2,"['learn', 'simpl']","['learned', 'simple']"
Usability,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:683,simpl,simply,683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543,1,['simpl'],['simply']
Usability,"To be clear, the purpose of the constants is to support intuitive scripting patterns like. ```julia; Δt = 10minute; finaltime = 4day; ```. Changing `day` to `seconds_per_day` subverts this intent. I also think we need to be a little more sensitive to the effect that excessive verbosity has on code readability moving forward. I am fine with moving the constants to `planetary_constants.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515257986:6,clear,clear,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515257986,2,"['clear', 'intuit']","['clear', 'intuitive']"
Usability,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609:139,simpl,simply,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609,2,['simpl'],"['simplest', 'simply']"
Usability,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:42,simpl,simple,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839,3,['simpl'],['simple']
Usability,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:269,user-friendly,user-friendly,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652,1,['user-friendly'],['user-friendly']
Usability,"To summarize where we're at: we need at least two unit tests:; - a functionality test, like as proposed and implemented by @glwagner [here]:(https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433253320); ```julia; B(args...) = 0; function time_step_background_fields_with_closure_fluxes(arch); grid = RectilinearGrid(arch, size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B); model = NonhydrostaticModel(; grid, background_fields); time_step!(model, 1); return true; end; ```. @test time_step_background_fields_with_closure_fluxes(arch). - a correctness test, like the 1D diffusion example I proposed [here](https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2287291950) but have not yet implemented:; > The simplest test would be a 1D simulation with a background linear tracer profile with boundary conditions of Flux = − κ ∂ z c at the top and bottom. The correct solution would be that nothing happens when the simulation is time-stepped.; ; @liuchihl, can you create a PR into [Greg's branch](https://github.com/CliMA/Oceananigans.jl/tree/glw/background-flux-divergence) that adds both of these tests to the test suite?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433768523:824,simpl,simplest,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433768523,1,['simpl'],['simplest']
Usability,"True. Yeah I added a couple during PRs #410 and #474 but found it hard to test as most of our functions do not produce simple output, they usually modify the internal state of model. For example, a `jldoctest` for the `RegularCartesianGrid` examples only really ends up testing that the `show(::RegularCartesianGrid)` function produces the expected output. There are probably a few docstrings that will benefit from doctests, but the vast majority might not. If we just don't want the docstring examples to go out of date we should probably use `@example` block that Documenter provides: https://juliadocs.github.io/Documenter.jl/stable/man/syntax/#@example-block-1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/493#issuecomment-545119997:119,simpl,simple,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/493#issuecomment-545119997,1,['simpl'],['simple']
Usability,"Typing the kwargs seems like the simple, easy solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1204#issuecomment-733185262:33,simpl,simple,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1204#issuecomment-733185262,1,['simpl'],['simple']
Usability,"Unfortunately I don't think it's that simple:. ```julia; julia> model.tracers.T; Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}}, size: (130, 130, 3); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=128, Ny=128, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> minimum(interior(model.tracers.T)); ERROR: scalar getindex is disallowed; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779869124:38,simpl,simple,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1117#issuecomment-779869124,1,['simpl'],['simple']
Usability,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372:1217,clear,clearer,1217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372,1,['clear'],['clearer']
Usability,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828:44,clear,clear,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828,1,['clear'],['clear']
Usability,"Very exciting results! Thanks for sharing the plots and animations @simone-silvestri . I am very keen to help with the `ShallowWaterModel` and am sure we can get something working, after we figure out exactly what we want. I am a little surprised that Coriolis might play a problem as those terms don't invovle any derivitaves and so are usually the simplest. But there is probably something I'm not getting. I am happy to think about this more tomorrow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064730470:350,simpl,simplest,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064730470,1,['simpl'],['simplest']
Usability,"Very good point @navidcy!. Instead of trying to do this first, it makes more sense to include simple topography. I'll start with the example and include the affect of shelflike topography, as Glenn and I did in this paper. It should be easy to set up and will teach us how to include topography in a much simpler setting. https://journals.ametsoc.org/view/journals/phoc/35/5/jpo2719.1.xml?tab_body=abstract-display",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973422544:94,simpl,simple,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973422544,2,['simpl'],"['simple', 'simpler']"
Usability,"Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815284094>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQICFGOXKMU4HFN3NOLTHTG3PANCNFSM42RDHB2Q>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815341207:245,learn,learn,245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815341207,1,['learn'],['learn']
Usability,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:151,clear,clearer,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748,1,['clear'],['clearer']
Usability,"Wall models should be relatively simple to implement, see `eady_turbulence.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/examples/eady_turbulence.jl#L160-L169",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739538031:33,simpl,simple,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1183#issuecomment-739538031,1,['simpl'],['simple']
Usability,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:423,clear,clear,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,1,['clear'],['clear']
Usability,Was mostly trying to figure out the user API; implementation is clear.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732386424:64,clear,clear,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732386424,1,['clear'],['clear']
Usability,"We can apply 4 pretty immediately and start speeding up things if everyone agrees. . @glwagner I'm curious as to why you think we should remove that example. Also, do we need the diffusion example? One might argue that the 2D turbulence example is almost as simple and introductory, while being more illustrative of ocean simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1063185935:258,simpl,simple,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1063185935,1,['simpl'],['simple']
Usability,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:425,clear,clear,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693,1,['clear'],['clear']
Usability,"We can design a functionality that just uses left and right (which is; simple and general) and then write an additional layer over that to allow; users to use top and bottom in their scripts should they feel that is; better. On Thu, Feb 28, 2019 at 9:53 AM Ali Ramadhan <notifications@github.com>; wrote:. > Ah I see your point now. I still feel that using :left and :right for the; > *x* and *y* directions and :top and :bottom for the *z*-direction is; > clearer but this is a minor point.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/ali-ramadhan/Oceananigans.jl/issues/86#issuecomment-468301754>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBouO9TFg22xuLABdn7LbNTBjYoOEks5vR-1fgaJpZM4bVnpG>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468304309:71,simpl,simple,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86#issuecomment-468304309,2,"['clear', 'simpl']","['clearer', 'simple']"
Usability,We can undo the merging by `git reset --hard ae12376d1e31128e2e17e6b9447e75d37510e550`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482192734:7,undo,undo,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3026#issuecomment-1482192734,1,['undo'],['undo']
Usability,We can undo this. Didn't know.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235829416:7,undo,undo,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235829416,1,['undo'],['undo']
Usability,"We can't specify this at the moment because the forcing function does not take the currently model time `t` as an argument. I'm not sure whether you mean a barotropic tide or an internal tide. For a barotropic tide it would simply be something like `U/σ * sin(σ*t)`, where `U` is the tidal velocity and `σ` is the tidal frequency. A barotropic tide is not very interesting in the model right now because the bottom is flat. So it would have no effect on the solution. For an internal tide you are actually forcing an internal wave, so you design a forcing so that it excites a motion that satisfies the internal wave dispersion relation. This is potentially interesting because an internal tide induces strains that can modulate the intensity of small-scale turbulence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/212#issuecomment-501711754:224,simpl,simply,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/212#issuecomment-501711754,1,['simpl'],['simply']
Usability,"We don't support NormalFlow boundary conditions _emerging_ from an immersed boundary. The sponge is also centered on y = 0, where the southern boundary is. I think the means the solution is strongly damped throughout the entire domain?. An interesting case to simulate might be east-west flow _past_ a cape, idealized as a Gaussian excursion from the southern boundary. In this case we will want inflow in the west and outflow in the east. A simple starting point is to make the domain periodic in x and bounded in y, with an initial height h=1 and transport uh=1 everywhere. If that works, a sponge layer could be added downstream to idealize a cape embedded in a free stream. I wouldn't use NormalFlow unless it's really needed to shrink the domain, or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852657583:442,simpl,simple,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852657583,1,['simpl'],['simple']
Usability,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:255,learn,learned,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,1,['learn'],['learned']
Usability,"We now have some simple boundary condition physics test thanks to PR #118 and a couple of golden master tests in PR #140. #136 has some more specific physics tests that will be implemented. We should either come up with some concrete goals for this issue to become resolvable, or we should close it and rely on it for inspiration in designing future tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-475243811:17,simpl,simple,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-475243811,1,['simpl'],['simple']
Usability,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794:228,clear,clear,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"We should close this, but I'd like to leave an explanatory note in case others want to weigh in. This issue is really about ""vision"" than something missing with output writers. This issue really proposes that we think about JLD2 output differently (perhaps, in a way that's similar to how NetCDF views output). In that mode output would be somewhat independent of Oceananigans; if we output ""sliced"" data, then we could also output a ""sliced grid"" that represents the portion of the grid on which the data lives. One might then be able to load data and a grid ""simply"" (ie as `Array`s) and make sense of it without `using Oceananigans`. But since this issue was opened we have implemented `Field.indices` to move towards more full support for ""windowed"" or ""sliced"" fields (not _only_ when writing output), which sends us in a slightly different direction. Now a single output writer can be used to output fields that are differently sliced or windowed. We also support loading sliced fields with `FieldTimeSeries` (which is then able to correctly locate sliced fields on a grid), and doing further computations with those fields (we even envision supporting computations between fields that are sliced differently by computing index ""intersections""). Since we do save index information now when we slice a field, it is actually possible to manually slice a grid after data has been outputted. So savvy users can achieve this functionality with themselves if they (for some reason) are allergic to `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1194#issuecomment-1115175994:561,simpl,simply,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194#issuecomment-1115175994,1,['simpl'],['simply']
Usability,"We should now be able to create cubed sphere face grids from the JLD2 files in https://github.com/CliMA/OceananigansArtifacts.jl using. ```julia; using DataDeps; using Oceananigans. dd = DataDep(""cubed_sphere_32_grid"",; ""Conformal cubed sphere grid with 32×32 grid points on each face"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cubed_sphere_32_grid.jld2"",; ""3cc5d86290c3af028cddfa47e61e095ee470fe6f8d779c845de09da2f1abeb15"" # sha256sum; ). DataDeps.register(dd). cs32_filepath = datadep""cubed_sphere_32_grid/cubed_sphere_32_grid.jld2""; grid = ConformalCubedSphereFaceGrid(cs32_filepath, face=6, Nz=1, z=(-1, 0)); ```. so we should be able to start running some simple tests on single faces!. Should we merge and work on testing in subsequent PRs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745:700,simpl,simple,700,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-797074745,1,['simpl'],['simple']
Usability,"We should probably improve our suite of examples. Some ideas:. * I think the thermal bubble might be a decent one to re-instate, since it's extremely simple.; * We may want to simply / reduce the length of the internal wave example. It could also be simplified if waves were excited by forcing rather than initial condition... ?; * I think reducing ""deepening mixed layer"" to free convection would be a good idea; * Some simplified version of stratified Couette flow might be nice to show the use of no-slip boundary conditions; * Driven cavity? What else? More ocean-y examples?. We haven't discussed tutorials; perhaps this is out the window.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061:150,simpl,simple,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531048061,4,['simpl'],"['simple', 'simplified', 'simply']"
Usability,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:126,learn,learned,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232,1,['learn'],['learned']
Usability,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:330,simpl,simpler,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319,1,['simpl'],['simpler']
Usability,"We'll also write a simple script that solves a problem:. ```julia; using Oceananigans; using Krylov. # make a grid; # choose a preconditioner; solver = Oceananigans.Solvers.KrylovPoissonSolver(grid; preconditioner=cool_preconditioner). x = CenterField(grid); b = CenterField(grid); set!(b, rand(size(grid)...)); solve!(x, solver, b); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2383598140:19,simpl,simple,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2383598140,1,['simpl'],['simple']
Usability,"We've borrowed heavily from other projects in putting that together, so by all means feel free to borrow! I have no idea how/if the license applies to a Contributor's guide.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/436#issuecomment-537140670:167,guid,guide,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436#issuecomment-537140670,1,['guid'],['guide']
Usability,Well `sum` definitely won't work (it has to be a simple single-argument transformation) but you could try a function like. ```julia; square(x) = x * x; ```. or `log` if you want to be adventurous,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753:49,simpl,simple,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1995001753,1,['simpl'],['simple']
Usability,"Well to be clear, the name we are searching for is something that can describe _both_ reductions like sum, maximum, minimum (and average and integral, which are similar to sum but involve grid metrics) --- _and_ operations like cumsum. The things these have in common (in contrast to local operations like derivative, plus, minus, etc) is that they involve a loop over one or more dimensions (which is why they have a `dims` property) and therefore cannot be evaluated locally, they have to be precomputed. For example, we could envision also supporting `sort!` through the `Scan` abstraction... The key property of a reduction is that its output is _also_ lower dimensionality than the input, the `dims` are collapsed. On the other hand `sort!` and `cumsum!` have output with the same dimension as the input. So we need a few things to build the abstraction. First we need a name that encompasses reductions, plus cumsum and sort. Second, we need another pair of names that express the distinction between a ""reduction"" and a non-dimensionality-changing-yet-still-scanning operation like cumsum and sort. I meant the term ""scan"" simply to mean literally that we are going to traverse one or more dimensions (eg scanning the dimension). No doubt it can be improved but the improvement needs to be sufficiently general. that's the whole challenge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2108741773:11,clear,clear,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2108741773,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"Well!. It looks like the ""compute capability"" of an NVIDIA device determines the kind of computations it can do:. https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capabilities. Your device, which is an ""NVS 310"", has a compute capability of 2.1:. https://developer.nvidia.com/cuda-gpus. Apparently this compute capability is not supported by the julia CUDA tools. So I'm not sure you can resolve this issue, other than finding a different GPU. The issue you pasted briefly explains why this might be the case; it has something to do with the compiler used by `CUDAdrv`?. We typically use the Tesla V100 or P100, which apparently have compute capabilities of 7.0 or 6.0. I'm not 100% sure the NVS 310 would accelerate computations relative to your CPU anyways. It only has 48 cores (compared to 5,120 for a Tesla V100), and 512 MB of memory?. https://www.nvidia.com/en-us/design-visualization/nvs-graphics-cards/. Do you have access to a cluster with GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539791534:162,guid,guide,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451#issuecomment-539791534,1,['guid'],['guide']
Usability,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:532,simpl,simple,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['simpl'],['simple']
Usability,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199:129,learn,learn,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199,1,['learn'],['learn']
Usability,"Well, right now, the `Model` includes both discrete and continuous aspects of the PDE. `Model` also stores `architecture`, for example, which is unrelated to the PDE. We did consider an abstraction that represented the equation set independent from discretization. This would not be a replacement for model, but would simply be a way to organize some of the properties of model (eg buoyancy, coriolis, diffusion, etc). Yet this is a challenging abstraction to design. One issue is specification. If we try to separate the terms from their numerical implementation, we have to figure how to distinguish between ""diffusion with second-order differences"" and ""diffusion with fourth-order differences"". It's clearly possible to do this, but it's going to take some time and careful thought to implement. We've taken a more incremental approach to development the model instead, resulting in a fairly ""flat"" interface to `IncompressibleModel` that combines aspects both of the continuous equations, their discretization, and things like `architecture`, the `pressure_solver`, etc. I think flat is simple (think parameter files as the platonic ideal of a flat API); however, we still want to benefit from modularity where it's a simple change that doesn't overcomplicate the interface (hence this issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548:318,simpl,simply,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548,4,"['clear', 'simpl']","['clearly', 'simple', 'simply']"
Usability,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:886,guid,guideline,886,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,1,['guid'],['guideline']
Usability,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514:533,simpl,simplest,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514,1,['simpl'],['simplest']
Usability,What do folks think about the name `force` for the keyword that determines whether or not to overwrite an existing file? I'm thinking that something more verbose like `force_overwrite` might be clearer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-718711091:194,clear,clearer,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963#issuecomment-718711091,1,['clear'],['clearer']
Usability,"What do we expect to happen?. I think its physically impossible to have a constant velocity emerging / impinging on a box. This is clear in 1D; I don't think the picture changes in 3D. ~~I think the mean momentum in a bounded direction must be zero.~~. EDIT: actually don't think my last comment is true, but I do think this behavior is expected. It's a bit simpler to think about 2D and just one constant velocity field. In this case all the terms in the momentum equation are zero except at the walls, where there is a large, uniform divergence `du/dx` due to the satisfaction of the no normal flow boundary condition there. It does seem like `d/dx (u^2)` should be non-zero in wall-adjacent points. But evidently the main effect is that a large, domain spanning pressure gradient is implied which exactly cancels the momentum in the initial condition, leading to a divergence-free (and zero) velocity field... If there were a `NormalFlow` boundary condition equal to this initial condition then hopefully the velocities would remain constant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/951#issuecomment-693758931:131,clear,clear,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/951#issuecomment-693758931,2,"['clear', 'simpl']","['clear', 'simpler']"
Usability,"What do you mean by 'fetched'? Are you referring to memory movement from main memory to cache?. I don't know much about cache optimization, but I think a guideline is that nearby operations should be nearby in memory. For example, when looping over elements of an array `u[i]`, your machine will use a linear forecast to bring `u[i-1], u[i-2], u[i+1], u[i+2]` into the cache simultaneous to `u[i]`. This idea leads to the 'struct of arrays' optimization when running loops over the elements of many arrays simultaneously. This may be useful:. https://software.intel.com/en-us/articles/memory-layout-transformations",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462541310:154,guid,guideline,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462541310,1,['guid'],['guideline']
Usability,"What does J-M think?; John. On Mon, Mar 9, 2020, 3:07 PM rafferrari <notifications@github.com> wrote:. > The Roquet’s approximation is perfectly sufficient for Oceananigans,; > because it will never be used for global calculations where local; > approximations are an issue. However I agree with everybody else that it; > would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that; > case we should adopt TEOS-10. Be warned that it is quite inefficient; > through. So we may be hit performance-wise. Hard to tell without trying.; >; > Raffaele; >; >; >; > > On Mar 9, 2020, at 11:48 AM, Gregory L. Wagner <notifications@github.com>; > wrote:; > >; > > I also think it’s a good idea to use a full equation of state for all; > simulations sooner rather than later. It’s simpler: we won’t have to report; > constants of linearization everywhere. And setting up simulations will be; > easier.; > >; > > I’ll defer to the modelers for whether Roquet’s approximation is an; > acceptable model for TEOS-10.; > >; > > This package is relevant and we should consider contributing to it; > rather than implementing an equation of state somewhere in the Clima; > ecosystem:; > >; > > https://github.com/gher-ulg/PhysOcean.jl <; > https://github.com/gher-ulg/PhysOcean.jl>; > > —; > > You are receiving this because you were mentioned.; > > Reply to this email directly, view it on GitHub <; > https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AK24ROIBMZMYD77AGEZNM3DRGUMURA5CNFSM4LEKJAAKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEOHZCYQ#issuecomment-596611426>,; > or unsubscribe <; > https://github.com/notifications/unsubscribe-auth/AK24ROONT4RO4YCCF6BTIIDRGUMURANCNFSM4LEKJAAA; > >.; > >; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AKXUEQUJLIMSIC2HX",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596864018:785,simpl,simpler,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596864018,1,['simpl'],['simpler']
Usability,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:415,clear,clear,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917,1,['clear'],['clear']
Usability,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501:398,simpl,simply,398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501,1,['simpl'],['simply']
Usability,"What is the intent of these tests? Are they intended to be included in CI, or are they more in the style of “benchmarks” that are run relatively infrequently?. @edoddridge A twist on option 1 is to design a forcing that exactly cancels the terms associated with nonlinear and linear terms in a given equation for some simple initial condition consisting of sines and cosines. For example, pick an initial condition, calculate all terms in a given equation, and then write a forcing that exactly cancels those terms. Then check that the initial condition doesn’t change after a few time-steps. This method allows a test at low resolution with low computational burden and allows each nonlinear and linear term in each equation to be assessed separately. . It would also be good to run “benchmarks” that are designed to be run less frequently, which is a category I think some of the suggested tests fall into (?) Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242:318,simpl,simple,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242,1,['simpl'],['simple']
Usability,"What parallelism strategy makes sense? One particle per thread? Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Presumably `TimeSeries` makes sense for simple diagnosed particle ""properties"" and is the place to start. Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design, especially because our time stepping is not very abstracted yet. If we are integrated with DifferentialEquations this job might get a bit easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123:240,simpl,simple,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123,1,['simpl'],['simple']
Usability,"What you've done with the examples makes more sense now if viewed as utilitarian examples meant to show case how you can interact with the code. For users who are trying to familiarize themselves with Julia, maybe it could help if we further split the time stepping and plotting so that all time stepping happens in the first `n` lines and afterwards some plotting happens so it's clearer to the user what is Oceananigans code and what is plotting code. But yeah I'm happy with the examples in this PR. There will be plenty of opportunities to improve. Should we merge this now? The docs have been improved, and would be good to start getting some feedback.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-545434983:381,clear,clearer,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-545434983,2,"['clear', 'feedback']","['clearer', 'feedback']"
Usability,"What's wrong with using a twice-precision step size?. The advantage of ranges is that they are a lot faster --- this is why such attention was paid to ranges in designing them in julia base. This affects simulations that use coordinates in GPU kernels. We probably should have a very good reason for using arrays when there are clear advantages to ranges, eg arrays should improve the experience of most users (I don't see why it matters).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/544#issuecomment-563233384:328,clear,clear,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/544#issuecomment-563233384,1,['clear'],['clear']
Usability,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:183,simpl,simpler,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,1,['simpl'],['simpler']
Usability,"When running the script on a CPU with `--check-bounds=yes`, the script can be finished without errors:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:457,clear,clear,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,1,['clear'],['clear']
Usability,When we switch to finite volume operators (PR #283) it'll become much clearer where we are imposing no-flux and zero gradient conditions which should help along with comments like `# no penetration` and `# no-gradient condition`. We also switch from `▶` to `ϊ (\iota\ddot)` for interpolation but we can take care of these later. Would be good to have the turbulence closures using `Oceananigans.Operators` instead of redefining their own operators when I get back to working on #283 and #47.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508952122:70,clear,clearer,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508952122,1,['clear'],['clearer']
Usability,"While bathymetry is not a priority at the moment, there may be simple, non-invasive methods (from an algorithms standpoint) like the one described in the slack message pasted by @ali-ramadhan for modeling non-rectangular domains. . Probably the main challenge is not implementing the method (which could take a few days), but verifying and validating the implementation (more likely a few weeks of work at minimum). A collaboration with others who are knowledgeable in Julia and can participate in debugging and validation is probably the best chance for having this feature implemented any time soon, given the time constraints of the main developers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644:63,simpl,simple,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644,1,['simpl'],['simple']
Usability,"While we are breaking the API, why not use `size` instead of `N`, so its. ```julia; RegularCartesianGrid(Float64; size=(10, 10, 10), x=(-5, 5), y=(-π, π), z=(0, 1)); ```. It's not only more verbose but also removes the sometimes painful fact that we really want to use `N` to mean 'buoyancy frequency' in many contexts. It's unfortunate if we remove that potential for clear nomenclature in scripts for geophysical stuff. I'd also propose adding a constructor of the form. ```julia; RegularCartesianGrid(FT, nx, ny, nz; length) = RegularCartesianGrid(FT; size=(nx, ny, nz), ; x=(-length[1]/2, length[1]/2), y=(-length[2]/2, length[2]/2), z=(-length[3], 0)); ```. This has a syntax similar to the `Base` function `zeros`, which is nice. Also, we add a small nod to ""Oceans"" by putting `z[nx+1]` at the surface. In addition we can add. ```julia; RegularCartesianGrid(FT, size::Tuple; length) = RegularCartesianGrid(FT, size...; length); ```. (Along with the corresponding constructors with default float types.). I'm not too fond of `RegularCartesianGrid(size, length)`, but happy to keep it around if some find it useful, we just don't need to use it in examples and docs. We've also never discussed this --- but why do we use `Nx` rather than `nx`? I find it harder to type; plus julia uses capital letters for types so its a bit of a break in pattern; almost everything else is lowercase. Edit: if `size` isn't satisfactory, we could try `resolution` or `number_grid_points` (ugly... 😒) instead.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541315939:369,clear,clear,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-541315939,1,['clear'],['clear']
Usability,"Why not just extract the tracers to be scaled in advance of launching the kernel?. ```julia; tracers_to_scale = Tuple(fields[name] for name in keys(scale.tracers)); # launch kernel, indexing from 1:length(tracers_to_scale); ```. You can also launch one kernel per tracer which might be ok and a bit simpler which is nice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1718747355:299,simpl,simpler,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1718747355,1,['simpl'],['simpler']
Usability,"With `advection = CenteredSecondOrder()`, the differences are more dramatic (maybe explains the 100x slow down I saw with a simple setup):. ```julia; 17.859 s (144483404 allocations: 94.43 GiB) # KA 0.8; 294.401 ms (118604 allocations: 52.20 MiB) # KA 0.7; ```. If we look just at `calculate_tendencies!` via. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: calculate_tendencies!; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; #time_step!(model, Δt); calculate_tendencies!(model, []); end; end. @btime lots_of_steps!(model, 0.01); ```. results are (`advection = WENO()`). ```julia; 5.268 s (23061000 allocations: 11.73 GiB) # KA 0.8; 1.989 s (14600 allocations: 13.03 MiB) # KA 0.7; ```. and `advection = CenteredSecondOrder()`. ```julia; 2.846 s (23061000 allocations: 11.73 GiB) # KA 0.8; 105.867 ms (14600 allocations: 13.03 MiB) # KA 0.7; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481310062:124,simpl,simple,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481310062,1,['simpl'],['simple']
Usability,"With my student, I wanted to look at flow over a tall seamount and icemount, like many people have done. That is a first step, but then I want her to look at sigma-coordinates, as we discussed. One goal is to compare the two and to learn more about their respective strengths and weaknesses. I have ran the example you created in this PR on my local computer and it's been 3 hours and it's still going. Is that to be expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867209568:232,learn,learn,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867209568,1,['learn'],['learn']
Usability,"With no background diffusivity I also find the energy increases slowly. This is with WENO advection scheme. https://user-images.githubusercontent.com/15271942/221060649-86deb92a-45c3-401d-96ac-3dceabacc686.mp4. Perhaps one could compute the discrete conservation laws for the linear wave equations here given our staggered discretization of buoyancy / hydrostatic pressure + nonhydrostatic pressure... I'm not sure what we would find. It's not that simple, because nonhydrostatic pressure is treated implicitly / with a fractional step. Our hydrostatic pressure scheme is not the only possible scheme one might use. Perhaps other schemes have different numerical properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489:449,simpl,simple,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442609489,1,['simpl'],['simple']
Usability,"Won't this prevent us from doing simple stuff like creating a grid with size (1, 1, 1) that has the default halos -- (3, 3, 3)?. It's better to use `map` than broadcasting btw",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002553157:33,simpl,simple,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3516#issuecomment-2002553157,1,['simpl'],['simple']
Usability,"Would it make sense to initialize with the analytical solution to the (linear or weakly nonlinear) barotropic problem? Even if a simple Laplacian viscosity is a poor parameterization for eddy effects, it should dramatically accelerate the equilibration process, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493:129,simpl,simple,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493,1,['simpl'],['simple']
Usability,Wow! So many interesting things here and thanks for guiding me along the path to figure this out. . I will give this a try now and let you know if it resolves this problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684023:52,guid,guiding,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684023,1,['guid'],['guiding']
Usability,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:283,clear,clearer,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,1,['clear'],['clearer']
Usability,"WxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `19.23% <0%> (-4.58%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0%> (-1.62%)` | :arrow_down: |; | [...lence\_closure\_implementations/smagorinsky\_lilly.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3NtYWdvcmluc2t5X2xpbGx5Lmps) | `92.85% <100%> (-0.76%)` | :arrow_down: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `80% <100%> (+10%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <100%> (ø)` | :arrow_up: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `81.81% <88.23%> (+1.17%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=footer). Last update [6f40796...c53227c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/520?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706:3826,learn,learn,3826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/520#issuecomment-548763706,1,['learn'],['learn']
Usability,"XJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100.00% <ø> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `76.19% <ø> (+4.76%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <ø> (-32.36%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `100.00% <ø> (+25.00%)` | :arrow_up: |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=footer). Last update [3f491e7...c789ec6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/765?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496:3125,learn,learn,3125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/765#issuecomment-637790496,1,['learn'],['learn']
Usability,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...7e7449e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941:3671,learn,learn,3671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135941,1,['learn'],['learn']
Usability,"Y29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `100% <100%> (+40.54%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.97% <100%> (-0.61%)` | :arrow_down: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <23.95%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `53.33% <53.33%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <67.79%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <69.72%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=footer). Last update [5a12ab6...be136c3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/383?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943:3667,learn,learn,3667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383#issuecomment-526135943,1,['learn'],['learn']
Usability,"Y2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `35.84% <0%> (-2.45%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | [src/Solvers/triply\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvdHJpcGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | ... and [41 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=footer). Last update [4ed3660...2610b13](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/636?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940:3609,learn,learn,3609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/636#issuecomment-589657940,1,['learn'],['learn']
Usability,"Y3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=footer). Last update [417e890...73a6798](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:3372,learn,learn,3372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['learn'],['learn']
Usability,Yeah I don't know... I was going to email around for quotes to see if they have any premium/custom set ups with GPUs and multiple CPUs. If they're just spinning up VMs on the cloud then maybe it's just as simple as requesting a multi-core CPU with 2-4 GPUs (which I know is available on Google Cloud). But after factoring in support cost it might be pretty steep.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474808481:205,simpl,simple,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474808481,1,['simpl'],['simple']
Usability,"Yeah I guess we're pretty restricted in our thread-block layouts although it should be easy to generate them for all the grids we usually use. The important thing is that we can run on a wide variety of useful grid sizes, instead of being restricted to multiples of 16 in the horizontal like we are right now. It's also important to keep the kernel indexing intuitive, e.g. this kernel does things point-wise so it gets a triple for-loop, another kernel does things column-wise so it gets a double for-loop and a third unrolled inner loop, another only acts on the surface and bottom, etc. So maybe it's not worth introducing `Tz` (which might complicate the kernels) unless we know it'll improve performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496545455:358,intuit,intuitive,358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496545455,1,['intuit'],['intuitive']
Usability,Yeah I should have been clearer. I meant that it could increase compile times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429566787:24,clear,clearer,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429566787,1,['clear'],['clearer']
Usability,"Yeah I think it's just an unknown GPU compilation problem/failure. Unclear to me whether it's the fault of `Oceananigans.AbstractOperations` or something in CUDA.jl (or even KernelAbstractions.jl). > Certainly starting simple is what I would recommend. Maybe it makes sense to try and condense some abstract operations into an isolated minimal working example which we can use to open an issue on CUDA.jl if that turns out to be the problem? Might help isolate the problem, and would certainly be much easier to debug. I recall we encounter a limitation of the GPU compiler when trying to construct a GPU model with too many arbitrary tracers. I think in this case the type information was too large to even fit into the argument of a CUDA kernel or something so maybe this was a hard GPU limitation? Would be unfortunate if something similar is happening for complex abstract operations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738529401:219,simpl,simple,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738529401,1,['simpl'],['simple']
Usability,"Yeah I think simplifying the existing examples as much as possible would be good. I can add back the rising thermal bubble example. Stratified Couette flow would make a nice example, but I'm slightly against including it as it has to be run at high resolution (or with LES) to get proper results. Whereas you can run the other examples on your laptop and get good results quickly. I want to add the lid-driven cavity as it's even simpler than rising thermal bubble and is used a first example/tutorial for other CFD packages. But we'd have to impose no-slip via a forcing function as y boundary conditions aren't implemented yet, which makes it a bad example right now. Might also be good to have 1 example that uses an output writer, and another that uses both diagnostics and an output writer. Tutorials would be awesome, although I think simple examples are perhaps more important. I don't know, maybe not. Tutorials aren't required for JOSS, whereas examples are. @christophernhill might have some good thoughts here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531062053:13,simpl,simplifying,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/332#issuecomment-531062053,3,['simpl'],"['simple', 'simpler', 'simplifying']"
Usability,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908:70,clear,clearer,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908,3,"['clear', 'intuit', 'simpl']","['clearer', 'intuitive', 'simplify']"
Usability,"Yeah okay, both of those suggestions make sense and adding a line in update state is probably the most general solution too. Once I've cleaned up a bit I guess the only the last we would need to settle on for the simplest case is how we specify the form of $\phi^{n+1}$ (and how I've written the fill_bulk_outflow_halo file). Currently, it is hardcoded that it is upwinded when there is an outflow and relaxed to an external solution when it inflows as:. `(1 - Ūᵇ - 1/τ̄) * ϕⁿ + Ūᵇ * ϕᵢ₋₁ + ϕᵉ / τ̄`,. where $0 < U^b < 1 $, but conceivably it could be something along the lines of unwinding both ways like:. `(1 - Ūᵇ) * ϕⁿ + max(0, Ūᵇ) * ϕᵢ₋₁ - min(0, Ūᵇ) * ϕᵉ`. Perhaps if we change to:; ```julia; struct BulkOutflow{IS, OS} <: AbstractBoundaryConditionClassification; inflow_speed :: IS; outflow_speed :: OS; end; ```; then we can make it the general form:. $\phi^{n+1} _i = (1 - U_i - U_o) \phi^n + U_i \phi^e + U_o \phi^n _{i-1}$. with $0 < U_i, U_o < 1$ and only $U_i$ or $U_o$ can be non-zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978821684:213,simpl,simplest,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978821684,1,['simpl'],['simplest']
Usability,"Yeah this sounds like a good idea, since you probably want to make sure all outputs end up with the same float type. And it would simplify diagnostics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/901#issuecomment-686449294:130,simpl,simplify,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/901#issuecomment-686449294,1,['simpl'],['simplify']
Usability,Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2020691320:41,simpl,simple,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2020691320,1,['simpl'],['simple']
Usability,"Yeah, I've been noticing that a lot of simple PRs have been having failing tests lately. I haven't had time to investigate but I do find it kinda odd...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815947872:39,simpl,simple,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-815947872,1,['simpl'],['simple']
Usability,"Yeah, I've run quite a bit of tests at this point, and the issue seems persistent and (as far as I could tell) independent of topology (although I haven't tried every single topology option). Thanks for looking into this, btw. Let's hope it's something simple. Let me know how I can help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868184351:253,simpl,simple,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868184351,1,['simpl'],['simple']
Usability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:863,simpl,simplifying,863,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,1,['simpl'],['simplifying']
Usability,"Yes we have some notes on the Fourier Poisson solver here: https://climate-machine.github.io/Oceananigans.jl/latest/algorithm/#Discrete-Fourier-spectral-method-1. Yes we'd need a _new_ Poisson solver with Neumann boundary conditions in two directions but this would be a minor change. I think we'd just have to use the same wavenumbers in the _y_-direction as we do for the _z_-direction [see equations (47) and (48)] and use DCTs in the _y_-direction instead of FFTs. I think that should be it but not 100% sure if it's that simple. **Note**: It's only this simple if _Δy_ and _Δz_ are constants (well, _Δz_ can be variable #46). But if both _Δy_ and _Δz_ are variable, then the Poisson solve will become much slower and more difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198:526,simpl,simple,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198,2,['simpl'],['simple']
Usability,"Yes, a simple example would be great.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847392951:7,simpl,simple,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1691#issuecomment-847392951,1,['simpl'],['simple']
Usability,"Yes, should have mentioned it @tomchor. That's much simpler :) (no need to open issue etc..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799813301:52,simpl,simpler,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799813301,1,['simpl'],['simpler']
Usability,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:306,simpl,simple,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,1,['simpl'],['simple']
Usability,"Yes. The simplest way is to define a function `progress(sim)` that throws an error if your simulation NaNs, and pass this to `Simulation` when constructing it:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/simulation.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733253466:9,simpl,simplest,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196#issuecomment-733253466,1,['simpl'],['simplest']
Usability,"Yes. We've implemented some simple tests recently (https://github.com/climate-machine/Oceananigans.jl/issues/126, https://github.com/climate-machine/Oceananigans.jl/pull/118, https://github.com/climate-machine/Oceananigans.jl/pull/140) and we're working on https://github.com/climate-machine/Oceananigans.jl/issues/136 but we should definitely do more. Some tests will require a channel model which we're working towards (https://github.com/climate-machine/Oceananigans.jl/issues/100) but others that you've suggested should work in doubly periodic domains I think, e.g. spin down of a flow-field under the influence of friction, thermal wind balance, and Rayleigh–Bénard convection. Might be good to open issues for those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-478100649:28,simpl,simple,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-478100649,1,['simpl'],['simple']
Usability,"Yesterday we discussed solving the SW model in conservative form, which is a perfectly good approach. However, I remembered that there another formulation in terms of the velocity where we use the vorticity and the Bernouli function. This is also very nice and this approach shows there are the different finite difference formulations that ensure either energy or enstrophy conservation. I don't know how Finite Volume would compare, but I'm tempted to start with this for simplicity. http://www.aos.wisc.edu/~aos718/sadourny.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193:474,simpl,simplicity,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726852193,1,['simpl'],['simplicity']
Usability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:382,simpl,simplify,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,2,['simpl'],"['simple', 'simplify']"
Usability,"You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Try to split your computation into simpler abstract trees:; ```; @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = compute!(Field(∂x(u) + 1e-7)); dudz_tilt = compute!(Field(∂z(u)). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581675497:217,simpl,simpler,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581675497,1,['simpl'],['simpler']
Usability,You can merge this --- the changes are clearly enough concentrated in docs.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1736#issuecomment-854990278:39,clear,clearly,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1736#issuecomment-854990278,1,['clear'],['clearly']
Usability,"You mean have a GitHub action in the Docs repo and every week clear up all accumulated previews?; That's great! That would work amazingly. Do you know how to do this weekly schedule?; (Then we can also do it for ClimaOcean Docs repo, etc!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418:62,clear,clear,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3726#issuecomment-2308648418,1,['clear'],['clear']
Usability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:474,simpl,simple,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,1,['simpl'],['simple']
Usability,"You should use `FluxBoundaryCondition(nothing)` for zero flux boundary condition since it simplifies the code _slightly_ (the difference between ""adding 0"", and not calling a function at all). It's also the default so you shouldn't have to set it (this might've been an MWE --- just want to make sure people know). I think we should ""regularize"" boundary conditions with `Number` to `Float64`; we've seen this error a few times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176:90,simpl,simplifies,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176,1,['simpl'],['simplifies']
Usability,"ZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0%> (-6.67%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32% <0%> (-2.1%)` | :arrow_down: |; | [src/Solvers/box\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYm94X3ByZXNzdXJlX3NvbHZlci5qbA==) | `0% <0%> (ø)` | :arrow_up: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=footer). Last update [2019cb7...c627f48](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/644?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313:3625,learn,learn,3625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644#issuecomment-591088313,1,['learn'],['learn']
Usability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:812,simpl,simply,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,1,['simpl'],['simply']
Usability,"](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c1f4c3363201d16a872617cca6dc0f180b9ef82e?src=pr&el=desc) will **increase** coverage by `0.41%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #264 +/- ##; ==========================================; + Coverage 70.73% 71.14% +0.41% ; ==========================================; Files 23 23 ; Lines 868 870 +2 ; ==========================================; + Hits 614 619 +5 ; + Misses 254 251 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `78.78% <0%> (+11.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=footer). Last update [c1f4c33...32fc894](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/264?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184:1770,learn,learn,1770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/264#issuecomment-498487184,1,['learn'],['learn']
Usability,"_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfZGlmZnVzaXZpdHlfY2xvc3VyZXMuamw=) | `59.45% <100%> (ø)` | |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `83.33% <100%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <100%> (-58.53%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85.71% <100%> (-3.58%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <27.27%> (ø)` | |; | [src/turbulence\_closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY2xvc3VyZV9vcGVyYXRvcnMuamw=) | `42.62% <42.85%> (ø)` | |; | ... and [12 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=footer). Last update [c961d39...a40de27](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/312?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216:3447,learn,learn,3447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312#issuecomment-510662216,1,['learn'],['learn']
Usability,"_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <ø> (-57.62%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `30% <0%> (-29.71%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `68.33% <100%> (-1.67%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.68% <100%> (-1.9%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.5% <19.44%> (-6.41%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `46.83% <50%> (-15.19%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [848edd9...25cf2da](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877:2999,learn,learn,2999,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164877,1,['learn'],['learn']
Usability,"`91.42% <ø> (-0.24%)` | :arrow_down: |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `94.35% <ø> (+0.75%)` | :arrow_up: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `67.56% <73.33%> (+42.56%)` | :arrow_up: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <100.00%> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <100.00%> (ø)` | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `76.66% <100.00%> (-9.34%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=footer). Last update [8198ca7...871b448](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/850?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397:3065,learn,learn,3065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850#issuecomment-672128397,1,['learn'],['learn']
Usability,"`CUDA.CuArray`](https://juliagpu.gitlab.io/CUDA.jl/usage/array/https://juliagpu.gitlab.io/CUDA.jl/usage/array/). It looks like you are using an object called `df.taux` that comes out of the `CSV` package:. ```julia; spl_taux = Spline1D(secs, df.taux / ρₒ, k=1); ```. Provided that whatever `Spline1D` does is GPU-friendly (and it may not be), then you may only need to convert `df.taux / ρₒ` to a `CuArray` prior to passing it to `Spline1D`. I don't know if this code would work, but as an example of something you _might_ do:. ```julia; using CUDA. kinematic_x_momentum_flux = Array(df.taux / ρₒ); kinematic_x_momentum_flux = CuArray(kinematic_x_momentum_flux). spl_taux = Spline1D(secs, kinematic_x_momentum_flux, k=1); ```. The array `secs` may also need to be converted:. ```julia; secs = CuArray(secs); ```. `Spline1D` may not work on the GPU, but there seem to be other options. A google search for ""interpolation GPU julia"" turned up this page:. https://juliagpu.org/2020-10-30-cuda_2.1/. which has instructions for using some CUDA built-in interpolation functionality. In summary, if you're working with arrays on the GPU, you'll need to. * convert arrays to `CuArray` when using the GPU; * use interpolation / other functionality that's GPU-friendly. As a side note, a convenient way to program a script to be switchable from CPU to GPU easily is to include a line at the top like. ```julia; DeviceArrayType = arch isa GPU ? CuArray : Array; ```. and then use patterns like. ```julia; data = Array(df.data); data = convert(DeviceArrayType, data); ```. This allows you to switch between `arch = GPU()` and `arch = CPU()` with a single line at the top of your script. As a side, side note, julia does not require you to put semi-colons to end lines!. Please don't be afraid to simply try running your script and reporting the error you get (if any!) With a concrete error, we can make concrete suggestions to solve your problem (without having to run the script ourselves, which is more work).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274:1861,simpl,simply,1861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-811561274,1,['simpl'],['simply']
Usability,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:85,simpl,simple,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,1,['simpl'],['simple']
Usability,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:308,simpl,simple,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,2,['simpl'],['simple']
Usability,`test_dynamics.jl` has physics-based tests; `test_field.jl` has tests for `Field` construction and some simple computations (broadcasting I think). This issue regards the `IncompressibleModel` constructor (eg we want to pass a `Field` to the keyword argument `background_fields` in `IncompressibleModel`. So I think it belongs in. https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_incompressible_models.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1834#issuecomment-875936013:104,simpl,simple,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1834#issuecomment-875936013,1,['simpl'],['simple']
Usability,"`z_faces` sounds good to me. As a newish user who will be reading examples and trying to figure things out, I think this is clearer than `zF`. Certainly people can learn to use either without much difficulty. Also, I thought that `zF` is mostly used for a face, wheres we want multiple, so plural. I suppose even `zFs` would be better in my mind.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782:124,clear,clearer,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814950782,2,"['clear', 'learn']","['clearer', 'learn']"
Usability,a 'simple forcing' script to reproduce this error is here:. https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547:3,simpl,simple,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547,1,['simpl'],['simple']
Usability,"aWxzL3ZlcnNpb25pbmZvLmps) | `37.50% <0.00%> (-31.25%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_dynamics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2R5bmFtaWNzLmps) | | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | | |; | [benchmark/benchmark\_forcing\_functions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mb3JjaW5nX2Z1bmN0aW9ucy5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | ... and [60 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=footer). Last update [0fe0d15...c70ed0e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/911?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822:3004,learn,learn,3004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/911#issuecomment-687049822,1,['learn'],['learn']
Usability,"age 78.23% 78.28% +0.05% ; ==========================================; Files 118 118 ; Lines 2375 2390 +15 ; ==========================================; + Hits 1858 1871 +13 ; - Misses 517 519 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <0%> (-1.93%)` | :arrow_down: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.44% <0%> (-0.44%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=footer). Last update [e90c52a...d614833](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/665?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926:2300,learn,learn,2300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665#issuecomment-594938926,1,['learn'],['learn']
Usability,"age Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0% <ø> (ø)` | |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `100% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0% <0%> (ø)` | |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <100%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.78% <88.88%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84.21% <90.9%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=footer). Last update [c417701...9187570](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/627?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059:2522,learn,learn,2522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627#issuecomment-586666059,1,['learn'],['learn']
Usability,"alo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `98.07% <100.00%> (+0.21%)` | :arrow_up: |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <100.00%> (-0.25%)` | :arrow_down: |; | [src/Simulations/simulation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3NpbXVsYXRpb24uamw=) | `68.75% <0.00%> (-6.25%)` | :arrow_down: |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `92.30% <0.00%> (+0.47%)` | :arrow_up: |; | [src/Buoyancy/seawater\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L3NlYXdhdGVyX2J1b3lhbmN5Lmps) | `74.07% <0.00%> (+3.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=footer). Last update [d80be8c...f384f90](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/984?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385:3130,learn,learn,3130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984#issuecomment-699495385,1,['learn'],['learn']
Usability,"an't use `const z₁ = -1*znodes(Center,grid)[1]` because if I do that, the value of z1 will change to 14.88. My code `const z₁ = -1*znodes(Center,grid)[grid.Nz]` will keep z1 equals to Closest grid center to the bottom (0.12). This isn't the best way to define $z_1$. The current statement will break if you, for example, decide to stretch the grid vertically. The more robust way to define $z_1$ is. ```julia; julia> grid = RectilinearGrid(CPU(), size=(64,64,64), extent=(π*H, π*H, H)); 64×64×64 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:1528,clear,clearer,1528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408,1,['clear'],['clearer']
Usability,"ananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <77.55%> (-14.67%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9mX3BsYW5lLmps) | `80.00% <80.00%> (ø)` | |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `82.60% <82.60%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | ... and [20 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=footer). Last update [eeb62d1...d5dfc74](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/899?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480:3152,learn,learn,3152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899#issuecomment-685689480,1,['learn'],['learn']
Usability,"anigans.jl/pull/130?src=pr&el=h1) Report; > Merging [#130](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/0947ba57b9f35a5ee721c951da8f6def89db0d70?src=pr&el=desc) will **decrease** coverage by `0.42%`.; > The diff coverage is `72.72%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #130 +/- ##; ==========================================; - Coverage 57.29% 56.87% -0.43% ; ==========================================; Files 19 19 ; Lines 644 647 +3 ; ==========================================; - Hits 369 368 -1 ; - Misses 275 279 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.33% <ø> (-4.91%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.28% <72.72%> (-1.07%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=footer). Last update [0947ba5...f31e0b3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/130?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188:1620,learn,learn,1620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/130#issuecomment-473474188,1,['learn'],['learn']
Usability,"ans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <0%> (ø)` | :arrow_up: |; | [...closures/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvcm96ZW1hX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `23.95% <0%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `52.54% <0%> (ø)` | |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `69.72% <0%> (ø)` | |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <0%> (ø)` | |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <0%> (+1.2%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=footer). Last update [8c1c776...ee0b40e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/380?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444:3571,learn,learn,3571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380#issuecomment-525911444,1,['learn'],['learn']
Usability,"apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the `IncompressibleModel` is really more of an `OceanModel` as evidence by the `surface_waves` functionality and the `SeawaterBuoyancy` default. And the proposed `CompressibleModel` is already more of an `AtmosphericModel` as tracers representing mixing ratios like ql, qv, qi, etc. are given special treatment (they contribute to the moist density). > The Boussinesq solver in Oceananigans is already useful for atmospheric simulations with depths small relative ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2558,simpl,simply,2558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['simpl'],['simply']
Usability,"as created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.; >; >; >; > plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; >; > but produce plans that perform the equivalent of the inverse transforms ifft and so on.; >; >; >; > help?> plan_fft!; >; > search: plan_fft! plan_ifft! plan_bfft! plan_fft plan_rfft plan_ifft plan_bfft plan_irfft plan_brfft; >; >; >; > plan_fft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Same as plan_fft, but operates in-place on A.; >; >; > But I just learned that you can apply the inverse plan with P \ Â which is; > cool!; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/119#issuecomment-471179127>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBrJ-I9C04VxTFehp8CvR6NOT2nSeks5vU71agaJpZM4bmrZ0>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:2618,learn,learned,2618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,1,['learn'],['learned']
Usability,"aster](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/232aab2b8c3dc5cf6bc59931a197fde588d6be57?el=desc) will **increase** coverage by `0.28%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1078 +/- ##; ==========================================; + Coverage 56.91% 57.20% +0.28% ; ==========================================; Files 162 162 ; Lines 3811 3881 +70 ; ==========================================; + Hits 2169 2220 +51 ; - Misses 1642 1661 +19 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `59.75% <0.00%> (+2.61%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `68.08% <0.00%> (+3.79%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `82.22% <0.00%> (+4.44%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=footer). Last update [232aab2...96e4113](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1078?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198:1766,learn,learn,1766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1078#issuecomment-711070198,1,['learn'],['learn']
Usability,"b3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0% <0%> (ø)` | |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `50% <100%> (-50%)` | :arrow_down: |; | [...mplementations/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2NvbnN0YW50X2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `33.33% <26.31%> (-66.67%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `66.66% <33.33%> (-13.59%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=footer). Last update [8666964...7a765f2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/518?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546:3055,learn,learn,3055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/518#issuecomment-548737546,1,['learn'],['learn']
Usability,"b3JzLmps) | `100.00% <0.00%> (ø)` | |; | [...urbulenceClosures/viscous\_dissipation\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92aXNjb3VzX2Rpc3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <0.00%> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <0.00%> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=footer). Last update [f18daed...0358145](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/782?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566:3612,learn,learn,3612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782#issuecomment-652577566,1,['learn'],['learn']
Usability,"bG93V2F0ZXJNb2RlbHMvc2V0X3NoYWxsb3dfd2F0ZXJfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...c/Models/ShallowWaterModels/shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hhbGxvd193YXRlcl9tb2RlbC5qbA==) | `0.00% <0.00%> (ø)` | |; | [...els/ShallowWaterModels/show\_shallow\_water\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc2hvd19zaGFsbG93X3dhdGVyX21vZGVsLmps) | `0.00% <0.00%> (ø)` | |; | [...allowWaterModels/solution\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvc29sdXRpb25fYW5kX3RyYWNlcl90ZW5kZW5jaWVzLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/ShallowWaterModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvdXBkYXRlX3N0YXRlLmps) | `0.00% <0.00%> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `75.00% <ø> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=footer). Last update [7c8c0cf...6112c6c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1188?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987:3587,learn,learn,3587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729133987,1,['learn'],['learn']
Usability,"bstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `61.11% <0.00%> (-23.10%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (-22.23%)` | :arrow_down: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <0.00%> (-20.00%)` | :arrow_down: |; | ... and [37 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=footer). Last update [6502f07...e778d2d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/720?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183:3439,learn,learn,3439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/720#issuecomment-605402183,1,['learn'],['learn']
Usability,"c/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.11% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `52.74% <0%> (-0.59%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX3R1cGxlcy5qbA==) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `70% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=footer). Last update [2803ace...590f224](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/517?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479:2634,learn,learn,2634,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/517#issuecomment-548111479,1,['learn'],['learn']
Usability,"c3NpcGF0aW9uX29wZXJhdG9ycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <ø> (+85.71%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/Operators/momentum\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | ... and [40 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=footer). Last update [9fbbc93...8e51fdc](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/543?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863:3504,learn,learn,3504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/543#issuecomment-560540863,1,['learn'],['learn']
Usability,"c3RydWN0aW9uLmps) | `0.00% <0.00%> (-60.00%)` | :arrow_down: |; | [src/Coriolis/beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2JldGFfcGxhbmUuamw=) | `0.00% <0.00%> (-58.83%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `0.00% <0.00%> (-58.07%)` | :arrow_down: |; | [src/Coriolis/non\_traditional\_beta\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vbl90cmFkaXRpb25hbF9iZXRhX3BsYW5lLmps) | `0.00% <0.00%> (-54.17%)` | :arrow_down: |; | [src/Fields/reduced\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9yZWR1Y2VkX2ZpZWxkLmps) | `28.94% <0.00%> (-50.01%)` | :arrow_down: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `0.00% <0.00%> (-44.28%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `47.36% <0.00%> (-32.64%)` | :arrow_down: |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=footer). Last update [03a6f85...c717dd5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1181?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894:3461,learn,learn,3461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181#issuecomment-727213894,1,['learn'],['learn']
Usability,"c=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `71.42% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `64.28% <0%> (+4.76%)` | :arrow_up: |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | `90.62% <0%> (+32%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `100% <0%> (+50%)` | :arrow_up: |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | `98.38% <0%> (+66.12%)` | :arrow_up: |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `100% <0%> (+85.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=footer). Last update [a511fdd...e187583](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/556?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953:3126,learn,learn,3126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-562859953,1,['learn'],['learn']
Usability,"c=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69% <100%> (-2.98%)` | :arrow_down: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `88.57% <100%> (+37.14%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.66% <61.29%> (+7.51%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40% <71.42%> (-0.66%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <75%> (+20.83%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [a26da9c...db0165c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485:3319,learn,learn,3319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942485,1,['learn'],['learn']
Usability,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2177,simpl,simplified,2177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,1,['simpl'],['simplified']
Usability,"ceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `69.23% <0.00%> (-30.77%)` | :arrow_down: |; | [src/Advection/weno\_reconstruction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX3JlY29uc3RydWN0aW9uLmps) | `63.15% <0.00%> (-27.17%)` | :arrow_down: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `40.00% <0.00%> (-26.67%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `5.40% <0.00%> (-21.63%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `83.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <0.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=footer). Last update [e808a82...ba06f1a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1000?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227:3315,learn,learn,3315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1000#issuecomment-700426227,1,['learn'],['learn']
Usability,"ceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <0%> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <100%> (+0.24%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (+0.17%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <86.36%> (+18.76%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <90%> (+3.86%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `75.33% <91.66%> (-0.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=footer). Last update [e65a74a...379df34](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/389?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190:2870,learn,learn,2870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527186190,1,['learn'],['learn']
Usability,"ced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1069,simpl,simple,1069,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,1,['simpl'],['simple']
Usability,"change results.; > ; > > I also suggest setting up a test that evaluates whether the drag boundary condition produces a measurable difference in a simulation that has a steppy boundary (like a constant slope, rather than a flat wall). You want to determine the relative contribution of this explicit drag compared to form drag for your setup of interest before investing lots of effort here.; > ; > That's a good point. Although I'd have to discuss this with @whitleyv since she's the main developer here. My thinking is that if indeed the form drag dominates, we can probably upgrade this to a partial cell grid-fitted IBM (much like @francispoulin intends to do in #2306). If my understanding is correct, you'd only need to change the definition of the volumes and areas to account for the partial step and it seems to significantly decrease form drag. Oh for sure, and hopefully we will also eventually have shaved cells which will reduce form drag even more. But you could also calculate that by the time we have partial cells working well with the FFT-based nonhydrostatic solver, et cetera, we might also have a more general implementation for boundary fluxes. But from a science point of view, if we simply need ""some drag"" to produce qualitatively useful results, then relying on form drag for `GridFittedBottom` is a simple and effective strategy to make initial progress. If we find that the numerical value of the drag exerts a strong control on the simulation results --- warranting an effort to implement a high-quality drag model, then the next question is whether the form drag with `GridFittedBottom` is _less_ than what we think is realistic. If there is indeed too little drag then we have good justification for hard coding a drag boundary condition into `conditional_flux`. On the other hand, if there's too much drag, then the first thing to work on is an alternative representation of bathymetry. We can then repeat the form drag analysis with the new bathymetry representation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164:1900,simpl,simply,1900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1084707164,2,['simpl'],"['simple', 'simply']"
Usability,"chine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `82.38% <0%> (+2.27%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=footer). Last update [d32cf20...db00c29](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/425?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372:2853,learn,learn,2853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425#issuecomment-533606372,1,['learn'],['learn']
Usability,"chine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <ø> (ø)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `75.86% <0%> (+10.34%)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `50% <0%> (-50%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `79.31% <0%> (-4.33%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (-2.78%)` | :arrow_down: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `51.85% <0%> (-9.02%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.81% <100%> (+0.25%)` | :arrow_up: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88% <0%> (+1.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=footer). Last update [d27ab4f...30319ec](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/570?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764:2680,learn,learn,2680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570#issuecomment-566756764,1,['learn'],['learn']
Usability,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043:1307,clear,clear,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043,1,['clear'],['clear']
Usability,"climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <ø> (+3.12%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <100%> (+0.34%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `9.09% <0%> (-13.64%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.98% <0%> (-5.8%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=footer). Last update [b6b27af...6d0b6d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/101?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943:2699,learn,learn,2699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/101#issuecomment-468943943,2,['learn'],['learn']
Usability,"climate-machine/Oceananigans.jl/pull/382?src=pr&el=h1) Report; > Merging [#382](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/8c1c776b50df17ff10735e57488f22b20d455303?src=pr&el=desc) will **increase** coverage by `0.13%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #382 +/- ##; =========================================; + Coverage 78.37% 78.5% +0.13% ; =========================================; Files 22 22 ; Lines 1244 1247 +3 ; =========================================; + Hits 975 979 +4 ; + Misses 269 268 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77% <100%> (+0.5%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `98.4% <0%> (+0.78%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=footer). Last update [8c1c776...424d943](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/382?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144:1599,learn,learn,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382#issuecomment-525955144,1,['learn'],['learn']
Usability,"climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #475 +/- ##; ==========================================; - Coverage 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=footer). Last update [211e18c...9a622f0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/475?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850:2140,learn,learn,2140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475#issuecomment-541976850,1,['learn'],['learn']
Usability,"climate-machine/Oceananigans.jl/pull/613?src=pr&el=h1) Report; > Merging [#613](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f080635b93bdab9da7d1189ed21f27523c0ff810?src=pr&el=desc) will **not change** coverage.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #613 +/- ##; =======================================; Coverage 74.55% 74.55% ; =======================================; Files 117 117 ; Lines 2209 2209 ; =======================================; Hits 1647 1647 ; Misses 562 562; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/BoundaryConditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9Cb3VuZGFyeUNvbmRpdGlvbnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=footer). Last update [f080635...e714993](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/613?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856:1599,learn,learn,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/613#issuecomment-581647856,1,['learn'],['learn']
Usability,"cmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-16.67%)` | :arrow_down: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <0.00%> (-13.34%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `48.38% <0.00%> (-3.54%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | | |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | | |; | ... and [184 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=footer). Last update [0fb5286...ab3e539](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/590?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236:3362,learn,learn,3362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-571334236,1,['learn'],['learn']
Usability,"codecov.io/gh/CliMA/Oceananigans.jl/commit/80fb511ff5a5bb641481b6209ca101ea8c4b8149&el=desc) will **decrease** coverage by `0.11%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #807 +/- ##; ==========================================; - Coverage 71.15% 71.04% -0.12% ; ==========================================; Files 186 186 ; Lines 4839 4824 -15 ; ==========================================; - Hits 3443 3427 -16 ; - Misses 1396 1397 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `90.74% <100.00%> (-0.49%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <100.00%> (-5.32%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=footer). Last update [80fb511...7e95ea6](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/807?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101:1780,learn,learn,1780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807#issuecomment-660647101,1,['learn'],['learn']
Usability,"codecov.io/gh/climate-machine/Oceananigans.jl/commit/cde6246ac753b206d81167dbc024521e8c7276c7?src=pr&el=desc) will **decrease** coverage by `0.08%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #172 +/- ##; ==========================================; - Coverage 68.79% 68.71% -0.09% ; ==========================================; Files 18 18 ; Lines 657 652 -5 ; ==========================================; - Hits 452 448 -4 ; + Misses 205 204 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <100%> (+0.02%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=footer). Last update [cde6246...c3a3c3d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/172?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290:1780,learn,learn,1780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172#issuecomment-481421290,1,['learn'],['learn']
Usability,"codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #352 +/- ##; ==========================================; + Coverage 72.86% 72.89% +0.03% ; ==========================================; Files 22 22 ; Lines 1157 1214 +57 ; ==========================================; + Hits 843 885 +42 ; - Misses 314 329 +15; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <0%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `61.42% <100%> (+1.72%)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `50% <47.56%> (+37.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=footer). Last update [7a4142c...5bbb71e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/352?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462:2126,learn,learn,2126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352#issuecomment-520223462,1,['learn'],['learn']
Usability,"commit/e83d621859dd660e4576024ab461dafa46ff45bc?src=pr&el=desc) will **increase** coverage by `0.26%`.; > The diff coverage is `78.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #490 +/- ##; ==========================================; + Coverage 73.22% 73.48% +0.26% ; ==========================================; Files 27 27 ; Lines 1505 1516 +11 ; ==========================================; + Hits 1102 1114 +12 ; + Misses 403 402 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `68.18% <78.57%> (+8.18%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=footer). Last update [e83d621...de5764b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/490?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641:1826,learn,learn,1826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490#issuecomment-544486641,1,['learn'],['learn']
Usability,"complex geometries in the 1980s. That also would not require us to change; the solver. You carry out Green's function calculations in a rectangular; region where the delta-functions vorticities are placed at the positions of; the irregular boundary within the larger rectangular region. I will look; them out. John. On Sat, Mar 28, 2020 at 11:20 AM Gregory L. Wagner <notifications@github.com>; wrote:. > @johncmarshall54 <https://github.com/johncmarshall54> agreed, that's a; > challenge we have to confront.; >; > If we implement immersed boundaries using the ""continuous forcing; > technique"", then a boundary may be defined essentially by a masking; > function. In this case, we might be able to ""label"" each boundary / masking; > function with a name or number.; >; > The boundary condition objects we then give to fields would have to define; > a condition to be applied both at the boundaries of the numerical grid; > (which we currently support), as well as any immersed boundaries, where; > immersed boundaries are referenced by name or number.; >; > By the way, if we use a continuous forcing technique, we do not have to; > change the pressure solver. This is a major simplification. Recent work; > suggests there is no disadvantage in terms of accuracy in using the; > continuous forcing technique, either. I'm not sure if this is too good to; > believe or not --- we should discuss and take a deeper look at the; > literature.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605461456>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQHGXSSKOU7EIXSLBTRJYIVFANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623:1254,simpl,simplification,1254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605466623,1,['simpl'],['simplification']
Usability,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1864,clear,clearly,1864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,1,['clear'],['clearly']
Usability,"cov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=h1) Report; > Merging [#1161](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=desc) (8124ad7) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/0c2b51293d324836846f31ab93c7515b05e797b5?el=desc) (0c2b512) will **increase** coverage by `0.38%`.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1161 +/- ##; ==========================================; + Coverage 57.01% 57.39% +0.38% ; ==========================================; Files 162 162 ; Lines 3913 3962 +49 ; ==========================================; + Hits 2231 2274 +43 ; - Misses 1682 1688 +6 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `85.54% <66.66%> (-2.62%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.30% <0.00%> (+2.64%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=footer). Last update [0c2b512...8124ad7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1161?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486:1607,learn,learn,1607,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1161#issuecomment-724397486,1,['learn'],['learn']
Usability,"cov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/92d77b028d39014e2818d2d1fe56038fd1810256&el=desc) will **increase** coverage by `0.05%`.; > The diff coverage is `84.61%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #745 +/- ##; ==========================================; + Coverage 77.05% 77.10% +0.05% ; ==========================================; Files 123 124 +1 ; Lines 2462 2477 +15 ; ==========================================; + Hits 1897 1910 +13 ; - Misses 565 567 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Forcing/relaxation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcmVsYXhhdGlvbi5qbA==) | `84.61% <84.61%> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `80.00% <0.00%> (+5.00%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=footer). Last update [92d77b0...63f9f11](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/745?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232:1701,learn,learn,1701,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745#issuecomment-622493232,1,['learn'],['learn']
Usability,"cov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/7f957d7762b61ee4e51b360944428d5b660d50bf&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #772 +/- ##; ==========================================; + Coverage 77.65% 77.70% +0.04% ; ==========================================; Files 165 165 ; Lines 4404 4413 +9 ; ==========================================; + Hits 3420 3429 +9 ; Misses 984 984 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <ø> (ø)` | |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `84.61% <100.00%> (+4.61%)` | :arrow_up: |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=footer). Last update [7f957d7...c19f69c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/772?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370:1701,learn,learn,1701,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/772#issuecomment-641394370,1,['learn'],['learn']
Usability,"cov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=h1) Report; > Merging [#794](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/d383b6a27fc95837b591bd1e68e1aaca50f97da6&el=desc) will **decrease** coverage by `0.62%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #794 +/- ##; ==========================================; - Coverage 71.67% 71.05% -0.63% ; ==========================================; Files 184 186 +2 ; Lines 4781 4823 +42 ; ==========================================; Hits 3427 3427 ; - Misses 1354 1396 +42 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/citations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9jaXRhdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [docs/make.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794/diff?src=pr&el=tree#diff-ZG9jcy9tYWtlLmps) | `0.00% <ø> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=footer). Last update [d383b6a...c6d7bbe](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/794?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828:1609,learn,learn,1609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794#issuecomment-657608828,1,['learn'],['learn']
Usability,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...0f59662](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658:1572,learn,learn,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220658,1,['learn'],['learn']
Usability,"cov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=h1) Report; > Merging [#228](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/ca03838d46fd4905379a1bc08697be5bcfcf99ef?src=pr&el=desc) will **increase** coverage by `0.29%`.; > The diff coverage is `50%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #228 +/- ##; ==========================================; + Coverage 67.25% 67.55% +0.29% ; ==========================================; Files 18 18 ; Lines 675 675 ; ==========================================; + Hits 454 456 +2 ; + Misses 221 219 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.04% <50%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.35% <0%> (+3.5%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=footer). Last update [ca03838...4bb6f50](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/228?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644:1572,learn,learn,1572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495220644,1,['learn'],['learn']
Usability,"coverage by `0.03%`.; > The diff coverage is `85.36%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #464 +/- ##; ==========================================; - Coverage 73.34% 73.31% -0.04% ; ==========================================; Files 27 27 ; Lines 1508 1525 +17 ; ==========================================; + Hits 1106 1118 +12 ; - Misses 402 407 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `79.54% <66.66%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `83.33% <86.84%> (-10.22%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `80.64% <0%> (+3.22%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=footer). Last update [41a2b55...cab311e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/464?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667:1908,learn,learn,1908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464#issuecomment-545240667,1,['learn'],['learn']
Usability,"cted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #237 +/- ##; ==========================================; + Coverage 73.92% 74.04% +0.12% ; ==========================================; Files 23 23 ; Lines 859 863 +4 ; ==========================================; + Hits 635 639 +4 ; Misses 224 224; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `83.33% <ø> (+16.66%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.72% <50%> (-0.99%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `67.74% <86.95%> (+12.56%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40.54% <0%> (-5.41%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=footer). Last update [1e693f8...f7eb047](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/237?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818:1970,learn,learn,1970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237#issuecomment-495868818,2,['learn'],['learn']
Usability,"d specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case,. For `GridFittedImmersedBoundary` the normal direction can be easily and efficiently inferred from the masking function by evaluating it at offset `i`, `j`, `k`. If fluid is adjacent to solid in any of those directions, you are on a boundary with a normal in the `x, y, z` direction (respectively), and the sign of the normal direction can be inferred from the offset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:1471,simpl,simple,1471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,1,['simpl'],['simple']
Usability,"decov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=h1) Report; > Merging [#302](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/c3428825442f8d155b3128a0f79797ba8f070f68?src=pr&el=desc) will **increase** coverage by `0.84%`.; > The diff coverage is `92.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #302 +/- ##; ==========================================; + Coverage 71.8% 72.64% +0.84% ; ==========================================; Files 24 24 ; Lines 1000 1031 +31 ; ==========================================; + Hits 718 749 +31 ; Misses 282 282; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `20% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.3% <92.42%> (+3.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=footer). Last update [c342882...a0e8a14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/302?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260:1587,learn,learn,1587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302#issuecomment-506989260,1,['learn'],['learn']
Usability,"decov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=h1) Report; > Merging [#915](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/6d349e1d85d61ff997f249881cd58232de865996?el=desc) will **increase** coverage by `0.07%`.; > The diff coverage is `96.07%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #915 +/- ##; ==========================================; + Coverage 72.60% 72.67% +0.07% ; ==========================================; Files 191 191 ; Lines 5610 5622 +12 ; ==========================================; + Hits 4073 4086 +13 ; + Misses 1537 1536 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `77.63% <91.66%> (-0.15%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.62% <100.00%> (+0.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=footer). Last update [6d349e1...22e9b04](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/915?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456:1590,learn,learn,1590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915#issuecomment-687316456,1,['learn'],['learn']
Usability,"diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #401 +/- ##; ==========================================; - Coverage 71.74% 71.46% -0.28% ; ==========================================; Files 23 23 ; Lines 1412 1416 +4 ; ==========================================; - Hits 1013 1012 -1 ; - Misses 399 404 +5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.47% <ø> (-0.25%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.12% <100%> (+0.12%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.97% <64.28%> (-9.88%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=footer). Last update [f77d3e6...0408059](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/401?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520:1936,learn,learn,1936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401#issuecomment-531079520,1,['learn'],['learn']
Usability,"diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/store\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9zdG9yZV90ZW5kZW5jaWVzLmps) | `72.72% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | | |; | [.../Models/ShallowWaterModels/calculate\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9TaGFsbG93V2F0ZXJNb2RlbHMvY2FsY3VsYXRlX3RlbmRlbmNpZXMuamw=) | | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | | |; | ... and [28 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=footer). Last update [3108501...8043370](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1120?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146:3237,learn,learn,3237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-719683146,1,['learn'],['learn']
Usability,"diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <0.00%> (ø)` | |; | ... and [35 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=footer). Last update [24e9c2c...c9ed348](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/993?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566:3094,learn,learn,3094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993#issuecomment-700294566,1,['learn'],['learn']
Usability,"diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | | |; | [...erification/lid\_driven\_cavity/lid\_driven\_cavity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2xpZF9kcml2ZW5fY2F2aXR5L2xpZF9kcml2ZW5fY2F2aXR5Lmps) | | |; | [test/test\_surface\_waves.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3N1cmZhY2Vfd2F2ZXMuamw=) | | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | ... and [58 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=footer). Last update [ee14f8a...1b1dbba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1017?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991:3022,learn,learn,3022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1017#issuecomment-701768991,1,['learn'],['learn']
Usability,"down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `83.56% <0%> (-4.68%)` | :arrow_down: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `81.25% <0%> (-2.97%)` | :arrow_down: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `67.77% <0%> (-0.77%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.21% <0%> (+0.12%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.47% <0%> (+0.19%)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `84.37% <0%> (+1.04%)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.61% <0%> (+4.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=footer). Last update [7bbdd3d...d50e02d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/503?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136:2796,learn,learn,2796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/503#issuecomment-546029136,1,['learn'],['learn']
Usability,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1274,simpl,simply,1274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['simpl'],['simply']
Usability,"e 72.07% 69.12% -2.95% ; ==========================================; Files 26 26 ; Lines 1418 1490 +72 ; ==========================================; + Hits 1022 1030 +8 ; - Misses 396 460 +64; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <0%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `48.83% <0%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `59.34% <20%> (-25.91%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `60.18% <29.41%> (-29.96%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.97% <95.23%> (+0.94%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=footer). Last update [211e18c...8eae176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/476?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378:2304,learn,learn,2304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476#issuecomment-541986378,1,['learn'],['learn']
Usability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1948,simpl,simply,1948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,"['learn', 'simpl']","['learn', 'simply']"
Usability,"e-machine/Oceananigans.jl/pull/385?src=pr&el=h1) Report; > Merging [#385](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/a2b7c0e59c2f224f4fc978668cb2b85b45543981?src=pr&el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #385 +/- ##; ==========================================; + Coverage 70.57% 70.58% +0.01% ; ==========================================; Files 23 23 ; Lines 1383 1387 +4 ; ==========================================; + Hits 976 979 +3 ; - Misses 407 408 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.12% <100%> (+0.15%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `86.27% <66.66%> (-1.23%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=footer). Last update [a2b7c0e...0c07933](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/385?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168:1605,learn,learn,1605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385#issuecomment-526284168,1,['learn'],['learn']
Usability,"e-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/poisson\_solver\_gpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfZ3B1Lmps) | `0% <0%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `100% <100%> (ø)` | |; | [src/Solvers/poisson\_solver\_cpu.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcG9pc3Nvbl9zb2x2ZXJfY3B1Lmps) | `100% <100%> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100% <100%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <100%> (ø)` | |; | ... and [36 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=footer). Last update [4b8ff03...9060a5f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/512?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284:3358,learn,learn,3358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512#issuecomment-548115284,1,['learn'],['learn']
Usability,"e/Oceananigans.jl/pull/623?src=pr&el=h1) Report; > Merging [#623](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/73bea229721624d65d4e2b2b79810622cf221993?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #623 +/- ##; ==========================================; + Coverage 74.49% 74.58% +0.09% ; ==========================================; Files 118 118 ; Lines 2227 2231 +4 ; ==========================================; + Hits 1659 1664 +5 ; + Misses 568 567 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `100% <ø> (+8.33%)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.93% <100%> (+0.6%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=footer). Last update [73bea22...7014037](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/623?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829:1613,learn,learn,1613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/623#issuecomment-585468829,1,['learn'],['learn']
Usability,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:2228,clear,clearer,2228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,1,['clear'],['clearer']
Usability,"east_west_u_velocity! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_top_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_top_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_west_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_east_halo! with worksize (1, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ┌ Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1); └ @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ```. I think I'll try to pepper a few `@info` here and there when resolving this issue. Ultimately it'd be slick to have some cool wigits, spinners, and progress bars like what happens when julia precompiles packages...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021:5347,progress bar,progress bars,5347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021,1,['progress bar'],['progress bars']
Usability,"ection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `50.00% <ø> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `80.00% <ø> (ø)` | |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `76.92% <0.00%> (-6.42%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `96.55% <0.00%> (-1.70%)` | :arrow_down: |; | ... and [22 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=footer). Last update [d274364...d03718b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1014?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105:3131,learn,learn,3131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014#issuecomment-704467105,1,['learn'],['learn']
Usability,"ently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires evaluation, and also reduces a field along a certain dimension. For this to work well, we need a `ReducedField` type (eg #525)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:1805,clear,clearly,1805,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,1,['clear'],['clearly']
Usability,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1357,simpl,simple,1357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['simpl'],['simple']
Usability,"er](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/716356088a610da1fe75f00b38e3646f046edbb4?src=pr&el=desc) will **increase** coverage by `9.94%`.; > The diff coverage is `78.94%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ==========================================; + Coverage 56.03% 65.97% +9.94% ; ==========================================; Files 19 19 ; Lines 605 629 +24 ; ==========================================; + Hits 339 415 +76 ; + Misses 266 214 -52; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.78% <78.94%> (+79.78%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [7163560...371af73](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131:1768,learn,learn,1768,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633131,1,['learn'],['learn']
Usability,"erging [#612](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/88a4f8f08d976bb0029ea337202bf94fe292374d?src=pr&el=desc) will **increase** coverage by `0.04%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #612 +/- ##; ==========================================; + Coverage 74.51% 74.55% +0.04% ; ==========================================; Files 117 117 ; Lines 2209 2209 ; ==========================================; + Hits 1646 1647 +1 ; + Misses 563 562 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `93.33% <100%> (ø)` | :arrow_up: |; | [src/Buoyancy/nonlinear\_equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L25vbmxpbmVhcl9lcXVhdGlvbl9vZl9zdGF0ZS5qbA==) | `75% <0%> (+4.16%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=footer). Last update [88a4f8f...7d4e5b6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/612?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656:1665,learn,learn,1665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612#issuecomment-581598656,1,['learn'],['learn']
Usability,"es) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_clos",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1564,simpl,simple,1564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,1,['simpl'],['simple']
Usability,"es, I am suggesting this syntax; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```; or the following where `stretch_function` is an `@inline function`; ```; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=stretch_function); ```; Both will work. There are pluses and minuses in the different approaches. Below are a few thoughts. - You are correct that if you pass an array you know the end points so there is no real need to have `z=(0,Lz)`. ; - However, if you want to pass an inline function, then you don't need to specify the bounds at all, and these then serve a purpose.; - As I mentioned before, I think that specifying the domain is more similar to what's done in other grids. I do think that normzlizing the grids so that they follow a similar framework is advantageous. Both to be able to switch from one to the other, but also to the user who sees that this function is only different that we add another argument. ; - There could and should be a check added it to make sure that the first element and lasta elements of the grid are equal to z. What you suggest is also possible but then when you want to have stretching in 2 or 3 dimenions, you can still do it but then you need to have `xF`, `yF`, `zF` and you no longer have `x,y,z`. In terms of the coding, it seems easy to write up and run code that would specify the domain in all three directions and then stretches in whatever directions the user wants to stretch, with checks. I choose the name `z_stretch` to denote the stretched grid in the `z` direction. I supposed we could use `z_stretched` or something else. `zF` is not intuitive to me, someone who never used the stretched grid before, since it just suggests the faces. In some code I have seen `zF_generator`, which is better than `zF` but generator is maybe not as explicit as stretched or something else. Maybe we can come up with a better name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813465259:1722,intuit,intuitive,1722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813465259,1,['intuit'],['intuitive']
Usability,"es](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `12.9% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.09% <ø> (+2.49%)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `88.7% <ø> (+2.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `73.39% <100%> (-2.74%)` | :arrow_down: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `74.19% <61.11%> (-9.6%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <88.23%> (+5.54%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `90.9% <0%> (-9.1%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=footer). Last update [2749d07...770125d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/386?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398:2516,learn,learn,2516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386#issuecomment-526924398,2,['learn'],['learn']
Usability,"existing simulation will hopefully be straightforward. In Oceananigans, `Periodic`, `Bounded`, and `Flat` do not refer to boundary conditions, but to the ""topology"" of a domain. Envision a two-dimensional domain as a piece of paper. If the domain is `Bounded` in both direction, then by default no fluid can enter or leave the paper (in addition to other conditions imposed on the physics). If the domain is `Periodic` in one direction, then its as if the paper is curled into a cylinder: fluid leaving the right side of the domain reappears on the left side. This is what it means for a domain to be `Periodic`. When a direction has a `Periodic` topology, we impose ""periodic boundary conditions"" (though a better way to think about this scenario is that there is no boundary at all!) Periodic topologies are convenient for all sorts of problems, which is why you see them cropping up in the examples frequently. If you can use a domain that is periodic in the ""streamwise"" direction (the direction oriented with the primary direction of your flow), you may make your life a bit simpler. A `Flat` topology is the Oceananigans way of saying that your problem does not vary in that direction. If one direction is `Flat`, then your problem is two-dimensional. So you don't impose boundary conditions in `Flat` directions either. When a direction is `Bounded`, you may impose `Value`, `Gradient`, and `Flux` boundary conditions on tracers and the components of the velocity field that are _tangential_ to the boundary. (Note that the velocity component _normal_ to the boundary is special. It is trickier to set boundary conditions on this component, and I don't think you will need to do this for your project.) If your domain is periodic in x and bounded in z, then you only need to worry about imposing boundary conditions at the top and bottom on tracers, `u`, and `v`. I am happy to help more if you like. You can also try to _force_ your flow to drive motion, rather than by imposing boundary condi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819091284:1375,simpl,simpler,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819091284,1,['simpl'],['simpler']
Usability,"ff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <ø> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `100.00% <ø> (ø)` | |; | [src/Models/show\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9zaG93X21vZGVscy5qbA==) | `0.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `100.00% <ø> (ø)` | |; | [...e\_closure\_implementations/isotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2lzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100.00% <ø> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=footer). Last update [03f1aa5...586529d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/799?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692:3261,learn,learn,3261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799#issuecomment-658184692,1,['learn'],['learn']
Usability,"file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #803 +/- ##; ==========================================; + Coverage 71.05% 71.24% +0.18% ; ==========================================; Files 186 186 ; Lines 4823 4854 +31 ; ==========================================; + Hits 3427 3458 +31 ; Misses 1396 1396 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `79.54% <0.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `94.11% <0.00%> (+3.37%)` | :arrow_up: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `69.64% <0.00%> (+10.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=footer). Last update [b022627...2572835](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/803?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336:1957,learn,learn,1957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/803#issuecomment-660244336,1,['learn'],['learn']
Usability,"g the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1787,learn,learn,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['learn'],['learn']
Usability,"g to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper support for systems of coupled nonlinear boundary conditions, etc). It's a good discussion to have regardless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:1577,clear,clearer,1577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,1,['clear'],['clearer']
Usability,"gans.jl/pull/402?src=pr&el=h1) Report; > Merging [#402](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/f77d3e6ef455fa3b7ed177c1af0e6a163b048a83?src=pr&el=desc) will **increase** coverage by `0.09%`.; > The diff coverage is `100%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #402 +/- ##; ==========================================; + Coverage 71.74% 71.83% +0.09% ; ==========================================; Files 23 23 ; Lines 1412 1413 +1 ; ==========================================; + Hits 1013 1015 +2 ; + Misses 399 398 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `84.74% <100%> (+1.69%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.63% <0%> (+0.01%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=footer). Last update [f77d3e6...77a2c9a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/402?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966:1623,learn,learn,1623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402#issuecomment-531193966,1,['learn'],['learn']
Usability,"gans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `71.11% <0%> (-9.85%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=footer). Last update [d32cf20...3ce561b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/421?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303:2696,learn,learn,2696,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/421#issuecomment-532807303,1,['learn'],['learn']
Usability,"ge by `0.43%`.; > The diff coverage is `100.00%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #685 +/- ##; ==========================================; - Coverage 77.99% 77.56% -0.44% ; ==========================================; Files 120 120 ; Lines 2413 2478 +65 ; ==========================================; + Hits 1882 1922 +40 ; - Misses 531 556 +25 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=footer). Last update [74cfb85...6eb8db9](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/685?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245:1907,learn,learn,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685#issuecomment-595584245,1,['learn'],['learn']
Usability,"gence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [benchmark/benchmark\_ffts.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya19mZnRzLmps) | | |; | [...ts/one\_dimensional\_gaussian\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9nYXVzc2lhbl9hZHZlY3Rpb25fZGlmZnVzaW9uLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [test/test\_benchmarks.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JlbmNobWFya3Muamw=) | | |; | [test/test\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X29wZXJhdG9ycy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=footer). Last update [d383b6a...ad6a215](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/792?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230:3168,learn,learn,3168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/792#issuecomment-657511230,1,['learn'],['learn']
Usability,"gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=h1) Report; > Merging [#585](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.97%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #585 +/- ##; ==========================================; + Coverage 72.17% 73.14% +0.97% ; ==========================================; Files 70 70 ; Lines 2016 2011 -5 ; ==========================================; + Hits 1455 1471 +16 ; + Misses 561 540 -21; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `61.05% <0%> (ø)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `76.19% <0%> (+76.19%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=footer). Last update [5888900...01ec7b4](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/585?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084:1596,learn,learn,1596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585#issuecomment-568143084,1,['learn'],['learn']
Usability,"going back to @ali-ramadhan 's response. . When preparing a markdown document, it is convenient to view it in the pretty form, as one does in latex. Are there any markdown viewers that people might recommend for linux? If not no big deal, I will learn to use Documenter but that sounds like it might be a bit slow as you have to run code to compile it, but maybe I'm wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725542621:246,learn,learn,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725542621,1,['learn'],['learn']
Usability,"h/climate-machine/Oceananigans.jl/pull/326?src=pr&el=h1) Report; > Merging [#326](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/66670ad782b66db7906d407ab9217ec0f26a7bb2?src=pr&el=desc) will **increase** coverage by `1.31%`.; > The diff coverage is `81.1%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #326 +/- ##; ==========================================; + Coverage 74.74% 76.06% +1.31% ; ==========================================; Files 22 22 ; Lines 1176 1224 +48 ; ==========================================; + Hits 879 931 +52 ; + Misses 297 293 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `75.93% <81.1%> (+11.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=footer). Last update [66670ad...4e72d35](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/326?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978:1597,learn,learn,1597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326#issuecomment-523974978,1,['learn'],['learn']
Usability,"h1) Report; > Merging [#992](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/e808a821d78949b0482b8372533e992cabb5d65f?el=desc) will **not change** coverage.; > The diff coverage is `66.66%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #992 +/- ##; =======================================; Coverage 72.04% 72.04% ; =======================================; Files 218 218 ; Lines 6379 6379 ; =======================================; Hits 4596 4596 ; Misses 1783 1783 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <ø> (ø)` | |; | [src/Fields/new\_data.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `76.92% <50.00%> (ø)` | |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `88.88% <100.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=footer). Last update [e808a82...9054b82](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/992?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993:1660,learn,learn,1660,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/992#issuecomment-700346993,1,['learn'],['learn']
Usability,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...63f7bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517:1986,learn,learn,1986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975517,1,['learn'],['learn']
Usability,"h](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #183 +/- ##; ===========================================; - Coverage 68.81% 57.86% -10.96% ; ===========================================; Files 18 19 +1 ; Lines 651 776 +125 ; ===========================================; + Hits 448 449 +1 ; - Misses 203 327 +124; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/dst3fl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9kc3QzZmwuamw=) | `0% <0%> (ø)` | |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `10% <0%> (-23.34%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=footer). Last update [6c272ad...7ff5f20](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/183?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519:1986,learn,learn,1986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/183#issuecomment-485975519,1,['learn'],['learn']
Usability,"halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `81.25% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `43.9% <ø> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `59.7% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `70% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.58% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=footer). Last update [848edd9...7e48630](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/349?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094:2595,learn,learn,2595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/349#issuecomment-520158094,2,['learn'],['learn']
Usability,"hat sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1881,simpl,simpler,1881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,1,['simpl'],['simpler']
Usability,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:1832,simpl,simple,1832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,1,['simpl'],['simple']
Usability,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262:1970,simpl,simply,1970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262,1,['simpl'],['simply']
Usability,"hine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.85% <100%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `83.05% <100%> (+1.69%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.48% <100%> (+1.14%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `77.71% <0%> (+0.54%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <0%> (+14.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `62.02% <0%> (+15.18%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <0%> (+16.66%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.61% <0%> (+57.61%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=footer). Last update [079cb53...bd0ce51](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/395?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190:2682,learn,learn,2682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/395#issuecomment-530062190,1,['learn'],['learn']
Usability,"https://circleci.com/docs/2.0/gpu/. may be useful?. On Wed, Mar 20, 2019 at 08:30 Ali Ramadhan <notifications@github.com> wrote:. > Yeah I don't know... I was going to email around for quotes to see if they; > have any premium/custom set ups with GPUs and multiple CPUs.; >; > If they're just spinning up VMs on the cloud then maybe it's just as; > simple as requesting a multi-core CPU with 2-4 GPUs (which I know is; > available on Google Cloud). But after factoring in support cost it might be; > pretty steep.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/139#issuecomment-474808481>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ADXx4DUR7vVwZ_gPzKB5-UNlThhQbcZeks5vYim_gaJpZM4b8em2>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474819492:349,simpl,simple,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139#issuecomment-474819492,1,['simpl'],['simple']
Usability,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/fbbb5f81b851bb838c8796efba36a3021cb89f0e?el=desc) will **increase** coverage by `0.01%`.; > The diff coverage is `80.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #889 +/- ##; ==========================================; + Coverage 70.99% 71.00% +0.01% ; ==========================================; Files 188 188 ; Lines 5230 5229 -1 ; ==========================================; Hits 3713 3713 ; + Misses 1517 1516 -1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `75.00% <ø> (+3.57%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.07% <66.66%> (-0.55%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `88.42% <100.00%> (+0.24%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=footer). Last update [fbbb5f8...1db3d80](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/889?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273:1689,learn,learn,1689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/889#issuecomment-684069273,1,['learn'],['learn']
Usability,"https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `92.00% <80.00%> (+3.57%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (+0.74%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `71.42% <100.00%> (+8.09%)` | :arrow_up: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <100.00%> (+0.05%)` | :arrow_up: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | ... and [17 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=footer). Last update [f0c2821...60fd8ea](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/910?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898:3342,learn,learn,3342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/910#issuecomment-687186898,1,['learn'],['learn']
Usability,"https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.33% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (-1.34%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `71.56% <100%> (-1.58%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <100%> (ø)` | |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <60.39%> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <74.35%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=footer). Last update [cacb753...059d826](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/505?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353:2518,learn,learn,2518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505#issuecomment-546596353,1,['learn'],['learn']
Usability,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:689,simpl,simplifies,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588,1,['simpl'],['simplifies']
Usability,"iMA/Oceananigans.jl/pull/1090?src=pr&el=desc) (ca40ce0) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165?el=desc) (5aafe8e) will **decrease** coverage by `0.38%`.; > The diff coverage is `0.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1090 +/- ##; ==========================================; - Coverage 57.39% 57.01% -0.39% ; ==========================================; Files 161 162 +1 ; Lines 3887 3913 +26 ; ==========================================; Hits 2231 2231 ; - Misses 1656 1682 +26 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `25.00% <ø> (ø)` | |; | [src/Fields/interpolate.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9pbnRlcnBvbGF0ZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `73.80% <0.00%> (+1.71%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=footer). Last update [5aafe8e...ca40ce0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1090?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303:1713,learn,learn,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090#issuecomment-713241303,1,['learn'],['learn']
Usability,"iMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `82.50% <30.00%> (-4.78%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `60.37% <83.33%> (+7.43%)` | :arrow_up: |; | [src/BoundaryConditions/zero\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy96ZXJvX2hhbG9fcmVnaW9ucy5qbA==) | `78.94% <87.50%> (+2.47%)` | :arrow_up: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `94.44% <94.44%> (ø)` | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `71.79% <100.00%> (ø)` | |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `96.42% <100.00%> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.33% <100.00%> (-0.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=footer). Last update [0f33c1d...69d5cd7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/930?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704:3139,learn,learn,3139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930#issuecomment-690826704,1,['learn'],['learn']
Usability,"iff-dmVyaWZpY2F0aW9uL3BlcmlvZGljX2FkdmVjdGlvbi9wZXJpb2RpY19hZHZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/Advection/upwind\_biased\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2ZpZnRoX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <0.00%> (-5.00%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `83.33% <0.00%> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <0.00%> (ø)` | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/tuple\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3R1cGxlX3V0aWxzLmps) | `44.44% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=footer). Last update [24e9c2c...c4faf06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/994?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179:3075,learn,learn,3075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994#issuecomment-700312179,1,['learn'],['learn']
Usability,"iff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <100.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.71% <100.00%> (+0.18%)` | :arrow_up: |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `90.00% <100.00%> (-1.67%)` | :arrow_down: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.07% <100.00%> (-0.54%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.15% <0.00%> (+0.15%)` | :arrow_up: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (+3.33%)` | :arrow_up: |; | [src/AbstractOperations/grid\_validation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9ncmlkX3ZhbGlkYXRpb24uamw=) | `75.00% <0.00%> (+8.33%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=footer). Last update [ae33e4c...94c13c7](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/757?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673:3046,learn,learn,3046,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757#issuecomment-632822673,1,['learn'],['learn']
Usability,"iff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `85.10% <0.00%> (-0.61%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100.00% <0.00%> (ø)` | |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [43 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=footer). Last update [bff7abc...ec426ad](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/704?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254:3370,learn,learn,3370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704#issuecomment-599780254,1,['learn'],['learn']
Usability,"igans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `46.15% <ø> (-39.57%)` | :arrow_down: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `70.37% <100.00%> (-3.71%)` | :arrow_down: |; | [src/Diagnostics/average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2F2ZXJhZ2Uuamw=) | `100.00% <100.00%> (ø)` | |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-30.01%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `83.33% <0.00%> (-11.67%)` | :arrow_down: |; | ... and [92 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=footer). Last update [cec16b0...5cbac0d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/798?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369:2903,learn,learn,2903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/798#issuecomment-657840369,1,['learn'],['learn']
Usability,"iles](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.68% <100%> (+0.37%)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.7% <100%> (-0.28%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `52.3% <56%> (-6.85%)` | :arrow_down: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `58.06% <58.06%> (-41.94%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `66% <0%> (+26%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=footer). Last update [ac7dc2a...a473fee](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/329?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484:2513,learn,learn,2513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/329#issuecomment-517942484,1,['learn'],['learn']
Usability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2245,simpl,simply,2245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['simpl'],['simply']
Usability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:2024,simpl,simply,2024,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['simpl'],['simply']
Usability,"ine/Oceananigans.jl/pull/288?src=pr&el=h1) Report; > Merging [#288](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/40dbd96fd45a30867063c476b3eecbe13db1fb5c?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `42.85%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #288 +/- ##; ==========================================; - Coverage 68.36% 68.29% -0.08% ; ==========================================; Files 22 22 ; Lines 882 880 -2 ; ==========================================; - Hits 603 601 -2 ; Misses 279 279; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.64% <100%> (-1.18%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `84.09% <33.33%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=footer). Last update [40dbd96...51bc9e0](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/288?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989:1611,learn,learn,1611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-504026989,1,['learn'],['learn']
Usability,"ine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.94% <0%> (-56.72%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `49.35% <0%> (-15.59%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <0%> (-12.5%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `78.26% <0%> (-7.32%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `72.02% <0%> (-2.1%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <0%> (-1.64%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `79.54% <0%> (-0.57%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `82.05% <0%> (+1.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=footer). Last update [d32cf20...d88b63f](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/435?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587:2690,learn,learn,2690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/435#issuecomment-536922587,1,['learn'],['learn']
Usability,"ing"", we could maybe do that, but I think it's strange. Better in my opinion to keep plotting as minimalistic as possible to maximize readability. I really think the value of an example is a strongly diminishing function of its number of lines and its syntactical complexity. I think plotting could be important (or very important) if the plot output is crucial to the value of an example. This could be the case if we want to demonstrate the physics of the code (and I think this could be a good idea). At the moment, our examples do not explain the physics or physical motivation behind the examples. Instead, I designed the examples to be utilitarian to demonstrate valid syntax patterns for setting up a model. The physical aspects of the examples is incidental and not explained or justified (though I do think that for users who understand the physics, this ""extra sugar"" could be useful --- while causing no harm to users who do not understand the physics). Thus most of the plots simply demonstrate that the code ""did something"". They don't show anything meaningful in my opinion. I am all for more physically meaningful examples. But we should always think carefully about the purpose of the examples and each line of code they contain. Some of our examples should be about code and not physics --- because this better serves users who do not understand the physics (who would be distracted by lengthy physical justifications / discussions in the examples). . If ""vorticity"" as a title is not clear enough for the two-dimensional turbulence example we can say ""Heatmap of vorticity on an arbitrary scale""? Would that be more clear? The point of plotting vorticity is to demonstrate that the ""diagnostic"" that was defined is actually returning something (any significance of what was returned is just a bonus from the standpoint of that example, not a critical aspect of the example's purpose). Note that when I code things up I often use `imshow` for exactly this purpose; thus creating a plo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793:1939,simpl,simply,1939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793,1,['simpl'],['simply']
Usability,"io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <ø> (ø)` | |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `85.71% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `91.78% <69.23%> (-6.70%)` | :arrow_down: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `92.06% <85.71%> (+0.99%)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `89.18% <100.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <100.00%> (+5.31%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=footer). Last update [994eae3...a77b356](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/839?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251:2488,learn,learn,2488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839#issuecomment-670153251,1,['learn'],['learn']
Usability,"io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | | |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | | |; | [src/Operators/derivative\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9kZXJpdmF0aXZlX29wZXJhdG9ycy5qbA==) | | |; | [src/Operators/tracer\_advection\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | | |; | [...ure\_implementations/leith\_enstrophy\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2xlaXRoX2Vuc3Ryb3BoeV9kaWZmdXNpdml0eS5qbA==) | | |; | [...nce\_closure\_implementations/blasius\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2JsYXNpdXNfc21hZ29yaW5za3kuamw=) | | |; | ... and [75 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=footer). Last update [91e5626...45bf8a8](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/280?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532:3385,learn,learn,3385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280#issuecomment-500250532,1,['learn'],['learn']
Usability,"ion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `71.42% <0.00%> (ø)` | |; | [.../IncompressibleModels/show\_incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9zaG93X2luY29tcHJlc3NpYmxlX21vZGVsLmps) | `0.00% <ø> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `40.00% <ø> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `87.50% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `60.00% <ø> (ø)` | |; | [src/Models/Models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <ø> (ø)` | |; | ... and [8 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=footer). Last update [03a6f85...0386f31](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1174?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449:3606,learn,learn,3606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1174#issuecomment-727277449,1,['learn'],['learn']
Usability,"jL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100.00% <0.00%> (+33.33%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=footer). Last update [9b9e8e2...1c31ca5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/758?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290:3341,learn,learn,3341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758#issuecomment-632044290,1,['learn'],['learn']
Usability,"jL2dyaWRzLmps) | `94.59% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `0% <0%> (ø)` | |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <40%> (+12.5%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `38.46% <50%> (+1.61%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...c863622](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823:3102,learn,learn,3102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127823,1,['learn'],['learn']
Usability,"jl/pull/922/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #922 +/- ##; ==========================================; + Coverage 72.78% 72.79% +0.01% ; ==========================================; Files 192 192 ; Lines 5643 5649 +6 ; ==========================================; + Hits 4107 4112 +5 ; - Misses 1536 1537 +1 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.36% <ø> (ø)` | |; | [src/AbstractOperations/multiary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9tdWx0aWFyeV9vcGVyYXRpb25zLmps) | `86.36% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `85.71% <0.00%> (-3.18%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `96.29% <0.00%> (+0.14%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=footer). Last update [01b2481...ba87adc](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/922?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084:2017,learn,learn,2017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/922#issuecomment-689771084,1,['learn'],['learn']
Usability,"jl/pull/932/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <ø> (ø)` | |; | [src/Diagnostics/Diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL0RpYWdub3N0aWNzLmps) | `100.00% <ø> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `93.61% <ø> (ø)` | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | `99.25% <ø> (-0.08%)` | :arrow_down: |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [10 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=footer). Last update [3b45ce5...82d362a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/932?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401:3252,learn,learn,3252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932#issuecomment-691237401,1,['learn'],['learn']
Usability,"just a comment: pressure correction (as done now) is just one piece of an implicit in time; component of the time stepping. The more general form would be: explicit part (AB or RK or just ; simple forward) then implicit part (including: pressure correction, implicit vertical for ; diffusion/viscosity or/and advection, implicit relaxation/damping). On Tue, Feb 12, 2019 at 06:58:27PM -0800, Ali Ramadhan wrote:; > Yeah I think the current time stepping algorithm (essentially what the MITgcm does) is pretty custom so it's probably not shared by other equations/methods, but the pressure correction step is pretty common to finite volume Navier-Stokes solvers and it should be possible to generalize it.; > ; > I'm thinking it might be good to tackle ""generic time stepping"" in two steps. 1. Getting the current version of the time stepping algorithm running efficiently on GPUs for milestone v0.4 and then 2. we can redesign for v0.5 and include more generic time stepping.; > ; > ; > -- ; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub:; > https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463036545",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259:190,simpl,simple,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/49#issuecomment-463042259,1,['simpl'],['simple']
Usability,"k the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do some version of the unique directories? Or maybe have `overwrite_existing = false` (the default) just rename existing files?. I'm not sure of the best approach but as someone who's conservative about overwriting by default I'm tempted to err on the side of caution. > Another abstraction I think would be useful is a utility for building multiple outputs. Imagine this:; > ; > ```julia; > indices = (xy=(:, :, k), xz=(:, 1, :), yz=(1, :, :)); > sliced_outputs!(simulation, outputs, i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:1534,simpl,simply,1534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,1,['simpl'],['simply']
Usability,"l/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=footer). Last update [7a47b92...a20cf39](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:3557,learn,learn,3557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['learn'],['learn']
Usability,"l/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9pc290cm9waWNfZGlmZnVzaXZpdHkuamw=) | `100% <100%> (ø)` | |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [...ulenceClosures/constant\_anisotropic\_diffusivity.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jb25zdGFudF9hbmlzb3Ryb3BpY19kaWZmdXNpdml0eS5qbA==) | `100% <100%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.43% <100%> (+1.92%)` | :arrow_up: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `23.8% <25%> (-1.2%)` | :arrow_down: |; | [src/buoyancy.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree#diff-c3JjL2J1b3lhbmN5Lmps) | `77.41% <68.42%> (-10.09%)` | :arrow_down: |; | ... and [8 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=footer). Last update [99b1a70...5d796b5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/452?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654:3578,learn,learn,3578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452#issuecomment-541188654,1,['learn'],['learn']
Usability,"l/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <ø> (ø)` | |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Advection/weno\_nth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX250aF9vcmRlci5qbA==) | `53.19% <53.19%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <57.14%> (ø)` | |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `66.66% <66.66%> (+1.66%)` | :arrow_up: |; | [src/Advection/weno\_fifth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi93ZW5vX2ZpZnRoX29yZGVyLmps) | `80.46% <80.46%> (ø)` | |; | ... and [69 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=footer). Last update [d80be8c...7612a01](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/592?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399:3291,learn,learn,3291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-573978399,1,['learn'],['learn']
Usability,"l/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `75.86% <0.00%> (-10.81%)` | :arrow_down: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `53.84% <0.00%> (-5.13%)` | :arrow_down: |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `90.00% <0.00%> (-3.75%)` | :arrow_down: |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `0.00% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (+1.10%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=footer). Last update [e9583ce...19cd67a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/933?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830:3387,learn,learn,3387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/933#issuecomment-691108830,1,['learn'],['learn']
Usability,"l=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/54d8aa1ee1218ffed70232a277cc8cff5b72dc5b?src=pr&el=desc) will **decrease** coverage by `0.07%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #303 +/- ##; ==========================================; - Coverage 71.8% 71.72% -0.08% ; ==========================================; Files 24 24 ; Lines 1000 1001 +1 ; ==========================================; Hits 718 718 ; - Misses 282 283 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `58.33% <0%> (-1.67%)` | :arrow_down: |; | [src/time\_step\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcF91dGlscy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=footer). Last update [54d8aa1...4ac5bb2](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/303?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525:1750,learn,learn,1750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/303#issuecomment-506990525,1,['learn'],['learn']
Usability,"lZF9maWVsZC5qbA==) | `94.44% <ø> (ø)` | |; | [src/Fields/function\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9mdW5jdGlvbl9maWVsZC5qbA==) | `23.07% <0.00%> (ø)` | |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `76.47% <50.00%> (-10.20%)` | :arrow_down: |; | [src/AbstractOperations/averages\_of\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9hdmVyYWdlc19vZl9vcGVyYXRpb25zLmps) | `66.66% <66.66%> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <75.00%> (-4.87%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `89.47% <76.92%> (-6.83%)` | :arrow_down: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `77.77% <77.77%> (ø)` | |; | ... and [9 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=footer). Last update [e9583ce...ba8fc61](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/931?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059:3316,learn,learn,3316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931#issuecomment-690822059,1,['learn'],['learn']
Usability,"l](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2RpYWdub3N0aWNzX2tlcm5lbHMuamw=) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `36.36% <0.00%> (+1.06%)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100.00% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100.00% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `36.84% <ø> (ø)` | |; | [src/TurbulenceClosures/turbulence\_closure\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfdXRpbHMuamw=) | `75.00% <0.00%> (-25.00%)` | :arrow_down: |; | ... and [80 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=footer). Last update [ecc0fda...8a9755b](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/805?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378:3259,learn,learn,3259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805#issuecomment-660540378,1,['learn'],['learn']
Usability,"l](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <100%> (+43.75%)` | :arrow_up: |; | [src/turbulence\_closures/smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvc21hZ29yaW5za3kuamw=) | `67.79% <100%> (ø)` | :arrow_up: |; | [...bulence\_closures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX2RpYWdub3N0aWNzLmps) | `20% <20%> (ø)` | |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `70.21% <25%> (+5.76%)` | :arrow_up: |; | [...rc/turbulence\_closures/turbulence\_closure\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdHVyYnVsZW5jZV9jbG9zdXJlX3V0aWxzLmps) | `62.5% <62.5%> (ø)` | |; | ... and [4 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=footer). Last update [dd122e9...17e7f14](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/407?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704:3561,learn,learn,3561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/407#issuecomment-531510704,1,['learn'],['learn']
Usability,"lat` do not refer to boundary conditions, but to the ""topology"" of a domain. Envision a two-dimensional domain as a piece of paper. If the domain is `Bounded` in both direction, then by default no fluid can enter or leave the paper (in addition to other conditions imposed on the physics). If the domain is `Periodic` in one direction, then its as if the paper is curled into a cylinder: fluid leaving the right side of the domain reappears on the left side. This is what it means for a domain to be `Periodic`. When a direction has a `Periodic` topology, we impose ""periodic boundary conditions"" (though a better way to think about this scenario is that there is no boundary at all!) Periodic topologies are convenient for all sorts of problems, which is why you see them cropping up in the examples frequently. If you can use a domain that is periodic in the ""streamwise"" direction (the direction oriented with the primary direction of your flow), you may make your life a bit simpler. A `Flat` topology is the Oceananigans way of saying that your problem does not vary in that direction. If one direction is `Flat`, then your problem is two-dimensional. So you don't impose boundary conditions in `Flat` directions either. When a direction is `Bounded`, you may impose `Value`, `Gradient`, and `Flux` boundary conditions on tracers and the components of the velocity field that are _tangential_ to the boundary. (Note that the velocity component _normal_ to the boundary is special. It is trickier to set boundary conditions on this component, and I don't think you will need to do this for your project.) If your domain is periodic in x and bounded in z, then you only need to worry about imposing boundary conditions at the top and bottom on tracers, `u`, and `v`. I am happy to help more if you like. You can also try to _force_ your flow to drive motion, rather than by imposing boundary conditions. Sometimes this approach is a bit simpler than forcing a flow by applying boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819091284:2336,simpl,simpler,2336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1572#issuecomment-819091284,1,['simpl'],['simpler']
Usability,"lation models-constant anisotropic diffusivity section of the documentation. Probably should have sanity checked them beforehand. > julia> using Oceananigans.TurbulenceClosures; >; >julia> closure = AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1); >AnisotropicDiffusivity: (νx=0.001, νy=0.001, νz=0.05), (κx=0.002, κy=0.002, κz=0.1). Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The kinematic viscosity `νh=1e-3` looks to be much too big, though, with typical values ranging from `1.8 *10^-6` m^2/sec at 0ºC to `1.0*10^-6` m^2/ sec at 20ºC. However, substituting those measured values in results in an even more fantastic blowup than before:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763049-b720fa80-2aae-11eb-860e-ce707cd9d874.gif). Substituting in a larger value (1) for the kinematic viscosity while keeping the above eddy diffusivities also leads to mayhem:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763726-5c889e00-2ab0-11eb-9a97-a6368ea470a3.gif). I should also note that the simulation issues happening in areas of strong temperature contrast are not exclusive to this specific kind of simulation. Even a simple wind stress simulation I tried to set up earlier with a fairly normal thermocline exhibits bizarre behavior at it (you'll probably have to view the gif frame by frame):; ![More Degeneracy](https://user-images.githubusercontent.com/55706146/99763478-cfdde000-2aaf-11eb-964f-b5c3e76c9e83.gif). Given the above results, it seems like it may be something other than the anisotropic diffusivity messing things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824:1676,simpl,simple,1676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824,1,['simpl'],['simple']
Usability,"lc3RzL0NvbnZlcmdlbmNlVGVzdHMvYW5hbHlzaXMuamw=) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [...nvergence\_tests/ConvergenceTests/file\_wrangling.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvZmlsZV93cmFuZ2xpbmcuamw=) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [test/test\_pressure\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ByZXNzdXJlX3NvbHZlcnMuamw=) | | |; | [test/test\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2hhbG9fcmVnaW9ucy5qbA==) | | |; | [...\_tests/ConvergenceTests/TwoDimensionalDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvVHdvRGltZW5zaW9uYWxEaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=footer). Last update [162159d...a538a52](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/797?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968:3208,learn,learn,3208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797#issuecomment-657830968,1,['learn'],['learn']
Usability,"lcy92ZWxvY2l0eV90cmFjZXJfZ3JhZGllbnRzLmps) | `69.72% <ø> (ø)` | |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `100% <ø> (ø)` | |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `25% <ø> (ø)` | |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <0%> (ø)` | |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.12% <100%> (-0.18%)` | :arrow_down: |; | ... and [11 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=footer). Last update [a9e34a7...7fe8a47](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/412?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518:3406,learn,learn,3406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532091518,1,['learn'],['learn']
Usability,"ld not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation.; > ; > For installations and dependency reduction, hopefully the new HDF5 release, which will for the first time support cross compilation, will lead to HDF5.jl switching to BinaryBuilder, which will allow NetCDF.jl to do the same. Also with the Clang.jl improvements we can regenerate the bindings. I still hope that NetCDFand NCDatasets will be able to share more code in the future, and be mainly about exposing different user facing APIs. Thanks for the feedback! My thinking was the same, why use HDF5.jl when NetCDF.jl and NCDatasets.jl exist since we want NetCDF output in the end. Sorry if I misrepresented the two packages, it was just what I gleaned by skimming a few issues and PRs. Will definitely keep a look out for new HDF5 releases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:3304,feedback,feedback,3304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['feedback'],['feedback']
Usability,"limate-machine/Oceananigans.jl/pull/519?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #519 +/- ##; ==========================================; - Coverage 64.61% 64.15% -0.47% ; ==========================================; Files 68 69 +1 ; Lines 1950 1964 +14 ; ==========================================; Hits 1260 1260 ; - Misses 690 704 +14; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `84.37% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `74.35% <100%> (ø)` | :arrow_up: |; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `60.39% <100%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=footer). Last update [08294f7...972fbd1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/519?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850:2141,learn,learn,2141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519#issuecomment-548595850,1,['learn'],['learn']
Usability,"limate-machine/Oceananigans.jl/pull/584?src=pr&el=h1) Report; > Merging [#584](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/588890004e69cfc7db10472b12a9840b8a9ad7b6?src=pr&el=desc) will **increase** coverage by `0.65%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #584 +/- ##; ==========================================; + Coverage 72.17% 72.82% +0.65% ; ==========================================; Files 70 70 ; Lines 2016 2050 +34 ; ==========================================; + Hits 1455 1493 +38 ; + Misses 561 557 -4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `62.5% <0%> (+1.44%)` | :arrow_up: |; | [src/logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584/diff?src=pr&el=tree#diff-c3JjL2xvZ2dlci5qbA==) | `59.25% <0%> (+59.25%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=footer). Last update [5888900...b7cae54](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/584?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734:1600,learn,learn,1600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/584#issuecomment-568103734,1,['learn'],['learn']
Usability,"ll time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:2011,simpl,simple,2011,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['simpl'],['simple']
Usability,"ll/1047/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | `0.00% <0.00%> (ø)` | |; | [...ests/ConvergenceTests/DoublyPeriodicTaylorGreen.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRG91Ymx5UGVyaW9kaWNUYXlsb3JHcmVlbi5qbA==) | `0.00% <0.00%> (ø)` | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | `0.00% <0.00%> (ø)` | |; | [test/test\_coriolis.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2NvcmlvbGlzLmps) | `85.33% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.21% <0.00%> (ø)` | |; | [docs/bibliography.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-ZG9jcy9iaWJsaW9ncmFwaHkuamw=) | `0.00% <0.00%> (ø)` | |; | [...ergence\_tests/ConvergenceTests/ConvergenceTests.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvQ29udmVyZ2VuY2VUZXN0cy5qbA==) | `0.00% <0.00%> (ø)` | |; | ... and [95 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=footer). Last update [d100853...116f81c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1047?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132:3283,learn,learn,3283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1047#issuecomment-707893132,1,['learn'],['learn']
Usability,"losures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model using Oceananigans functionality and 2) a quasi-geostrophic model in Oceananigans (which would use the tridiagonal solver I mentioned earlier). What else? The best project is probably one that aligns with you and your students' research... ? Definitely happy to chat further and also collaborate on something if you'd like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2712,feedback,feedback,2712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['feedback'],['feedback']
Usability,"lux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.21% <0.00%> (-34.35%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `56.00% <0.00%> (-30.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (-21.56%)` | :arrow_down: |; | [src/Grids/Grids.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <0.00%> (-20.24%)` | :arrow_down: |; | [src/Solvers/index\_permutations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaW5kZXhfcGVybXV0YXRpb25zLmps) | `0.00% <0.00%> (-20.00%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-16.85%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `65.62% <0.00%> (-16.73%)` | :arrow_down: |; | ... and [172 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=footer). Last update [17f8cc6...19f23f1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/870?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161:3461,learn,learn,3461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870#issuecomment-681312161,1,['learn'],['learn']
Usability,"machine/Oceananigans.jl/pull/418?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #418 +/- ##; ==========================================; + Coverage 73.28% 76.87% +3.59% ; ==========================================; Files 25 25 ; Lines 1426 1427 +1 ; ==========================================; + Hits 1045 1097 +52 ; + Misses 381 330 -51; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `86.88% <0%> (+1.63%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `85.57% <0%> (+12.76%)` | :arrow_up: |; | [...c/turbulence\_closures/velocity\_tracer\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVsb2NpdHlfdHJhY2VyX2dyYWRpZW50cy5qbA==) | `86.23% <0%> (+16.51%)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvdmVyc3RhcHBlbl9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `84.74% <0%> (+32.2%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=footer). Last update [a9e34a7...2dff13a](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/418?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457:2145,learn,learn,2145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/418#issuecomment-532833457,1,['learn'],['learn']
Usability,"machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9zbWFnb3JpbnNreS5qbA==) | `77.33% <100%> (ø)` | :arrow_up: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `53.84% <100%> (ø)` | :arrow_up: |; | [...ures/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy92ZXJzdGFwcGVuX2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <16.66%> (ø)` | |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25% <25%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <33.33%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=footer). Last update [7bbdd3d...f61dbc6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/463?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268:3465,learn,learn,3465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463#issuecomment-541339268,1,['learn'],['learn']
Usability,"model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `61.53% <0.00%> (+2.56%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <0.00%> (+6.34%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `66.66% <0.00%> (+11.11%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `67.64% <0.00%> (+32.35%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=footer). Last update [533abcd...45c9255](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/742?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623:3200,learn,learn,3200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742#issuecomment-622097623,1,['learn'],['learn']
Usability,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2702,clear,clearer,2702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,2,['clear'],"['clear', 'clearer']"
Usability,"n=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #662 +/- ##; =========================================; + Coverage 78.06% 78.2% +0.14% ; =========================================; Files 118 118 ; Lines 2362 2368 +6 ; =========================================; + Hits 1844 1852 +8 ; + Misses 518 516 -2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100%> (+3.17%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `96.29% <100%> (+3.7%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.07% <100%> (-0.31%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `91.17% <88.88%> (+5.46%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=footer). Last update [042f8cf...90e9560](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/662?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845:2085,learn,learn,2085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/662#issuecomment-592911845,1,['learn'],['learn']
Usability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:2919,clear,clearer,2919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['clear'],['clearer']
Usability,"nditions/fill\_halo\_regions\_flat.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc19mbGF0Lmps) | `0.00% <0.00%> (-100.00%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `8.77% <0.00%> (-87.78%)` | :arrow_down: |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `0.00% <0.00%> (-85.08%)` | :arrow_down: |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `0.00% <0.00%> (-84.00%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `0.00% <0.00%> (-79.17%)` | :arrow_down: |; | ... and [121 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=footer). Last update [7687ab6...616ee5f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1025?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629:3750,learn,learn,3750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1025#issuecomment-707938629,1,['learn'],['learn']
Usability,"nes 676 754 +78 ; ==========================================; + Hits 449 523 +74 ; - Misses 227 231 +4; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcGVyYXRvcnMuamw=) | `100% <ø> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `86.86% <100%> (+2.81%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.9% <100%> (+0.43%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `86.71% <86.11%> (+0.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=footer). Last update [7e29af4...ac6ed18](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/218?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822:2389,learn,learn,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218#issuecomment-491127822,1,['learn'],['learn']
Usability,nigans.jl/pull/591?src=pr&el=h1) Report; > Merging [#591](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/91a9f6d1d51c8c23cd40e5f77c52e55278e44fb3?src=pr&el=desc) will **increase** coverage by `0.18%`.; > The diff coverage is `65.47%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #591 +/- ##; ==========================================; + Coverage 73.14% 73.33% +0.18% ; ==========================================; Files 70 117 +47 ; Lines 2011 2014 +3 ; ==========================================; + Hits 1471 1477 +6 ; + Misses 540 537 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `50% <ø> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.53% <ø> (ø)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `50% <ø> (ø)` | |; | [src/Solvers/solver\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVyX3V0aWxzLmps) | `82.6% <ø> (ø)` | :arrow_up: |; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/591/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `100% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codec,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573467341:1086,simpl,simple,1086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591#issuecomment-573467341,1,['simpl'],['simple']
Usability,"nigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9uZXdfZGF0YS5qbA==) | `66.66% <66.66%> (ø)` | |; | [src/TurbulenceClosures/diffusivity\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9kaWZmdXNpdml0eV9maWVsZHMuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/Utils/kernel\_launching.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2tlcm5lbF9sYXVuY2hpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `94.93% <0.00%> (+2.30%)` | :arrow_up: |; | [src/AbstractOperations/computations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9jb21wdXRhdGlvbnMuamw=) | `74.54% <0.00%> (+3.49%)` | :arrow_up: |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=footer). Last update [6d349e1...bbb2e4c](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/914?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336:3013,learn,learn,3013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/914#issuecomment-688933336,1,['learn'],['learn']
Usability,"now `norm` seems that it's not working for simple RectilinearGrid :); E.g., in the pgc solver, `residual_norm = norm(solver.residual)` gives zero... even when q=0 but rhs $\ne$ 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247693563:43,simpl,simple,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247693563,1,['simpl'],['simple']
Usability,ns.jl/pull/589?src=pr&el=h1) Report; > Merging [#589](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/77a22efa732b5fc2596231aa319c446ca80d835d?src=pr&el=desc) will **increase** coverage by `4.78%`.; > The diff coverage is `68.48%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #589 +/- ##; ==========================================; + Coverage 71.64% 76.42% +4.78% ; ==========================================; Files 77 124 +47 ; Lines 2095 2117 +22 ; ==========================================; + Hits 1501 1618 +117 ; + Misses 594 499 -95; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `50% <ø> (ø)` | |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.53% <ø> (ø)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `50% <ø> (ø)` | |; | [src/Models/model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <ø> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335:1090,simpl,simple,1090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335,1,['simpl'],['simple']
Usability,"ns/solution\_and\_model\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zb2x1dGlvbl9hbmRfbW9kZWxfYm91bmRhcnlfY29uZGl0aW9ucy5qbA==) | `94.59% <0%> (+5.4%)` | :arrow_up: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.68% <0%> (+6.55%)` | :arrow_up: |; | [src/Architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `88.88% <0%> (+22.22%)` | :arrow_up: |; | [src/Fields/set!.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `61.76% <0%> (+26.47%)` | :arrow_up: |; | [src/Solvers/plan\_transforms.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `100% <0%> (+33.33%)` | :arrow_up: |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <0%> (+56.6%)` | :arrow_up: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=footer). Last update [0f1f5ab...99f7404](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/626?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797:3474,learn,learn,3474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/626#issuecomment-586645797,1,['learn'],['learn']
Usability,"nto [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/47b46131e951c906dc38c29125395792762de57e?src=pr&el=desc) will **increase** coverage by `3.21%`.; > The diff coverage is `77.77%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #140 +/- ##; ========================================; + Coverage 56.78% 60% +3.21% ; ========================================; Files 19 19 ; Lines 597 620 +23 ; ========================================; + Hits 339 372 +33 ; + Misses 258 248 -10; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `80% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `37.64% <77.77%> (+37.64%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.72% <0%> (+0.63%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=footer). Last update [47b4613...b880a9b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/140?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129:1759,learn,learn,1759,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140#issuecomment-474633129,1,['learn'],['learn']
Usability,"o/gh/CliMA/Oceananigans.jl/commit/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251?el=desc) will **increase** coverage by `0.36%`.; > The diff coverage is `90.00%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #1082 +/- ##; ==========================================; + Coverage 56.79% 57.16% +0.36% ; ==========================================; Files 161 161 ; Lines 3796 3838 +42 ; ==========================================; + Hits 2156 2194 +38 ; - Misses 1640 1644 +4 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `83.01% <80.00%> (-1.30%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `88.15% <86.36%> (+0.22%)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `87.77% <95.65%> (+2.48%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=footer). Last update [e1026b0...d018eae](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1082?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035:1790,learn,learn,1790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082#issuecomment-712562035,1,['learn'],['learn']
Usability,"o/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=h1) Report; > Merging [#205](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/7f03edacd8acbded7bb1377c80b6995fc6c925b1?src=pr&el=desc) will **decrease** coverage by `0.09%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #205 +/- ##; =========================================; - Coverage 66.51% 66.42% -0.1% ; =========================================; Files 18 18 ; Lines 675 676 +1 ; =========================================; Hits 449 449 ; - Misses 226 227 +1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `55.17% <0%> (-1.98%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=footer). Last update [7f03eda...899ef72](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/205?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891:1594,learn,learn,1594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/205#issuecomment-485808891,2,['learn'],['learn']
Usability,"odecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=h1) Report; > Merging [#249](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/b746a0bce63642a8beb9e6771b4b43cd17368ba6?src=pr&el=desc) will **decrease** coverage by `0.73%`.; > The diff coverage is `28.57%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #249 +/- ##; ==========================================; - Coverage 74.71% 73.97% -0.74% ; ==========================================; Files 23 24 +1 ; Lines 866 876 +10 ; ==========================================; + Hits 647 648 +1 ; - Misses 219 228 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (+16.66%)` | :arrow_up: |; | [src/architectures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249/diff?src=pr&el=tree#diff-c3JjL2FyY2hpdGVjdHVyZXMuamw=) | `28.57% <28.57%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=footer). Last update [b746a0b...b40c347](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/249?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941:1586,learn,learn,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496661941,1,['learn'],['learn']
Usability,"odecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=h1) Report; > Merging [#381](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/289b1e3f8bb0012bfee30f1d8eb12f75179c2c4b?src=pr&el=desc) will **increase** coverage by `0.42%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #381 +/- ##; ==========================================; + Coverage 71.65% 72.07% +0.42% ; ==========================================; Files 26 26 ; Lines 1418 1418 ; ==========================================; + Hits 1016 1022 +6 ; + Misses 402 396 -6; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.66% <0%> (+3.38%)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `83.51% <0%> (+4.39%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=footer). Last update [289b1e3...55ae7b1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/381?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779:1569,learn,learn,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381#issuecomment-525894779,1,['learn'],['learn']
Usability,"oh, you suggested barotropic... yeah, that'd be even simpler!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140522625:53,simpl,simpler,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140522625,1,['simpl'],['simpler']
Usability,"omg, I was simply computing the limits for w! 🤦‍♂️; ```; P = file[""timeseries/w/$iteration""][:, 1, :]; ```; ....; sorry -- false alarm: P is positive!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723509541:11,simpl,simply,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128#issuecomment-723509541,1,['simpl'],['simply']
Usability,"ommit/27493f3682e4996af2e2abf4be240abe6384a3fd?src=pr&el=desc) will **increase** coverage by `0.37%`.; > The diff coverage is `76.19%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #438 +/- ##; ==========================================; + Coverage 73.46% 73.83% +0.37% ; ==========================================; Files 27 27 ; Lines 1515 1525 +10 ; ==========================================; + Hits 1113 1126 +13 ; + Misses 402 399 -3; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/coriolis.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL2NvcmlvbGlzLmps) | `76.19% <76.19%> (+16.19%)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `68.53% <0%> (+4.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=footer). Last update [27493f3...88427a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/438?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716:1827,learn,learn,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/438#issuecomment-537980716,1,['learn'],['learn']
Usability,"on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:2551,simpl,simplify,2551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,1,['simpl'],['simplify']
Usability,"ondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. We can also either i) materialize whatever the user provides into a full boundary condition or ii) build `BoundaryCondition` on the fly inside the kernel (it would get compiled away probably anyways). We don't need to modify the existing `getbc` methods. > For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. I agree, I think it's acceptable if the `condition` corresponds to the prescribed external state only, and the halo regions are determined by a calculation that additionally involves a scheme + the internal state. The main difference is where the matching calculation is performed --- either in `getbc`, or in `fill_halo_regions`. I don't think either choice is ""harder"" than the other. The difference and points to consider regard code clarity. That said, I see the advantages of generalizing `Open` rather than adding a new classification. Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over? . I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an analytical solution like a mode-1 internal wave as the external state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703:1659,simpl,simple,1659,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703,1,['simpl'],['simple']
Usability,"onvergenceTests/ForcedFlowFreeSlip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvRm9yY2VkRmxvd0ZyZWVTbGlwLmps) | | |; | [test/test\_forcings.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZvcmNpbmdzLmps) | | |; | [...vergence\_tests/analyze\_single\_forced\_fixed\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfc2luZ2xlX2ZvcmNlZF9maXhlZF9zbGlwLmps) | | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | | |; | [examples/eady\_turbulence.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvZWFkeV90dXJidWxlbmNlLmps) | | |; | [...tion/convergence\_tests/analyze\_forced\_free\_slip.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL2FuYWx5emVfZm9yY2VkX2ZyZWVfc2xpcC5qbA==) | | |; | ... and [50 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=footer). Last update [d383b6a...76c651a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/793?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751:3266,learn,learn,3266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/793#issuecomment-657517751,1,['learn'],['learn']
Usability,"oops - pasted this in the wrong place earlier! . @glwagner and @ali-ramadhan I took a quick look.; I think you should go ahead and merge, but quick comments for future reference -. there are a bunch of changes unrelated to the PR in the PR. They are probably there by accident, but the Git gods really don't like that. When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Most git projects more diligent about avoiding polluted PRs, which can be useful. I think ultimately we want halos to just be a thing that does a slightly more general form of what is in ::PBC mode. Everything else is not in halo rules. This is where we ended up in MITgcm and is similar to what is in MPIStateArray in the DG work (I am fairly sure!). A distinction to maybe think about is a set of halo() functions that just do the stuff that does not appear in any of the equations. Anything in equations turns out to be stuff that people may want to tinker with in surprisingly interesting ways. For example someone ultimately might want to do a numerical experiment that has flux BC on some set of the one bit of a boundary, something else on another bit etc.... (people do do things like this). For better or worse having bc's better separated from halos may ultimately prove the right thing. For now I wouldn't worry about it though!. Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Types are good for simple things, but Type::ItsComplicated is often also needed eventually. summary - +1 for merge, ; per https://github.com/google/eng-practices/blob/master/review/reviewer/standard.md ""its a step forward, its not a step backward, its maybe not the ultimate answer""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853:1581,simpl,simple,1581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853,1,['simpl'],['simple']
Usability,"opy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the `IncompressibleModel` is really more of an `OceanModel` as evidence by the `surface_waves` functionality and the `SeawaterBuoyancy` default. And the proposed `CompressibleModel` is already more of an `AtmosphericModel` as tracers representing mixing ratios like ql, qv, qi, etc. are given special treat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2439,simpl,simplify,2439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['simpl'],['simplify']
Usability,"oundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `21.87% <100.00%> (ø)` | |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `86.20% <100.00%> (+0.49%)` | :arrow_up: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `91.22% <100.00%> (+0.15%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `77.08% <100.00%> (+3.61%)` | :arrow_up: |; | [...ions/verstappen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `88.05% <100.00%> (+0.18%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=footer). Last update [847d446...9220221](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/820?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610:3060,learn,learn,3060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/820#issuecomment-663134610,1,['learn'],['learn']
Usability,"ov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `65.62% <100%> (+2.29%)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `76.66% <22.22%> (-18.79%)` | :arrow_down: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `51.63% <40.54%> (-6.81%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `52.77% <51.61%> (+34.59%)` | :arrow_up: |; | [src/closures/anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2FuaXNvdHJvcGljX21pbmltdW1fZGlzc2lwYXRpb24uamw=) | `96.96% <96.96%> (ø)` | |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=footer). Last update [8fdff75...11e3043](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/309?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002:3259,learn,learn,3259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309#issuecomment-508958002,2,['learn'],['learn']
Usability,"ov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9tb2RlbC5qbA==) | `91.66% <ø> (ø)` | |; | [...c/Solvers/horizontally\_periodic\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvaG9yaXpvbnRhbGx5X3BlcmlvZGljX3ByZXNzdXJlX3NvbHZlci5qbA==) | `98.11% <ø> (+56.6%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `73.68% <ø> (ø)` | :arrow_up: |; | [src/Solvers/channel\_pressure\_solver.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvY2hhbm5lbF9wcmVzc3VyZV9zb2x2ZXIuamw=) | `98.63% <ø> (+68.49%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <ø> (ø)` | :arrow_up: |; | ... and [137 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=footer). Last update [77a22ef...4b78751](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/589?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335:3437,learn,learn,3437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589#issuecomment-573490335,1,['learn'],['learn']
Usability,"overage by `0.29%`.; > The diff coverage is `55%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #444 +/- ##; =========================================; - Coverage 71.85% 71.55% -0.3% ; =========================================; Files 25 26 +1 ; Lines 1400 1417 +17 ; =========================================; + Hits 1006 1014 +8 ; - Misses 394 403 +9; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `81.57% <ø> (-0.48%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `47.67% <45.45%> (-1.68%)` | :arrow_down: |; | [src/forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444/diff?src=pr&el=tree#diff-c3JjL2ZvcmNpbmcuamw=) | `66.66% <66.66%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=footer). Last update [4b7e5bc...5a6c772](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/444?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456:1909,learn,learn,1909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444#issuecomment-539584456,1,['learn'],['learn']
Usability,"ow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `86.07% <100%> (+6.28%)` | :arrow_up: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `94.59% <100%> (+1.49%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `34.78% <25%> (+1.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `36.84% <48.57%> (-6.71%)` | :arrow_down: |; | ... and [6 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=footer). Last update [bbc8643...387aeda](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/147?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615:3140,learn,learn,3140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147#issuecomment-475444615,1,['learn'],['learn']
Usability,"pbWVfc3RlcHBpbmcuamw=) | `92.59% <0.00%> (-2.65%)` | :arrow_down: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `87.50% <0.00%> (-1.39%)` | :arrow_down: |; | [src/Utils/with\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3dpdGhfdHJhY2Vycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...bulence\_closure\_implementations/nothing\_closure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL25vdGhpbmdfY2xvc3VyZS5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/TimeSteppers/quasi\_adams\_bashforth\_2.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9xdWFzaV9hZGFtc19iYXNoZm9ydGhfMi5qbA==) | `84.84% <0.00%> (ø)` | |; | [src/TimeSteppers/runge\_kutta\_3.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9ydW5nZV9rdXR0YV8zLmps) | `85.07% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.44% <0.00%> (+0.82%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=footer). Last update [10949b0...369c7ba](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/948?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632:3387,learn,learn,3387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948#issuecomment-694124632,1,['learn'],['learn']
Usability,"pe and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so on. help?> plan_fft!; search: plan_fft! plan_ifft! plan_bfft! plan_fft plan_rfft plan_ifft plan_bfft plan_irfft plan_brfft. plan_fft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Same as plan_fft, but operates in-place on A.; ```. But I just learned that you can apply the inverse plan with `P \ Â` which is cool!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:2248,learn,learned,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,1,['learn'],['learned']
Usability,"pected the sponge layer to be _identically_ zero for most of the domain. Us not ""being on the same page"" here (for the lack of a better description! haha) may be due to different philosophies of what a sponge layer should be. So, due to my background, a sponge layer should be a function that _only_ acts in a _finite_ part of the domain. So, for example, in my code I set-up the sponge layer mask as. ```; mask = H(-(z-z₀)) ⋅ (z - z₀)² / (z₁ - z₀)²; ```; with H(z) being the Heaviside function. Comparing this to the Gaussian mask, this has a disadvantage of not being as smooth (although it should be smooth enough because of the (z - z₀)² / (z₁ - z₀)² term, and we can always increase the order of the exponents). However it has a very important advantage: I know _exactly_ when it stops influencing my solution. So I know that in the range `(z₀, max(z)]` my solver is solving the NS equations (plus or minus some approximations) without any added nonphysical term. I was always taught (and I still agree) that setting up a sponge layer mask as something that only reaches zero at infinity (like a Gaussian) is not recommended since you don't know when do start believing your solution. In practice if you're 4σs away from the center of the Gaussian you're pretty sure that the sponge layer influences are minimal (but they're not exactly zero!). But a harder question is: how far away is far enough?. A note here should be that if my mask was simply `mask = H(-(z-z₀))` it would probably fail as a sponge layer because, as @navidcy and @glwagner have pointed out, it would reflect a ton of waves. So the transition should be done with care. So, again, I think it boils down to your background and modeling philosophy! But it would be nice to have options for finite-range masks, such as the one I imposed, as well. (Although there are many other functions that are used and mine is probably the easiest one you can come up with...). I hope I made the issue clearer! And sorry about any confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734431314:1740,simpl,simply,1740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-734431314,2,"['clear', 'simpl']","['clearer', 'simply']"
Usability,"pen\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3ZlcnN0YXBwZW5fYW5pc290cm9waWNfbWluaW11bV9kaXNzaXBhdGlvbi5qbA==) | `86.81% <0.00%> (-1.07%)` | :arrow_down: |; | [src/BoundaryConditions/fill\_halo\_regions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9ucy5qbA==) | `85.00% <0.00%> (-0.72%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `90.54% <0.00%> (-0.54%)` | :arrow_down: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `75.00% <0.00%> (+1.53%)` | :arrow_up: |; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `23.63% <0.00%> (+1.76%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=footer). Last update [847d446...d0e01fa](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/817?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061:2948,learn,learn,2948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/817#issuecomment-663198061,1,['learn'],['learn']
Usability,"pproach could completely fail if we had cut cells, which represents another caveat. The problem is that, when the cell facets are no longer oriented along one of x, y, z, we need to define what a flux across the bottom _means_. Is it a flux normal to the boundary, or is it a flux projected along one of the orthogonal directions? I'm not sure interpreting `ImmersedBoundaryCondition(bottom=flux)` as representing _only_ the vertical component of the bottom flux is sensible, especially when we consider the small scale limit or large eddy simulation or direct numerical simulation. We'll have to discuss that. To elaborate on the details, the geological constraint we have from observations is on the heat flux averaged over large patches of the ocean basin:. $$ Q_\text{obs} \approx \frac{1}{A} \int \boldsymbol{q} \cdot \boldsymbol{n} d A $$. where $A$ is the surface area of the ocean bottom (not the horizontal area). As you have noted, we can reproduce this constraint by applying the flux $Q$ across all upward facing facets. Then the total flux in our model is. $$ Q_\text{model} = \frac{1}{A_h} \int Q_\text{obs} d A_h $$. where $A_h$ is the horizontal area of the ocean basin and $d A_h$ is the horizontal projection of the surface area of the bottom. Clearly we obtain $Q_\text{model} = Q_\text{obs}$ and our goal is achieved. At small scales, this approximate model becomes questionable (but of course, it is also questionable to use a constant heat flux at small scales). Basically, I think that using this convenience actually obscures the true physics. So while it produces the right answer, it leads to confusion about what the observed geological heat flux actually represents, and the detailed physics of heat flux across irregular boundaries... That said, I take the very important point that the convenience greatly simplifies applying this kind of model at large scales. So I am more convinced that we should expose `ImmersedBoundaryCondition` to users --- despite the dangers...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510:2152,simpl,simplifies,2152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1587736510,1,['simpl'],['simplifies']
Usability,"pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `92.00% <100.00%> (+8.00%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Logger.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL0xvZ2dlci5qbA==) | `79.16% <0.00%> (-9.73%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `93.33% <0.00%> (-6.67%)` | :arrow_down: |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `94.11% <0.00%> (-5.89%)` | :arrow_down: |; | [...ntations/rozema\_anisotropic\_minimum\_dissipation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `32.00% <0.00%> (-2.10%)` | :arrow_down: |; | ... and [46 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=footer). Last update [bff7abc...b83618c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/699?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973:3619,learn,learn,3619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699#issuecomment-599283973,1,['learn'],['learn']
Usability,"ps://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `77.77% <0.00%> (ø)` | |; | [...ncompressibleModels/update\_hydrostatic\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9jbG9jay5qbA==) | `53.84% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=footer). Last update [03a6f85...f307336](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1184?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160:3562,learn,learn,3562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184#issuecomment-727480160,1,['learn'],['learn']
Usability,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `71.42% <0%> (-11.91%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `81.17% <100%> (ø)` | :arrow_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95% <100%> (+0.4%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `90.47% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <45.45%> (+13.58%)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `41.53% <45.61%> (+6.75%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `81.11% <57.14%> (-2.61%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `57.57% <90.9%> (+11.62%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=footer). Last update [b746a0b...e4ae7bd](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/250?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099:2656,learn,learn,2656,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250#issuecomment-496941099,1,['learn'],['learn']
Usability,"ps://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.3% <ø> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.14% <100%> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `56.25% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `97.65% <100%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `64.44% <100%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=footer). Last update [5cd0e33...e5556a7](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/406?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548:3387,learn,learn,3387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406#issuecomment-531502548,1,['learn'],['learn']
Usability,"pull/815/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0cy5qbA==) | `77.77% <ø> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `73.46% <57.14%> (ø)` | |; | [src/Advection/Advection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9BZHZlY3Rpb24uamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/centered\_second\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9zZWNvbmRfb3JkZXIuamw=) | `100.00% <100.00%> (ø)` | |; | [src/Advection/momentum\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9tb21lbnR1bV9hZHZlY3Rpb25fb3BlcmF0b3JzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/tracer\_advection\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90cmFjZXJfYWR2ZWN0aW9uX29wZXJhdG9ycy5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `88.88% <100.00%> (ø)` | |; | ... and [7 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=footer). Last update [1dbe86c...d42428d](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/815?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506:3192,learn,learn,3192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815#issuecomment-662674506,1,['learn'],['learn']
Usability,"pull/945/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `64.28% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | `94.73% <ø> (ø)` | |; | [...ce\_tests/ConvergenceTests/PointExponentialDecay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvUG9pbnRFeHBvbmVudGlhbERlY2F5Lmps) | `0.00% <ø> (ø)` | |; | [...ation/convergence\_tests/point\_exponential\_decay.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL3BvaW50X2V4cG9uZW50aWFsX2RlY2F5Lmps) | `0.00% <0.00%> (ø)` | |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `91.83% <66.66%> (-1.79%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `83.33% <81.81%> (+13.33%)` | :arrow_up: |; | ... and [11 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=footer). Last update [10949b0...0b7899a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/945?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129:3279,learn,learn,3279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692734129,1,['learn'],['learn']
Usability,"r than `Face` or `Center`. I think the issue here is that there are a few flavors of ""reduced fields"":. * ""Sliced fields"", which have reduced dimensionality, but still have a ""position"" in 3D space. These may be fields that exist only on boundaries, like the free surface, ice concentration, boundary conditions, etc. It should also be valid to define ""sliced fields"" at other positions / indices, inside the domain. If one of the ranges has a length 1, then the field is ""2.5 dimensional""... ?; * _Truly_ two-dimensional fields derived from a reduction operation, like `Average` or `Integral`. These fields have no position in the reduced dimension. To express the above in code, we might introduce a new location, perhaps `Level` (`Slice`, `Layer`, `Plane`...), which maybe stores both an integer `index` and the ""underlying location"". The free surface might have the location `Level{Face}(grid.Nz+1)` in the vertical (for example). I'm unsure the best solution to the masking issue. For 2.5D fields, the answer is clear: we need to evaluate `solid_interface` at the actual ""location"" of the field. Right now `Nothing` in the vertical means `k -> 1`. But this is _wrong_, as this issue identifies. If we have a new location `Level`, we can evaluate `solid_interface` at `Level.index` (for example). For truly 2D fields, it's murkier. I think in _general_ if one wants to identify whether an _entire_ dimension is masked, there's little choice but to evaluate the masking function at every index in that dimension. But there are special cases for which the job is a bit easier, because we encode assumptions about the shape of the immersed boundary. For example, `GridFittedBottom` assumes that masking occurs at every location _below_ a specified depth. Thus, a column can be identified as masked by evaluating `solid_interface` at the upper grid point, eg `k = grid.Nz`. So, we have a design problem on our hands to figure out how to represent these ideas in the code. We might need more types ;-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044:1132,clear,clear,1132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177#issuecomment-1021328044,1,['clear'],['clear']
Usability,"r&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/3f3ef52eaa68d8e28901d7acbed5d99960798307?src=pr&el=desc) will **increase** coverage by `0.15%`.; > The diff coverage is `n/a`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #496 +/- ##; ==========================================; + Coverage 73.31% 73.46% +0.15% ; ==========================================; Files 27 27 ; Lines 1525 1515 -10 ; ==========================================; - Hits 1118 1113 -5 ; + Misses 407 402 -5; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `88.23% <ø> (+8.68%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=footer). Last update [3f3ef52...2373483](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/496?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286:1747,learn,learn,1747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496#issuecomment-545579286,1,['learn'],['learn']
Usability,"r&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `39.28% <0%> (-35.3%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `77.24% <0%> (-1.68%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `60.29% <100%> (+0.61%)` | :arrow_up: |; | [src/turbulence\_closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvY29uc3RhbnRfc21hZ29yaW5za3kuamw=) | `52.77% <66.66%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.65% <0%> (-58.55%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `16.21% <0%> (-16.22%)` | :arrow_down: |; | [src/planetary\_constants.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree#diff-c3JjL3BsYW5ldGFyeV9jb25zdGFudHMuamw=) | `9.67% <0%> (-3.23%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=footer). Last update [16c363e...4738b6b](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/315?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612:3156,learn,learn,3156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315#issuecomment-515218612,1,['learn'],['learn']
Usability,"r.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `100% <100%> (ø)` | :arrow_up: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `84% <0%> (-1.72%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `65% <0%> (-1.67%)` | :arrow_down: |; | [src/TimeSteppers/adams\_bashforth.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9hZGFtc19iYXNoZm9ydGguamw=) | `100% <0%> (ø)` | :arrow_up: |; | [src/OutputWriters/checkpointer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvY2hlY2twb2ludGVyLmps) | `91.89% <0%> (+0.22%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `90% <0%> (+4.28%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80% <0%> (+30%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=footer). Last update [2ae1cbb...9ceb221](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/652?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860:3071,learn,learn,3071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/652#issuecomment-592508860,1,['learn'],['learn']
Usability,"rGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.54466e-16, 47.1239) regularly spaced with Δx=0.736311; ├── Periodic y ∈ [1.54466e-16, 47.1239) regularly spaced with Δy=0.736311; └── Bounded z ∈ [-15.0, 0.0] regularly spaced with Δz=0.234375. julia> using Oceananigans.Grids: zspacing. julia> zspacing(1, 1, 1, grid, Center(), Center(), Center())/2 # Half the distance around a center point; 0.1171875; ```. This is clearer, and will give you the correct value even if you change the grid in the future. Note that in the call to `zspacing()` above, we need to specify the x, y and z positions to get the spacing, but in a `RectilinearGrid` Δz is constant in x and y so those arguments don't really matter. Also note that the code above is written for the most recent Oceananigans version (for which you'll need Julia 1.9). 3. Now to your main point (sorry for the tangents! :grimacing:), I don't see anything obviously wrong with the code. Just from looking at it, it looks like it _should_ work. (Btw, when I say that, I assume this is a _only snippet, and not the full-code_, since I get errors when I try to run your code (`coriolis`, `T_bcs` and `S_bcs` aren't defined, `Fx` looks like it'd cause an error, etc.), so I haven't been able to properly run and test your snippet.). That said, there are things I personally would try:; - Have you tried better resolving the model? A 64^3 model _should_ be able to achieve a log-law, but it's still worth investigating.; - Have you tried using the `SmagorinskyLilly` closure? I've had some issues with AMD in the past (although not exactly the same as yours), and I remember @glwagner mentioning having an issue with AMD near boundaries that could explain the behavior you're seeing.; - Finally, I'd suggest starting with a very simple model first for debugging/investigating. Just the bare minimum to reproduce a log-law. (i.e., no tracers, buoyancy, Coriolis, forcing...). @Tinydog8 @chabbymark Hope this helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408:2889,simpl,simple,2889,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649999408,1,['simpl'],['simple']
Usability,"rations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `64.51% <0.00%> (-6.92%)` | :arrow_down: |; | [src/Fields/Fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9GaWVsZHMuamw=) | `75.00% <ø> (ø)` | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `90.33% <ø> (-0.75%)` | :arrow_down: |; | [src/AbstractOperations/binary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9iaW5hcnlfb3BlcmF0aW9ucy5qbA==) | `92.30% <100.00%> (+0.20%)` | :arrow_up: |; | [src/Fields/pressure\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9wcmVzc3VyZV9maWVsZC5qbA==) | `100.00% <100.00%> (ø)` | |; | [src/OutputWriters/windowed\_time\_average.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvd2luZG93ZWRfdGltZV9hdmVyYWdlLmps) | `97.05% <100.00%> (+3.51%)` | :arrow_up: |; | [test/test\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `99.38% <100.00%> (+0.04%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=footer). Last update [d6ce0fe...98b825f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/964?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162:2612,learn,learn,2612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/964#issuecomment-695015162,1,['learn'],['learn']
Usability,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [90 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=footer). Last update [681fa0b...3a08525](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/829?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380:3347,learn,learn,3347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/829#issuecomment-668439380,1,['learn'],['learn']
Usability,"rc=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b3lhbmN5Lmps) | `63.15% <0.00%> (-15.79%)` | :arrow_down: |; | [src/Solvers/pressure\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcHJlc3N1cmVfc29sdmVyLmps) | `70.00% <0.00%> (-11.82%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field\_tuples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZF90dXBsZXMuamw=) | `78.37% <0.00%> (-10.82%)` | :arrow_down: |; | [src/AbstractOperations/function\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9mdW5jdGlvbl9maWVsZHMuamw=) | `25.00% <0.00%> (-8.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `85.13% <0.00%> (-8.29%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `60.86% <0.00%> (-8.10%)` | :arrow_down: |; | ... and [89 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=footer). Last update [8fe4d65...89b7350](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/832?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485:3347,learn,learn,3347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/832#issuecomment-668891485,1,['learn'],['learn']
Usability,"red buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buoyancy-related parameters. Because of that we may want to stick with `buoyancy_perturbation`. Any ideas / alternative suggestions? An alternative is to perform a translation in the kernel functions; aka use `buoyancy_params` in the function signature of kernel(s) that call the function `buoyancy`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:1864,simpl,simply,1864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['simpl'],['simply']
Usability,"ree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #107 +/- ##; ==========================================; + Coverage 52.71% 53.15% +0.44% ; ==========================================; Files 19 19 ; Lines 645 649 +4 ; ==========================================; + Hits 340 345 +5 ; + Misses 305 304 -1; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.1% <100%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `69.15% <100%> (+1.19%)` | :arrow_up: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `85.71% <88.88%> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `81.81% <0%> (+9.09%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=footer). Last update [3cd4ae3...998ee38](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/107?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151:1980,learn,learn,1980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/107#issuecomment-469743151,1,['learn'],['learn']
Usability,"row_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <100%> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `42.85% <100%> (+6.01%)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `85% <100%> (-1.37%)` | :arrow_down: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `95.23% <100%> (+0.64%)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `52.94% <33.33%> (-28.24%)` | :arrow_down: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `40.9% <44.82%> (+6.12%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `82.24% <76.47%> (-1.78%)` | :arrow_down: |; | ... and [2 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=footer). Last update [9260f02...dc2a79c](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/167?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596:3133,learn,learn,3133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/167#issuecomment-483002596,1,['learn'],['learn']
Usability,"rs the equations of motion. We thus require an additional condition to close the system which determines $\bar \phi$, and usually we pick $\bar \phi = 0$. This constraint is implemented in this PR. Another way to close the system is to change the Poisson equation. Written discretely the proposal is to use. $$ \big ( \underbrace{A + \delta e e^T}_{\equiv \tilde A} \big ) \phi = R $$. where $\delta$ is a constant. I was a bit confused about this form until I understood that $e^T \phi = N \bar \phi$, so that in continuous from this would read. $$ \Bigg ( \underbrace{\nabla^2 + \frac{\delta N}{V} \int \mathrm{d} V}_{\tilde L} \Bigg ) \phi = \nabla^2 \phi + \delta N \bar \phi = R $$. where $\tilde L$ is the ""regularized Laplacian operator"". $\tilde L$ is regularized because taking the mean is well-defined:. $$ \overline{\tilde L \phi} = \delta N \bar \phi = \bar R $$. unlike the unregularized Poisson equation when $\bar R \ne 0$. In terms of implementation, this is simply implemented by defining a new linear operator that adds the additional term, eg. https://github.com/CliMA/Oceananigans.jl/blob/4f6ffd71933fc3dd55df8a6093fd52d420b06b1d/src/Solvers/conjugate_gradient_poisson_solver.jl#L47-L51. Here are a few more loose ends:. 1. I am wondering whether this perturbation or shifting of the Laplacian is independent of the preconditioner. For example, the FFT-based preconditioner _also_ applies a gauge condition:. https://github.com/CliMA/Oceananigans.jl/blob/efb8b712c7541ba377af10f04795e542092565f0/src/Solvers/fft_based_poisson_solver.jl#L109-L115. Therefore it is unclear to me whether additionally solving the regularized Poisson equation is necessary or valid when we already have a linear constraint embedded in the preconditioner. Also, note that the constrained implemented in this PR is simply a shifting of the constraint embedded in the FFT-based preconditioner. While the FFT preconditioner zeros out the mean pressure over the whole domain, the constraint in this PR take",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665:1965,simpl,simply,1965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2417152665,1,['simpl'],['simply']
Usability,"ryCondition(Flux, bottom_flux))). bcs = ModelBoundaryConditions(; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = T_bc,; S = DoublyPeriodicBCs()); ```. We still need to figure the API a little because this gets a little annoying: you need to compute `bottom_flux` before constructing the `Model` but it's nice to use `xC, yC, zC` to compute `bottom_flux` but we get them from `model.grid`... The easiest thing to do right now might be to just create the model again but with the new `bcs`:; ```julia; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). T_bc = FieldBoundaryConditions(; x = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; y = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; z = CoordinateBoundaryConditions(; BoundaryCondition(Flux, 0),; BoundaryCondition(Flux, bottom_flux))). bcs = ModelBoundaryConditions(; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = T_bc,; S = DoublyPeriodicBCs()). model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4, bcs=bcs); ```. At least that was my attempt which should work. The API does need some cleaning up and user-friendly love, and @glwagner may have a better solution. Let me know if this doesn't work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875:3020,user-friendly,user-friendly,3020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875,1,['user-friendly'],['user-friendly']
Usability,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:3474,learn,learn,3474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['learn'],['learn']
Usability,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:2500,simpl,simply,2500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,1,['simpl'],['simply']
Usability,"s crucial to the value of an example. This could be the case if we want to demonstrate the physics of the code (and I think this could be a good idea). At the moment, our examples do not explain the physics or physical motivation behind the examples. Instead, I designed the examples to be utilitarian to demonstrate valid syntax patterns for setting up a model. The physical aspects of the examples is incidental and not explained or justified (though I do think that for users who understand the physics, this ""extra sugar"" could be useful --- while causing no harm to users who do not understand the physics). Thus most of the plots simply demonstrate that the code ""did something"". They don't show anything meaningful in my opinion. I am all for more physically meaningful examples. But we should always think carefully about the purpose of the examples and each line of code they contain. Some of our examples should be about code and not physics --- because this better serves users who do not understand the physics (who would be distracted by lengthy physical justifications / discussions in the examples). . If ""vorticity"" as a title is not clear enough for the two-dimensional turbulence example we can say ""Heatmap of vorticity on an arbitrary scale""? Would that be more clear? The point of plotting vorticity is to demonstrate that the ""diagnostic"" that was defined is actually returning something (any significance of what was returned is just a bonus from the standpoint of that example, not a critical aspect of the example's purpose). Note that when I code things up I often use `imshow` for exactly this purpose; thus creating a plot with `imshow` as a means of quickly checking data could be a useful code pattern. Perhaps you disagree?. Note that technically the colormap used for examples is the user's default (not viridis) --- it doesn't show as viridis on my laptop, for example. But I appreciate that viridis is matplotlib default and thus what will appear in the online docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793:2453,clear,clear,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488#issuecomment-544489793,2,['clear'],['clear']
Usability,"s.jl/pull/234?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/closures/turbulence\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | `100% <100%> (ø)` | |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `100% <100%> (ø)` | |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `100% <100%> (ø)` | |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `73.68% <73.68%> (ø)` | |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `93.38% <93.38%> (ø)` | |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=footer). Last update [1bd2036...62af7d5](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/234?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029:2571,learn,learn,2571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234#issuecomment-495651029,1,['learn'],['learn']
Usability,s.jl/pull/577?src=pr&el=h1) Report; > Merging [#577](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/18428b029eec34a4b5222306cb16519fbc0bbcbd?src=pr&el=desc) will **increase** coverage by `4.57%`.; > The diff coverage is `69.79%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #577 +/- ##; ==========================================; + Coverage 70.26% 74.84% +4.57% ; ==========================================; Files 71 122 +51 ; Lines 2065 2258 +193 ; ==========================================; + Hits 1451 1690 +239 ; + Misses 614 568 -46; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `50% <ø> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/horizontal\_average.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2hvcml6b250YWxfYXZlcmFnZS5qbA==) | `84.61% <ø> (ø)` | :arrow_up: |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744:1091,simpl,simple,1091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744,1,['simpl'],['simple']
Usability,"s://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #863 +/- ##; ==========================================; - Coverage 70.90% 70.81% -0.09% ; ==========================================; Files 187 187 ; Lines 5180 5171 -9 ; ==========================================; - Hits 3673 3662 -11 ; - Misses 1507 1509 +2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `95.23% <ø> (-0.12%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `92.78% <ø> (-0.18%)` | :arrow_down: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `80.51% <0.00%> (-1.30%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=footer). Last update [810a3a1...e05c400](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/863?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954:1976,learn,learn,1976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/863#issuecomment-682492954,1,['learn'],['learn']
Usability,"sb3N1cmVfb3BlcmF0b3JzLmps) | `95.34% <100%> (+0.3%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `83.13% <100%> (+2.02%)` | :arrow_up: |; | [src/closures/constant\_diffusivity\_closures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X2RpZmZ1c2l2aXR5X2Nsb3N1cmVzLmps) | `63.33% <38.88%> (-36.67%)` | :arrow_down: |; | [src/model\_configuration.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL21vZGVsX2NvbmZpZ3VyYXRpb24uamw=) | `0% <0%> (-100%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `65.59% <0%> (-20.58%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `12.5% <0%> (-13.59%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.94% <0%> (-11.63%)` | :arrow_down: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=footer). Last update [22b7121...1fdaf74](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/245?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424:3339,learn,learn,3339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496324424,1,['learn'],['learn']
Usability,"seems simple enough, just a few cosmetic comments. Does `shadowp` stand for ""`primal_shadow`""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2166579371:6,simpl,simple,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2166579371,1,['simpl'],['simple']
Usability,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=footer). Last update [9ef95e7...0e304f4](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/747?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090:3293,learn,learn,3293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/747#issuecomment-628274090,1,['learn'],['learn']
Usability,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=footer). Last update [92d77b0...8c02fb5](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/752?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073:3293,learn,learn,3293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/752#issuecomment-629570073,1,['learn'],['learn']
Usability,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=footer). Last update [1e8704c...ad40bb1](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/753?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678:3293,learn,learn,3293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753#issuecomment-629586678,1,['learn'],['learn']
Usability,"sforms.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvcGxhbl90cmFuc2Zvcm1zLmps) | `66.66% <0.00%> (-33.34%)` | :arrow_down: |; | [src/Fields/set!.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zZXQhLmps) | `35.29% <0.00%> (-32.36%)` | :arrow_down: |; | [src/Architectures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0FyY2hpdGVjdHVyZXMuamw=) | `55.55% <0.00%> (-11.12%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `63.49% <0.00%> (-6.35%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `58.97% <0.00%> (-2.57%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/Utils/launch\_config.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL2xhdW5jaF9jb25maWcuamw=) | `100.00% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=footer). Last update [57f633e...a320923](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/754?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934:3338,learn,learn,3338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/754#issuecomment-629587934,1,['learn'],['learn']
Usability,"sity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for st",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2840,simpl,simply,2840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,1,['simpl'],['simply']
Usability,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:2154,simpl,simple,2154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,1,['simpl'],['simple']
Usability,"src=pr&el=desc) into [master](https://codecov.io/gh/CliMA/Oceananigans.jl/commit/22d76926a9a3687e58de4a36568d55c7e3ca73ba&el=desc) will **increase** coverage by `0.11%`.; > The diff coverage is `85.71%`. [![Impacted file tree graph](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #744 +/- ##; ==========================================; + Coverage 77.16% 77.28% +0.11% ; ==========================================; Files 125 125 ; Lines 2483 2487 +4 ; ==========================================; + Hits 1916 1922 +6 ; + Misses 567 565 -2 ; ```. | [Impacted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Forcing/Forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvRm9yY2luZy5qbA==) | `100.00% <ø> (+50.00%)` | :arrow_up: |; | [src/Forcing/model\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvbW9kZWxfZm9yY2luZy5qbA==) | `75.00% <60.00%> (+8.33%)` | :arrow_up: |; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `100.00% <100.00%> (+16.66%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=footer). Last update [22d7692...f1dea29](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/744?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325:1397,simpl,simple,1397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744#issuecomment-622618325,2,"['learn', 'simpl']","['learn', 'simple']"
Usability,"ster](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/5c573ea1e8038c7cd7023e6675c9f3270ffa8f58?src=pr&el=desc) will **increase** coverage by `1.88%`.; > The diff coverage is `61.53%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #350 +/- ##; ==========================================; + Coverage 72.86% 74.74% +1.88% ; ==========================================; Files 22 22 ; Lines 1157 1176 +19 ; ==========================================; + Hits 843 879 +36 ; + Misses 314 297 -17; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `57.14% <0%> (-2.56%)` | :arrow_down: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `64.74% <84.21%> (+20.84%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=footer). Last update [5c573ea...cc18413](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/350?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879:1766,learn,learn,1766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350#issuecomment-520164879,1,['learn'],['learn']
Usability,"t into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1277,simpl,simple,1277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['simpl'],"['simple', 'simply']"
Usability,"t; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXXAHFI#issuecomment-502137749>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYEHNERHN4MHAGJQZH3P2OVODANCNFSM4HXEYRJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:2103,simpl,simple,2103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['simpl'],['simple']
Usability,"te-machine/Oceananigans.jl/pull/621/graphs/tree.svg?width=650&height=150&src=pr&token=1eev6VdKD0)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #621 +/- ##; ==========================================; + Coverage 74.53% 74.87% +0.34% ; ==========================================; Files 117 118 +1 ; Lines 2246 2277 +31 ; ==========================================; + Hits 1674 1705 +31 ; Misses 572 572 ; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Diagnostics/nan\_checker.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL25hbl9jaGVja2VyLmps) | `33.33% <0.00%> (-46.67%)` | :arrow_down: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `40.00% <0.00%> (-13.34%)` | :arrow_down: |; | [src/Utils/time\_step\_wizard.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3RpbWVfc3RlcF93aXphcmQuamw=) | `100.00% <0.00%> (ø)` | :arrow_up: |; | [src/Simulations.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zLmps) | `93.75% <0.00%> (ø)` | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=footer). Last update [eb9b07f...397c15d](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/621?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682:2009,learn,learn,2009,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621#issuecomment-584907682,1,['learn'],['learn']
Usability,"te:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 100 │ 378.867 ms │ 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1305,feedback,feedback,1305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['feedback'],['feedback']
Usability,ted Files](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `33.33% <0.00%> (-33.34%)` | :arrow_down: |; | [src/AbstractOperations/interpolation\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9pbnRlcnBvbGF0aW9uX3V0aWxzLmps) | `63.33% <0.00%> (-30.01%)` | :arrow_down: |; | [src/Oceananigans.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `75.00% <0.00%> (-25.00%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `60.71% <0.00%> (-24.29%)` | :arrow_down: |; | [src/Forcing/simple\_forcing.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvc2ltcGxlX2ZvcmNpbmcuamw=) | `81.81% <0.00%> (-18.19%)` | :arrow_down: |; | [test/runtests\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-dGVzdC9ydW50ZXN0c191dGlscy5qbA==) | `50.00% <0.00%> (-17.57%)` | :arrow_down: |; | [src/Utils/versioninfo.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ZlcnNpb25pbmZvLmps) | `68.75% <0.00%> (-16.97%)` | :arrow_down: |; | [...closure\_implementations/anisotropic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2RpZmZ1c2l2aXR5Lmps) | `84.00% <0.00%> (-16.00%)` | :arrow_down: |; | [src/Buoyancy/Buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/872/diff?src=pr&el=tree#diff-c3JjL0J1b3lhbmN5L0J1b,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872#issuecomment-681307450:1905,simpl,simple,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872#issuecomment-681307450,1,['simpl'],['simple']
Usability,thank you for replying - I've never tried the debugger on any package that uses KernelAbstractions. I've opened an issue on the julia-vscode extension github repo (linked above) - I'll open an issue on the KernelAbstractions github repo to get their feedback. thank you for helping me - I'll spend some more time on this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622057678:250,feedback,feedback,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1622057678,1,['feedback'],['feedback']
Usability,thank you so much for the detailed response @glwagner - that's very helpful - it's a great idea to turn this into a discussion - I'll close this issue - very exited to learn more about Oceananigans (and Veros!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572621436:168,learn,learn,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572621436,1,['learn'],['learn']
Usability,thanks @glwagner . Maybe we could plan to meet for an hour this week and give this a try? It would be great for `ShallowWaterModel` and could also be helpful for testing the immersed boundary methods in a simpler model. Happy to disucss on slack as you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318:205,simpl,simpler,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458#issuecomment-798606318,1,['simpl'],['simpler']
Usability,"thanks for the explanation. On Mon, Oct 12, 2020 at 8:25 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Greg, Doesn't Ali have a version of immersed boundary layers going?; >; > @johncmarshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It se",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:272,simpl,simple,272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,2,['simpl'],['simple']
Usability,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063:1061,simpl,simple,1061,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063,1,['simpl'],['simple']
Usability,"the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be confused by its purpose in any other context.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582:1895,clear,clear,1895,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582,1,['clear'],['clear']
Usability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2624,simpl,simpler,2624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,"['learn', 'simpl']","['learn', 'simpler']"
Usability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:3328,learn,learn,3328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,1,['learn'],['learn']
Usability,"tree#diff-c3JjL0ZpZWxkcy96ZXJvX2ZpZWxkLmps) | `50.00% <0.00%> (ø)` | |; | [src/TimeSteppers/time\_stepping\_kernels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy90aW1lX3N0ZXBwaW5nX2tlcm5lbHMuamw=) | `79.09% <0.00%> (+0.96%)` | :arrow_up: |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `96.87% <0.00%> (+1.63%)` | :arrow_up: |; | [src/Models/clock.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `85.71% <0.00%> (+2.38%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `96.15% <0.00%> (+2.40%)` | :arrow_up: |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `42.85% <0.00%> (+2.85%)` | :arrow_up: |; | [src/AbstractOperations/unary\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy91bmFyeV9vcGVyYXRpb25zLmps) | `82.35% <0.00%> (+5.88%)` | :arrow_up: |; | ... and [4 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=footer). Last update [d274364...253bb6e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1038?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154:3346,learn,learn,3346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1038#issuecomment-707642154,1,['learn'],['learn']
Usability,"ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:3527,learn,learn,3527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['learn'],['learn']
Usability,"uggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1500,simpl,simple-benchmark-of-various-math-operations,1500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,1,['simpl'],['simple-benchmark-of-various-math-operations']
Usability,"ugh some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to redirect `zspacings()` calls to. 1. Create a `KernelFunctionOperation` using `zspacing()`, which we know has the correct behavior for all cases; 2. Calculate and collect the values in a Array; 3. Return to user. The main challenge here (imo) is that . - if we wanna keep the user-interface simple (e.g. return a float or a 1D array from calls to `zspacings(::RectilinearGrid)` instead of a `Field` or a 3D array), then we lose consistency (because in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1608,simpl,simply,1608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,1,['simpl'],['simply']
Usability,"ull/325?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #325 +/- ##; ==========================================; - Coverage 60.71% 60.33% -0.38% ; ==========================================; Files 24 22 -2 ; Lines 1255 1243 -12 ; ==========================================; - Hits 762 750 -12 ; Misses 493 493; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `77.41% <ø> (ø)` | :arrow_up: |; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `62.5% <ø> (ø)` | :arrow_up: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `92.3% <100%> (+6.59%)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `71.98% <66.66%> (-0.27%)` | :arrow_down: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `40% <66.66%> (-2%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=footer). Last update [aa601c7...f7894de](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/325?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768:2172,learn,learn,2172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325#issuecomment-517482768,1,['learn'],['learn']
Usability,"ull/671?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/BoundaryConditions/apply\_flux\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9mbHV4X2Jjcy5qbA==) | `53.84% <0.00%> (-29.49%)` | :arrow_down: |; | [src/BoundaryConditions/boundary\_function.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `71.42% <0.00%> (-28.58%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `75.17% <0.00%> (-0.73%)` | :arrow_down: |; | [src/OutputWriters/output\_writer\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvb3V0cHV0X3dyaXRlcl91dGlscy5qbA==) | `66.66% <0.00%> (+2.56%)` | :arrow_up: |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `96.22% <0.00%> (+11.61%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `75.00% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=footer). Last update [74cfb85...ef8f0a3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/671?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281:2574,learn,learn,2574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/671#issuecomment-595367281,1,['learn'],['learn']
Usability,"up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `80.11% <ø> (ø)` | :arrow_up: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `72.81% <ø> (ø)` | :arrow_up: |; | [src/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2Nsb2NrLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/turbulence\_closures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL3R1cmJ1bGVuY2VfY2xvc3VyZXMvVHVyYnVsZW5jZUNsb3N1cmVzLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `64.93% <ø> (ø)` | :arrow_up: |; | [src/equation\_of\_state.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2VxdWF0aW9uX29mX3N0YXRlLmps) | `100% <ø> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `85.24% <100%> (+1.37%)` | :arrow_up: |; | ... and [5 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=footer). Last update [cf55bcd...1dfa8a6](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/410?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177:3245,learn,learn,3245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410#issuecomment-531594177,1,['learn'],['learn']
Usability,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2110,clear,clearer,2110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,1,['clear'],['clearer']
Usability,"uspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people suggest this would work?; 6. I would like to have both `VectorInvariant` and `Conservative` forms. Each has their advantages and if you wanted to know if your results were robust, you could try both and if they give you the same result then you would have confidence in your results. But maybe people would think this is too much effort to maintain?. As for the utility of the shallow water model, I would like to get some students using it in Oceananigans to study oceanographic problems, and if we wanted to include coastlines I think we could do this using the `VectorInvariant` form but not the `Conservative` form. I don't expect this will be of huge demand, but it is also be useful for pedagogical reasons, for students learning about GFD and oceanography. I also think it's a nice way to test advection schemes as with the free-surface version we don't have to solve for the pressure, so it's simpler. I am of course very interested as to what others think about these issues as well. Maybe this should move to an issue instead of this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:3839,learn,learning,3839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,"['learn', 'simpl']","['learning', 'simpler']"
Usability,"v.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL3JvemVtYV9hbmlzb3Ryb3BpY19taW5pbXVtX2Rpc3NpcGF0aW9uLmps) | `30.00% <0.00%> (-4.10%)` | :arrow_down: |; | [src/Solvers/batched\_tridiagonal\_solver.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvYmF0Y2hlZF90cmlkaWFnb25hbF9zb2x2ZXIuamw=) | `96.42% <0.00%> (-3.58%)` | :arrow_down: |; | [src/Solvers/solve\_for\_pressure.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVfZm9yX3ByZXNzdXJlLmps) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `84.90% <0.00%> (+0.29%)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `37.93% <0.00%> (+1.08%)` | :arrow_up: |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=footer). Last update [e5c7aaf...d063105](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/767?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089:3482,learn,learn,3482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767#issuecomment-636191089,1,['learn'],['learn']
Usability,"v.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=h1) Report; > Merging [#571](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=desc) into [master](https://codecov.io/gh/climate-machine/Oceananigans.jl/commit/70a9308e59cb620632e3539ba4e0f2cab2aeab29?src=pr&el=desc) will **decrease** coverage by `0.06%`.; > The diff coverage is `0%`. [![Impacted file tree graph](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/graphs/tree.svg?width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #571 +/- ##; ==========================================; - Coverage 69.42% 69.35% -0.07% ; ==========================================; Files 71 71 ; Lines 2054 2056 +2 ; ==========================================; Hits 1426 1426 ; - Misses 628 630 +2; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/TimeSteppers/kernels.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9rZXJuZWxzLmps) | `61.53% <ø> (ø)` | :arrow_up: |; | [src/SurfaceWaves.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571/diff?src=pr&el=tree#diff-c3JjL1N1cmZhY2VXYXZlcy5qbA==) | `0% <0%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=footer). Last update [70a9308...2e8228e](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/571?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907:1591,learn,learn,1591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571#issuecomment-565757907,1,['learn'],['learn']
Usability,"vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfaHlkcm9zdGF0aWNfcHJlc3N1cmUuamw=) | `50.00% <0.00%> (ø)` | |; | [...dels/IncompressibleModels/non\_dimensional\_model.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9ub25fZGltZW5zaW9uYWxfbW9kZWwuamw=) | `0.00% <0.00%> (ø)` | |; | [...odels/IncompressibleModels/IncompressibleModels.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy5qbA==) | `100.00% <0.00%> (ø)` | |; | [...mpressibleModels/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...Models/IncompressibleModels/pressure\_correction.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy9wcmVzc3VyZV9jb3JyZWN0aW9uLmps) | `83.33% <0.00%> (ø)` | |; | [src/Models/IncompressibleModels/update\_state.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9JbmNvbXByZXNzaWJsZU1vZGVscy91cGRhdGVfc3RhdGUuamw=) | `100.00% <0.00%> (ø)` | |; | ... and [3 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=footer). Last update [03a6f85...f933fbd](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1187?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192:3646,learn,learn,3646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187#issuecomment-727718192,1,['learn'],['learn']
Usability,"vbGlzLmps) | | |; | [examples/internal\_wave.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvaW50ZXJuYWxfd2F2ZS5qbA==) | | |; | [test/test\_verification.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3ZlcmlmaWNhdGlvbi5qbA==) | | |; | [test/test\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2RpYWdub3N0aWNzLmps) | | |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | | |; | [test/test\_models.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X21vZGVscy5qbA==) | | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | | |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | | |; | [test/test\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2ZpZWxkcy5qbA==) | | |; | ... and [49 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=footer). Last update [162159d...17a22a9](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/795?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854:2974,learn,learn,2974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/795#issuecomment-657824854,1,['learn'],['learn']
Usability,"vbnMuamw=) | `16.66% <ø> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/TurbulenceClosures.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9UdXJidWxlbmNlQ2xvc3VyZXMuamw=) | `42.85% <ø> (ø)` | :arrow_up: |; | [src/Diagnostics/cfl.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL0RpYWdub3N0aWNzL2NmbC5qbA==) | `66.66% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/Solvers/Solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvU29sdmVycy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/OutputWriters/netcdf\_output\_writer.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvbmV0Y2RmX291dHB1dF93cml0ZXIuamw=) | `86.53% <ø> (ø)` | :arrow_up: |; | [src/Solvers/solver\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvc29sdmVyX3V0aWxzLmps) | `100% <ø> (+17.39%)` | :arrow_up: |; | ... and [148 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=footer). Last update [18428b0...9288c58](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/577?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744:3421,learn,learn,3421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/577#issuecomment-579406744,1,['learn'],['learn']
Usability,"vection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:1143,clear,clearer,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,1,['clear'],['clearer']
Usability,"veraged), which indicates that the issue doesn't necessarily have to do with `KernelComputedField`s. https://user-images.githubusercontent.com/13205162/112888062-c03b5d00-9088-11eb-9d70-82ecda21477b.mp4. https://user-images.githubusercontent.com/13205162/112888067-c3364d80-9088-11eb-8eb4-4c5174f45b62.mp4. Here are some line plots comparing dissipation calculated with both `ComputedFields` (cf) and `KernelComputedFields` (kcf) and output with both `TimeInterval` and `AveragedTimeInterval`. (Sorry for the colors being weird, but I wanna be able to see the overlaps.). ![Screenshot from 2021-03-29 12-23-18](https://user-images.githubusercontent.com/13205162/112888734-959dd400-9089-11eb-8423-44dfa0df94ff.png). As you can see the time-averaged results are consistent with each other, but not with the snapshot results. However, if I plot TKE I get somewhat different results:. ![Screenshot from 2021-03-29 12-22-55](https://user-images.githubusercontent.com/13205162/112888917-cbdb5380-9089-11eb-82c7-2de997138b1b.png). Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with `ComputedFields` actually match the snapshots, but not the time-averaged TKE results computed with `KernelComputedFields`!. There's also a difference between the u-velocity using time-averaged results and snapshots:. ![Screenshot from 2021-03-29 12-32-23](https://user-images.githubusercontent.com/13205162/112889703-d8ac7700-908a-11eb-8e03-a5c3b6a70f02.png). I think this last plot provides us with a clue since the averages start at the right value, but the oscillations get dampened as time progresses. This may indicate that the average is being done with a window much bigger than the averaging period for some reason. Although this last one is hard to believe since, as @ali-ramadhan pointed out, there are many tests for `AveragedTimeInterval` and I feel like they'd have caught that. In any case, that's all I got for now! Some feedback is very much appreciated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170:2939,feedback,feedback,2939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170,1,['feedback'],['feedback']
Usability,"w=) | `25% <0%> (-8.34%)` | :arrow_down: |; | [src/Coriolis/f\_plane.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL2ZfcGxhbmUuamw=) | `63.33% <0%> (-6.67%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.7% <0%> (-1.3%)` | :arrow_down: |; | [src/Operators/interpolation\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9pbnRlcnBvbGF0aW9uX29wZXJhdG9ycy5qbA==) | `59.01% <0%> (-0.51%)` | :arrow_down: |; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `78.35% <0%> (-0.34%)` | :arrow_down: |; | [src/Coriolis/no\_rotation.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0NvcmlvbGlzL25vX3JvdGF0aW9uLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `100% <0%> (ø)` | :arrow_up: |; | ... and [9 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=footer). Last update [1f4465d...d25abdb](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/622?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187:3605,learn,learn,3605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622#issuecomment-584704187,1,['learn'],['learn']
Usability,"w_up: |; | [src/grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2dyaWRzLmps) | `93.54% <100%> (ø)` | :arrow_up: |; | [src/TurbulenceClosures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy9jbG9zdXJlX29wZXJhdG9ycy5qbA==) | `64.44% <100%> (ø)` | :arrow_up: |; | [src/diagnostics.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2RpYWdub3N0aWNzLmps) | `79.31% <50%> (ø)` | :arrow_up: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `80.59% <72.72%> (ø)` | :arrow_up: |; | [src/halo\_regions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL2hhbG9fcmVnaW9ucy5qbA==) | `90.27% <87.23%> (+0.13%)` | :arrow_up: |; | [src/Operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `84.21% <92.3%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `76.08% <92.85%> (-0.13%)` | :arrow_down: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=footer). Last update [5114a22...419f176](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/462?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744:3097,learn,learn,3097,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542464744,1,['learn'],['learn']
Usability,"why wouldn't they be just defined at cell centers?; Suggest make that assumption.; John. On Mon, Oct 21, 2019 at 2:29 PM Ali Ramadhan <notifications@github.com>; wrote:. > Title sounds ridiculous but @jm-c <https://github.com/jm-c> mentioned; > that for stretched grids, models (e.g. WRF) usually place the cell center; > halfway between the two cell faces, but some models relax this choice so; > that you can specify cell centers to be slightly offset from the true; > center.; >; > I guess they won't be ""cell centers"" anymore, but just opening an issue in; > case there's anything to discuss.; >; > Without assuming cell centers are halfway between the two faces then; > interpolation operators are a bit more complicated; >; > @inline ℑz_aac(i, j, k, grid::VerticallyStretchedCartesianGrid, f) =; >; > @inbounds ((grid.zC[k] - grid.zF[k]) * f[k, j, i] + (grid.zF[k+1] - grid.zC[k]) * f[k+1, j, i]) / grid.ΔzF[k]; >; > and if we assume e.g. grid.zC[k] - grid.zF[k] = grid.ΔzF[k]/2 then the; > interpolation operators simplify.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/491?email_source=notifications&email_token=AKXUEQROF3YBCYTVKZUUNMLQPXYINA5CNFSM4JDC6IX2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HTI3OWQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQQAZQL25R7ZQ4S7J63QPXYINANCNFSM4JDC6IXQ>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984:1021,simpl,simplify,1021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491#issuecomment-544660984,1,['simpl'],['simplify']
Usability,"width=650&token=1eev6VdKD0&height=150&src=pr)](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree). ```diff; @@ Coverage Diff @@; ## master #109 +/- ##; =======================================; Coverage 52.71% 52.71% ; =======================================; Files 19 19 ; Lines 645 645 ; =======================================; Hits 340 340 ; Misses 305 305; ```. | [Impacted Files](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=tree) | Coverage Δ | |; |---|---|---|; | [src/Oceananigans.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL09jZWFuYW5pZ2Fucy5qbA==) | `100% <ø> (ø)` | :arrow_up: |; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `0% <0%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `46.45% <25%> (ø)` | |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `87.5% <50%> (ø)` | :arrow_up: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `67.96% <50%> (ø)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=footer). Last update [3cd4ae3...08d8495](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/109?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436:2062,learn,learn,2062,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/109#issuecomment-470193436,1,['learn'],['learn']
Usability,"wn: |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `57.14% <0.00%> (-0.86%)` | :arrow_down: |; | [src/Fields/averaged\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hdmVyYWdlZF9maWVsZC5qbA==) | `77.77% <ø> (+7.77%)` | :arrow_up: |; | [src/Fields/computed\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9jb21wdXRlZF9maWVsZC5qbA==) | `64.28% <0.00%> (ø)` | |; | [src/Fields/field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `82.35% <0.00%> (-5.89%)` | :arrow_down: |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <0.00%> (ø)` | |; | [src/Operators/laplacian\_operators.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL09wZXJhdG9ycy9sYXBsYWNpYW5fb3BlcmF0b3JzLmps) | `9.09% <ø> (ø)` | |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `80.00% <ø> (ø)` | |; | ... and [21 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=footer). Last update [c5f47e0...c35af73](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/1057?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357:3256,learn,learn,3256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057#issuecomment-708214357,1,['learn'],['learn']
Usability,"y for going slow on this, but if I understand correctly what you're proposing is:. - Remove the calculation of diffusivities from `DiffusivityFields()` (and thus remove tracer diffusivities from `model.diffusivity_fields`); - Specialize `κᶠᶜᶜ()` functions for `SmagoriknskyLilly` so that diffusivities are calculated on the fly. As opposed to what I'm doing here which is just to change the calculation of diffusivities in `DiffusivityFields()` from using a `BinaryOperation` to a kernel (keeping them in `model.diffusivity_fields`). If I understand correctly both methods do the same number of operations (one calculation of $\nu_e$, a division by `Pr` and one interpolation for each face of each grid cell), no?. So I guess the advantage of what you're proposing is that it saves memory (since diffusivities are calculated on the fly), at the cost of a bit more code complexity (i.e., one more specialization). Conversely, the direction this PR is going atm uses more memory (for the diffusivities) but in my opinion the code is a bit clearer, since there's one fewer specialization (i.e. `κᶠᶜᶜ()` remains the same) and the code in `smagorinsky_lilly.jl` looks more like the code in `anisotropic_minimum_dissipation.jl`, which makes things more standardized. I'll defer to you either way, but I vote that we take the approach that this PR is currently doing since, as we discussed before in a few PRs, the code in `TurbulenceClosures` is already a bit on the complex side and not super easy to understand. So I think the standardization of having `smagorinsky_lilly.jl` have the same structure as `anisotropic_minimum_dissipation.jl` I'd argue is a benefit. If we follow with this PR, the increase in memory should be around 15% for one tracer and less for more tracers, so relatively small, plus the memory limitation is about to become less severe since hopefully https://github.com/CliMA/Oceananigans.jl/pull/2795 will be merged soon?. @glwagner like I said I'll defer to you either way. So if y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419759789:1041,clear,clearer,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419759789,1,['clear'],['clearer']
Usability,"yes, it makes sense to me now! Thanks for the clear explanation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286695648:46,clear,clear,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286695648,1,['clear'],['clear']
Usability,"| :arrow_up: |; | [...vection/topologically\_conditional\_interpolation.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi90b3BvbG9naWNhbGx5X2NvbmRpdGlvbmFsX2ludGVycG9sYXRpb24uamw=) | `60.00% <60.00%> (ø)` | |; | [src/Advection/centered\_fourth\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9mb3VydGhfb3JkZXIuamw=) | `64.28% <62.50%> (+64.28%)` | :arrow_up: |; | [src/Advection/upwind\_biased\_third\_order.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX3RoaXJkX29yZGVyLmps) | `65.00% <65.00%> (ø)` | |; | [src/Advection/centered\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi9jZW50ZXJlZF9hZHZlY3RpdmVfZmx1eGVzLmps) | `100.00% <100.00%> (ø)` | |; | [src/Advection/upwind\_biased\_advective\_fluxes.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-c3JjL0FkdmVjdGlvbi91cHdpbmRfYmlhc2VkX2FkdmVjdGl2ZV9mbHV4ZXMuamw=) | `100.00% <100.00%> (ø)` | |; | [test/test\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmcuamw=) | `100.00% <100.00%> (ø)` | |; | ... and [6 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=footer). Last update [7260ce8...5f6a3a0](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/972?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507:3162,learn,learn,3162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972#issuecomment-699121507,1,['learn'],['learn']
Usability,"| :arrow_up: |; | [src/closures/closure\_operators.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2Nsb3N1cmVfb3BlcmF0b3JzLmps) | `58.44% <100%> (-34.82%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `80.68% <100%> (+0.44%)` | :arrow_up: |; | [src/fields.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkcy5qbA==) | `45.76% <28%> (-13.07%)` | :arrow_down: |; | [src/operators/ops\_regular\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL29wZXJhdG9ycy9vcHNfcmVndWxhcl9jYXJ0ZXNpYW5fZ3JpZC5qbA==) | `64.51% <66.66%> (-1.45%)` | :arrow_down: |; | [src/closures/constant\_smagorinsky.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL2NvbnN0YW50X3NtYWdvcmluc2t5Lmps) | `18.18% <0%> (-81.82%)` | :arrow_down: |; | [src/closures/velocity\_gradients.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree#diff-c3JjL2Nsb3N1cmVzL3ZlbG9jaXR5X2dyYWRpZW50cy5qbA==) | `0% <0%> (-73.69%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=footer). Last update [9204afe...5f743c1](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/253?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321:3171,learn,learn,3171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253#issuecomment-498649321,1,['learn'],['learn']
Usability,"| [test/test\_solvers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3NvbHZlcnMuamw=) | `51.06% <ø> (ø)` | |; | [src/TimeSteppers/generic\_time\_stepping.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9nZW5lcmljX3RpbWVfc3RlcHBpbmcuamw=) | `95.23% <100.00%> (+0.23%)` | :arrow_up: |; | [...sts/ocean\_large\_eddy\_simulation\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL29jZWFuX2xhcmdlX2VkZHlfc2ltdWxhdGlvbl9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...egression\_tests/rayleigh\_benard\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3JheWxlaWdoX2JlbmFyZF9yZWdyZXNzaW9uX3Rlc3Quamw=) | `100.00% <100.00%> (ø)` | |; | [...regression\_tests/thermal\_bubble\_regression\_test.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC9yZWdyZXNzaW9uX3Rlc3RzL3RoZXJtYWxfYnViYmxlX3JlZ3Jlc3Npb25fdGVzdC5qbA==) | `100.00% <100.00%> (ø)` | |; | [test/test\_regression.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3JlZ3Jlc3Npb24uamw=) | `100.00% <100.00%> (ø)` | |; | ... and [26 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=footer). Last update [0f33c1d...8fe7c2a](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/943?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816:3399,learn,learn,3399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943#issuecomment-692271816,1,['learn'],['learn']
Usability,"| |; | [...nceTests/OneDimensionalCosineAdvectionDiffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL0NvbnZlcmdlbmNlVGVzdHMvT25lRGltZW5zaW9uYWxDb3NpbmVBZHZlY3Rpb25EaWZmdXNpb24uamw=) | | |; | [benchmark/benchmark\_tracers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya190cmFjZXJzLmps) | | |; | [test/test\_buoyancy.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2J1b3lhbmN5Lmps) | | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | | |; | [...ests/one\_dimensional\_cosine\_advection\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dmVyaWZpY2F0aW9uL2NvbnZlcmdlbmNlX3Rlc3RzL29uZV9kaW1lbnNpb25hbF9jb3NpbmVfYWR2ZWN0aW9uX2RpZmZ1c2lvbi5qbA==) | | |; | [benchmark/benchmark\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-YmVuY2htYXJrL2JlbmNobWFya191dGlscy5qbA==) | | |; | [test/test\_turbulence\_closures.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3R1cmJ1bGVuY2VfY2xvc3VyZXMuamw=) | | |; | ... and [53 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=footer). Last update [b444acf...639be06](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/966?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202:3062,learn,learn,3062,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/966#issuecomment-696645202,1,['learn'],['learn']
Usability,"|; | [src/Fields/field.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `69.84% <81.81%> (-1.59%)` | :arrow_down: |; | [src/Solvers/discrete\_eigenvalues.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL1NvbHZlcnMvZGlzY3JldGVfZWlnZW52YWx1ZXMuamw=) | `85.71% <83.33%> (ø)` | |; | [src/Grids/vertically\_stretched\_cartesian\_grid.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3ZlcnRpY2FsbHlfc3RyZXRjaGVkX2NhcnRlc2lhbl9ncmlkLmps) | `96.61% <96.49%> (-3.39%)` | :arrow_down: |; | [src/Grids/grid\_utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL2dyaWRfdXRpbHMuamw=) | `98.52% <98.18%> (+0.31%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `84.00% <100.00%> (ø)` | |; | [src/Grids/Grids.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL0dyaWRzLmps) | `71.42% <100.00%> (+7.79%)` | :arrow_up: |; | ... and [10 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=footer). Last update [7e22384...d72cde3](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/733?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846:3421,learn,learn,3421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733#issuecomment-618603846,1,['learn'],['learn']
Usability,"|; | [src/output\_writers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL291dHB1dF93cml0ZXJzLmps) | `74.57% <ø> (-6.82%)` | :arrow_down: |; | [src/models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL21vZGVscy5qbA==) | `89.28% <100%> (-4.47%)` | :arrow_down: |; | [src/boundary\_conditions.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `66.12% <100%> (-1.22%)` | :arrow_down: |; | [src/fieldsets.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL2ZpZWxkc2V0cy5qbA==) | `100% <100%> (ø)` | :arrow_up: |; | [src/poisson\_solvers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3BvaXNzb25fc29sdmVycy5qbA==) | `39.16% <0%> (-60.01%)` | :arrow_down: |; | [src/utils.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3V0aWxzLmps) | `26.08% <0%> (-26.09%)` | :arrow_down: |; | [src/time\_steppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree#diff-c3JjL3RpbWVfc3RlcHBlcnMuamw=) | `74.17% <0%> (-7.14%)` | :arrow_down: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=footer). Last update [8fdff75...d8da673](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/282?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011:2817,learn,learn,2817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282#issuecomment-508952011,2,['learn'],['learn']
Usability,"|; |---|---|---|; | [src/OutputWriters/OutputWriters.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvT3V0cHV0V3JpdGVycy5qbA==) | `66.66% <ø> (ø)` | |; | [src/Fields/abstract\_field.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9hYnN0cmFjdF9maWVsZC5qbA==) | `52.94% <50.00%> (ø)` | |; | [src/OutputWriters/fetch\_output.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvZmV0Y2hfb3V0cHV0Lmps) | `60.00% <60.00%> (ø)` | |; | [src/OutputWriters/jld2\_output\_writer.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL091dHB1dFdyaXRlcnMvamxkMl9vdXRwdXRfd3JpdGVyLmps) | `90.90% <96.00%> (-0.62%)` | :arrow_down: |; | [test/test\_output\_writers.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X291dHB1dF93cml0ZXJzLmps) | `93.91% <100.00%> (+0.28%)` | :arrow_up: |; | [src/Utils/output\_writer\_diagnostic\_utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL291dHB1dF93cml0ZXJfZGlhZ25vc3RpY191dGlscy5qbA==) | `100.00% <0.00%> (+8.69%)` | :arrow_up: |; | [src/Utils/pretty\_time.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL3ByZXR0eV90aW1lLmps) | `87.50% <0.00%> (+12.50%)` | :arrow_up: |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=footer). Last update [0f33c1d...8d7f82e](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/927?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678:2576,learn,learn,2576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/927#issuecomment-690372678,1,['learn'],['learn']
Usability,"~One other option that might be easier to implement is to keep the store the tuple in `model.closures`, but only store the total viscosity (the sum of all closures in the tuple) in `model.diffusivities`. Maybe we'd have to rename it as `model.diffusivities.ν_tot` and `model.diffusivities.κ_tot` .~. ~I think that's as clear, but simpler.~. Scratch that! I was thinking of a specific example I had in mind and forgot that not every closure can be simplified to the sum of diffusivities times the nabla operator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465:319,clear,clear,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465,3,"['clear', 'simpl']","['clear', 'simpler', 'simplified']"
Usability,"ø)` | |; | [examples/netcdf\_ouput\_example.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvbmV0Y2RmX291cHV0X2V4YW1wbGUuamw=) | `0.00% <ø> (ø)` | |; | [examples/ocean\_convection\_with\_plankton.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <ø> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <ø> (ø)` | |; | [examples/one\_dimensional\_diffusion.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb25lX2RpbWVuc2lvbmFsX2RpZmZ1c2lvbi5qbA==) | `0.00% <ø> (ø)` | |; | [src/Grids/regular\_cartesian\_grid.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL0dyaWRzL3JlZ3VsYXJfY2FydGVzaWFuX2dyaWQuamw=) | `81.81% <ø> (ø)` | |; | [src/Utils/Utils.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-c3JjL1V0aWxzL1V0aWxzLmps) | `100.00% <ø> (ø)` | |; | [test/test\_examples.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2V4YW1wbGVzLmps) | `86.00% <ø> (ø)` | |; | ... and [27 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=footer). Last update [66ddeb7...81d21f3](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/836?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153:3105,learn,learn,3105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/836#issuecomment-669319153,1,['learn'],['learn']
